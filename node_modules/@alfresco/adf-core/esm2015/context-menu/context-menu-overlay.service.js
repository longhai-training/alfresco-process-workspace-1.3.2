/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable, Injector, ElementRef } from '@angular/core';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { PortalInjector, ComponentPortal } from '@angular/cdk/portal';
import { ContextMenuOverlayRef } from './context-menu-overlay';
import { CONTEXT_MENU_DATA } from './context-menu.tokens';
import { ContextMenuListComponent } from './context-menu-list.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
/** @type {?} */
const DEFAULT_CONFIG = {
    panelClass: 'cdk-overlay-pane',
    backdropClass: 'cdk-overlay-transparent-backdrop',
    hasBackdrop: true
};
export class ContextMenuOverlayService {
    /**
     * @param {?} injector
     * @param {?} overlay
     */
    constructor(injector, overlay) {
        this.injector = injector;
        this.overlay = overlay;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    open(config) {
        /** @type {?} */
        const overlayConfig = Object.assign({}, DEFAULT_CONFIG, config);
        /** @type {?} */
        const overlay = this.createOverlay(overlayConfig);
        /** @type {?} */
        const overlayRef = new ContextMenuOverlayRef(overlay);
        this.attachDialogContainer(overlay, config, overlayRef);
        overlay.backdropClick().subscribe((/**
         * @return {?}
         */
        () => overlayRef.close()));
        // prevent native contextmenu on overlay element if config.hasBackdrop is true
        if (overlayConfig.hasBackdrop) {
            ((/** @type {?} */ (overlay)))._backdropElement
                .addEventListener('contextmenu', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                event.preventDefault();
                ((/** @type {?} */ (overlay)))._backdropClick.next(null);
            }), true);
        }
        return overlayRef;
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    createOverlay(config) {
        /** @type {?} */
        const overlayConfig = this.getOverlayConfig(config);
        return this.overlay.create(overlayConfig);
    }
    /**
     * @private
     * @param {?} overlay
     * @param {?} config
     * @param {?} contextMenuOverlayRef
     * @return {?}
     */
    attachDialogContainer(overlay, config, contextMenuOverlayRef) {
        /** @type {?} */
        const injector = this.createInjector(config, contextMenuOverlayRef);
        /** @type {?} */
        const containerPortal = new ComponentPortal(ContextMenuListComponent, null, injector);
        /** @type {?} */
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    /**
     * @private
     * @param {?} config
     * @param {?} contextMenuOverlayRef
     * @return {?}
     */
    createInjector(config, contextMenuOverlayRef) {
        /** @type {?} */
        const injectionTokens = new WeakMap();
        injectionTokens.set(ContextMenuOverlayRef, contextMenuOverlayRef);
        injectionTokens.set(CONTEXT_MENU_DATA, config.data);
        return new PortalInjector(this.injector, injectionTokens);
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getOverlayConfig(config) {
        const { clientY, clientX } = config.source;
        /** @type {?} */
        const fakeElement = {
            getBoundingClientRect: (/**
             * @return {?}
             */
            () => ({
                bottom: clientY,
                height: 0,
                left: clientX,
                right: clientX,
                top: clientY,
                width: 0
            }))
        };
        /** @type {?} */
        const positionStrategy = this.overlay.position()
            .connectedTo(new ElementRef(fakeElement), { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
            .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
            .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })
            .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });
        /** @type {?} */
        const overlayConfig = new OverlayConfig({
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass,
            panelClass: config.panelClass,
            scrollStrategy: this.overlay.scrollStrategies.close(),
            positionStrategy
        });
        return overlayConfig;
    }
}
ContextMenuOverlayService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ContextMenuOverlayService.ctorParameters = () => [
    { type: Injector },
    { type: Overlay }
];
/** @nocollapse */ ContextMenuOverlayService.ngInjectableDef = i0.defineInjectable({ factory: function ContextMenuOverlayService_Factory() { return new ContextMenuOverlayService(i0.inject(i0.INJECTOR), i0.inject(i1.Overlay)); }, token: ContextMenuOverlayService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ContextMenuOverlayService.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    ContextMenuOverlayService.prototype.overlay;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1tZW51LW92ZXJsYXkuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbImNvbnRleHQtbWVudS9jb250ZXh0LW1lbnUtb3ZlcmxheS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBZ0IsTUFBTSxlQUFlLENBQUM7QUFDL0UsT0FBTyxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQWMsTUFBTSxzQkFBc0IsQ0FBQztBQUMxRSxPQUFPLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRS9ELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzFELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLCtCQUErQixDQUFDOzs7O01BRW5FLGNBQWMsR0FBNkI7SUFDN0MsVUFBVSxFQUFFLGtCQUFrQjtJQUM5QixhQUFhLEVBQUUsa0NBQWtDO0lBQ2pELFdBQVcsRUFBRSxJQUFJO0NBQ3BCO0FBS0QsTUFBTSxPQUFPLHlCQUF5Qjs7Ozs7SUFFbEMsWUFBcUIsUUFBa0IsRUFBVSxPQUFnQjtRQUE1QyxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQVUsWUFBTyxHQUFQLE9BQU8sQ0FBUztJQUFJLENBQUM7Ozs7O0lBRXRFLElBQUksQ0FBQyxNQUFnQzs7Y0FDM0IsYUFBYSxxQkFBUSxjQUFjLEVBQUssTUFBTSxDQUFFOztjQUVoRCxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUM7O2NBRTNDLFVBQVUsR0FBRyxJQUFJLHFCQUFxQixDQUFDLE9BQU8sQ0FBQztRQUVyRCxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxFQUFF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S0FBSyxFQUFFLENBQUM7YUFDMUMsb0JBQW9CLENBQ2pCLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEVBQ3BDLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLENBQUM7YUFDeEMsb0JBQW9CLENBQ2pCLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLEVBQ3JDLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLENBQUM7YUFDN0Msb0JBQW9CLENBQ2pCLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLEVBQ3ZDLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLENBQzFDOztjQUVDLGFBQWEsR0FBRyxJQUFJLGFBQWEsQ0FBQztZQUNwQyxXQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVc7WUFDL0IsYUFBYSxFQUFFLE1BQU0sQ0FBQyxhQUFhO1lBQ25DLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtZQUM3QixjQUFjLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUU7WUFDckQsZ0JBQWdCO1NBQ25CLENBQUM7UUFFRixPQUFPLGFBQWEsQ0FBQztJQUN6QixDQUFDOzs7WUFsR0osVUFBVSxTQUFDO2dCQUNSLFVBQVUsRUFBRSxNQUFNO2FBQ3JCOzs7O1lBaEJvQixRQUFRO1lBQ3BCLE9BQU87Ozs7Ozs7O0lBa0JDLDZDQUEwQjs7Ozs7SUFBRSw0Q0FBd0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3RvciwgRWxlbWVudFJlZiwgQ29tcG9uZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPdmVybGF5LCBPdmVybGF5Q29uZmlnLCBPdmVybGF5UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgUG9ydGFsSW5qZWN0b3IsIENvbXBvbmVudFBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgQ29udGV4dE1lbnVPdmVybGF5UmVmIH0gZnJvbSAnLi9jb250ZXh0LW1lbnUtb3ZlcmxheSc7XG5pbXBvcnQgeyBDb250ZXh0TWVudU92ZXJsYXlDb25maWcgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQ09OVEVYVF9NRU5VX0RBVEEgfSBmcm9tICcuL2NvbnRleHQtbWVudS50b2tlbnMnO1xuaW1wb3J0IHsgQ29udGV4dE1lbnVMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi9jb250ZXh0LW1lbnUtbGlzdC5jb21wb25lbnQnO1xuXG5jb25zdCBERUZBVUxUX0NPTkZJRzogQ29udGV4dE1lbnVPdmVybGF5Q29uZmlnID0ge1xuICAgIHBhbmVsQ2xhc3M6ICdjZGstb3ZlcmxheS1wYW5lJyxcbiAgICBiYWNrZHJvcENsYXNzOiAnY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnLFxuICAgIGhhc0JhY2tkcm9wOiB0cnVlXG59O1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIENvbnRleHRNZW51T3ZlcmxheVNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IoIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLCBwcml2YXRlIG92ZXJsYXk6IE92ZXJsYXkpIHsgfVxuXG4gICAgb3Blbihjb25maWc6IENvbnRleHRNZW51T3ZlcmxheUNvbmZpZyk6IENvbnRleHRNZW51T3ZlcmxheVJlZiB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB7IC4uLkRFRkFVTFRfQ09ORklHLCAuLi5jb25maWcgfTtcblxuICAgICAgICBjb25zdCBvdmVybGF5ID0gdGhpcy5jcmVhdGVPdmVybGF5KG92ZXJsYXlDb25maWcpO1xuXG4gICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSBuZXcgQ29udGV4dE1lbnVPdmVybGF5UmVmKG92ZXJsYXkpO1xuXG4gICAgICAgIHRoaXMuYXR0YWNoRGlhbG9nQ29udGFpbmVyKG92ZXJsYXksIGNvbmZpZywgb3ZlcmxheVJlZik7XG5cbiAgICAgICAgb3ZlcmxheS5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKCgpID0+IG92ZXJsYXlSZWYuY2xvc2UoKSk7XG5cbiAgICAgICAgLy8gcHJldmVudCBuYXRpdmUgY29udGV4dG1lbnUgb24gb3ZlcmxheSBlbGVtZW50IGlmIGNvbmZpZy5oYXNCYWNrZHJvcCBpcyB0cnVlXG4gICAgICAgIGlmIChvdmVybGF5Q29uZmlnLmhhc0JhY2tkcm9wKSB7XG4gICAgICAgICAgICAoPGFueT4gb3ZlcmxheSkuX2JhY2tkcm9wRWxlbWVudFxuICAgICAgICAgICAgICAgIC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAoPGFueT4gb3ZlcmxheSkuX2JhY2tkcm9wQ2xpY2submV4dChudWxsKTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdmVybGF5UmVmO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlT3ZlcmxheShjb25maWc6IENvbnRleHRNZW51T3ZlcmxheUNvbmZpZyk6IE92ZXJsYXlSZWYge1xuICAgICAgICBjb25zdCBvdmVybGF5Q29uZmlnID0gdGhpcy5nZXRPdmVybGF5Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXkuY3JlYXRlKG92ZXJsYXlDb25maWcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXR0YWNoRGlhbG9nQ29udGFpbmVyKG92ZXJsYXk6IE92ZXJsYXlSZWYsIGNvbmZpZzogQ29udGV4dE1lbnVPdmVybGF5Q29uZmlnLCBjb250ZXh0TWVudU92ZXJsYXlSZWY6IENvbnRleHRNZW51T3ZlcmxheVJlZikge1xuICAgICAgICBjb25zdCBpbmplY3RvciA9IHRoaXMuY3JlYXRlSW5qZWN0b3IoY29uZmlnLCBjb250ZXh0TWVudU92ZXJsYXlSZWYpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoQ29udGV4dE1lbnVMaXN0Q29tcG9uZW50LCBudWxsLCBpbmplY3Rvcik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJlZjogQ29tcG9uZW50UmVmPENvbnRleHRNZW51TGlzdENvbXBvbmVudD4gPSBvdmVybGF5LmF0dGFjaChjb250YWluZXJQb3J0YWwpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXJSZWYuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVJbmplY3Rvcihjb25maWc6IENvbnRleHRNZW51T3ZlcmxheUNvbmZpZywgY29udGV4dE1lbnVPdmVybGF5UmVmOiBDb250ZXh0TWVudU92ZXJsYXlSZWYpOiBQb3J0YWxJbmplY3RvciB7XG4gICAgICAgIGNvbnN0IGluamVjdGlvblRva2VucyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICAgICAgaW5qZWN0aW9uVG9rZW5zLnNldChDb250ZXh0TWVudU92ZXJsYXlSZWYsIGNvbnRleHRNZW51T3ZlcmxheVJlZik7XG4gICAgICAgIGluamVjdGlvblRva2Vucy5zZXQoQ09OVEVYVF9NRU5VX0RBVEEsIGNvbmZpZy5kYXRhKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBvcnRhbEluamVjdG9yKHRoaXMuaW5qZWN0b3IsIGluamVjdGlvblRva2Vucyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRPdmVybGF5Q29uZmlnKGNvbmZpZzogQ29udGV4dE1lbnVPdmVybGF5Q29uZmlnKTogT3ZlcmxheUNvbmZpZyB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50WSwgY2xpZW50WCAgfSA9IGNvbmZpZy5zb3VyY2U7XG5cbiAgICAgICAgY29uc3QgZmFrZUVsZW1lbnQ6IGFueSA9IHtcbiAgICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogKCk6IENsaWVudFJlY3QgPT4gKHtcbiAgICAgICAgICAgICAgICBib3R0b206IGNsaWVudFksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGNsaWVudFgsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGNsaWVudFgsXG4gICAgICAgICAgICAgICAgdG9wOiBjbGllbnRZLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLm92ZXJsYXkucG9zaXRpb24oKVxuICAgICAgICAgICAgLmNvbm5lY3RlZFRvKFxuICAgICAgICAgICAgICAgIG5ldyBFbGVtZW50UmVmKGZha2VFbGVtZW50KSxcbiAgICAgICAgICAgICAgICB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nIH0sXG4gICAgICAgICAgICAgICAgeyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgeyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAndG9wJyB9LFxuICAgICAgICAgICAgICAgIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnYm90dG9tJyB9KVxuICAgICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKFxuICAgICAgICAgICAgICAgIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICd0b3AnIH0sXG4gICAgICAgICAgICAgICAgeyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgeyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAndG9wJyB9LFxuICAgICAgICAgICAgICAgIHsgb3ZlcmxheVg6ICdlbmQnLCBvdmVybGF5WTogJ3RvcCcgfSlcbiAgICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcbiAgICAgICAgICAgICAgICB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnY2VudGVyJyB9LFxuICAgICAgICAgICAgICAgIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9KVxuICAgICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKFxuICAgICAgICAgICAgICAgIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2NlbnRlcicgfSxcbiAgICAgICAgICAgICAgICB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICdjZW50ZXInIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3Qgb3ZlcmxheUNvbmZpZyA9IG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgICAgICAgIGhhc0JhY2tkcm9wOiBjb25maWcuaGFzQmFja2Ryb3AsXG4gICAgICAgICAgICBiYWNrZHJvcENsYXNzOiBjb25maWcuYmFja2Ryb3BDbGFzcyxcbiAgICAgICAgICAgIHBhbmVsQ2xhc3M6IGNvbmZpZy5wYW5lbENsYXNzLFxuICAgICAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMub3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmNsb3NlKCksXG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvdmVybGF5Q29uZmlnO1xuICAgIH1cbn1cbiJdfQ==