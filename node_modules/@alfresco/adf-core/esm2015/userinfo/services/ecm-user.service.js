/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { from, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { ContentService } from '../../services/content.service';
import { AlfrescoApiService } from '../../services/alfresco-api.service';
import { LogService } from '../../services/log.service';
import { EcmUserModel } from '../models/ecm-user.model';
import * as i0 from "@angular/core";
import * as i1 from "../../services/alfresco-api.service";
import * as i2 from "../../services/content.service";
import * as i3 from "../../services/log.service";
export class EcmUserService {
    /**
     * @param {?} apiService
     * @param {?} contentService
     * @param {?} logService
     */
    constructor(apiService, contentService, logService) {
        this.apiService = apiService;
        this.contentService = contentService;
        this.logService = logService;
    }
    /**
     * Gets information about a user identified by their username.
     * @param {?} userName Target username
     * @return {?} User information
     */
    getUserInfo(userName) {
        return from(this.apiService.getInstance().core.peopleApi.getPerson(userName))
            .pipe(map((/**
         * @param {?} personEntry
         * @return {?}
         */
        (personEntry) => {
            return new EcmUserModel(personEntry.entry);
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets information about the user who is currently logged-in.
     * @return {?} User information as for getUserInfo
     */
    getCurrentUserInfo() {
        return this.getUserInfo('-me-');
    }
    /**
     * Returns a profile image as a URL.
     * @param {?} avatarId Target avatar
     * @return {?} Image URL
     */
    getUserProfileImage(avatarId) {
        if (avatarId) {
            /** @type {?} */
            const nodeObj = { entry: { id: avatarId } };
            return this.contentService.getContentUrl(nodeObj);
        }
    }
    /**
     * Throw the error
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
EcmUserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
EcmUserService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: ContentService },
    { type: LogService }
];
/** @nocollapse */ EcmUserService.ngInjectableDef = i0.defineInjectable({ factory: function EcmUserService_Factory() { return new EcmUserService(i0.inject(i1.AlfrescoApiService), i0.inject(i2.ContentService), i0.inject(i3.LogService)); }, token: EcmUserService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    EcmUserService.prototype.apiService;
    /**
     * @type {?}
     * @private
     */
    EcmUserService.prototype.contentService;
    /**
     * @type {?}
     * @private
     */
    EcmUserService.prototype.logService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNtLXVzZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbInVzZXJpbmZvL3NlcnZpY2VzL2VjbS11c2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNoRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN6RSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDeEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDOzs7OztBQU14RCxNQUFNLE9BQU8sY0FBYzs7Ozs7O0lBRXZCLFlBQW9CLFVBQThCLEVBQzlCLGNBQThCLEVBQzlCLFVBQXNCO1FBRnRCLGVBQVUsR0FBVixVQUFVLENBQW9CO1FBQzlCLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5QixlQUFVLEdBQVYsVUFBVSxDQUFZO0lBQzFDLENBQUM7Ozs7OztJQU9ELFdBQVcsQ0FBQyxRQUFnQjtRQUN4QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3hFLElBQUksQ0FDRCxHQUFHOzs7O1FBQUMsQ0FBQyxXQUF3QixFQUFFLEVBQUU7WUFDN0IsT0FBTyxJQUFJLFlBQVksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0MsQ0FBQyxFQUFDLEVBQ0YsVUFBVTs7OztRQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFDLENBQzdDLENBQUM7SUFDVixDQUFDOzs7OztJQU1ELGtCQUFrQjtRQUNkLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwQyxDQUFDOzs7Ozs7SUFPRCxtQkFBbUIsQ0FBQyxRQUFnQjtRQUNoQyxJQUFJLFFBQVEsRUFBRTs7a0JBQ0osT0FBTyxHQUFHLEVBQUMsS0FBSyxFQUFFLEVBQUMsRUFBRSxFQUFFLFFBQVEsRUFBQyxFQUFDO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDckQ7SUFDTCxDQUFDOzs7Ozs7O0lBTU8sV0FBVyxDQUFDLEtBQVU7UUFDMUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0IsT0FBTyxVQUFVLENBQUMsS0FBSyxJQUFJLGNBQWMsQ0FBQyxDQUFDO0lBQy9DLENBQUM7OztZQXBESixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7Ozs7WUFQUSxrQkFBa0I7WUFEbEIsY0FBYztZQUVkLFVBQVU7Ozs7Ozs7O0lBU0gsb0NBQXNDOzs7OztJQUN0Qyx3Q0FBc0M7Ozs7O0lBQ3RDLG9DQUE4QiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20sIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENvbnRlbnRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29udGVudC5zZXJ2aWNlJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2FsZnJlc2NvLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IExvZ1NlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9sb2cuc2VydmljZSc7XG5pbXBvcnQgeyBFY21Vc2VyTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvZWNtLXVzZXIubW9kZWwnO1xuaW1wb3J0IHsgUGVyc29uRW50cnkgfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcblxuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBFY21Vc2VyU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRlbnRTZXJ2aWNlOiBDb250ZW50U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IGEgdXNlciBpZGVudGlmaWVkIGJ5IHRoZWlyIHVzZXJuYW1lLlxuICAgICAqIEBwYXJhbSB1c2VyTmFtZSBUYXJnZXQgdXNlcm5hbWVcbiAgICAgKiBAcmV0dXJucyBVc2VyIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgZ2V0VXNlckluZm8odXNlck5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8RWNtVXNlck1vZGVsPiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvcmUucGVvcGxlQXBpLmdldFBlcnNvbih1c2VyTmFtZSkpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHBlcnNvbkVudHJ5OiBQZXJzb25FbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVjbVVzZXJNb2RlbChwZXJzb25FbnRyeS5lbnRyeSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIgd2hvIGlzIGN1cnJlbnRseSBsb2dnZWQtaW4uXG4gICAgICogQHJldHVybnMgVXNlciBpbmZvcm1hdGlvbiBhcyBmb3IgZ2V0VXNlckluZm9cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50VXNlckluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVzZXJJbmZvKCctbWUtJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb2ZpbGUgaW1hZ2UgYXMgYSBVUkwuXG4gICAgICogQHBhcmFtIGF2YXRhcklkIFRhcmdldCBhdmF0YXJcbiAgICAgKiBAcmV0dXJucyBJbWFnZSBVUkxcbiAgICAgKi9cbiAgICBnZXRVc2VyUHJvZmlsZUltYWdlKGF2YXRhcklkOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGF2YXRhcklkKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlT2JqID0ge2VudHJ5OiB7aWQ6IGF2YXRhcklkfX07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2VydmljZS5nZXRDb250ZW50VXJsKG5vZGVPYmopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhyb3cgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIGVycm9yXG4gICAgICovXG4gICAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogYW55KSB7XG4gICAgICAgIHRoaXMubG9nU2VydmljZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yIHx8ICdTZXJ2ZXIgZXJyb3InKTtcbiAgICB9XG5cbn1cbiJdfQ==