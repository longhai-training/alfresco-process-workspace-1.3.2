/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { from, of } from 'rxjs';
import { AlfrescoApiService } from './alfresco-api.service';
import { UserPreferencesService } from './user-preferences.service';
import { catchError } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./alfresco-api.service";
import * as i2 from "./user-preferences.service";
export class SharedLinksApiService {
    /**
     * @param {?} apiService
     * @param {?} preferences
     */
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    /**
     * @private
     * @return {?}
     */
    get sharedLinksApi() {
        return this.apiService.getInstance().core.sharedlinksApi;
    }
    /**
     * Gets shared links available to the current user.
     * @param {?=} options Options supported by JS-API
     * @return {?} List of shared links
     */
    getSharedLinks(options = {}) {
        /** @type {?} */
        const defaultOptions = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['properties', 'allowableOperations']
        };
        /** @type {?} */
        const queryOptions = Object.assign({}, defaultOptions, options);
        /** @type {?} */
        const promise = this.sharedLinksApi.findSharedLinks(queryOptions);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => of(err))));
    }
    /**
     * Creates a shared link available to the current user.
     * @param {?} nodeId ID of the node to link to
     * @param {?=} options Options supported by JS-API
     * @return {?} The shared link just created
     */
    createSharedLinks(nodeId, options = {}) {
        /** @type {?} */
        const promise = this.sharedLinksApi.addSharedLink({ nodeId: nodeId });
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => of(err))));
    }
    /**
     * Deletes a shared link.
     * @param {?} sharedId ID of the link to delete
     * @return {?} Null response notifying when the operation is complete
     */
    deleteSharedLink(sharedId) {
        /** @type {?} */
        const promise = this.sharedLinksApi.deleteSharedLink(sharedId);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => of(err))));
    }
}
SharedLinksApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SharedLinksApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];
/** @nocollapse */ SharedLinksApiService.ngInjectableDef = i0.defineInjectable({ factory: function SharedLinksApiService_Factory() { return new SharedLinksApiService(i0.inject(i1.AlfrescoApiService), i0.inject(i2.UserPreferencesService)); }, token: SharedLinksApiService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    SharedLinksApiService.prototype.apiService;
    /**
     * @type {?}
     * @private
     */
    SharedLinksApiService.prototype.preferences;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhcmVkLWxpbmtzLWFwaS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsic2VydmljZXMvc2hhcmVkLWxpbmtzLWFwaS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFjLElBQUksRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDNUQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDcEUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBSzVDLE1BQU0sT0FBTyxxQkFBcUI7Ozs7O0lBRTlCLFlBQW9CLFVBQThCLEVBQzlCLFdBQW1DO1FBRG5DLGVBQVUsR0FBVixVQUFVLENBQW9CO1FBQzlCLGdCQUFXLEdBQVgsV0FBVyxDQUF3QjtJQUN2RCxDQUFDOzs7OztJQUVELElBQVksY0FBYztRQUN0QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUM3RCxDQUFDOzs7Ozs7SUFPRCxjQUFjLENBQUMsVUFBZSxFQUFFOztjQUN0QixjQUFjLEdBQUc7WUFDbkIsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYztZQUN6QyxTQUFTLEVBQUUsQ0FBQztZQUNaLE9BQU8sRUFBRSxDQUFDLFlBQVksRUFBRSxxQkFBcUIsQ0FBQztTQUNqRDs7Y0FDSyxZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsY0FBYyxFQUFFLE9BQU8sQ0FBQzs7Y0FDekQsT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQztRQUVqRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ3JCLFVBQVU7Ozs7UUFBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFDLENBQy9CLENBQUM7SUFDTixDQUFDOzs7Ozs7O0lBUUQsaUJBQWlCLENBQUMsTUFBYyxFQUFFLFVBQWUsRUFBRTs7Y0FDekMsT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDO1FBRXJFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDckIsVUFBVTs7OztRQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUMsQ0FDL0IsQ0FBQztJQUNOLENBQUM7Ozs7OztJQU9ELGdCQUFnQixDQUFDLFFBQWdCOztjQUN2QixPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUM7UUFFOUQsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNyQixVQUFVOzs7O1FBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQyxDQUMvQixDQUFDO0lBQ04sQ0FBQzs7O1lBekRKLFVBQVUsU0FBQztnQkFDUixVQUFVLEVBQUUsTUFBTTthQUNyQjs7OztZQU5RLGtCQUFrQjtZQUNsQixzQkFBc0I7Ozs7Ozs7O0lBUWYsMkNBQXNDOzs7OztJQUN0Qyw0Q0FBMkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOb2RlUGFnaW5nLCBTaGFyZWRMaW5rRW50cnkgfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20sIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UgfSBmcm9tICcuL2FsZnJlc2NvLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UgfSBmcm9tICcuL3VzZXItcHJlZmVyZW5jZXMuc2VydmljZSc7XG5pbXBvcnQgeyBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFNoYXJlZExpbmtzQXBpU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHByZWZlcmVuY2VzOiBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgc2hhcmVkTGlua3NBcGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5jb3JlLnNoYXJlZGxpbmtzQXBpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgc2hhcmVkIGxpbmtzIGF2YWlsYWJsZSB0byB0aGUgY3VycmVudCB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgc3VwcG9ydGVkIGJ5IEpTLUFQSVxuICAgICAqIEByZXR1cm5zIExpc3Qgb2Ygc2hhcmVkIGxpbmtzXG4gICAgICovXG4gICAgZ2V0U2hhcmVkTGlua3Mob3B0aW9uczogYW55ID0ge30pOiBPYnNlcnZhYmxlPE5vZGVQYWdpbmc+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtYXhJdGVtczogdGhpcy5wcmVmZXJlbmNlcy5wYWdpbmF0aW9uU2l6ZSxcbiAgICAgICAgICAgIHNraXBDb3VudDogMCxcbiAgICAgICAgICAgIGluY2x1ZGU6IFsncHJvcGVydGllcycsICdhbGxvd2FibGVPcGVyYXRpb25zJ11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcXVlcnlPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zaGFyZWRMaW5rc0FwaS5maW5kU2hhcmVkTGlua3MocXVlcnlPcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiBvZihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFyZWQgbGluayBhdmFpbGFibGUgdG8gdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSBub2RlIHRvIGxpbmsgdG9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHN1cHBvcnRlZCBieSBKUy1BUElcbiAgICAgKiBAcmV0dXJucyBUaGUgc2hhcmVkIGxpbmsganVzdCBjcmVhdGVkXG4gICAgICovXG4gICAgY3JlYXRlU2hhcmVkTGlua3Mobm9kZUlkOiBzdHJpbmcsIG9wdGlvbnM6IGFueSA9IHt9KTogT2JzZXJ2YWJsZTxTaGFyZWRMaW5rRW50cnk+IHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuc2hhcmVkTGlua3NBcGkuYWRkU2hhcmVkTGluayh7IG5vZGVJZDogbm9kZUlkIH0pO1xuXG4gICAgICAgIHJldHVybiBmcm9tKHByb21pc2UpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKChlcnIpID0+IG9mKGVycikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHNoYXJlZCBsaW5rLlxuICAgICAqIEBwYXJhbSBzaGFyZWRJZCBJRCBvZiB0aGUgbGluayB0byBkZWxldGVcbiAgICAgKiBAcmV0dXJucyBOdWxsIHJlc3BvbnNlIG5vdGlmeWluZyB3aGVuIHRoZSBvcGVyYXRpb24gaXMgY29tcGxldGVcbiAgICAgKi9cbiAgICBkZWxldGVTaGFyZWRMaW5rKHNoYXJlZElkOiBzdHJpbmcpOiBPYnNlcnZhYmxlPFNoYXJlZExpbmtFbnRyeT4ge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zaGFyZWRMaW5rc0FwaS5kZWxldGVTaGFyZWRMaW5rKHNoYXJlZElkKTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiBvZihlcnIpKVxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==