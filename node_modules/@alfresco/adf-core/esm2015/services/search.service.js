/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { Subject, from, throwError } from 'rxjs';
import { AlfrescoApiService } from './alfresco-api.service';
import { SearchConfigurationService } from './search-configuration.service';
import { catchError } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./alfresco-api.service";
import * as i2 from "./search-configuration.service";
export class SearchService {
    /**
     * @param {?} apiService
     * @param {?} searchConfigurationService
     */
    constructor(apiService, searchConfigurationService) {
        this.apiService = apiService;
        this.searchConfigurationService = searchConfigurationService;
        this.dataLoaded = new Subject();
    }
    /**
     * Gets a list of nodes that match the given search criteria.
     * @param {?} term Term to search for
     * @param {?=} options Options for delivery of the search results
     * @return {?} List of nodes resulting from the search
     */
    getNodeQueryResults(term, options) {
        /** @type {?} */
        const promise = this.apiService.getInstance().core.queriesApi.findNodes(term, options);
        promise.then((/**
         * @param {?} nodePaging
         * @return {?}
         */
        (nodePaging) => {
            this.dataLoaded.next(nodePaging);
        }));
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Performs a search.
     * @param {?} searchTerm Term to search for
     * @param {?} maxResults Maximum number of items in the list of results
     * @param {?} skipCount Number of higher-ranked items to skip over in the list
     * @return {?} List of search results
     */
    search(searchTerm, maxResults, skipCount) {
        /** @type {?} */
        const searchQuery = Object.assign(this.searchConfigurationService.generateQueryBody(searchTerm, maxResults, skipCount));
        /** @type {?} */
        const promise = this.apiService.getInstance().search.searchApi.search(searchQuery);
        promise.then((/**
         * @param {?} nodePaging
         * @return {?}
         */
        (nodePaging) => {
            this.dataLoaded.next(nodePaging);
        }));
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Performs a search with its parameters supplied by a QueryBody object.
     * @param {?} queryBody Object containing the search parameters
     * @return {?} List of search results
     */
    searchByQueryBody(queryBody) {
        /** @type {?} */
        const promise = this.apiService.getInstance().search.searchApi.search(queryBody);
        promise.then((/**
         * @param {?} nodePaging
         * @return {?}
         */
        (nodePaging) => {
            this.dataLoaded.next(nodePaging);
        }));
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return throwError(error || 'Server error');
    }
}
SearchService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SearchService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: SearchConfigurationService }
];
/** @nocollapse */ SearchService.ngInjectableDef = i0.defineInjectable({ factory: function SearchService_Factory() { return new SearchService(i0.inject(i1.AlfrescoApiService), i0.inject(i2.SearchConfigurationService)); }, token: SearchService, providedIn: "root" });
if (false) {
    /** @type {?} */
    SearchService.prototype.dataLoaded;
    /**
     * @type {?}
     * @private
     */
    SearchService.prototype.apiService;
    /**
     * @type {?}
     * @private
     */
    SearchService.prototype.searchConfigurationService;
}
/**
 * @record
 */
export function SearchOptions() { }
if (false) {
    /**
     * The number of entities that exist in the collection before those included in this list.
     * @type {?|undefined}
     */
    SearchOptions.prototype.skipCount;
    /**
     * The maximum number of items to return in the list.
     * @type {?|undefined}
     */
    SearchOptions.prototype.maxItems;
    /**
     * The id of the node to start the search from. Supports the aliases -my-, -root- and -shared-.
     * @type {?|undefined}
     */
    SearchOptions.prototype.rootNodeId;
    /**
     * Restrict the returned results to only those of the given node type and its sub-types.
     * @type {?|undefined}
     */
    SearchOptions.prototype.nodeType;
    /**
     * Return additional information about the node. The available optional fields are:
     * `allowableOperations`, `aspectNames`, `isLink`, `isLocked`, `path` and `properties`.
     * @type {?|undefined}
     */
    SearchOptions.prototype.include;
    /**
     * String to control the order of the entities returned in a list. You can use this
     * parameter to sort the list by one or more fields. Each field has a default sort order,
     * which is normally ascending order (but see the JS-API docs to check if any fields used
     * in a method have a descending default search order). To sort the entities in a specific
     * order, you can use the "ASC" and "DESC" keywords for any field.
     * @type {?|undefined}
     */
    SearchOptions.prototype.orderBy;
    /**
     * List of field names. You can use this parameter to restrict the fields returned within
     * a response if, for example, you want to save on overall bandwidth. The list applies to a
     * returned individual entity or entries within a collection. If the API method also supports
     * the `include` parameter, then the fields specified in the include parameter are returned in
     * addition to those specified in the fields parameter.
     * @type {?|undefined}
     */
    SearchOptions.prototype.fields;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9zZWFyY2guc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBYyxPQUFPLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM3RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM1RSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7QUFLNUMsTUFBTSxPQUFPLGFBQWE7Ozs7O0lBSXRCLFlBQW9CLFVBQThCLEVBQzlCLDBCQUFzRDtRQUR0RCxlQUFVLEdBQVYsVUFBVSxDQUFvQjtRQUM5QiwrQkFBMEIsR0FBMUIsMEJBQTBCLENBQTRCO1FBSDFFLGVBQVUsR0FBd0IsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQUloRCxDQUFDOzs7Ozs7O0lBUUQsbUJBQW1CLENBQUMsSUFBWSxFQUFFLE9BQXVCOztjQUMvQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDO1FBRXRGLE9BQU8sQ0FBQyxJQUFJOzs7O1FBQUMsQ0FBQyxVQUFzQixFQUFFLEVBQUU7WUFDcEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckMsQ0FBQyxFQUFDLENBQUM7UUFFSCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ3JCLFVBQVU7Ozs7UUFBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBQyxDQUM3QyxDQUFDO0lBQ04sQ0FBQzs7Ozs7Ozs7SUFTRCxNQUFNLENBQUMsVUFBa0IsRUFBRSxVQUFrQixFQUFFLFNBQWlCOztjQUN0RCxXQUFXLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsaUJBQWlCLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQzs7Y0FDakgsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDO1FBRWxGLE9BQU8sQ0FBQyxJQUFJOzs7O1FBQUMsQ0FBQyxVQUFzQixFQUFFLEVBQUU7WUFDcEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckMsQ0FBQyxFQUFDLENBQUM7UUFFSCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ3JCLFVBQVU7Ozs7UUFBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBQyxDQUM3QyxDQUFDO0lBQ04sQ0FBQzs7Ozs7O0lBT0QsaUJBQWlCLENBQUMsU0FBb0I7O2NBQzVCLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUVoRixPQUFPLENBQUMsSUFBSTs7OztRQUFDLENBQUMsVUFBc0IsRUFBRSxFQUFFO1lBQ3BDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3JDLENBQUMsRUFBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNyQixVQUFVOzs7O1FBQUMsQ0FBQyxHQUFRLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUMsQ0FDbEQsQ0FBQztJQUNOLENBQUM7Ozs7OztJQUVPLFdBQVcsQ0FBQyxLQUFVO1FBQzFCLE9BQU8sVUFBVSxDQUFDLEtBQUssSUFBSSxjQUFjLENBQUMsQ0FBQztJQUMvQyxDQUFDOzs7WUFwRUosVUFBVSxTQUFDO2dCQUNSLFVBQVUsRUFBRSxNQUFNO2FBQ3JCOzs7O1lBTlEsa0JBQWtCO1lBQ2xCLDBCQUEwQjs7Ozs7SUFRL0IsbUNBQWdEOzs7OztJQUVwQyxtQ0FBc0M7Ozs7O0lBQ3RDLG1EQUE4RDs7Ozs7QUErRDlFLG1DQW9DQzs7Ozs7O0lBbENHLGtDQUFtQjs7Ozs7SUFHbkIsaUNBQWtCOzs7OztJQUdsQixtQ0FBb0I7Ozs7O0lBR3BCLGlDQUFrQjs7Ozs7O0lBTWxCLGdDQUFtQjs7Ozs7Ozs7O0lBU25CLGdDQUFpQjs7Ozs7Ozs7O0lBU2pCLCtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5vZGVQYWdpbmcsIFF1ZXJ5Qm9keSB9IGZyb20gJ0BhbGZyZXNjby9qcy1hcGknO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnLi9hbGZyZXNjby1hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hDb25maWd1cmF0aW9uU2VydmljZSB9IGZyb20gJy4vc2VhcmNoLWNvbmZpZ3VyYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaFNlcnZpY2Uge1xuXG4gICAgZGF0YUxvYWRlZDogU3ViamVjdDxOb2RlUGFnaW5nPiA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHNlYXJjaENvbmZpZ3VyYXRpb25TZXJ2aWNlOiBTZWFyY2hDb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHNlYXJjaCBjcml0ZXJpYS5cbiAgICAgKiBAcGFyYW0gdGVybSBUZXJtIHRvIHNlYXJjaCBmb3JcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBkZWxpdmVyeSBvZiB0aGUgc2VhcmNoIHJlc3VsdHNcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIG5vZGVzIHJlc3VsdGluZyBmcm9tIHRoZSBzZWFyY2hcbiAgICAgKi9cbiAgICBnZXROb2RlUXVlcnlSZXN1bHRzKHRlcm06IHN0cmluZywgb3B0aW9ucz86IFNlYXJjaE9wdGlvbnMpOiBPYnNlcnZhYmxlPE5vZGVQYWdpbmc+IHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvcmUucXVlcmllc0FwaS5maW5kTm9kZXModGVybSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKChub2RlUGFnaW5nOiBOb2RlUGFnaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMb2FkZWQubmV4dChub2RlUGFnaW5nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZyb20ocHJvbWlzZSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgc2VhcmNoLlxuICAgICAqIEBwYXJhbSBzZWFyY2hUZXJtIFRlcm0gdG8gc2VhcmNoIGZvclxuICAgICAqIEBwYXJhbSBtYXhSZXN1bHRzIE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0IG9mIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0gc2tpcENvdW50IE51bWJlciBvZiBoaWdoZXItcmFua2VkIGl0ZW1zIHRvIHNraXAgb3ZlciBpbiB0aGUgbGlzdFxuICAgICAqIEByZXR1cm5zIExpc3Qgb2Ygc2VhcmNoIHJlc3VsdHNcbiAgICAgKi9cbiAgICBzZWFyY2goc2VhcmNoVGVybTogc3RyaW5nLCBtYXhSZXN1bHRzOiBudW1iZXIsIHNraXBDb3VudDogbnVtYmVyKTogT2JzZXJ2YWJsZTxOb2RlUGFnaW5nPiB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih0aGlzLnNlYXJjaENvbmZpZ3VyYXRpb25TZXJ2aWNlLmdlbmVyYXRlUXVlcnlCb2R5KHNlYXJjaFRlcm0sIG1heFJlc3VsdHMsIHNraXBDb3VudCkpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuc2VhcmNoLnNlYXJjaEFwaS5zZWFyY2goc2VhcmNoUXVlcnkpO1xuXG4gICAgICAgIHByb21pc2UudGhlbigobm9kZVBhZ2luZzogTm9kZVBhZ2luZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRhTG9hZGVkLm5leHQobm9kZVBhZ2luZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmcm9tKHByb21pc2UpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKChlcnIpID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHNlYXJjaCB3aXRoIGl0cyBwYXJhbWV0ZXJzIHN1cHBsaWVkIGJ5IGEgUXVlcnlCb2R5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcXVlcnlCb2R5IE9iamVjdCBjb250YWluaW5nIHRoZSBzZWFyY2ggcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIExpc3Qgb2Ygc2VhcmNoIHJlc3VsdHNcbiAgICAgKi9cbiAgICBzZWFyY2hCeVF1ZXJ5Qm9keShxdWVyeUJvZHk6IFF1ZXJ5Qm9keSk6IE9ic2VydmFibGU8Tm9kZVBhZ2luZz4ge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuc2VhcmNoLnNlYXJjaEFwaS5zZWFyY2gocXVlcnlCb2R5KTtcblxuICAgICAgICBwcm9taXNlLnRoZW4oKG5vZGVQYWdpbmc6IE5vZGVQYWdpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxvYWRlZC5uZXh0KG5vZGVQYWdpbmcpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyOiBhbnkpID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciB8fCAnU2VydmVyIGVycm9yJyk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaE9wdGlvbnMge1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGVudGl0aWVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24gYmVmb3JlIHRob3NlIGluY2x1ZGVkIGluIHRoaXMgbGlzdC4gKi9cbiAgICBza2lwQ291bnQ/OiBudW1iZXI7XG5cbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybiBpbiB0aGUgbGlzdC4gKi9cbiAgICBtYXhJdGVtcz86IG51bWJlcjtcblxuICAgIC8qKiBUaGUgaWQgb2YgdGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCBmcm9tLiBTdXBwb3J0cyB0aGUgYWxpYXNlcyAtbXktLCAtcm9vdC0gYW5kIC1zaGFyZWQtLiAqL1xuICAgIHJvb3ROb2RlSWQ/OiBzdHJpbmc7XG5cbiAgICAvKiogUmVzdHJpY3QgdGhlIHJldHVybmVkIHJlc3VsdHMgdG8gb25seSB0aG9zZSBvZiB0aGUgZ2l2ZW4gbm9kZSB0eXBlIGFuZCBpdHMgc3ViLXR5cGVzLiAqL1xuICAgIG5vZGVUeXBlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG5vZGUuIFRoZSBhdmFpbGFibGUgb3B0aW9uYWwgZmllbGRzIGFyZTpcbiAgICAgKiBgYWxsb3dhYmxlT3BlcmF0aW9uc2AsIGBhc3BlY3ROYW1lc2AsIGBpc0xpbmtgLCBgaXNMb2NrZWRgLCBgcGF0aGAgYW5kIGBwcm9wZXJ0aWVzYC5cbiAgICAgKi9cbiAgICBpbmNsdWRlPzogc3RyaW5nW107XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgdG8gY29udHJvbCB0aGUgb3JkZXIgb2YgdGhlIGVudGl0aWVzIHJldHVybmVkIGluIGEgbGlzdC4gWW91IGNhbiB1c2UgdGhpc1xuICAgICAqIHBhcmFtZXRlciB0byBzb3J0IHRoZSBsaXN0IGJ5IG9uZSBvciBtb3JlIGZpZWxkcy4gRWFjaCBmaWVsZCBoYXMgYSBkZWZhdWx0IHNvcnQgb3JkZXIsXG4gICAgICogd2hpY2ggaXMgbm9ybWFsbHkgYXNjZW5kaW5nIG9yZGVyIChidXQgc2VlIHRoZSBKUy1BUEkgZG9jcyB0byBjaGVjayBpZiBhbnkgZmllbGRzIHVzZWRcbiAgICAgKiBpbiBhIG1ldGhvZCBoYXZlIGEgZGVzY2VuZGluZyBkZWZhdWx0IHNlYXJjaCBvcmRlcikuIFRvIHNvcnQgdGhlIGVudGl0aWVzIGluIGEgc3BlY2lmaWNcbiAgICAgKiBvcmRlciwgeW91IGNhbiB1c2UgdGhlIFwiQVNDXCIgYW5kIFwiREVTQ1wiIGtleXdvcmRzIGZvciBhbnkgZmllbGQuXG4gICAgICovXG4gICAgb3JkZXJCeT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgZmllbGQgbmFtZXMuIFlvdSBjYW4gdXNlIHRoaXMgcGFyYW1ldGVyIHRvIHJlc3RyaWN0IHRoZSBmaWVsZHMgcmV0dXJuZWQgd2l0aGluXG4gICAgICogYSByZXNwb25zZSBpZiwgZm9yIGV4YW1wbGUsIHlvdSB3YW50IHRvIHNhdmUgb24gb3ZlcmFsbCBiYW5kd2lkdGguIFRoZSBsaXN0IGFwcGxpZXMgdG8gYVxuICAgICAqIHJldHVybmVkIGluZGl2aWR1YWwgZW50aXR5IG9yIGVudHJpZXMgd2l0aGluIGEgY29sbGVjdGlvbi4gSWYgdGhlIEFQSSBtZXRob2QgYWxzbyBzdXBwb3J0c1xuICAgICAqIHRoZSBgaW5jbHVkZWAgcGFyYW1ldGVyLCB0aGVuIHRoZSBmaWVsZHMgc3BlY2lmaWVkIGluIHRoZSBpbmNsdWRlIHBhcmFtZXRlciBhcmUgcmV0dXJuZWQgaW5cbiAgICAgKiBhZGRpdGlvbiB0byB0aG9zZSBzcGVjaWZpZWQgaW4gdGhlIGZpZWxkcyBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgZmllbGRzPzogc3RyaW5nW107XG59XG4iXX0=