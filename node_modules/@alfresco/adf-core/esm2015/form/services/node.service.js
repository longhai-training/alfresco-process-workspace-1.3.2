/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AlfrescoApiService } from '../../services/alfresco-api.service';
import { Injectable } from '@angular/core';
import { from } from 'rxjs';
import { NodeMetadata } from '../models/node-metadata.model';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../services/alfresco-api.service";
export class NodeService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * Get the metadata and the nodeType for a nodeId cleaned by the prefix.
     * @param {?} nodeId ID of the target node
     * @return {?} Node metadata
     */
    getNodeMetadata(nodeId) {
        return from(this.apiService.getInstance().nodes.getNode(nodeId))
            .pipe(map(this.cleanMetadataFromSemicolon));
    }
    /**
     * Create a new Node from form metadata.
     * @param {?} nodeType Node type
     * @param {?} nameSpace Namespace for properties
     * @param {?} data Property data to store in the node under namespace
     * @param {?} path Path to the node
     * @param {?=} name Node name
     * @return {?} The created node
     */
    createNodeMetadata(nodeType, nameSpace, data, path, name) {
        /** @type {?} */
        const properties = {};
        for (const key in data) {
            if (data[key]) {
                properties[nameSpace + ':' + key] = data[key];
            }
        }
        return this.createNode(name || this.generateUuid(), nodeType, properties, path);
    }
    /**
     * Create a new Node from form metadata
     * @param {?} name Node name
     * @param {?} nodeType Node type
     * @param {?} properties Node body properties
     * @param {?} path Path to the node
     * @return {?} The created node
     */
    createNode(name, nodeType, properties, path) {
        /** @type {?} */
        const body = {
            name: name,
            nodeType: nodeType,
            properties: properties,
            relativePath: path
        };
        /** @type {?} */
        const apiService = this.apiService.getInstance();
        return from(apiService.nodes.addNode('-root-', body, {}));
    }
    /**
     * @private
     * @return {?}
     */
    generateUuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (/**
         * @param {?} c
         * @return {?}
         */
        function (c) {
            /** @type {?} */
            const r = Math.random() * 16 | 0;
            /** @type {?} */
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        }));
    }
    /**
     * @private
     * @param {?} nodeEntry
     * @return {?}
     */
    cleanMetadataFromSemicolon(nodeEntry) {
        /** @type {?} */
        const metadata = {};
        if (nodeEntry && nodeEntry.entry.properties) {
            for (const key in nodeEntry.entry.properties) {
                if (key) {
                    if (key.indexOf(':') !== -1) {
                        metadata[key.split(':')[1]] = nodeEntry.entry.properties[key];
                    }
                    else {
                        metadata[key] = nodeEntry.entry.properties[key];
                    }
                }
            }
        }
        return new NodeMetadata(metadata, nodeEntry.entry.nodeType);
    }
}
NodeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NodeService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ NodeService.ngInjectableDef = i0.defineInjectable({ factory: function NodeService_Factory() { return new NodeService(i0.inject(i1.AlfrescoApiService)); }, token: NodeService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NodeService.prototype.apiService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsiZm9ybS9zZXJ2aWNlcy9ub2RlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDekUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsSUFBSSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUM3RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQU1yQyxNQUFNLE9BQU8sV0FBVzs7OztJQUVwQixZQUFvQixVQUE4QjtRQUE5QixlQUFVLEdBQVYsVUFBVSxDQUFvQjtJQUNsRCxDQUFDOzs7Ozs7SUFPTSxlQUFlLENBQUMsTUFBYztRQUNqQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDM0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7Ozs7Ozs7Ozs7SUFXTSxrQkFBa0IsQ0FBQyxRQUFnQixFQUFFLFNBQWMsRUFBRSxJQUFTLEVBQUUsSUFBWSxFQUFFLElBQWE7O2NBQ3hGLFVBQVUsR0FBRyxFQUFFO1FBQ3JCLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ3BCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNYLFVBQVUsQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNqRDtTQUNKO1FBRUQsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNwRixDQUFDOzs7Ozs7Ozs7SUFVTSxVQUFVLENBQUMsSUFBWSxFQUFFLFFBQWdCLEVBQUUsVUFBZSxFQUFFLElBQVk7O2NBQ3JFLElBQUksR0FBRztZQUNULElBQUksRUFBRSxJQUFJO1lBQ1YsUUFBUSxFQUFFLFFBQVE7WUFDbEIsVUFBVSxFQUFFLFVBQVU7WUFDdEIsWUFBWSxFQUFFLElBQUk7U0FDckI7O2NBRUssVUFBVSxHQUE2QixJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRTtRQUMxRSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUQsQ0FBQzs7Ozs7SUFFTyxZQUFZO1FBQ2hCLE9BQU8sc0NBQXNDLENBQUMsT0FBTyxDQUFDLE9BQU87Ozs7UUFBRSxVQUFVLENBQUM7O2tCQUNoRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDOztrQkFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQ3JFLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMxQixDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7OztJQUVPLDBCQUEwQixDQUFDLFNBQW9COztjQUM3QyxRQUFRLEdBQUcsRUFBRTtRQUVuQixJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRTtZQUN6QyxLQUFLLE1BQU0sR0FBRyxJQUFJLFNBQVMsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO2dCQUMxQyxJQUFJLEdBQUcsRUFBRTtvQkFDTCxJQUFJLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7d0JBQ3pCLFFBQVEsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7cUJBQ2xFO3lCQUFNO3dCQUNILFFBQVEsQ0FBRSxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztxQkFDcEQ7aUJBQ0o7YUFDSjtTQUNKO1FBRUQsT0FBTyxJQUFJLFlBQVksQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNoRSxDQUFDOzs7WUFqRkosVUFBVSxTQUFDO2dCQUNSLFVBQVUsRUFBRSxNQUFNO2FBQ3JCOzs7O1lBVFEsa0JBQWtCOzs7Ozs7OztJQVlYLGlDQUFzQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2FsZnJlc2NvLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5vZGVNZXRhZGF0YSB9IGZyb20gJy4uL21vZGVscy9ub2RlLW1ldGFkYXRhLm1vZGVsJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpQ29tcGF0aWJpbGl0eSwgTm9kZUVudHJ5IH0gZnJvbSAnQGFsZnJlc2NvL2pzLWFwaSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgTm9kZVNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1ldGFkYXRhIGFuZCB0aGUgbm9kZVR5cGUgZm9yIGEgbm9kZUlkIGNsZWFuZWQgYnkgdGhlIHByZWZpeC5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEByZXR1cm5zIE5vZGUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Tm9kZU1ldGFkYXRhKG5vZGVJZDogc3RyaW5nKTogT2JzZXJ2YWJsZTxOb2RlTWV0YWRhdGE+IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkubm9kZXMuZ2V0Tm9kZShub2RlSWQpKVxuICAgICAgICAgICAgLnBpcGUobWFwKHRoaXMuY2xlYW5NZXRhZGF0YUZyb21TZW1pY29sb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgTm9kZSBmcm9tIGZvcm0gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHBhdGggUGF0aCB0byB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSBub2RlVHlwZSBOb2RlIHR5cGVcbiAgICAgKiBAcGFyYW0gbmFtZSBOb2RlIG5hbWVcbiAgICAgKiBAcGFyYW0gbmFtZVNwYWNlIE5hbWVzcGFjZSBmb3IgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSBkYXRhIFByb3BlcnR5IGRhdGEgdG8gc3RvcmUgaW4gdGhlIG5vZGUgdW5kZXIgbmFtZXNwYWNlXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbm9kZVxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVOb2RlTWV0YWRhdGEobm9kZVR5cGU6IHN0cmluZywgbmFtZVNwYWNlOiBhbnksIGRhdGE6IGFueSwgcGF0aDogc3RyaW5nLCBuYW1lPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxOb2RlRW50cnk+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtrZXldKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1tuYW1lU3BhY2UgKyAnOicgKyBrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTm9kZShuYW1lIHx8IHRoaXMuZ2VuZXJhdGVVdWlkKCksIG5vZGVUeXBlLCBwcm9wZXJ0aWVzLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgTm9kZSBmcm9tIGZvcm0gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gbmFtZSBOb2RlIG5hbWVcbiAgICAgKiBAcGFyYW0gbm9kZVR5cGUgTm9kZSB0eXBlXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXMgTm9kZSBib2R5IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gcGF0aCBQYXRoIHRvIHRoZSBub2RlXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbm9kZVxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVOb2RlKG5hbWU6IHN0cmluZywgbm9kZVR5cGU6IHN0cmluZywgcHJvcGVydGllczogYW55LCBwYXRoOiBzdHJpbmcpOiBPYnNlcnZhYmxlPE5vZGVFbnRyeT4ge1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIG5vZGVUeXBlOiBub2RlVHlwZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgICAgICByZWxhdGl2ZVBhdGg6IHBhdGhcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaUNvbXBhdGliaWxpdHkgPSB0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgcmV0dXJuIGZyb20oYXBpU2VydmljZS5ub2Rlcy5hZGROb2RlKCctcm9vdC0nLCBib2R5LCB7fSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2VuZXJhdGVVdWlkKCkge1xuICAgICAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFuTWV0YWRhdGFGcm9tU2VtaWNvbG9uKG5vZGVFbnRyeTogTm9kZUVudHJ5KTogTm9kZU1ldGFkYXRhIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcblxuICAgICAgICBpZiAobm9kZUVudHJ5ICYmIG5vZGVFbnRyeS5lbnRyeS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub2RlRW50cnkuZW50cnkucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSBba2V5LnNwbGl0KCc6JylbMV1dID0gbm9kZUVudHJ5LmVudHJ5LnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhIFtrZXldID0gbm9kZUVudHJ5LmVudHJ5LnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTm9kZU1ldGFkYXRhKG1ldGFkYXRhLCBub2RlRW50cnkuZW50cnkubm9kZVR5cGUpO1xuICAgIH1cbn1cbiJdfQ==