/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable: component-selector no-use-before-declare no-input-rename  */
import { Directive, ElementRef, forwardRef, HostListener, Input, Renderer2 } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
/** @type {?} */
export const CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => InputMaskDirective)),
    multi: true
};
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
export class InputMaskDirective {
    /**
     * @param {?} el
     * @param {?} render
     */
    constructor(el, render) {
        this.el = el;
        this.render = render;
        this.translationMask = {
            '0': { pattern: /\d/ },
            '9': { pattern: /\d/, optional: true },
            '#': { pattern: /\d/, recursive: true },
            'A': { pattern: /[a-zA-Z0-9]/ },
            'S': { pattern: /[a-zA-Z]/ }
        };
        this.byPassKeys = [9, 16, 17, 18, 36, 37, 38, 39, 40, 91];
        this.invalidCharacters = [];
        this._onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        this._onTouched = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTextInput(event) {
        if (this.inputMask && this.inputMask.mask) {
            this.maskValue(this.el.nativeElement.value, this.el.nativeElement.selectionStart, this.inputMask.mask, this.inputMask.isReversed, event.keyCode);
        }
        else {
            this._onChange(this.el.nativeElement.value);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['inputMask'] && changes['inputMask'].currentValue['mask']) {
            this.inputMask = changes['inputMask'].currentValue;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.el.nativeElement.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @private
     * @param {?} actualValue
     * @param {?} startCaret
     * @param {?} maskToApply
     * @param {?} isMaskReversed
     * @param {?} keyCode
     * @return {?}
     */
    maskValue(actualValue, startCaret, maskToApply, isMaskReversed, keyCode) {
        if (this.byPassKeys.indexOf(keyCode) === -1) {
            /** @type {?} */
            const value = this.getMasked(false, actualValue, maskToApply, isMaskReversed);
            /** @type {?} */
            const calculatedCaret = this.calculateCaretPosition(startCaret, actualValue, keyCode);
            this.render.setAttribute(this.el.nativeElement, 'value', value);
            this.el.nativeElement.value = value;
            this.setValue(value);
            this._onChange(value);
            this.setCaretPosition(calculatedCaret);
        }
    }
    /**
     * @private
     * @param {?} caretPosition
     * @return {?}
     */
    setCaretPosition(caretPosition) {
        this.el.nativeElement.moveStart = caretPosition;
        this.el.nativeElement.moveEnd = caretPosition;
    }
    /**
     * @param {?} caretPosition
     * @param {?} newValue
     * @param {?} keyCode
     * @return {?}
     */
    calculateCaretPosition(caretPosition, newValue, keyCode) {
        /** @type {?} */
        const newValueLength = newValue.length;
        /** @type {?} */
        const oldValue = this.getValue() || '';
        /** @type {?} */
        const oldValueLength = oldValue.length;
        if (keyCode === 8 && oldValue !== newValue) {
            caretPosition = caretPosition - (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
        }
        else if (oldValue !== newValue) {
            if (caretPosition >= oldValueLength) {
                caretPosition = newValueLength;
            }
            else {
                caretPosition = caretPosition + (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
            }
        }
        return caretPosition;
    }
    /**
     * @param {?} skipMaskChars
     * @param {?} val
     * @param {?} mask
     * @param {?=} isReversed
     * @return {?}
     */
    getMasked(skipMaskChars, val, mask, isReversed = false) {
        /** @type {?} */
        const buf = [];
        /** @type {?} */
        const value = val;
        /** @type {?} */
        let maskIndex = 0;
        /** @type {?} */
        const maskLen = mask.length;
        /** @type {?} */
        let valueIndex = 0;
        /** @type {?} */
        const valueLength = value.length;
        /** @type {?} */
        let offset = 1;
        /** @type {?} */
        let addMethod = 'push';
        /** @type {?} */
        let resetPos = -1;
        /** @type {?} */
        let lastMaskChar;
        /** @type {?} */
        let lastUntranslatedMaskChar;
        /** @type {?} */
        let check;
        if (isReversed) {
            addMethod = 'unshift';
            offset = -1;
            lastMaskChar = 0;
            maskIndex = maskLen - 1;
            valueIndex = valueLength - 1;
        }
        else {
            lastMaskChar = maskLen - 1;
        }
        check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        while (check) {
            /** @type {?} */
            const maskDigit = mask.charAt(maskIndex);
            /** @type {?} */
            const valDigit = value.charAt(valueIndex);
            /** @type {?} */
            const translation = this.translationMask[maskDigit];
            if (translation) {
                if (valDigit.match(translation.pattern)) {
                    buf[addMethod](valDigit);
                    if (translation.recursive) {
                        if (resetPos === -1) {
                            resetPos = maskIndex;
                        }
                        else if (maskIndex === lastMaskChar) {
                            maskIndex = resetPos - offset;
                        }
                        if (lastMaskChar === resetPos) {
                            maskIndex -= offset;
                        }
                    }
                    maskIndex += offset;
                }
                else if (valDigit === lastUntranslatedMaskChar) {
                    lastUntranslatedMaskChar = undefined;
                }
                else if (translation.optional) {
                    maskIndex += offset;
                    valueIndex -= offset;
                }
                else {
                    this.invalidCharacters.push({
                        index: valueIndex,
                        digit: valDigit,
                        translated: translation.pattern
                    });
                }
                valueIndex += offset;
            }
            else {
                if (!skipMaskChars) {
                    buf[addMethod](maskDigit);
                }
                if (valDigit === maskDigit) {
                    valueIndex += offset;
                }
                else {
                    lastUntranslatedMaskChar = maskDigit;
                }
                maskIndex += offset;
            }
            check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        }
        /** @type {?} */
        const lastMaskCharDigit = mask.charAt(lastMaskChar);
        if (maskLen === valueLength + 1 && !this.translationMask[lastMaskCharDigit]) {
            buf.push(lastMaskCharDigit);
        }
        return buf.join('');
    }
    /**
     * @private
     * @param {?} isReversed
     * @param {?} maskIndex
     * @param {?} maskLen
     * @param {?} valueIndex
     * @param {?} valueLength
     * @return {?}
     */
    isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength) {
        /** @type {?} */
        let check = false;
        if (isReversed) {
            check = (maskIndex > -1) && (valueIndex > -1);
        }
        else {
            check = (maskIndex < maskLen) && (valueIndex < valueLength);
        }
        return check;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setValue(value) {
        this.value = value;
    }
    /**
     * @private
     * @return {?}
     */
    getValue() {
        return this.value;
    }
}
InputMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-text-mask], [textMask]',
                providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR]
            },] }
];
/** @nocollapse */
InputMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
InputMaskDirective.propDecorators = {
    inputMask: [{ type: Input, args: ['textMask',] }],
    onTextInput: [{ type: HostListener, args: ['input', ['$event'],] }, { type: HostListener, args: ['keyup', ['$event'],] }]
};
if (false) {
    /**
     * Object defining mask and "reversed" status.
     * @type {?}
     */
    InputMaskDirective.prototype.inputMask;
    /**
     * @type {?}
     * @private
     */
    InputMaskDirective.prototype.translationMask;
    /**
     * @type {?}
     * @private
     */
    InputMaskDirective.prototype.byPassKeys;
    /**
     * @type {?}
     * @private
     */
    InputMaskDirective.prototype.value;
    /**
     * @type {?}
     * @private
     */
    InputMaskDirective.prototype.invalidCharacters;
    /** @type {?} */
    InputMaskDirective.prototype._onChange;
    /** @type {?} */
    InputMaskDirective.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    InputMaskDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    InputMaskDirective.prototype.render;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC1tYXNrLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbImZvcm0vY29tcG9uZW50cy93aWRnZXRzL3RleHQvdGV4dC1tYXNrLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsT0FBTyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBQ1YsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBRUwsU0FBUyxFQUVaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBd0IsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7QUFFekUsTUFBTSxPQUFPLG1DQUFtQyxHQUFRO0lBQ3BELE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVU7OztJQUFDLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixFQUFDO0lBQ2pELEtBQUssRUFBRSxJQUFJO0NBQ2Q7Ozs7QUFTRCxNQUFNLE9BQU8sa0JBQWtCOzs7OztJQW9CM0IsWUFBb0IsRUFBYyxFQUFVLE1BQWlCO1FBQXpDLE9BQUUsR0FBRixFQUFFLENBQVk7UUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFXO1FBWnJELG9CQUFlLEdBQUc7WUFDdEIsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRTtZQUN0QixHQUFHLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUU7WUFDdEMsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFO1lBQ3ZDLEdBQUcsRUFBRSxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUU7WUFDL0IsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRTtTQUMvQixDQUFDO1FBRU0sZUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFB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LENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVc7O1lBQ2pFLEtBQUssR0FBRyxLQUFLO1FBQ2pCLElBQUksVUFBVSxFQUFFO1lBQ1osS0FBSyxHQUFHLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqRDthQUFNO1lBQ0gsS0FBSyxHQUFHLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxHQUFHLFdBQVcsQ0FBQyxDQUFDO1NBQy9EO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQzs7Ozs7O0lBRU8sUUFBUSxDQUFDLEtBQUs7UUFDbEIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDdkIsQ0FBQzs7Ozs7SUFFTyxRQUFRO1FBQ1osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3RCLENBQUM7OztZQTdMSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLDZCQUE2QjtnQkFDdkMsU0FBUyxFQUFFLENBQUMsbUNBQW1DLENBQUM7YUFDbkQ7Ozs7WUF0QkcsVUFBVTtZQUtWLFNBQVM7Ozt3QkFxQlIsS0FBSyxTQUFDLFVBQVU7MEJBMEJoQixZQUFZLFNBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLGNBQ2hDLFlBQVksU0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUM7Ozs7Ozs7SUEzQmpDLHVDQUdFOzs7OztJQUVGLDZDQU1FOzs7OztJQUVGLHdDQUE2RDs7Ozs7SUFDN0QsbUNBQWM7Ozs7O0lBQ2QsK0NBQStCOztJQUsvQix1Q0FDQzs7SUFFRCx3Q0FDQzs7Ozs7SUFQVyxnQ0FBc0I7Ozs7O0lBQUUsb0NBQXlCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuIC8qIHRzbGludDpkaXNhYmxlOiBjb21wb25lbnQtc2VsZWN0b3Igbm8tdXNlLWJlZm9yZS1kZWNsYXJlIG5vLWlucHV0LXJlbmFtZSAgKi9cblxuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbnB1dCxcbiAgICBPbkNoYW5nZXMsXG4gICAgUmVuZGVyZXIyLFxuICAgIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBjb25zdCBDVVNUT01fSU5QVVRfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElucHV0TWFza0RpcmVjdGl2ZSksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbi8qKlxuICogRGlyZWN0aXZlIHNlbGVjdG9ycyB3aXRob3V0IGFkZi0gcHJlZml4IHdpbGwgYmUgZGVwcmVjYXRlZCBvbiAzLjAuMFxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1thZGYtdGV4dC1tYXNrXSwgW3RleHRNYXNrXScsXG4gICAgcHJvdmlkZXJzOiBbQ1VTVE9NX0lOUFVUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIElucHV0TWFza0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgLyoqIE9iamVjdCBkZWZpbmluZyBtYXNrIGFuZCBcInJldmVyc2VkXCIgc3RhdHVzLiAqL1xuICAgIEBJbnB1dCgndGV4dE1hc2snKSBpbnB1dE1hc2s6IHtcbiAgICAgICAgbWFzazogJycsXG4gICAgICAgIGlzUmV2ZXJzZWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIHByaXZhdGUgdHJhbnNsYXRpb25NYXNrID0ge1xuICAgICAgICAnMCc6IHsgcGF0dGVybjogL1xcZC8gfSxcbiAgICAgICAgJzknOiB7IHBhdHRlcm46IC9cXGQvLCBvcHRpb25hbDogdHJ1ZSB9LFxuICAgICAgICAnIyc6IHsgcGF0dGVybjogL1xcZC8sIHJlY3Vyc2l2ZTogdHJ1ZSB9LFxuICAgICAgICAnQSc6IHsgcGF0dGVybjogL1thLXpBLVowLTldLyB9LFxuICAgICAgICAnUyc6IHsgcGF0dGVybjogL1thLXpBLVpdLyB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgYnlQYXNzS2V5cyA9IFs5LCAxNiwgMTcsIDE4LCAzNiwgMzcsIDM4LCAzOSwgNDAsIDkxXTtcbiAgICBwcml2YXRlIHZhbHVlO1xuICAgIHByaXZhdGUgaW52YWxpZENoYXJhY3RlcnMgPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVuZGVyOiBSZW5kZXJlcjIpIHtcbiAgICB9XG5cbiAgICBfb25DaGFuZ2UgPSAoXzogYW55KSA9PiB7XG4gICAgfVxuXG4gICAgX29uVG91Y2hlZCA9ICgpID0+IHtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdpbnB1dCcsIFsnJGV2ZW50J10pXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5dXAnLCBbJyRldmVudCddKSBvblRleHRJbnB1dChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dE1hc2sgJiYgdGhpcy5pbnB1dE1hc2subWFzaykge1xuICAgICAgICAgICAgdGhpcy5tYXNrVmFsdWUodGhpcy5lbC5uYXRpdmVFbGVtZW50LnZhbHVlLCB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dE1hc2subWFzaywgdGhpcy5pbnB1dE1hc2suaXNSZXZlcnNlZCwgZXZlbnQua2V5Q29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snaW5wdXRNYXNrJ10gJiYgY2hhbmdlc1snaW5wdXRNYXNrJ10uY3VycmVudFZhbHVlWydtYXNrJ10pIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRNYXNrID0gY2hhbmdlc1snaW5wdXRNYXNrJ10uY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkID0gZm47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYXNrVmFsdWUoYWN0dWFsVmFsdWUsIHN0YXJ0Q2FyZXQsIG1hc2tUb0FwcGx5LCBpc01hc2tSZXZlcnNlZCwga2V5Q29kZSkge1xuICAgICAgICBpZiAodGhpcy5ieVBhc3NLZXlzLmluZGV4T2Yoa2V5Q29kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0TWFza2VkKGZhbHNlLCBhY3R1YWxWYWx1ZSwgbWFza1RvQXBwbHksIGlzTWFza1JldmVyc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRDYXJldCA9IHRoaXMuY2FsY3VsYXRlQ2FyZXRQb3NpdGlvbihzdGFydENhcmV0LCBhY3R1YWxWYWx1ZSwga2V5Q29kZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlci5zZXRBdHRyaWJ1dGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zZXRDYXJldFBvc2l0aW9uKGNhbGN1bGF0ZWRDYXJldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldENhcmV0UG9zaXRpb24oY2FyZXRQb3NpdGlvbikge1xuICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQubW92ZVN0YXJ0ID0gY2FyZXRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50Lm1vdmVFbmQgPSBjYXJldFBvc2l0aW9uO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZUNhcmV0UG9zaXRpb24oY2FyZXRQb3NpdGlvbiwgbmV3VmFsdWUsIGtleUNvZGUpIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWVMZW5ndGggPSBuZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpIHx8ICcnO1xuICAgICAgICBjb25zdCBvbGRWYWx1ZUxlbmd0aCA9IG9sZFZhbHVlLmxlbmd0aDtcblxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gOCAmJiBvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBjYXJldFBvc2l0aW9uIC0gKG5ld1ZhbHVlLnNsaWNlKDAsIGNhcmV0UG9zaXRpb24pLmxlbmd0aCAtIG9sZFZhbHVlLnNsaWNlKDAsIGNhcmV0UG9zaXRpb24pLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FyZXRQb3NpdGlvbiA+PSBvbGRWYWx1ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBuZXdWYWx1ZUxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGNhcmV0UG9zaXRpb24gKyAobmV3VmFsdWUuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbikubGVuZ3RoIC0gb2xkVmFsdWUuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbikubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICBnZXRNYXNrZWQoc2tpcE1hc2tDaGFycywgdmFsLCBtYXNrLCBpc1JldmVyc2VkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYnVmID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsO1xuICAgICAgICBsZXQgbWFza0luZGV4ID0gMDtcbiAgICAgICAgY29uc3QgbWFza0xlbiA9IG1hc2subGVuZ3RoO1xuICAgICAgICBsZXQgdmFsdWVJbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMTtcbiAgICAgICAgbGV0IGFkZE1ldGhvZCA9ICdwdXNoJztcbiAgICAgICAgbGV0IHJlc2V0UG9zID0gLTE7XG4gICAgICAgIGxldCBsYXN0TWFza0NoYXI7XG4gICAgICAgIGxldCBsYXN0VW50cmFuc2xhdGVkTWFza0NoYXI7XG4gICAgICAgIGxldCBjaGVjaztcblxuICAgICAgICBpZiAoaXNSZXZlcnNlZCkge1xuICAgICAgICAgICAgYWRkTWV0aG9kID0gJ3Vuc2hpZnQnO1xuICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICBsYXN0TWFza0NoYXIgPSAwO1xuICAgICAgICAgICAgbWFza0luZGV4ID0gbWFza0xlbiAtIDE7XG4gICAgICAgICAgICB2YWx1ZUluZGV4ID0gdmFsdWVMZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE1hc2tDaGFyID0gbWFza0xlbiAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2sgPSB0aGlzLmlzVG9DaGVjayhpc1JldmVyc2VkLCBtYXNrSW5kZXgsIG1hc2tMZW4sIHZhbHVlSW5kZXgsIHZhbHVlTGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGNoZWNrKSB7XG4gICAgICAgICAgICBjb25zdCBtYXNrRGlnaXQgPSBtYXNrLmNoYXJBdChtYXNrSW5kZXgpLFxuICAgICAgICAgICAgICAgIHZhbERpZ2l0ID0gdmFsdWUuY2hhckF0KHZhbHVlSW5kZXgpLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uID0gdGhpcy50cmFuc2xhdGlvbk1hc2tbbWFza0RpZ2l0XTtcblxuICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbERpZ2l0Lm1hdGNoKHRyYW5zbGF0aW9uLnBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZlthZGRNZXRob2RdKHZhbERpZ2l0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9uLnJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2V0UG9zID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0UG9zID0gbWFza0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXNrSW5kZXggPT09IGxhc3RNYXNrQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tJbmRleCA9IHJlc2V0UG9zIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RNYXNrQ2hhciA9PT0gcmVzZXRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrSW5kZXggLT0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbmRleCArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWxEaWdpdCA9PT0gbGFzdFVudHJhbnNsYXRlZE1hc2tDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RVbnRyYW5zbGF0ZWRNYXNrQ2hhciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0aW9uLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbmRleCArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSW5kZXggLT0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZENoYXJhY3RlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogdmFsdWVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0OiB2YWxEaWdpdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWQ6IHRyYW5zbGF0aW9uLnBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlSW5kZXggKz0gb2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBNYXNrQ2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2FkZE1ldGhvZF0obWFza0RpZ2l0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbERpZ2l0ID09PSBtYXNrRGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVJbmRleCArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVudHJhbnNsYXRlZE1hc2tDaGFyID0gbWFza0RpZ2l0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXNrSW5kZXggKz0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2sgPSB0aGlzLmlzVG9DaGVjayhpc1JldmVyc2VkLCBtYXNrSW5kZXgsIG1hc2tMZW4sIHZhbHVlSW5kZXgsIHZhbHVlTGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhc3RNYXNrQ2hhckRpZ2l0ID0gbWFzay5jaGFyQXQobGFzdE1hc2tDaGFyKTtcbiAgICAgICAgaWYgKG1hc2tMZW4gPT09IHZhbHVlTGVuZ3RoICsgMSAmJiAhdGhpcy50cmFuc2xhdGlvbk1hc2tbbGFzdE1hc2tDaGFyRGlnaXRdKSB7XG4gICAgICAgICAgICBidWYucHVzaChsYXN0TWFza0NoYXJEaWdpdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNUb0NoZWNrKGlzUmV2ZXJzZWQsIG1hc2tJbmRleCwgbWFza0xlbiwgdmFsdWVJbmRleCwgdmFsdWVMZW5ndGgpIHtcbiAgICAgICAgbGV0IGNoZWNrID0gZmFsc2U7XG4gICAgICAgIGlmIChpc1JldmVyc2VkKSB7XG4gICAgICAgICAgICBjaGVjayA9IChtYXNrSW5kZXggPiAtMSkgJiYgKHZhbHVlSW5kZXggPiAtMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVjayA9IChtYXNrSW5kZXggPCBtYXNrTGVuKSAmJiAodmFsdWVJbmRleCA8IHZhbHVlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuIl19