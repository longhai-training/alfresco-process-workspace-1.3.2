import { isMoment } from 'moment';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { OverlayContainer, Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { PortalInjector, ComponentPortal } from '@angular/cdk/portal';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { MatIconRegistry as MatIconRegistry$1 } from '@angular/material/icon';
import { MatSnackBar as MatSnackBar$1 } from '@angular/material/snack-bar';
import { DOWN_ARROW, UP_ARROW, ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { MomentDatetimeAdapter, MAT_MOMENT_DATETIME_FORMATS } from '@mat-datetimepicker/moment';
import { MatDatetimepickerModule, MatNativeDatetimeModule, DatetimeAdapter, MAT_DATETIME_FORMATS } from '@mat-datetimepicker/core';
import { MediaMatcher } from '@angular/cdk/layout';
import { state, style, animate, transition, query, group, sequence, trigger } from '@angular/animations';
import { FlexLayoutModule } from '@angular/flex-layout';
import { Router, RouterModule, NavigationEnd, ActivatedRoute } from '@angular/router';
import { DomSanitizer, DOCUMENT, Title } from '@angular/platform-browser';
import { Minimatch } from 'minimatch-browser';
import { map, distinctUntilChanged, catchError, tap, mergeMap, share, buffer, filter, debounceTime, switchMap, combineAll, defaultIfEmpty, concatMap, takeWhile, retry } from 'rxjs/operators';
import { MatDialog as MatDialog$1 } from '@angular/material/dialog';
import { AlfrescoApiCompatibility, AlfrescoApiConfig, Pagination, FormSaveRepresentation } from '@alfresco/js-api';
import moment from 'moment-es6';
import { DateAdapter, MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatDatepickerModule, MatDialogModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule, MatMenuModule, MatProgressBarModule, MatSidenavModule, MatSnackBarModule, MatToolbarModule, MatTooltipModule, MatExpansionModule, MatMenuTrigger, MatMenuItem, MatIconRegistry, MAT_DIALOG_DATA, MatDialogRef, MatDialog, MatSnackBar, MAT_DATE_FORMATS, MatTableDataSource, MatSidenav } from '@angular/material';
import { HttpClient, HttpClientModule, HttpHeaders } from '@angular/common/http';
import { Subject, Observable, from, throwError, BehaviorSubject, forkJoin, of, interval, empty } from 'rxjs';
import { __awaiter } from 'tslib';
import { TestBed } from '@angular/core/testing';
import { CommonModule, Location } from '@angular/common';
import { Injectable, NgModule, Component, ViewEncapsulation, HostListener, Optional, Inject, ViewChildren, InjectionToken, Pipe, Compiler, ComponentFactoryResolver, Input, ViewChild, ViewContainerRef, Directive, ContentChild, TemplateRef, Output, EventEmitter, ChangeDetectionStrategy, ElementRef, forwardRef, Renderer2, ContentChildren, ChangeDetectorRef, HostBinding, Host, NgZone, Injector, IterableDiffers, defineInjectable, inject, APP_INITIALIZER, INJECTOR } from '@angular/core';
import { FormControl, Validators, FormsModule, ReactiveFormsModule, FormBuilder, NG_VALUE_ACCESSOR } from '@angular/forms';
import { TranslateModule, TranslateService, TranslateStore, TranslateLoader } from '@ngx-translate/core';
import { AppExtensionService, ExtensionsModule } from '@alfresco/adf-extensions';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectUtils {
    /**
     * Gets a value from an object by composed key
     * ObjectUtils.getValue({ item: { nodeType: 'cm:folder' }}, 'item.nodeType') ==> 'cm:folder'
     * @param {?} target
     * @param {?} key
     * @return {?}
     */
    static getValue(target, key) {
        if (!target) {
            return undefined;
        }
        /** @type {?} */
        const keys = key.split('.');
        key = '';
        do {
            key += keys.shift();
            /** @type {?} */
            const value = target[key];
            if (value !== undefined && (typeof value === 'object' || !keys.length)) {
                target = value;
                key = '';
            }
            else if (!keys.length) {
                target = undefined;
            }
            else {
                key += '.';
            }
        } while (keys.length);
        return target;
    }
    /**
     * @param {...?} objects
     * @return {?}
     */
    static merge(...objects) {
        /** @type {?} */
        const result = {};
        objects.forEach((/**
         * @param {?} source
         * @return {?}
         */
        (source) => {
            Object.keys(source).forEach((/**
             * @param {?} prop
             * @return {?}
             */
            (prop) => {
                if (prop in result && Array.isArray(result[prop])) {
                    result[prop] = result[prop].concat(source[prop]);
                }
                else if (prop in result && typeof result[prop] === 'object') {
                    result[prop] = ObjectUtils.merge(result[prop], source[prop]);
                }
                else {
                    result[prop] = source[prop];
                }
            }));
        }));
        return result;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const AppConfigValues = {
    APP_CONFIG_LANGUAGES_KEY: 'languages',
    PROVIDERS: 'providers',
    OAUTHCONFIG: 'oauth2',
    ECMHOST: 'ecmHost',
    BASESHAREURL: 'baseShareUrl',
    BPMHOST: 'bpmHost',
    IDENTITY_HOST: 'identityHost',
    AUTHTYPE: 'authType',
    CONTEXTROOTECM: 'contextRootEcm',
    CONTEXTROOTBPM: 'contextRootBpm',
    ALFRESCO_REPOSITORY_NAME: 'alfrescoRepositoryName',
    LOG_LEVEL: 'logLevel',
    LOGIN_ROUTE: 'loginRoute',
    DISABLECSRF: 'disableCSRF',
    AUTH_WITH_CREDENTIALS: 'auth.withCredentials',
    APPLICATION: 'application',
    NOTIFY_DURATION: 'notificationDefaultDuration',
};
/** @enum {string} */
const Status = {
    INIT: 'init',
    LOADING: 'loading',
    LOADED: 'loaded',
};
/* spellchecker: enable */
class AppConfigService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.config = {
            application: {
                name: 'Alfresco ADF Application'
            },
            ecmHost: 'http://{hostname}{:port}/ecm',
            bpmHost: 'http://{hostname}{:port}/bpm',
            logLevel: 'silent',
            alfrescoRepositoryName: 'alfresco-1'
        };
        this.status = Status.INIT;
        this.onLoadSubject = new Subject();
        this.onLoad = this.onLoadSubject.asObservable();
    }
    /**
     * Requests notification of a property value when it is loaded.
     * @param {?} property The desired property value
     * @return {?} Property value, when loaded
     */
    select(property) {
        return this.onLoadSubject
            .pipe(map((/**
         * @param {?} config
         * @return {?}
         */
        (config) => config[property])), distinctUntilChanged());
    }
    /**
     * Gets the value of a named property.
     * @template T
     * @param {?} key Name of the property
     * @param {?=} defaultValue Value to return if the key is not found
     * @return {?} Value of the property
     */
    get(key, defaultValue) {
        /** @type {?} */
        let result = ObjectUtils.getValue(this.config, key);
        if (typeof result === 'string') {
            /** @type {?} */
            const keywords = new Map();
            keywords.set('hostname', this.getLocationHostname());
            keywords.set(':port', this.getLocationPort(':'));
            keywords.set('port', this.getLocationPort());
            keywords.set('protocol', this.getLocationProtocol());
            result = this.formatString(result, keywords);
        }
        if (result === undefined) {
            return defaultValue;
        }
        return (/** @type {?} */ (result));
    }
    /**
     * Gets the location.protocol value.
     * @return {?} The location.protocol string
     */
    getLocationProtocol() {
        return location.protocol;
    }
    /**
     * Gets the location.hostname property.
     * @return {?} Value of the property
     */
    getLocationHostname() {
        return location.hostname;
    }
    /**
     * Gets the location.port property.
     * @param {?=} prefix Text added before port value
     * @return {?} Port with prefix
     */
    getLocationPort(prefix = '') {
        return location.port ? prefix + location.port : '';
    }
    /**
     * Loads the config file.
     * @return {?} Notification when loading is complete
     */
    load() {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const configUrl = `app.config.json?v=${Date.now()}`;
            if (this.status === Status.INIT) {
                this.status = Status.LOADING;
                yield this.http.get(configUrl).subscribe((/**
                 * @param {?} data
                 * @return {?}
                 */
                (data) => {
                    this.status = Status.LOADED;
                    this.config = Object.assign({}, this.config, data || {});
                    this.onLoadSubject.next(this.config);
                    resolve(this.config);
                }), (/**
                 * @return {?}
                 */
                () => {
                    resolve(this.config);
                }));
            }
            else if (this.status === Status.LOADED) {
                resolve(this.config);
            }
            else if (this.status === Status.LOADING) {
                this.onLoad.subscribe((/**
                 * @return {?}
                 */
                () => {
                    resolve(this.config);
                }));
            }
        })));
    }
    /**
     * @private
     * @param {?} str
     * @param {?} keywords
     * @return {?}
     */
    formatString(str, keywords) {
        /** @type {?} */
        let result = str;
        keywords.forEach((/**
         * @param {?} value
         * @param {?} key
         * @return {?}
         */
        (value, key) => {
            /** @type {?} */
            const expr = new RegExp('{' + key + '}', 'gm');
            result = result.replace(expr, value);
        }));
        return result;
    }
}
AppConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AppConfigService.ctorParameters = () => [
    { type: HttpClient }
];
/** @nocollapse */ AppConfigService.ngInjectableDef = defineInjectable({ factory: function AppConfigService_Factory() { return new AppConfigService(inject(HttpClient)); }, token: AppConfigService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable:adf-file-name */
class AlfrescoApiService {
    /**
     * @param {?} appConfig
     */
    constructor(appConfig) {
        this.appConfig = appConfig;
        /**
         * Publish/subscribe to events related to node updates.
         */
        this.nodeUpdated = new Subject();
    }
    /**
     * @return {?}
     */
    getInstance() {
        return this.alfrescoApi;
    }
    /**
     * @return {?}
     */
    get taskApi() {
        return this.getInstance().activiti.taskApi;
    }
    /**
     * @return {?}
     */
    get contentApi() {
        return this.getInstance().content;
    }
    /**
     * @return {?}
     */
    get nodesApi() {
        return this.getInstance().nodes;
    }
    /**
     * @return {?}
     */
    get renditionsApi() {
        return this.getInstance().core.renditionsApi;
    }
    /**
     * @return {?}
     */
    get sharedLinksApi() {
        return this.getInstance().core.sharedlinksApi;
    }
    /**
     * @return {?}
     */
    get sitesApi() {
        return this.getInstance().core.sitesApi;
    }
    /**
     * @return {?}
     */
    get favoritesApi() {
        return this.getInstance().core.favoritesApi;
    }
    /**
     * @return {?}
     */
    get peopleApi() {
        return this.getInstance().core.peopleApi;
    }
    /**
     * @return {?}
     */
    get searchApi() {
        return this.getInstance().search.searchApi;
    }
    /**
     * @return {?}
     */
    get versionsApi() {
        return this.getInstance().core.versionsApi;
    }
    /**
     * @return {?}
     */
    get classesApi() {
        return this.getInstance().core.classesApi;
    }
    /**
     * @return {?}
     */
    get groupsApi() {
        return this.getInstance().core.groupsApi;
    }
    /**
     * @return {?}
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.appConfig.load().then((/**
             * @return {?}
             */
            () => {
                this.initAlfrescoApi();
            }));
        });
    }
    /**
     * @return {?}
     */
    reset() {
        return __awaiter(this, void 0, void 0, function* () {
            this.initAlfrescoApi();
        });
    }
    /**
     * @protected
     * @return {?}
     */
    initAlfrescoApi() {
        /** @type {?} */
        const oauth = Object.assign({}, this.appConfig.get(AppConfigValues.OAUTHCONFIG, null));
        if (oauth) {
            oauth.redirectUri = window.location.origin + (oauth.redirectUri || '/');
            oauth.redirectUriLogout = window.location.origin + (oauth.redirectUriLogout || '/');
        }
        /** @type {?} */
        const config = new AlfrescoApiConfig({
            provider: this.appConfig.get(AppConfigValues.PROVIDERS),
            hostEcm: this.appConfig.get(AppConfigValues.ECMHOST),
            hostBpm: this.appConfig.get(AppConfigValues.BPMHOST),
            authType: this.appConfig.get(AppConfigValues.AUTHTYPE, 'BASIC'),
            contextRootBpm: this.appConfig.get(AppConfigValues.CONTEXTROOTBPM),
            contextRoot: this.appConfig.get(AppConfigValues.CONTEXTROOTECM),
            disableCsrf: this.appConfig.get(AppConfigValues.DISABLECSRF),
            withCredentials: this.appConfig.get(AppConfigValues.AUTH_WITH_CREDENTIALS, false),
            oauth2: oauth
        });
        if (this.alfrescoApi && this.isDifferentConfig(this.lastConfig, config)) {
            this.lastConfig = config;
            this.alfrescoApi.configureJsApi(config);
        }
        else {
            this.lastConfig = config;
            this.alfrescoApi = new AlfrescoApiCompatibility(config);
        }
    }
    /**
     * @param {?} lastConfig
     * @param {?} newConfig
     * @return {?}
     */
    isDifferentConfig(lastConfig, newConfig) {
        return JSON.stringify(lastConfig) !== JSON.stringify(newConfig);
    }
}
AlfrescoApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AlfrescoApiService.ctorParameters = () => [
    { type: AppConfigService }
];
/** @nocollapse */ AlfrescoApiService.ngInjectableDef = defineInjectable({ factory: function AlfrescoApiService_Factory() { return new AlfrescoApiService(inject(AppConfigService)); }, token: AlfrescoApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CookieService {
    /**
     * Checks if cookies are enabled.
     * @return {?} True if enabled, false otherwise
     */
    isEnabled() {
        // for certain scenarios Chrome may say 'true' but have cookies still disabled
        if (navigator.cookieEnabled === false) {
            return false;
        }
        document.cookie = 'test-cookie';
        return document.cookie.indexOf('test-cookie') >= 0;
    }
    /**
     * Retrieves a cookie by its key.
     * @param {?} key Key to identify the cookie
     * @return {?} The cookie data or null if it is not found
     */
    getItem(key) {
        /** @type {?} */
        const regexp = new RegExp('(?:' + key + '|;\s*' + key + ')=(.*?)(?:;|$)', 'g');
        /** @type {?} */
        const result = regexp.exec(document.cookie);
        return (result === null) ? null : result[1];
    }
    /**
     * Sets a cookie.
     * @param {?} key Key to identify the cookie
     * @param {?} data Data value to set for the cookie
     * @param {?} expiration Expiration date of the data
     * @param {?} path "Pathname" to store the cookie
     * @return {?}
     */
    setItem(key, data, expiration, path) {
        document.cookie = `${key}=${data}` +
            (expiration ? ';expires=' + expiration.toUTCString() : '') +
            (path ? `;path=${path}` : ';path=/');
    }
    /**
     * Placeholder for testing purposes - do not use.
     * @return {?}
     */
    clear() {
        /* placeholder for testing purposes */
    }
}
CookieService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ CookieService.ngInjectableDef = defineInjectable({ factory: function CookieService_Factory() { return new CookieService(); }, token: CookieService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LogLevelsEnum extends Number {
}
LogLevelsEnum.TRACE = 5;
LogLevelsEnum.DEBUG = 4;
LogLevelsEnum.INFO = 3;
LogLevelsEnum.WARN = 2;
LogLevelsEnum.ERROR = 1;
LogLevelsEnum.SILENT = 0;
/** @type {?} */
let logLevels = [
    { level: LogLevelsEnum.TRACE, name: 'TRACE' },
    { level: LogLevelsEnum.DEBUG, name: 'DEBUG' },
    { level: LogLevelsEnum.INFO, name: 'INFO' },
    { level: LogLevelsEnum.WARN, name: 'WARN' },
    { level: LogLevelsEnum.ERROR, name: 'ERROR' },
    { level: LogLevelsEnum.SILENT, name: 'SILENT' }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LogService {
    /**
     * @param {?} appConfig
     */
    constructor(appConfig) {
        this.appConfig = appConfig;
        this.onMessage = new Subject();
    }
    /**
     * @return {?}
     */
    get currentLogLevel() {
        /** @type {?} */
        const configLevel = this.appConfig.get(AppConfigValues.LOG_LEVEL);
        if (configLevel) {
            return this.getLogLevel(configLevel);
        }
        return LogLevelsEnum.TRACE;
    }
    /**
     * Logs a message at the "ERROR" level.
     * @param {?=} message Message to log
     * @param {...?} optionalParams Interpolation values for the message in "printf" format
     * @return {?}
     */
    error(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.ERROR) {
            this.messageBus(message, 'ERROR');
            console.error(message, ...optionalParams);
        }
    }
    /**
     * Logs a message at the "DEBUG" level.
     * @param {?=} message Message to log
     * @param {...?} optionalParams Interpolation values for the message in "printf" format
     * @return {?}
     */
    debug(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.DEBUG) {
            this.messageBus(message, 'DEBUG');
            console.debug(message, ...optionalParams);
        }
    }
    /**
     * Logs a message at the "INFO" level.
     * @param {?=} message Message to log
     * @param {...?} optionalParams Interpolation values for the message in "printf" format
     * @return {?}
     */
    info(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.INFO) {
            this.messageBus(message, 'INFO');
            console.info(message, ...optionalParams);
        }
    }
    /**
     * Logs a message at any level from "TRACE" upwards.
     * @param {?=} message Message to log
     * @param {...?} optionalParams Interpolation values for the message in "printf" format
     * @return {?}
     */
    log(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.TRACE) {
            this.messageBus(message, 'LOG');
            console.log(message, ...optionalParams);
        }
    }
    /**
     * Logs a message at the "TRACE" level.
     * @param {?=} message Message to log
     * @param {...?} optionalParams Interpolation values for the message in "printf" format
     * @return {?}
     */
    trace(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.TRACE) {
            this.messageBus(message, 'TRACE');
            console.trace(message, ...optionalParams);
        }
    }
    /**
     * Logs a message at the "WARN" level.
     * @param {?=} message Message to log
     * @param {...?} optionalParams Interpolation values for the message in "printf" format
     * @return {?}
     */
    warn(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.WARN) {
            this.messageBus(message, 'WARN');
            console.warn(message, ...optionalParams);
        }
    }
    /**
     * Logs a message if a boolean test fails.
     * @param {?=} test Test value (typically a boolean expression)
     * @param {?=} message Message to show if test is false
     * @param {...?} optionalParams Interpolation values for the message in "printf" format
     * @return {?}
     */
    assert(test, message, ...optionalParams) {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            this.messageBus(message, 'ASSERT');
            console.assert(test, message, ...optionalParams);
        }
    }
    /**
     * Starts an indented group of log messages.
     * @param {?=} groupTitle Title shown at the start of the group
     * @param {...?} optionalParams Interpolation values for the title in "printf" format
     * @return {?}
     */
    group(groupTitle, ...optionalParams) {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            console.group(groupTitle, ...optionalParams);
        }
    }
    /**
     * Ends a indented group of log messages.
     * @return {?}
     */
    groupEnd() {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            console.groupEnd();
        }
    }
    /**
     * Converts a log level name string into its numeric equivalent.
     * @param {?} level Level name
     * @return {?} Numeric log level
     */
    getLogLevel(level) {
        /** @type {?} */
        const referencedLevel = logLevels.find((/**
         * @param {?} currentLevel
         * @return {?}
         */
        (currentLevel) => {
            return currentLevel.name.toLocaleLowerCase() === level.toLocaleLowerCase();
        }));
        return referencedLevel ? referencedLevel.level : 5;
    }
    /**
     * Triggers notification callback for log messages.
     * @param {?} text Message text
     * @param {?} logLevel Log level for the message
     * @return {?}
     */
    messageBus(text, logLevel) {
        this.onMessage.next({ text: text, type: logLevel });
    }
}
LogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
LogService.ctorParameters = () => [
    { type: AppConfigService }
];
/** @nocollapse */ LogService.ngInjectableDef = defineInjectable({ factory: function LogService_Factory() { return new LogService(inject(AppConfigService)); }, token: LogService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const REMEMBER_ME_COOKIE_KEY = 'ALFRESCO_REMEMBER_ME';
/** @type {?} */
const REMEMBER_ME_UNTIL = 1000 * 60 * 60 * 24 * 30;
class AuthenticationService {
    /**
     * @param {?} appConfig
     * @param {?} alfrescoApi
     * @param {?} cookie
     * @param {?} logService
     */
    constructor(appConfig, alfrescoApi, cookie, logService) {
        this.appConfig = appConfig;
        this.alfrescoApi = alfrescoApi;
        this.cookie = cookie;
        this.logService = logService;
        this.redirectUrl = null;
        this.bearerExcludedUrls = ['auth/realms', 'resources/', 'assets/'];
        this.onLogin = new Subject();
        this.onLogout = new Subject();
    }
    /**
     * Checks if the user logged in.
     * @return {?} True if logged in, false otherwise
     */
    isLoggedIn() {
        if (!this.isOauth() && this.cookie.isEnabled() && !this.isRememberMeSet()) {
            return false;
        }
        return this.alfrescoApi.getInstance().isLoggedIn();
    }
    /**
     * Does the provider support OAuth?
     * @return {?} True if supported, false otherwise
     */
    isOauth() {
        return this.alfrescoApi.getInstance().isOauthConfiguration();
    }
    /**
     * Does the provider support ECM?
     * @return {?} True if supported, false otherwise
     */
    isECMProvider() {
        return this.alfrescoApi.getInstance().isEcmConfiguration();
    }
    /**
     * Does the provider support BPM?
     * @return {?} True if supported, false otherwise
     */
    isBPMProvider() {
        return this.alfrescoApi.getInstance().isBpmConfiguration();
    }
    /**
     * Does the provider support both ECM and BPM?
     * @return {?} True if both are supported, false otherwise
     */
    isALLProvider() {
        return this.alfrescoApi.getInstance().isEcmBpmConfiguration();
    }
    /**
     * Logs the user in.
     * @param {?} username Username for the login
     * @param {?} password Password for the login
     * @param {?=} rememberMe Stores the user's login details if true
     * @return {?} Object with auth type ("ECM", "BPM" or "ALL") and auth ticket
     */
    login(username, password, rememberMe = false) {
        return from(this.alfrescoApi.getInstance().login(username, password))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            this.saveRememberMeCookie(rememberMe);
            this.onLogin.next(response);
            return {
                type: this.appConfig.get(AppConfigValues.PROVIDERS),
                ticket: response
            };
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Logs the user in with SSO
     * @return {?}
     */
    ssoImplicitLogin() {
        this.alfrescoApi.getInstance().implicitLogin();
    }
    /**
     * Saves the "remember me" cookie as either a long-life cookie or a session cookie.
     * @private
     * @param {?} rememberMe Enables a long-life cookie
     * @return {?}
     */
    saveRememberMeCookie(rememberMe) {
        /** @type {?} */
        let expiration = null;
        if (rememberMe) {
            expiration = new Date();
            /** @type {?} */
            const time = expiration.getTime();
            /** @type {?} */
            const expireTime = time + REMEMBER_ME_UNTIL;
            expiration.setTime(expireTime);
        }
        this.cookie.setItem(REMEMBER_ME_COOKIE_KEY, '1', expiration, null);
    }
    /**
     * Checks whether the "remember me" cookie was set or not.
     * @return {?} True if set, false otherwise
     */
    isRememberMeSet() {
        return (this.cookie.getItem(REMEMBER_ME_COOKIE_KEY) === null) ? false : true;
    }
    /**
     * Logs the user out.
     * @return {?} Response event called when logout is complete
     */
    logout() {
        return from(this.callApiLogout())
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            this.onLogout.next(response);
            return response;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @private
     * @return {?}
     */
    callApiLogout() {
        if (this.alfrescoApi.getInstance()) {
            return this.alfrescoApi.getInstance().logout();
        }
    }
    /**
     * Gets the ECM ticket stored in the Storage.
     * @return {?} The ticket or `null` if none was found
     */
    getTicketEcm() {
        return this.alfrescoApi.getInstance().getTicketEcm();
    }
    /**
     * Gets the BPM ticket stored in the Storage.
     * @return {?} The ticket or `null` if none was found
     */
    getTicketBpm() {
        return this.alfrescoApi.getInstance().getTicketBpm();
    }
    /**
     * Gets the BPM ticket from the Storage in Base 64 format.
     * @return {?} The ticket or `null` if none was found
     */
    getTicketEcmBase64() {
        /** @type {?} */
        const ticket = this.alfrescoApi.getInstance().getTicketEcm();
        if (ticket) {
            return 'Basic ' + btoa(ticket);
        }
        return null;
    }
    /**
     * Checks if the user is logged in on an ECM provider.
     * @return {?} True if logged in, false otherwise
     */
    isEcmLoggedIn() {
        if (this.isECMProvider() || this.isALLProvider()) {
            if (!this.isOauth() && this.cookie.isEnabled() && !this.isRememberMeSet()) {
                return false;
            }
            return this.alfrescoApi.getInstance().isEcmLoggedIn();
        }
        return false;
    }
    /**
     * Checks if the user is logged in on a BPM provider.
     * @return {?} True if logged in, false otherwise
     */
    isBpmLoggedIn() {
        if (this.isBPMProvider() || this.isALLProvider()) {
            if (!this.isOauth() && this.cookie.isEnabled() && !this.isRememberMeSet()) {
                return false;
            }
            return this.alfrescoApi.getInstance().isBpmLoggedIn();
        }
        return false;
    }
    /**
     * Gets the ECM username.
     * @return {?} The ECM username
     */
    getEcmUsername() {
        return this.alfrescoApi.getInstance().getEcmUsername();
    }
    /**
     * Gets the BPM username
     * @return {?} The BPM username
     */
    getBpmUsername() {
        return this.alfrescoApi.getInstance().getBpmUsername();
    }
    /**
     * Sets the URL to redirect to after login.
     * @param {?} url URL to redirect to
     * @return {?}
     */
    setRedirect(url) {
        this.redirectUrl = url;
    }
    /**
     * Gets the URL to redirect to after login.
     * @return {?} The redirect URL
     */
    getRedirect() {
        /** @type {?} */
        const provider = (/** @type {?} */ (this.appConfig.get(AppConfigValues.PROVIDERS)));
        return this.hasValidRedirection(provider) ? this.redirectUrl.url : null;
    }
    /**
     * Gets information about the user currently logged into APS.
     * @return {?} User information
     */
    getBpmLoggedUser() {
        return from(this.alfrescoApi.getInstance().activiti.profileApi.getProfile());
    }
    /**
     * @private
     * @param {?} provider
     * @return {?}
     */
    hasValidRedirection(provider) {
        return this.redirectUrl && (this.redirectUrl.provider === provider || this.hasSelectedProviderAll(provider));
    }
    /**
     * @private
     * @param {?} provider
     * @return {?}
     */
    hasSelectedProviderAll(provider) {
        return this.redirectUrl && (this.redirectUrl.provider === 'ALL' || provider === 'ALL');
    }
    /**
     * Prints an error message in the console browser
     * @param {?} error Error message
     * @return {?} Object representing the error message
     */
    handleError(error) {
        this.logService.error('Error when logging in', error);
        return throwError(error || 'Server error');
    }
    /**
     * Gets the set of URLs that the token bearer is excluded from.
     * @return {?} Array of URL strings
     */
    getBearerExcludedUrls() {
        return this.bearerExcludedUrls;
    }
    /**
     * Gets the auth token.
     * @return {?} Auth token string
     */
    getToken() {
        return localStorage.getItem('access_token');
    }
    /**
     * Adds the auth token to an HTTP header using the 'bearer' scheme.
     * @param {?=} headersArg Header that will receive the token
     * @return {?} The new header with the token added
     */
    addTokenToHeader(headersArg) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            let headers = headersArg;
            if (!headers) {
                headers = new HttpHeaders();
            }
            try {
                /** @type {?} */
                const token = this.getToken();
                headers = headers.set('Authorization', 'bearer ' + token);
                observer.next(headers);
                observer.complete();
            }
            catch (error) {
                observer.error(error);
            }
        }));
    }
    /**
     * Checks if SSO is configured correctly.
     * @return {?} True if configured correctly, false otherwise
     */
    isSSODiscoveryConfigured() {
        return this.alfrescoApi.getInstance().storage.getItem('discovery') ? true : false;
    }
}
AuthenticationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AuthenticationService.ctorParameters = () => [
    { type: AppConfigService },
    { type: AlfrescoApiService },
    { type: CookieService },
    { type: LogService }
];
/** @nocollapse */ AuthenticationService.ngInjectableDef = defineInjectable({ factory: function AuthenticationService_Factory() { return new AuthenticationService(inject(AppConfigService), inject(AlfrescoApiService), inject(CookieService), inject(LogService)); }, token: AuthenticationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BpmProductVersionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.edition = obj.edition || null;
            this.majorVersion = obj.majorVersion || null;
            this.revisionVersion = obj.revisionVersion || null;
            this.minorVersion = obj.minorVersion || null;
            this.type = obj.type || null;
        }
    }
}
class VersionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.major = obj.major || null;
            this.minor = obj.minor || null;
            this.patch = obj.patch || null;
            this.hotfix = obj.hotfix || null;
            this.schema = obj.schema || null;
            this.label = obj.label || null;
            this.display = obj.display || null;
        }
    }
}
class LicenseModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.issuedAt = obj.issuedAt || null;
            this.expiresAt = obj.expiresAt || null;
            this.remainingDays = obj.remainingDays || null;
            this.holder = obj.holder || null;
            this.mode = obj.mode || null;
            this.isClusterEnabled = obj.isClusterEnabled ? true : false;
            this.isCryptodocEnabled = obj.isCryptodocEnabled ? true : false;
        }
    }
}
class VersionStatusModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.isReadOnly = obj.isReadOnly ? true : false;
            this.isAuditEnabled = obj.isAuditEnabled ? true : false;
            this.isQuickShareEnabled = obj.isQuickShareEnabled ? true : false;
            this.isThumbnailGenerationEnabled = obj.isThumbnailGenerationEnabled ? true : false;
        }
    }
}
class VersionModuleModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.title = obj.title || null;
            this.description = obj.description || null;
            this.version = obj.version || null;
            this.installDate = obj.installDate || null;
            this.installState = obj.installState || null;
            this.versionMin = obj.versionMin || null;
            this.versionMax = obj.versionMax || null;
        }
    }
}
class EcmProductVersionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.modules = [];
        if (obj && obj.entry && obj.entry.repository) {
            this.edition = obj.entry.repository.edition || null;
            this.version = new VersionModel(obj.entry.repository.version);
            this.license = new LicenseModel(obj.entry.repository.license);
            this.status = new VersionStatusModel(obj.entry.repository.status);
            if (obj.entry.repository.modules) {
                obj.entry.repository.modules.forEach((/**
                 * @param {?} module
                 * @return {?}
                 */
                (module) => {
                    this.modules.push(new VersionModuleModel(module));
                }));
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DiscoveryApiService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * Gets product information for Content Services.
     * @return {?} ProductVersionModel containing product details
     */
    getEcmProductInfo() {
        return from(this.apiService.getInstance().discovery.discoveryApi.getRepositoryInformation())
            .pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        (res) => new EcmProductVersionModel(res))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => throwError(err))));
    }
    /**
     * Gets product information for Process Services.
     * @return {?} ProductVersionModel containing product details
     */
    getBpmProductInfo() {
        return from(this.apiService.getInstance().activiti.aboutApi.getAppVersion())
            .pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        (res) => new BpmProductVersionModel(res))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => throwError(err))));
    }
}
DiscoveryApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DiscoveryApiService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ DiscoveryApiService.ngInjectableDef = defineInjectable({ factory: function DiscoveryApiService_Factory() { return new DiscoveryApiService(inject(AlfrescoApiService)); }, token: DiscoveryApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileUtils {
    /**
     * @param {?} folder
     * @return {?}
     */
    static flatten(folder) {
        /** @type {?} */
        const reader = folder.createReader();
        /** @type {?} */
        const files = [];
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => {
            /** @type {?} */
            const iterations = [];
            ((/**
             * @return {?}
             */
            function traverse() {
                reader.readEntries((/**
                 * @param {?} entries
                 * @return {?}
                 */
                (entries) => {
                    if (!entries.length) {
                        Promise.all(iterations).then((/**
                         * @return {?}
                         */
                        () => resolve(files)));
                    }
                    else {
                        iterations.push(Promise.all(entries.map((/**
                         * @param {?} entry
                         * @return {?}
                         */
                        (entry) => {
                            if (entry.isFile) {
                                return new Promise((/**
                                 * @param {?} resolveFile
                                 * @return {?}
                                 */
                                (resolveFile) => {
                                    entry.file((/**
                                     * @param {?} file
                                     * @return {?}
                                     */
                                    function (file) {
                                        files.push({
                                            entry: entry,
                                            file: file,
                                            relativeFolder: entry.fullPath.replace(/\/[^\/]*$/, '')
                                        });
                                        resolveFile();
                                    }));
                                }));
                            }
                            else {
                                return FileUtils.flatten(entry).then((/**
                                 * @param {?} result
                                 * @return {?}
                                 */
                                (result) => {
                                    files.push(...result);
                                }));
                            }
                        }))));
                        // Try calling traverse() again for the same dir, according to spec
                        traverse();
                    }
                }));
            }))();
        }));
    }
    /**
     * @param {?} fileList
     * @return {?}
     */
    static toFileArray(fileList) {
        /** @type {?} */
        const result = [];
        if (fileList && fileList.length > 0) {
            for (let i = 0; i < fileList.length; i++) {
                result.push(fileList[i]);
            }
        }
        return result;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
const MOMENT_DATE_FORMATS = {
    parse: {
        dateInput: 'DD/MM/YYYY'
    },
    display: {
        dateInput: 'DD/MM/YYYY',
        monthYearLabel: 'MMMM Y',
        dateA11yLabel: 'LL',
        monthYearA11yLabel: 'MMMM Y'
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MomentDateAdapter extends DateAdapter {
    constructor() {
        super(...arguments);
        this.localeData = moment.localeData();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYear(date) {
        return date.year();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getMonth(date) {
        return date.month();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDate(date) {
        return date.date();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDayOfWeek(date) {
        return date.day();
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getMonthNames(style$$1) {
        switch (style$$1) {
            case 'long':
                return this.localeData.months();
            case 'short':
                return this.localeData.monthsShort();
            case 'narrow':
                return this.localeData.monthsShort().map((/**
                 * @param {?} month
                 * @return {?}
                 */
                (month) => month[0]));
            default:
                return;
        }
    }
    /**
     * @return {?}
     */
    getDateNames() {
        /** @type {?} */
        const dateNames = [];
        for (let date = 1; date <= 31; date++) {
            dateNames.push(String(date));
        }
        return dateNames;
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getDayOfWeekNames(style$$1) {
        switch (style$$1) {
            case 'long':
                return this.localeData.weekdays();
            case 'short':
                return this.localeData.weekdaysShort();
            case 'narrow':
                return this.localeData.weekdaysShort();
            default:
                return;
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYearName(date) {
        return String(date.year());
    }
    /**
     * @return {?}
     */
    getFirstDayOfWeek() {
        return this.localeData.firstDayOfWeek();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getNumDaysInMonth(date) {
        return date.daysInMonth();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    clone(date) {
        /** @type {?} */
        const locale = this.locale || 'en';
        return date.clone().locale(locale);
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    createDate(year, month, date) {
        return moment([year, month, date]);
    }
    /**
     * @return {?}
     */
    today() {
        /** @type {?} */
        const locale = this.locale || 'en';
        return moment().locale(locale);
    }
    /**
     * @param {?} value
     * @param {?} parseFormat
     * @return {?}
     */
    parse(value, parseFormat) {
        /** @type {?} */
        const locale = this.locale || 'en';
        if (value && typeof value === 'string') {
            /** @type {?} */
            let m = moment(value, parseFormat, locale, true);
            if (!m.isValid()) {
                // use strict parsing because Moment's parser is very forgiving, and this can lead to undesired behavior.
                m = moment(value, this.overrideDisplayFormat, locale, true);
            }
            if (m.isValid()) {
                // if user omits year, it defaults to 2001, so check for that issue.
                if (m.year() === 2001 && value.indexOf('2001') === -1) {
                    // if 2001 not actually in the value string, change to current year
                    /** @type {?} */
                    const currentYear = new Date().getFullYear();
                    m.set('year', currentYear);
                    // if date is in the future, set previous year
                    if (m.isAfter(moment())) {
                        m.set('year', currentYear - 1);
                    }
                }
            }
            return m;
        }
        return value ? moment(value).locale(locale) : null;
    }
    /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    format(date, displayFormat) {
        date = this.clone(date);
        displayFormat = this.overrideDisplayFormat ? this.overrideDisplayFormat : displayFormat;
        if (date && date.format) {
            return date.format(displayFormat);
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    addCalendarYears(date, years) {
        return date.clone().add(years, 'y');
    }
    /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    addCalendarMonths(date, months) {
        return date.clone().add(months, 'M');
    }
    /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    addCalendarDays(date, days) {
        return date.clone().add(days, 'd');
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getISODateString(date) {
        return date.toISOString();
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    setLocale(locale) {
        super.setLocale(locale);
        this.localeData = moment.localeData(locale);
    }
    /**
     * @param {?} first
     * @param {?} second
     * @return {?}
     */
    compareDate(first, second) {
        return first.diff(second, 'seconds', true);
    }
    /**
     * @param {?} first
     * @param {?} second
     * @return {?}
     */
    sameDate(first, second) {
        if (first == null) {
            // same if both null
            return second == null;
        }
        else if (isMoment(first)) {
            return first.isSame(second);
        }
        else {
            /** @type {?} */
            const isSame = super.sameDate(first, second);
            return isSame;
        }
    }
    /**
     * @param {?} date
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    clampDate(date, min, max) {
        if (min && date.isBefore(min)) {
            return min;
        }
        else if (max && date.isAfter(max)) {
            return max;
        }
        else {
            return date;
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    isDateInstance(date) {
        /** @type {?} */
        let isValidDateInstance = false;
        if (date) {
            isValidDateInstance = date._isAMomentObject;
        }
        return isValidDateInstance;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    isValid(date) {
        return date.isValid();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    toIso8601(date) {
        return this.clone(date).format();
    }
    /**
     * @param {?} iso8601String
     * @return {?}
     */
    fromIso8601(iso8601String) {
        /** @type {?} */
        const locale = this.locale || 'en';
        /** @type {?} */
        const d = moment(iso8601String, moment.ISO_8601).locale(locale);
        return this.isValid(d) ? d : null;
    }
    /**
     * @return {?}
     */
    invalid() {
        return moment.invalid();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Simple implementation of the DataRow interface.
class ObjectDataRow {
    /**
     * @param {?} obj
     * @param {?=} isSelected
     */
    constructor(obj, isSelected = false) {
        this.obj = obj;
        this.isSelected = isSelected;
        if (!obj) {
            throw new Error('Object source not found');
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getValue(key) {
        return ObjectUtils.getValue(this.obj, key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    hasValue(key) {
        return this.getValue(key) !== undefined;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    imageErrorResolver(event) {
        return '';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Simple implementation of the DataColumn interface.
class ObjectDataColumn {
    /**
     * @param {?} input
     */
    constructor(input) {
        this.key = input.key;
        this.type = input.type || 'text';
        this.format = input.format;
        this.sortable = input.sortable;
        this.title = input.title;
        this.srTitle = input.srTitle;
        this.cssClass = input.cssClass;
        this.template = input.template;
        this.copyContent = input.copyContent;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataSorting {
    /**
     * @param {?=} key
     * @param {?=} direction
     */
    constructor(key, direction) {
        this.key = key;
        this.direction = direction;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Simple implementation of the DataTableAdapter interface.
class ObjectDataTableAdapter {
    /**
     * @param {?} data
     * @return {?}
     */
    static generateSchema(data) {
        /** @type {?} */
        const schema = [];
        if (data && data.length) {
            /** @type {?} */
            const rowToExaminate = data[0];
            if (typeof rowToExaminate === 'object') {
                for (const key in rowToExaminate) {
                    if (rowToExaminate.hasOwnProperty(key)) {
                        schema.push({
                            type: 'text',
                            key: key,
                            title: key,
                            sortable: false
                        });
                    }
                }
            }
        }
        return schema;
    }
    /**
     * @param {?=} data
     * @param {?=} schema
     */
    constructor(data = [], schema = []) {
        this._rows = [];
        this._columns = [];
        if (data && data.length > 0) {
            this._rows = data.map((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                return new ObjectDataRow(item);
            }));
        }
        if (schema && schema.length > 0) {
            this._columns = schema.map((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                return new ObjectDataColumn(item);
            }));
            // Sort by first sortable or just first column
            /** @type {?} */
            const sortable = this._columns.filter((/**
             * @param {?} column
             * @return {?}
             */
            (column) => column.sortable));
            if (sortable.length > 0) {
                this.sort(sortable[0].key, 'asc');
            }
        }
        this.rowsChanged = new Subject();
    }
    /**
     * @return {?}
     */
    getRows() {
        return this._rows;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    setRows(rows) {
        this._rows = rows || [];
        this.sort();
        this.rowsChanged.next(this._rows);
    }
    /**
     * @return {?}
     */
    getColumns() {
        return this._columns;
    }
    /**
     * @param {?} columns
     * @return {?}
     */
    setColumns(columns) {
        this._columns = columns || [];
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getValue(row, col) {
        if (!row) {
            throw new Error('Row not found');
        }
        if (!col) {
            throw new Error('Column not found');
        }
        /** @type {?} */
        const value = row.getValue(col.key);
        if (col.type === 'icon') {
            /** @type {?} */
            const icon = row.getValue(col.key);
            return icon;
        }
        return value;
    }
    /**
     * @return {?}
     */
    getSorting() {
        return this._sorting;
    }
    /**
     * @param {?} sorting
     * @return {?}
     */
    setSorting(sorting) {
        this._sorting = sorting;
        if (sorting && sorting.key) {
            this._rows.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => {
                /** @type {?} */
                let left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                /** @type {?} */
                let right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right)
                    : right.localeCompare(left);
            }));
        }
    }
    /**
     * @param {?=} key
     * @param {?=} direction
     * @return {?}
     */
    sort(key, direction) {
        /** @type {?} */
        const sorting = this._sorting || new DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AboutComponent {
    /**
     * @param {?} http
     * @param {?} appConfig
     * @param {?} authService
     * @param {?} discovery
     * @param {?} appExtensions
     */
    constructor(http, appConfig, authService, discovery, appExtensions) {
        this.http = http;
        this.appConfig = appConfig;
        this.authService = authService;
        this.discovery = discovery;
        this.extensionColumns = ['$id', '$name', '$version', '$vendor', '$license', '$runtime', '$description'];
        /**
         * Commit corresponding to the version of ADF to be used.
         */
        this.githubUrlCommitAlpha = 'https://github.com/Alfresco/alfresco-ng2-components/commits/';
        /**
         * Toggles showing/hiding of extensions block.
         */
        this.showExtensions = true;
        /**
         * Regular expression for filtering dependencies packages.
         */
        this.regexp = '^(@alfresco)';
        this.ecmHost = '';
        this.bpmHost = '';
        this.ecmVersion = null;
        this.bpmVersion = null;
        this.extensions$ = appExtensions.references$;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.authService.isEcmLoggedIn()) {
            this.discovery.getEcmProductInfo().subscribe((/**
             * @param {?} ecmVers
             * @return {?}
             */
            (ecmVers) => {
                this.ecmVersion = ecmVers;
                this.modules = new ObjectDataTableAdapter(this.ecmVersion.modules, [
                    { type: 'text', key: 'id', title: 'ABOUT.TABLE_HEADERS.MODULES.ID', sortable: true },
                    { type: 'text', key: 'title', title: 'ABOUT.TABLE_HEADERS.MODULES.TITLE', sortable: true },
                    { type: 'text', key: 'version', title: 'ABOUT.TABLE_HEADERS.MODULES.DESCRIPTION', sortable: true },
                    {
                        type: 'text',
                        key: 'installDate',
                        title: 'ABOUT.TABLE_HEADERS.MODULES.INSTALL_DATE',
                        sortable: true
                    },
                    {
                        type: 'text',
                        key: 'installState',
                        title: 'ABOUT.TABLE_HEADERS.MODULES.INSTALL_STATE',
                        sortable: true
                    },
                    {
                        type: 'text',
                        key: 'versionMin',
                        title: 'ABOUT.TABLE_HEADERS.MODULES.VERSION_MIN',
                        sortable: true
                    },
                    {
                        type: 'text',
                        key: 'versionMax',
                        title: 'ABOUT.TABLE_HEADERS.MODULES.VERSION_MAX',
                        sortable: true
                    }
                ]);
                this.status = new ObjectDataTableAdapter([this.ecmVersion.status], [
                    { type: 'text', key: 'isReadOnly', title: 'ABOUT.TABLE_HEADERS.STATUS.READ_ONLY', sortable: true },
                    {
                        type: 'text',
                        key: 'isAuditEnabled',
                        title: 'ABOUT.TABLE_HEADERS.STATUS.AUDIT_ENABLED',
                        sortable: true
                    },
                    {
                        type: 'text',
                        key: 'isQuickShareEnabled',
                        title: 'ABOUT.TABLE_HEADERS.STATUS.QUICK_SHARE_ENABLED',
                        sortable: true
                    },
                    {
                        type: 'text',
                        key: 'isThumbnailGenerationEnabled',
                        title: 'ABOUT.TABLE_HEADERS.STATUS.THUMBNAIL_ENABLED',
                        sortable: true
                    }
                ]);
                this.license = new ObjectDataTableAdapter([this.ecmVersion.license], [
                    { type: 'text', key: 'issuedAt', title: 'ABOUT.TABLE_HEADERS.LICENSE.ISSUES_AT', sortable: true },
                    { type: 'text', key: 'expiresAt', title: 'ABOUT.TABLE_HEADERS.LICENSE.EXPIRES_AT', sortable: true },
                    {
                        type: 'text',
                        key: 'remainingDays',
                        title: 'ABOUT.TABLE_HEADERS.LICENSE.REMAINING_DAYS',
                        sortable: true
                    },
                    { type: 'text', key: 'holder', title: 'ABOUT.TABLE_HEADERS.LICENSE.HOLDER', sortable: true },
                    { type: 'text', key: 'mode', title: 'ABOUT.TABLE_HEADERS.LICENSE.MODE', sortable: true },
                    {
                        type: 'text',
                        key: 'isClusterEnabled',
                        title: 'ABOUT.TABLE_HEADERS.LICENSE.CLUSTER_ENABLED',
                        sortable: true
                    },
                    {
                        type: 'text',
                        key: 'isCryptodocEnabled',
                        title: 'ABOUT.TABLE_HEADERS.LICENSE.CRYPTODOC_ENABLED',
                        sortable: true
                    }
                ]);
            }));
        }
        if (this.authService.isBpmLoggedIn()) {
            this.discovery.getBpmProductInfo().subscribe((/**
             * @param {?} bpmVers
             * @return {?}
             */
            (bpmVers) => {
                this.bpmVersion = bpmVers;
            }));
        }
        this.http.get('/versions.json?' + new Date()).subscribe((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const alfrescoPackages = Object.keys(response.dependencies).filter((/**
             * @param {?} val
             * @return {?}
             */
            (val) => {
                return new RegExp(this.regexp).test(val);
            }));
            /** @type {?} */
            const alfrescoPackagesTableRepresentation = [];
            alfrescoPackages.forEach((/**
             * @param {?} val
             * @return {?}
             */
            (val) => {
                alfrescoPackagesTableRepresentation.push({
                    name: val,
                    version: (response.dependencies[val].version || response.dependencies[val].required.version)
                });
            }));
            this.gitHubLinkCreation(alfrescoPackagesTableRepresentation);
            this.data = new ObjectDataTableAdapter(alfrescoPackagesTableRepresentation, [
                { type: 'text', key: 'name', title: 'Name', sortable: true },
                { type: 'text', key: 'version', title: 'Version', sortable: true }
            ]);
        }));
        this.ecmHost = this.appConfig.get(AppConfigValues.ECMHOST);
        this.bpmHost = this.appConfig.get(AppConfigValues.BPMHOST);
    }
    /**
     * @private
     * @param {?} alfrescoPackagesTableRepresentation
     * @return {?}
     */
    gitHubLinkCreation(alfrescoPackagesTableRepresentation) {
        /** @type {?} */
        const corePackage = alfrescoPackagesTableRepresentation.find((/**
         * @param {?} packageUp
         * @return {?}
         */
        (packageUp) => {
            return packageUp.name === '@alfresco/adf-core';
        }));
        if (corePackage) {
            /** @type {?} */
            const commitIsh = corePackage.version.split('-');
            if (commitIsh.length > 1) {
                this.githubUrlCommitAlpha = this.githubUrlCommitAlpha + commitIsh[1];
            }
            else {
                this.githubUrlCommitAlpha = this.githubUrlCommitAlpha + corePackage.version;
            }
        }
    }
}
AboutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-about',
                template: "<div class=\"adf-about-container\">\n    <div class=\"adf-extension-details-container\" *ngIf=\"showExtensions\">\n        <h3>{{ 'ABOUT.TITLE' | translate }}</h3>\n        <mat-table [dataSource]=\"extensions$ | async\">\n            <!-- $id Column -->\n            <ng-container matColumnDef=\"$id\">\n                <mat-header-cell *matHeaderCellDef>{{ 'ABOUT.TABLE_HEADERS.ID' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$id}}</mat-cell>\n            </ng-container>\n\n            <!-- $name Column -->\n            <ng-container matColumnDef=\"$name\">\n                <mat-header-cell *matHeaderCellDef>{{ 'ABOUT.TABLE_HEADERS.NAME' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$name}}</mat-cell>\n            </ng-container>\n\n            <!-- $version Column -->\n            <ng-container matColumnDef=\"$version\">\n                <mat-header-cell *matHeaderCellDef>{{ 'ABOUT.TABLE_HEADERS.VERSION' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$version}}</mat-cell>\n            </ng-container>\n\n            <!-- $vendor Column -->\n            <ng-container matColumnDef=\"$vendor\">\n                <mat-header-cell *matHeaderCellDef>{{ 'ABOUT.TABLE_HEADERS.VENDOR' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$vendor}}</mat-cell>\n            </ng-container>\n\n            <!-- $license Column -->\n            <ng-container matColumnDef=\"$license\">\n                <mat-header-cell *matHeaderCellDef>{{ 'ABOUT.TABLE_HEADERS.LICENSE' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$license}}</mat-cell>\n            </ng-container>\n\n            <!-- $runtime Column -->\n            <ng-container matColumnDef=\"$runtime\">\n                <mat-header-cell *matHeaderCellDef>{{ 'ABOUT.TABLE_HEADERS.RUNTIME' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$runtime}}</mat-cell>\n            </ng-container>\n\n            <!-- $description Column -->\n            <ng-container matColumnDef=\"$description\">\n                <mat-header-cell *matHeaderCellDef>{{ 'ABOUT.TABLE_HEADERS.DESCRIPTION' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$description}}</mat-cell>\n            </ng-container>\n\n            <mat-header-row *matHeaderRowDef=\"extensionColumns\"></mat-header-row>\n            <mat-row *matRowDef=\"let row; columns: extensionColumns;\"></mat-row>\n        </mat-table>\n    </div>\n    <h3>{{ 'ABOUT.SERVER_SETTINGS.TITLE' | translate }}</h3>\n    <mat-list>\n        <small>{{ 'ABOUT.SERVER_SETTINGS.DESCRIPTION' | translate }}</small>\n        <mat-list-item>\n            <h4 matLine> {{ 'ABOUT.SERVER_SETTINGS.PROCESS_SERVICE_HOST' | translate: { value: bpmHost } }}</h4>\n        </mat-list-item>\n        <mat-divider></mat-divider>\n        <mat-list-item>\n            <h4 matLine>{{ 'ABOUT.SERVER_SETTINGS.PROCESS_SERVICE_HOST' | translate: { value: ecmHost } }}</h4>\n        </mat-list-item>\n    </mat-list>\n\n    <h3>{{ 'ABOUT.VERSIONS.TITLE' | translate }}</h3>\n    <div *ngIf=\"bpmVersion\">\n        <h3>{{ 'ABOUT.VERSIONS.PROCESS_SERVICE' | translate }}</h3>\n        <div> {{ 'ABOUT.VERSIONS.divS.EDITION' | translate }} </div> {{ bpmVersion.edition }}\n        <p></p>\n        <div> {{ 'ABOUT.VERSIONS.divS.VERSION' | translate }} </div> {{ bpmVersion.majorVersion }}.{{\n        bpmVersion.minorVersion }}.{{ bpmVersion.revisionVersion }}\n    </div>\n    <div *ngIf=\"ecmVersion\">\n        <h3>{{ 'ABOUT.VERSIONS.CONTENT_SERVICE' | translate }}</h3>\n        <div>{{ 'ABOUT.VERSIONS.divS.EDITION' | translate }}</div> {{ ecmVersion.edition }}\n        <p></p>\n        <div> {{ 'ABOUT.VERSIONS.divS.VERSION' | translate }} </div> {{ ecmVersion.version.display }}\n        <p></p>\n        <h4>{{ 'ABOUT.VERSIONS.divS.LICENSE' | translate }}</h4>\n        <adf-datatable [data]=\"license\"></adf-datatable>\n\n        <h4> {{ 'ABOUT.VERSIONS.divS.STATUS' | translate }}</h4>\n        <adf-datatable [data]=\"status\"></adf-datatable>\n\n        <h4>{{ 'ABOUT.VERSIONS.divS.MODULES' | translate }}</h4>\n\n        <adf-datatable [data]=\"modules\"></adf-datatable>\n    </div>\n\n    <div *ngIf=\"githubUrlCommitAlpha\">\n        <h3>{{ 'ABOUT.SOURCE_CODE.TITLE' | translate }}</h3>\n        <small>{{ 'ABOUT.SOURCE_CODE.DESCRIPTION' | translate }}</small>\n        <div>\n            <a [href]=\"githubUrlCommitAlpha\">{{githubUrlCommitAlpha}}</a>\n        </div>\n    </div>\n\n    <h3>{{ 'ABOUT.PACKAGES.TITLE' | translate }}</h3>\n    <small>{{ 'ABOUT.PACKAGES.DESCRIPTION' | translate }}</small>\n    <adf-datatable [data]=\"data\"></adf-datatable>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-about-container{padding:10px}.adf-table-version{width:60%;border:0;border-spacing:0;text-align:center}"]
            }] }
];
/** @nocollapse */
AboutComponent.ctorParameters = () => [
    { type: HttpClient },
    { type: AppConfigService },
    { type: AuthenticationService },
    { type: DiscoveryApiService },
    { type: AppExtensionService }
];
AboutComponent.propDecorators = {
    githubUrlCommitAlpha: [{ type: Input }],
    showExtensions: [{ type: Input }],
    regexp: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function modules() {
    return [
        MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule,
        MatChipsModule, MatDatepickerModule, MatDialogModule, MatGridListModule, MatIconModule,
        MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule,
        MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule,
        MatMenuModule, MatProgressBarModule, MatSidenavModule, MatSnackBarModule, MatToolbarModule,
        MatTooltipModule, MatDatetimepickerModule, MatNativeDatetimeModule, MatExpansionModule
    ];
}
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                imports: modules(),
                exports: modules()
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContextMenuService {
    constructor() {
        this.show = new Subject();
    }
}
ContextMenuService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ContextMenuService.ngInjectableDef = defineInjectable({ factory: function ContextMenuService_Factory() { return new ContextMenuService(); }, token: ContextMenuService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContextMenuHolderComponent {
    /**
     * @param {?} viewport
     * @param {?} overlayContainer
     * @param {?} contextMenuService
     * @param {?} renderer
     */
    constructor(viewport, overlayContainer, contextMenuService, renderer) {
        this.viewport = viewport;
        this.overlayContainer = overlayContainer;
        this.contextMenuService = contextMenuService;
        this.renderer = renderer;
        this.links = [];
        this.mouseLocation = { left: 0, top: 0 };
        this.menuElement = null;
        this.subscriptions = [];
        this.showIcons = false;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onShowContextMenu(event) {
        if (event) {
            event.preventDefault();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        if (this.mdMenuElement) {
            this.updatePosition();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.contextMenuService.show.subscribe((/**
         * @param {?} mouseEvent
         * @return {?}
         */
        (mouseEvent) => this.showMenu(mouseEvent.event, mouseEvent.obj))), this.menuTrigger.onMenuOpen.subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const container = this.overlayContainer.getContainerElement();
            if (container) {
                this.contextMenuListenerFn = this.renderer.listen(container, 'contextmenu', (/**
                 * @param {?} contextmenuEvent
                 * @return {?}
                 */
                (contextmenuEvent) => {
                    contextmenuEvent.preventDefault();
                }));
            }
            this.menuElement = this.getContextMenuElement();
        })), this.menuTrigger.onMenuClose.subscribe((/**
         * @return {?}
         */
        () => {
            this.menuElement = null;
            if (this.contextMenuListenerFn) {
                this.contextMenuListenerFn();
            }
        })));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.contextMenuListenerFn) {
            this.contextMenuListenerFn();
        }
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => subscription.unsubscribe()));
        this.subscriptions = [];
        this.menuElement = null;
    }
    /**
     * @param {?} event
     * @param {?} menuItem
     * @return {?}
     */
    onMenuItemClick(event, menuItem) {
        if (menuItem && menuItem.model && menuItem.model.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return;
        }
        menuItem.subject.next(menuItem);
    }
    /**
     * @param {?} mouseEvent
     * @param {?} links
     * @return {?}
     */
    showMenu(mouseEvent, links) {
        this.links = links;
        if (mouseEvent) {
            this.mouseLocation = {
                left: mouseEvent.clientX,
                top: mouseEvent.clientY
            };
        }
        this.menuTrigger.openMenu();
        if (this.mdMenuElement) {
            this.updatePosition();
        }
    }
    /**
     * @return {?}
     */
    get mdMenuElement() {
        return this.menuElement;
    }
    /**
     * @private
     * @return {?}
     */
    locationCss() {
        return {
            left: this.mouseLocation.left + 'px',
            top: this.mouseLocation.top + 'px'
        };
    }
    /**
     * @private
     * @return {?}
     */
    updatePosition() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.mdMenuElement.parentElement) {
                if (this.mdMenuElement.clientWidth + this.mouseLocation.left > this.viewport.getViewportRect().width) {
                    this.menuTrigger.menu.xPosition = 'before';
                    this.mdMenuElement.parentElement.style.left = this.mouseLocation.left - this.mdMenuElement.clientWidth + 'px';
                }
                else {
                    this.menuTrigger.menu.xPosition = 'after';
                    this.mdMenuElement.parentElement.style.left = this.locationCss().left;
                }
                if (this.mdMenuElement.clientHeight + this.mouseLocation.top > this.viewport.getViewportRect().height) {
                    this.menuTrigger.menu.yPosition = 'above';
                    this.mdMenuElement.parentElement.style.top = this.mouseLocation.top - this.mdMenuElement.clientHeight + 'px';
                }
                else {
                    this.menuTrigger.menu.yPosition = 'below';
                    this.mdMenuElement.parentElement.style.top = this.locationCss().top;
                }
            }
        }), 0);
    }
    /**
     * @private
     * @return {?}
     */
    getContextMenuElement() {
        return this.overlayContainer.getContainerElement().querySelector('.context-menu');
    }
}
ContextMenuHolderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-context-menu-holder',
                template: `
        <button mat-button [matMenuTriggerFor]="contextMenu"></button>
        <mat-menu #contextMenu="matMenu" class="context-menu">
            <ng-container *ngFor="let link of links">
                <button *ngIf="link.model?.visible"
                        [attr.data-automation-id]="'context-'+((link.title || link.model?.title) | translate)"
                        mat-menu-item
                        [disabled]="link.model?.disabled"
                        (click)="onMenuItemClick($event, link)">
                    <mat-icon *ngIf="showIcons && link.model?.icon">{{ link.model.icon }}</mat-icon>
                    {{ (link.title || link.model?.title) | translate }}
                </button>
            </ng-container>
        </mat-menu>
    `
            }] }
];
/** @nocollapse */
ContextMenuHolderComponent.ctorParameters = () => [
    { type: ViewportRuler },
    { type: OverlayContainer },
    { type: ContextMenuService },
    { type: Renderer2 }
];
ContextMenuHolderComponent.propDecorators = {
    showIcons: [{ type: Input }],
    menuTrigger: [{ type: ViewChild, args: [MatMenuTrigger,] }],
    onShowContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContextMenuOverlayRef {
    /**
     * @param {?} overlayRef
     */
    constructor(overlayRef) {
        this.overlayRef = overlayRef;
    }
    /**
     * @return {?}
     */
    close() {
        this.overlayRef.dispose();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CONTEXT_MENU_DATA = new InjectionToken('CONTEXT_MENU_DATA');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const contextMenuAnimation = [
    state('void', style({
        opacity: 0,
        transform: 'scale(0.01, 0.01)'
    })),
    transition('void => *', sequence([
        query('.mat-menu-content', style({ opacity: 0 })),
        animate('100ms linear', style({ opacity: 1, transform: 'scale(1, 0.5)' })),
        group([
            query('.mat-menu-content', animate('400ms cubic-bezier(0.55, 0, 0.55, 0.2)', style({ opacity: 1 }))),
            animate('300ms cubic-bezier(0.25, 0.8, 0.25, 1)', style({ transform: 'scale(1, 1)' }))
        ])
    ])),
    transition('* => void', animate('150ms 50ms linear', style({ opacity: 0 })))
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContextMenuListComponent {
    /**
     * @param {?} contextMenuOverlayRef
     * @param {?} data
     */
    constructor(contextMenuOverlayRef, data) {
        this.contextMenuOverlayRef = contextMenuOverlayRef;
        this.data = data;
        this.links = this.data;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleKeydownEscape(event) {
        if (event) {
            this.contextMenuOverlayRef.close();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleKeydownEvent(event) {
        if (event) {
            /** @type {?} */
            const keyCode = event.keyCode;
            if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
                this.keyManager.onKeydown(event);
            }
        }
    }
    /**
     * @param {?} event
     * @param {?} menuItem
     * @return {?}
     */
    onMenuItemClick(event, menuItem) {
        if (menuItem && menuItem.model && menuItem.model.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return;
        }
        menuItem.subject.next(menuItem);
        this.contextMenuOverlayRef.close();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.keyManager = new FocusKeyManager(this.items);
        this.keyManager.setFirstItemActive();
    }
}
ContextMenuListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-context-menu',
                template: `
        <div mat-menu class="mat-menu-panel" @panelAnimation>
            <div id="adf-context-menu-content" class="mat-menu-content">
                <ng-container *ngFor="let link of links">
                    <button *ngIf="link.model?.visible"
                            [attr.data-automation-id]="'context-'+((link.title || link.model?.title) | translate)"
                            mat-menu-item
                            [disabled]="link.model?.disabled"
                            (click)="onMenuItemClick($event, link)">
                        <mat-icon *ngIf="link.model?.icon">{{ link.model.icon }}</mat-icon>
                        <span>{{ (link.title || link.model?.title) | translate }}</span>
                    </button>
                </ng-container>
            </div>
        </div>
    `,
                host: {
                    role: 'menu',
                    class: 'adf-context-menu'
                },
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('panelAnimation', contextMenuAnimation)
                ]
            }] }
];
/** @nocollapse */
ContextMenuListComponent.ctorParameters = () => [
    { type: ContextMenuOverlayRef, decorators: [{ type: Inject, args: [ContextMenuOverlayRef,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_DATA,] }] }
];
ContextMenuListComponent.propDecorators = {
    items: [{ type: ViewChildren, args: [MatMenuItem,] }],
    handleKeydownEscape: [{ type: HostListener, args: ['document:keydown.Escape', ['$event'],] }],
    handleKeydownEvent: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_CONFIG = {
    panelClass: 'cdk-overlay-pane',
    backdropClass: 'cdk-overlay-transparent-backdrop',
    hasBackdrop: true
};
class ContextMenuOverlayService {
    /**
     * @param {?} injector
     * @param {?} overlay
     */
    constructor(injector, overlay) {
        this.injector = injector;
        this.overlay = overlay;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    open(config) {
        /** @type {?} */
        const overlayConfig = Object.assign({}, DEFAULT_CONFIG, config);
        /** @type {?} */
        const overlay = this.createOverlay(overlayConfig);
        /** @type {?} */
        const overlayRef = new ContextMenuOverlayRef(overlay);
        this.attachDialogContainer(overlay, config, overlayRef);
        overlay.backdropClick().subscribe((/**
         * @return {?}
         */
        () => overlayRef.close()));
        // prevent native contextmenu on overlay element if config.hasBackdrop is true
        if (overlayConfig.hasBackdrop) {
            ((/** @type {?} */ (overlay)))._backdropElement
                .addEventListener('contextmenu', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                event.preventDefault();
                ((/** @type {?} */ (overlay)))._backdropClick.next(null);
            }), true);
        }
        return overlayRef;
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    createOverlay(config) {
        /** @type {?} */
        const overlayConfig = this.getOverlayConfig(config);
        return this.overlay.create(overlayConfig);
    }
    /**
     * @private
     * @param {?} overlay
     * @param {?} config
     * @param {?} contextMenuOverlayRef
     * @return {?}
     */
    attachDialogContainer(overlay, config, contextMenuOverlayRef) {
        /** @type {?} */
        const injector = this.createInjector(config, contextMenuOverlayRef);
        /** @type {?} */
        const containerPortal = new ComponentPortal(ContextMenuListComponent, null, injector);
        /** @type {?} */
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    /**
     * @private
     * @param {?} config
     * @param {?} contextMenuOverlayRef
     * @return {?}
     */
    createInjector(config, contextMenuOverlayRef) {
        /** @type {?} */
        const injectionTokens = new WeakMap();
        injectionTokens.set(ContextMenuOverlayRef, contextMenuOverlayRef);
        injectionTokens.set(CONTEXT_MENU_DATA, config.data);
        return new PortalInjector(this.injector, injectionTokens);
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getOverlayConfig(config) {
        const { clientY, clientX } = config.source;
        /** @type {?} */
        const fakeElement = {
            getBoundingClientRect: (/**
             * @return {?}
             */
            () => ({
                bottom: clientY,
                height: 0,
                left: clientX,
                right: clientX,
                top: clientY,
                width: 0
            }))
        };
        /** @type {?} */
        const positionStrategy = this.overlay.position()
            .connectedTo(new ElementRef(fakeElement), { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
            .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
            .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })
            .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });
        /** @type {?} */
        const overlayConfig = new OverlayConfig({
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass,
            panelClass: config.panelClass,
            scrollStrategy: this.overlay.scrollStrategies.close(),
            positionStrategy
        });
        return overlayConfig;
    }
}
ContextMenuOverlayService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ContextMenuOverlayService.ctorParameters = () => [
    { type: Injector },
    { type: Overlay }
];
/** @nocollapse */ ContextMenuOverlayService.ngInjectableDef = defineInjectable({ factory: function ContextMenuOverlayService_Factory() { return new ContextMenuOverlayService(inject(INJECTOR), inject(Overlay)); }, token: ContextMenuOverlayService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContextMenuDirective {
    /**
     * @param {?} contextMenuService
     */
    constructor(contextMenuService) {
        this.contextMenuService = contextMenuService;
        /**
         * Is the menu enabled?
         */
        this.enabled = false;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onShowContextMenu(event) {
        if (this.enabled) {
            if (event) {
                event.preventDefault();
            }
            if (this.links && this.links.length > 0) {
                this.contextMenuService.open({
                    source: event,
                    data: this.links
                });
            }
        }
    }
}
ContextMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-context-menu], [context-menu]'
            },] }
];
/** @nocollapse */
ContextMenuDirective.ctorParameters = () => [
    { type: ContextMenuOverlayService }
];
ContextMenuDirective.propDecorators = {
    links: [{ type: Input, args: ['adf-context-menu',] }],
    enabled: [{ type: Input, args: ['adf-context-menu-enabled',] }],
    onShowContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContextMenuModule {
}
ContextMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild()
                ],
                declarations: [
                    ContextMenuHolderComponent,
                    ContextMenuDirective,
                    ContextMenuListComponent
                ],
                exports: [
                    ContextMenuHolderComponent,
                    ContextMenuDirective
                ],
                entryComponents: [
                    ContextMenuListComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StorageService {
    /**
     * @param {?} appConfigService
     */
    constructor(appConfigService) {
        this.appConfigService = appConfigService;
        this.memoryStore = {};
        this.useLocalStorage = false;
        this.useLocalStorage = this.storageAvailable('localStorage');
        this.appConfigService.onLoad.subscribe(this.getAppPrefix.bind(this));
    }
    /**
     * Gets an item.
     * @param {?} key Key to identify the item
     * @return {?} The item (if any) retrieved by the key
     */
    getItem(key) {
        if (this.useLocalStorage) {
            return localStorage.getItem(this.storagePrefix + key);
        }
        else {
            return this.memoryStore.hasOwnProperty(this.storagePrefix + key) ? this.memoryStore[this.storagePrefix + key] : null;
        }
    }
    /**
     * Stores an item
     * @param {?} key Key to identify the item
     * @param {?} data Data to store
     * @return {?}
     */
    setItem(key, data) {
        if (this.useLocalStorage) {
            localStorage.setItem(this.storagePrefix + key, data);
        }
        else {
            this.memoryStore[this.storagePrefix + key] = data.toString();
        }
    }
    /**
     * Removes all currently stored items.
     * @return {?}
     */
    clear() {
        if (this.useLocalStorage) {
            localStorage.clear();
        }
        else {
            this.memoryStore = {};
        }
    }
    /**
     * Removes a single item.
     * @param {?} key Key to identify the item
     * @return {?}
     */
    removeItem(key) {
        if (this.useLocalStorage) {
            localStorage.removeItem(this.storagePrefix + key);
        }
        else {
            delete this.memoryStore[this.storagePrefix + key];
        }
    }
    /**
     * Is any item currently stored under `key`?
     * @param {?} key Key identifying item to check
     * @return {?} True if key retrieves an item, false otherwise
     */
    hasItem(key) {
        if (this.useLocalStorage) {
            return localStorage.getItem(this.storagePrefix + key) ? true : false;
        }
        else {
            return this.memoryStore.hasOwnProperty(key);
        }
    }
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    storageAvailable(type) {
        try {
            /** @type {?} */
            const storage = window[type];
            /** @type {?} */
            const key = '__storage_test__';
            storage.setItem(key, key);
            storage.removeItem(key, key);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Sets the prefix that is used for the local storage of the app
     * It assigns the string that is defined i the app config,
     * empty prefix otherwise.
     * @return {?}
     */
    getAppPrefix() {
        /** @type {?} */
        const appConfiguration = this.appConfigService.get('application');
        if (appConfiguration && appConfiguration.storagePrefix) {
            this.storagePrefix = appConfiguration.storagePrefix + '_';
        }
        else {
            this.storagePrefix = '';
        }
    }
}
StorageService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
StorageService.ctorParameters = () => [
    { type: AppConfigService }
];
/** @nocollapse */ StorageService.ngInjectableDef = defineInjectable({ factory: function StorageService_Factory() { return new StorageService(inject(AppConfigService)); }, token: StorageService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const UserPreferenceValues = {
    PaginationSize: 'paginationSize',
    Locale: 'locale',
    SupportedPageSizes: 'supportedPageSizes',
    ExpandedSideNavStatus: 'expandedSidenav',
};
class UserPreferencesService {
    /**
     * @param {?} translate
     * @param {?} appConfig
     * @param {?} storage
     */
    constructor(translate, appConfig, storage) {
        this.translate = translate;
        this.appConfig = appConfig;
        this.storage = storage;
        this.defaults = {
            paginationSize: 25,
            supportedPageSizes: [5, 10, 15, 20],
            locale: 'en',
            expandedSidenav: true
        };
        this.userPreferenceStatus = this.defaults;
        this.appConfig.onLoad.subscribe(this.initUserPreferenceStatus.bind(this));
        this.onChangeSubject = new BehaviorSubject(this.userPreferenceStatus);
        this.onChange = this.onChangeSubject.asObservable();
    }
    /**
     * @private
     * @return {?}
     */
    initUserPreferenceStatus() {
        this.initUserLanguage();
        this.set(UserPreferenceValues.PaginationSize, this.paginationSize);
        this.set(UserPreferenceValues.SupportedPageSizes, JSON.stringify(this.supportedPageSizes));
    }
    /**
     * @private
     * @return {?}
     */
    initUserLanguage() {
        if (this.locale || this.appConfig.get(UserPreferenceValues.Locale)) {
            this.set(UserPreferenceValues.Locale, (this.locale || this.getDefaultLocale()));
        }
        else {
            this.setWithoutStore(UserPreferenceValues.Locale, (this.locale || this.getDefaultLocale()));
        }
    }
    /**
     * Sets up a callback to notify when a property has changed.
     * @param {?} property The property to watch
     * @return {?} Notification callback
     */
    select(property) {
        return this.onChange
            .pipe(map((/**
         * @param {?} userPreferenceStatus
         * @return {?}
         */
        (userPreferenceStatus) => userPreferenceStatus[property])), distinctUntilChanged());
    }
    /**
     * Gets a preference property.
     * @param {?} property Name of the property
     * @param {?=} defaultValue Default to return if the property is not found
     * @return {?} Preference property
     */
    get(property, defaultValue) {
        /** @type {?} */
        const key = this.getPropertyKey(property);
        /** @type {?} */
        const value = this.storage.getItem(key);
        if (value === undefined || value === null) {
            return defaultValue;
        }
        return value;
    }
    /**
     * Sets a preference property.
     * @param {?} property Name of the property
     * @param {?} value New value for the property
     * @return {?}
     */
    set(property, value) {
        if (!property) {
            return;
        }
        this.storage.setItem(this.getPropertyKey(property), value);
        this.userPreferenceStatus[property] = value;
        this.onChangeSubject.next(this.userPreferenceStatus);
    }
    /**
     * Sets a preference property.
     * @param {?} property Name of the property
     * @param {?} value New value for the property
     * @return {?}
     */
    setWithoutStore(property, value) {
        if (!property) {
            return;
        }
        this.userPreferenceStatus[property] = value;
        this.onChangeSubject.next(this.userPreferenceStatus);
    }
    /**
     * Check if an item is present in the storage
     * @param {?} property Name of the property
     * @return {?} True if the item is present, false otherwise
     */
    hasItem(property) {
        if (!property) {
            return;
        }
        return this.storage.hasItem(this.getPropertyKey(property));
    }
    /**
     * Gets the active storage prefix for preferences.
     * @return {?} Storage prefix
     */
    getStoragePrefix() {
        return this.storage.getItem('USER_PROFILE') || 'GUEST';
    }
    /**
     * Sets the active storage prefix for preferences.
     * @param {?} value Name of the prefix
     * @return {?}
     */
    setStoragePrefix(value) {
        this.storage.setItem('USER_PROFILE', value || 'GUEST');
        this.initUserPreferenceStatus();
    }
    /**
     * Gets the full property key with prefix.
     * @param {?} property The property name
     * @return {?} Property key
     */
    getPropertyKey(property) {
        return `${this.getStoragePrefix()}__${property}`;
    }
    /**
     * Gets an array containing the available page sizes.
     * @return {?} Array of page size values
     */
    get supportedPageSizes() {
        /** @type {?} */
        const supportedPageSizes = this.get(UserPreferenceValues.SupportedPageSizes);
        if (supportedPageSizes) {
            return JSON.parse(supportedPageSizes);
        }
        else {
            return this.appConfig.get('pagination.supportedPageSizes', this.defaults.supportedPageSizes);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set supportedPageSizes(value) {
        this.set(UserPreferenceValues.SupportedPageSizes, JSON.stringify(value));
    }
    /**
     * Pagination size.
     * @param {?} value
     * @return {?}
     */
    set paginationSize(value) {
        this.set(UserPreferenceValues.PaginationSize, value);
    }
    /**
     * @return {?}
     */
    get paginationSize() {
        /** @type {?} */
        const paginationSize = this.get(UserPreferenceValues.PaginationSize);
        if (paginationSize) {
            return Number(paginationSize);
        }
        else {
            return Number(this.appConfig.get('pagination.size', this.defaults.paginationSize));
        }
    }
    /**
     * Current locale setting.
     * @return {?}
     */
    get locale() {
        return this.get(UserPreferenceValues.Locale);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this.set(UserPreferenceValues.Locale, value);
    }
    /**
     * Gets the default locale.
     * @return {?} Default locale language code
     */
    getDefaultLocale() {
        return this.appConfig.get(UserPreferenceValues.Locale) || this.translate.getBrowserCultureLang() || 'en';
    }
}
UserPreferencesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UserPreferencesService.ctorParameters = () => [
    { type: TranslateService },
    { type: AppConfigService },
    { type: StorageService }
];
/** @nocollapse */ UserPreferencesService.ngInjectableDef = defineInjectable({ factory: function UserPreferencesService_Factory() { return new UserPreferencesService(inject(TranslateService), inject(AppConfigService), inject(StorageService)); }, token: UserPreferencesService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TRANSLATION_PROVIDER = new InjectionToken('Injection token for translation providers.');
class TranslationService {
    /**
     * @param {?} translate
     * @param {?} userPreferencesService
     * @param {?} providers
     */
    constructor(translate, userPreferencesService, providers) {
        this.translate = translate;
        this.customLoader = (/** @type {?} */ (this.translate.currentLoader));
        this.defaultLang = 'en';
        translate.setDefaultLang(this.defaultLang);
        this.customLoader.setDefaultLang(this.defaultLang);
        if (providers && providers.length > 0) {
            for (const provider of providers) {
                this.addTranslationFolder(provider.name, provider.source);
            }
        }
        userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            if (locale) {
                this.userLang = locale;
                this.use(this.userLang);
            }
        }));
    }
    /**
     * Adds a new folder of translation source files.
     * @param {?=} name Name for the translation provider
     * @param {?=} path Path to the folder
     * @return {?}
     */
    addTranslationFolder(name = '', path = '') {
        if (!this.customLoader.providerRegistered(name)) {
            this.customLoader.registerProvider(name, path);
            if (this.userLang) {
                this.loadTranslation(this.userLang, this.defaultLang);
            }
            else {
                this.loadTranslation(this.defaultLang);
            }
        }
    }
    /**
     * Loads a translation file.
     * @param {?} lang Language code for the language to load
     * @param {?=} fallback Language code to fall back to if the first one was unavailable
     * @return {?}
     */
    loadTranslation(lang, fallback) {
        this.translate.getTranslation(lang).subscribe((/**
         * @return {?}
         */
        () => {
            this.translate.use(lang);
            this.onTranslationChanged(lang);
        }), (/**
         * @return {?}
         */
        () => {
            if (fallback && fallback !== lang) {
                this.loadTranslation(fallback);
            }
        }));
    }
    /**
     * Triggers a notification callback when the translation language changes.
     * @param {?} lang The new language code
     * @return {?}
     */
    onTranslationChanged(lang) {
        this.translate.onTranslationChange.next({
            lang: lang,
            translations: this.customLoader.getFullTranslationJSON(lang)
        });
    }
    /**
     * Sets the target language for translations.
     * @param {?} lang Code name for the language
     * @return {?} Translations available for the language
     */
    use(lang) {
        this.customLoader.init(lang);
        return this.translate.use(lang);
    }
    /**
     * Gets the translation for the supplied key.
     * @param {?} key Key to translate
     * @param {?=} interpolateParams String(s) to be interpolated into the main message
     * @return {?} Translated text
     */
    get(key, interpolateParams) {
        return this.translate.get(key, interpolateParams);
    }
    /**
     * Directly returns the translation for the supplied key.
     * @param {?} key Key to translate
     * @param {?=} interpolateParams String(s) to be interpolated into the main message
     * @return {?} Translated text
     */
    instant(key, interpolateParams) {
        return key ? this.translate.instant(key, interpolateParams) : '';
    }
}
TranslationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TranslationService.ctorParameters = () => [
    { type: TranslateService },
    { type: UserPreferencesService },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLATION_PROVIDER,] }] }
];
/** @nocollapse */ TranslationService.ngInjectableDef = defineInjectable({ factory: function TranslationService_Factory() { return new TranslationService(inject(TranslateService), inject(UserPreferencesService), inject(TRANSLATION_PROVIDER, 8)); }, token: TranslationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileSizePipe {
    /**
     * @param {?} translation
     */
    constructor(translation) {
        this.translation = translation;
    }
    /**
     * @param {?} bytes
     * @param {?=} decimals
     * @return {?}
     */
    transform(bytes, decimals = 2) {
        if (bytes == null || bytes === undefined) {
            return '';
        }
        if (bytes === 0) {
            return '0 ' + this.translation.instant('CORE.FILE_SIZE.BYTES');
        }
        /** @type {?} */
        const k = 1024;
        /** @type {?} */
        const dm = decimals || 2;
        /** @type {?} */
        const sizes = ['BYTES', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        /** @type {?} */
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        /** @type {?} */
        const i18nSize = this.translation.instant(`CORE.FILE_SIZE.${sizes[i]}`);
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + i18nSize;
    }
}
FileSizePipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfFileSize',
                pure: false
            },] }
];
/** @nocollapse */
FileSizePipe.ctorParameters = () => [
    { type: TranslationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* spellchecker: disable */
class PermissionsEnum extends String {
}
PermissionsEnum.CONTRIBUTOR = 'Contributor';
PermissionsEnum.CONSUMER = 'Consumer';
PermissionsEnum.COLLABORATOR = 'Collaborator';
PermissionsEnum.MANAGER = 'Manager';
PermissionsEnum.EDITOR = 'Editor';
PermissionsEnum.COORDINATOR = 'Coordinator';
PermissionsEnum.NOT_CONTRIBUTOR = '!Contributor';
PermissionsEnum.NOT_CONSUMER = '!Consumer';
PermissionsEnum.NOT_COLLABORATOR = '!Collaborator';
PermissionsEnum.NOT_MANAGER = '!Manager';
PermissionsEnum.NOT_EDITOR = '!Editor';
PermissionsEnum.NOT_COORDINATOR = '!Coordinator';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* spellchecker: disable */
class AllowableOperationsEnum extends String {
}
AllowableOperationsEnum.DELETE = 'delete';
AllowableOperationsEnum.UPDATE = 'update';
AllowableOperationsEnum.CREATE = 'create';
AllowableOperationsEnum.COPY = 'copy';
AllowableOperationsEnum.LOCK = 'lock';
AllowableOperationsEnum.UPDATEPERMISSIONS = 'updatePermissions';
AllowableOperationsEnum.NOT_DELETE = '!delete';
AllowableOperationsEnum.NOT_UPDATE = '!update';
AllowableOperationsEnum.NOT_CREATE = '!create';
AllowableOperationsEnum.NOT_UPDATEPERMISSIONS = '!updatePermissions';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentService {
    /**
     * @param {?} authService
     * @param {?} apiService
     * @param {?} logService
     * @param {?} sanitizer
     */
    constructor(authService, apiService, logService, sanitizer) {
        this.authService = authService;
        this.apiService = apiService;
        this.logService = logService;
        this.sanitizer = sanitizer;
        this.folderCreated = new Subject();
        this.folderCreate = new Subject();
        this.folderEdit = new Subject();
        this.saveData = ((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            const a = document.createElement('a');
            document.body.appendChild(a);
            a.style.display = 'none';
            return (/**
             * @param {?} fileData
             * @param {?} format
             * @param {?} fileName
             * @return {?}
             */
            function (fileData, format, fileName) {
                /** @type {?} */
                let blob = null;
                if (format === 'blob' || format === 'data') {
                    blob = new Blob([fileData], { type: 'octet/stream' });
                }
                if (format === 'object' || format === 'json') {
                    /** @type {?} */
                    const json = JSON.stringify(fileData);
                    blob = new Blob([json], { type: 'octet/stream' });
                }
                if (blob) {
                    if (typeof window.navigator !== 'undefined' && window.navigator.msSaveOrOpenBlob) {
                        navigator.msSaveOrOpenBlob(blob, fileName);
                    }
                    else {
                        /** @type {?} */
                        const url = window.URL.createObjectURL(blob);
                        a.href = url;
                        a.download = fileName;
                        a.click();
                        window.URL.revokeObjectURL(url);
                    }
                }
            });
        })());
    }
    /**
     * Invokes content download for a Blob with a file name.
     * @param {?} blob Content to download.
     * @param {?} fileName Name of the resulting file.
     * @return {?}
     */
    downloadBlob(blob, fileName) {
        this.saveData(blob, 'blob', fileName);
    }
    /**
     * Invokes content download for a data array with a file name.
     * @param {?} data Data to download.
     * @param {?} fileName Name of the resulting file.
     * @return {?}
     */
    downloadData(data, fileName) {
        this.saveData(data, 'data', fileName);
    }
    /**
     * Invokes content download for a JSON object with a file name.
     * @param {?} json JSON object to download.
     * @param {?} fileName Name of the resulting file.
     * @return {?}
     */
    downloadJSON(json, fileName) {
        this.saveData(json, 'json', fileName);
    }
    /**
     * Creates a trusted object URL from the Blob.
     * WARNING: calling this method with untrusted user data exposes your application to XSS security risks!
     * @param {?} blob Data to wrap into object URL
     * @return {?} URL string
     */
    createTrustedUrl(blob) {
        /** @type {?} */
        const url = window.URL.createObjectURL(blob);
        return (/** @type {?} */ (this.sanitizer.bypassSecurityTrustUrl(url)));
    }
    /**
     * @private
     * @return {?}
     */
    get contentApi() {
        return this.apiService.getInstance().content;
    }
    /**
     * Gets a thumbnail URL for the given document node.
     * @param {?} node Node to get URL for.
     * @param {?=} attachment Toggles whether to retrieve content as an attachment for download
     * @param {?=} ticket Custom ticket to use for authentication
     * @return {?} URL string
     */
    getDocumentThumbnailUrl(node, attachment, ticket) {
        if (node && node.entry) {
            node = node.entry.id;
        }
        return this.contentApi.getDocumentThumbnailUrl(node, attachment, ticket);
    }
    /**
     * Gets a content URL for the given node.
     * @param {?} node Node to get URL for.
     * @param {?=} attachment Toggles whether to retrieve content as an attachment for download
     * @param {?=} ticket Custom ticket to use for authentication
     * @return {?} URL string
     */
    getContentUrl(node, attachment, ticket) {
        if (node && node.entry) {
            node = node.entry.id;
        }
        return this.contentApi.getContentUrl(node, attachment, ticket);
    }
    /**
     * Gets content for the given node.
     * @param {?} nodeId ID of the target node
     * @return {?} Content data
     */
    getNodeContent(nodeId) {
        return from(this.apiService.getInstance().core.nodesApi.getFileContent(nodeId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a Node via its node ID.
     * @param {?} nodeId ID of the target node
     * @param {?=} opts Options supported by JS-API
     * @return {?} Details of the folder
     */
    getNode(nodeId, opts) {
        return from(this.apiService.getInstance().nodes.getNode(nodeId, opts));
    }
    /**
     * Checks if the user has permission on that node
     * @param {?} node Node to check permissions
     * @param {?} permission Required permission type
     * @return {?} True if the user has the required permissions, false otherwise
     */
    hasPermissions(node, permission) {
        /** @type {?} */
        let hasPermissions = false;
        if (node && node.permissions && node.permissions.locallySet) {
            if (permission && permission.startsWith('!')) {
                hasPermissions = node.permissions.locallySet.find((/**
                 * @param {?} currentPermission
                 * @return {?}
                 */
                (currentPermission) => currentPermission.name === permission.replace('!', ''))) ? false : true;
            }
            else {
                hasPermissions = node.permissions.locallySet.find((/**
                 * @param {?} currentPermission
                 * @return {?}
                 */
                (currentPermission) => currentPermission.name === permission)) ? true : false;
            }
        }
        else {
            if (permission === PermissionsEnum.CONSUMER) {
                hasPermissions = true;
            }
            else if (permission === PermissionsEnum.NOT_CONSUMER) {
                hasPermissions = false;
            }
            else if (permission && permission.startsWith('!')) {
                hasPermissions = true;
            }
        }
        return hasPermissions;
    }
    /**
     * Checks if the user has permissions on that node
     * @param {?} node Node to check allowableOperations
     * @param {?} allowableOperation Create, delete, update, updatePermissions, !create, !delete, !update, !updatePermissions
     * @return {?} True if the user has the required permissions, false otherwise
     */
    hasAllowableOperations(node, allowableOperation) {
        /** @type {?} */
        let hasAllowableOperations = false;
        if (node && node.allowableOperations) {
            if (allowableOperation && allowableOperation.startsWith('!')) {
                hasAllowableOperations = node.allowableOperations.find((/**
                 * @param {?} currentOperation
                 * @return {?}
                 */
                (currentOperation) => currentOperation === allowableOperation.replace('!', ''))) ? false : true;
            }
            else {
                hasAllowableOperations = node.allowableOperations.find((/**
                 * @param {?} currentOperation
                 * @return {?}
                 */
                (currentOperation) => currentOperation === allowableOperation)) ? true : false;
            }
        }
        else {
            if (allowableOperation && allowableOperation.startsWith('!')) {
                hasAllowableOperations = true;
            }
        }
        if (allowableOperation === AllowableOperationsEnum.COPY) {
            hasAllowableOperations = true;
        }
        if (allowableOperation === AllowableOperationsEnum.LOCK) {
            hasAllowableOperations = node.isFile;
            if (node.isLocked && node.allowableOperations) {
                hasAllowableOperations = !!~node.allowableOperations.indexOf('updatePermissions');
            }
        }
        return hasAllowableOperations;
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
ContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ContentService.ctorParameters = () => [
    { type: AuthenticationService },
    { type: AlfrescoApiService },
    { type: LogService },
    { type: DomSanitizer }
];
/** @nocollapse */ ContentService.ngInjectableDef = defineInjectable({ factory: function ContentService_Factory() { return new ContentService(inject(AuthenticationService), inject(AlfrescoApiService), inject(LogService), inject(DomSanitizer)); }, token: ContentService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ThumbnailService {
    /**
     * @param {?} contentService
     * @param {?} matIconRegistry
     * @param {?} sanitizer
     */
    constructor(contentService, matIconRegistry, sanitizer) {
        this.contentService = contentService;
        this.DEFAULT_ICON = './assets/images/ft_ic_miscellaneous.svg';
        this.mimeTypeIcons = {
            'image/png': './assets/images/ft_ic_raster_image.svg',
            'image/jpeg': './assets/images/ft_ic_raster_image.svg',
            'image/gif': './assets/images/ft_ic_raster_image.svg',
            'image/bmp': './assets/images/ft_ic_raster_image.svg',
            'image/cgm': './assets/images/ft_ic_raster_image.svg',
            'image/ief': './assets/images/ft_ic_raster_image.svg',
            'image/jp2': './assets/images/ft_ic_raster_image.svg',
            'image/tiff': './assets/images/ft_ic_raster_image.svg',
            'image/vnd.adobe.photoshop': './assets/images/ft_ic_raster_image.svg',
            'image/vnd.adobe.premiere': './assets/images/ft_ic_raster_image.svg',
            'image/x-cmu-raster': './assets/images/ft_ic_raster_image.svg',
            'image/x-dwt': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-anymap': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-bitmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-graymap': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-pixmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-adobe': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-canon': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-fuji': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-hasselblad': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-kodak': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-leica': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-minolta': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-nikon': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-olympus': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-panasonic': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-pentax': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-red': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-sigma': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-sony': './assets/images/ft_ic_raster_image.svg',
            'image/x-xbitmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-xpixmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-xwindowdump': './assets/images/ft_ic_raster_image.svg',
            'image/svg+xml': './assets/images/ft_ic_vector_image.svg',
            'application/eps': './assets/images/ft_ic_raster_image.svg',
            'application/illustrator': './assets/images/ft_ic_raster_image.svg',
            'application/pdf': './assets/images/ft_ic_pdf.svg',
            'application/vnd.ms-excel': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.template': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.addin.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.sheet.binary.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.sheet.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.template.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.sun.xml.calc': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.sun.xml.calc.template': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-outlook': './assets/images/ft_ic_document.svg',
            'application/msword': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.template': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-word.document.macroenabled.12': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-word.template.macroenabled.12': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.sun.xml.writer': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.sun.xml.writer.template': './assets/images/ft_ic_ms_word.svg',
            'application/rtf': './assets/images/ft_ic_ms_word.svg',
            'text/rtf': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-powerpoint': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.slideshow': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.oasis.opendocument.presentation': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.oasis.opendocument.presentation-template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.slide': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.sun.xml.impress': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.sun.xml.impress.template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.oasis.opendocument.spreadsheet': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.oasis.opendocument.spreadsheet-template': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-powerpoint.addin.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.presentation.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.slide.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.slideshow.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.template.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'video/mp4': './assets/images/ft_ic_video.svg',
            'video/3gpp': './assets/images/ft_ic_video.svg',
            'video/3gpp2': './assets/images/ft_ic_video.svg',
            'video/mp2t': './assets/images/ft_ic_video.svg',
            'video/mpeg': './assets/images/ft_ic_video.svg',
            'video/mpeg2': './assets/images/ft_ic_video.svg',
            'video/ogg': './assets/images/ft_ic_video.svg',
            'video/quicktime': './assets/images/ft_ic_video.svg',
            'video/webm': './assets/images/ft_ic_video.svg',
            'video/x-flv': './assets/images/ft_ic_video.svg',
            'video/x-m4v': './assets/images/ft_ic_video.svg',
            'video/x-ms-asf': './assets/images/ft_ic_video.svg',
            'video/x-ms-wmv': './assets/images/ft_ic_video.svg',
            'video/x-msvideo': './assets/images/ft_ic_video.svg',
            'video/x-rad-screenplay': './assets/images/ft_ic_video.svg',
            'video/x-sgi-movie': './assets/images/ft_ic_video.svg',
            'video/x-matroska': './assets/images/ft_ic_video.svg',
            'audio/mpeg': './assets/images/ft_ic_audio.svg',
            'audio/ogg': './assets/images/ft_ic_audio.svg',
            'audio/wav': './assets/images/ft_ic_audio.svg',
            'audio/basic': './assets/images/ft_ic_audio.svg',
            'audio/mp4': './assets/images/ft_ic_audio.svg',
            'audio/vnd.adobe.soundbooth': './assets/images/ft_ic_audio.svg',
            'audio/vorbis': './assets/images/ft_ic_audio.svg',
            'audio/x-aiff': './assets/images/ft_ic_audio.svg',
            'audio/x-flac': './assets/images/ft_ic_audio.svg',
            'audio/x-ms-wma': './assets/images/ft_ic_audio.svg',
            'audio/x-wav': './assets/images/ft_ic_audio.svg',
            'x-world/x-vrml': './assets/images/ft_ic_video.svg',
            'text/plain': './assets/images/ft_ic_document.svg',
            'application/vnd.oasis.opendocument.text': './assets/images/ft_ic_document.svg',
            'application/vnd.oasis.opendocument.text-template': './assets/images/ft_ic_document.svg',
            'application/x-javascript': './assets/images/ft_ic_document.svg',
            'application/json': './assets/images/ft_ic_document.svg',
            'text/csv': './assets/images/ft_ic_document.svg',
            'text/xml': './assets/images/ft_ic_document.svg',
            'text/html': './assets/images/ft_ic_website.svg',
            'application/x-compressed': './assets/images/ft_ic_archive.svg',
            'application/x-zip-compressed': './assets/images/ft_ic_archive.svg',
            'application/zip': './assets/images/ft_ic_archive.svg',
            'application/x-tar': './assets/images/ft_ic_archive.svg',
            'application/vnd.apple.keynote': './assets/images/ft_ic_presentation.svg',
            'application/vnd.apple.pages': './assets/images/ft_ic_document.svg',
            'application/vnd.apple.numbers': './assets/images/ft_ic_spreadsheet.svg',
            'application/vnd.visio': './assets/images/ft_ic_document.svg',
            'application/wordperfect': './assets/images/ft_ic_document.svg',
            'application/x-cpio': './assets/images/ft_ic_document.svg',
            'folder': './assets/images/ft_ic_folder.svg',
            'smartFolder': './assets/images/ft_ic_smart_folder.svg',
            'ruleFolder': './assets/images/ft_ic_folder_rule.svg',
            'linkFolder': './assets/images/ft_ic_folder_shortcut_link.svg',
            'disable/folder': './assets/images/ft_ic_folder_disable.svg',
            'selected': './assets/images/ft_ic_selected.svg'
        };
        Object.keys(this.mimeTypeIcons).forEach((/**
         * @param {?} key
         * @return {?}
         */
        (key) => {
            /** @type {?} */
            const url = sanitizer.bypassSecurityTrustResourceUrl(this.mimeTypeIcons[key]);
            matIconRegistry.addSvgIcon(key, url);
            matIconRegistry.addSvgIconInNamespace('adf', key, url);
        }));
    }
    /**
     * Gets a thumbnail URL for the given document node.
     * @param {?} node Node to get URL for.
     * @return {?} URL string
     */
    getDocumentThumbnailUrl(node) {
        /** @type {?} */
        const thumbnail = this.contentService.getDocumentThumbnailUrl(node);
        return thumbnail || this.DEFAULT_ICON;
    }
    /**
     * Gets a thumbnail URL for a MIME type.
     * @param {?} mimeType MIME type for the thumbnail
     * @return {?} URL string
     */
    getMimeTypeIcon(mimeType) {
        /** @type {?} */
        const icon = this.mimeTypeIcons[mimeType];
        return (icon || this.DEFAULT_ICON);
    }
    /**
     * Gets a "miscellaneous" thumbnail URL for types with no other icon defined.
     * @return {?} URL string
     */
    getDefaultMimeTypeIcon() {
        return this.DEFAULT_ICON;
    }
}
ThumbnailService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ThumbnailService.ctorParameters = () => [
    { type: ContentService },
    { type: MatIconRegistry },
    { type: DomSanitizer }
];
/** @nocollapse */ ThumbnailService.ngInjectableDef = defineInjectable({ factory: function ThumbnailService_Factory() { return new ThumbnailService(inject(ContentService), inject(MatIconRegistry$1), inject(DomSanitizer)); }, token: ThumbnailService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MimeTypeIconPipe {
    /**
     * @param {?} thumbnailService
     */
    constructor(thumbnailService) {
        this.thumbnailService = thumbnailService;
    }
    /**
     * @param {?} text
     * @return {?}
     */
    transform(text) {
        return this.thumbnailService.getMimeTypeIcon(text);
    }
}
MimeTypeIconPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfMimeTypeIcon'
            },] }
];
/** @nocollapse */
MimeTypeIconPipe.ctorParameters = () => [
    { type: ThumbnailService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodeNameTooltipPipe {
    /**
     * @param {?} node
     * @return {?}
     */
    transform(node) {
        if (node) {
            return this.getNodeTooltip(node);
        }
        return null;
    }
    /**
     * @private
     * @param {?} lines
     * @param {?} line
     * @return {?}
     */
    containsLine(lines, line) {
        return lines.some((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            return item.toLowerCase() === line.toLowerCase();
        }));
    }
    /**
     * @private
     * @param {?} lines
     * @return {?}
     */
    removeDuplicateLines(lines) {
        /** @type {?} */
        const reducer = (/**
         * @param {?} acc
         * @param {?} line
         * @return {?}
         */
        (acc, line) => {
            if (!this.containsLine(acc, line)) {
                acc.push(line);
            }
            return acc;
        });
        return lines.reduce(reducer, []);
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getNodeTooltip(node) {
        if (!node || !node.entry) {
            return null;
        }
        const { entry: { properties, name } } = node;
        /** @type {?} */
        const lines = [name];
        if (properties) {
            const { 'cm:title': title, 'cm:description': description } = properties;
            if (title && description) {
                lines[0] = title;
                lines[1] = description;
            }
            if (title) {
                lines[1] = title;
            }
            if (description) {
                lines[1] = description;
            }
        }
        return this.removeDuplicateLines(lines).join(`\n`);
    }
}
NodeNameTooltipPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfNodeNameTooltip'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HighlightTransformService {
    /**
     * Searches for `search` string(s) within `text` and highlights all occurrences.
     * @param {?} text Text to search within
     * @param {?} search Text pattern to search for
     * @param {?=} wrapperClass CSS class used to provide highlighting style
     * @return {?} New text along with boolean value to indicate whether anything was highlighted
     */
    highlight(text, search, wrapperClass = 'adf-highlight') {
        /** @type {?} */
        let isMatching = false;
        /** @type {?} */
        let result = text;
        if (search && text) {
            /** @type {?} */
            let pattern = search.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            pattern = pattern.split(' ').filter((/**
             * @param {?} t
             * @return {?}
             */
            (t) => {
                return t.length > 0;
            })).join('|');
            /** @type {?} */
            const regex = new RegExp(pattern, 'gi');
            result = text.replace(/<[^>]+>/g, '').replace(regex, (/**
             * @param {?} match
             * @return {?}
             */
            (match) => {
                isMatching = true;
                return `<span class="${wrapperClass}">${match}</span>`;
            }));
            return { text: result, changed: isMatching };
        }
        else {
            return { text: result, changed: isMatching };
        }
    }
}
HighlightTransformService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ HighlightTransformService.ngInjectableDef = defineInjectable({ factory: function HighlightTransformService_Factory() { return new HighlightTransformService(); }, token: HighlightTransformService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HighlightPipe {
    /**
     * @param {?} highlightTransformService
     */
    constructor(highlightTransformService) {
        this.highlightTransformService = highlightTransformService;
    }
    /**
     * @param {?} text
     * @param {?} search
     * @return {?}
     */
    transform(text, search) {
        /** @type {?} */
        const highlightTransformResult = this.highlightTransformService.highlight(text, search);
        return highlightTransformResult.text;
    }
}
HighlightPipe.decorators = [
    { type: Pipe, args: [{
                name: 'highlight'
            },] }
];
/** @nocollapse */
HighlightPipe.ctorParameters = () => [
    { type: HighlightTransformService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TimeAgoPipe {
    constructor() {
        this.defaultLocale = 'en-US';
    }
    /**
     * @param {?} value
     * @param {?=} locale
     * @return {?}
     */
    transform(value, locale) {
        if (value !== null && value !== undefined) {
            /** @type {?} */
            const actualLocale = locale ? locale : this.defaultLocale;
            /** @type {?} */
            const then = moment(value);
            /** @type {?} */
            const diff = moment().locale(actualLocale).diff(then, 'days');
            return diff > 7 ? then.locale(actualLocale).format('DD/MM/YYYY HH:mm') : then.locale(actualLocale).fromNow();
        }
        return '';
    }
}
TimeAgoPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfTimeAgo'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InitialUsernamePipe {
    /**
     * @param {?} sanitized
     */
    constructor(sanitized) {
        this.sanitized = sanitized;
    }
    /**
     * @param {?} user
     * @param {?=} className
     * @param {?=} delimiter
     * @return {?}
     */
    transform(user, className = '', delimiter = '') {
        /** @type {?} */
        let safeHtml = '';
        if (user) {
            /** @type {?} */
            const initialResult = this.getInitialUserName(user.firstName, user.lastName, delimiter);
            safeHtml = this.sanitized.bypassSecurityTrustHtml(`<div id="user-initials-image" class="${className}">${initialResult}</div>`);
        }
        return safeHtml;
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @param {?} delimiter
     * @return {?}
     */
    getInitialUserName(firstName, lastName, delimiter) {
        firstName = (firstName ? firstName[0] : '');
        lastName = (lastName ? lastName[0] : '');
        return firstName + delimiter + lastName;
    }
}
InitialUsernamePipe.decorators = [
    { type: Pipe, args: [{
                name: 'usernameInitials'
            },] }
];
/** @nocollapse */
InitialUsernamePipe.ctorParameters = () => [
    { type: DomSanitizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FullNamePipe {
    /**
     * @param {?} user
     * @return {?}
     */
    transform(user) {
        /** @type {?} */
        let fullName = '';
        if (user) {
            if (user.firstName) {
                fullName += user.firstName;
            }
            if (user.lastName) {
                fullName += fullName.length > 0 ? ' ' : '';
                fullName += user.lastName;
            }
        }
        return fullName;
    }
}
FullNamePipe.decorators = [
    { type: Pipe, args: [{ name: 'fullName' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormatSpacePipe {
    /**
     * @param {?} inputValue
     * @param {?=} replaceChar
     * @param {?=} lowerCase
     * @return {?}
     */
    transform(inputValue, replaceChar = '_', lowerCase = true) {
        /** @type {?} */
        let transformedString = '';
        if (inputValue) {
            transformedString = lowerCase ? inputValue.trim().split(' ').join(replaceChar).toLocaleLowerCase() :
                inputValue.trim().split(' ').join(replaceChar);
        }
        return transformedString;
    }
}
FormatSpacePipe.decorators = [
    { type: Pipe, args: [{
                name: 'formatSpace'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileTypePipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        if (value == null || value === undefined) {
            return '';
        }
        else {
            /** @type {?} */
            const fileInfo = value.substring(value.lastIndexOf('/') + 1).replace(/\.[a-z]+/, '');
            return fileInfo.split('_').pop();
        }
    }
}
FileTypePipe.decorators = [
    { type: Pipe, args: [{
                name: 'fileType',
                pure: true
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MultiValuePipe {
    /**
     * @param {?} values
     * @param {?=} valueSeparator
     * @return {?}
     */
    transform(values, valueSeparator = MultiValuePipe.DEFAULT_SEPARATOR) {
        if (values && values instanceof Array) {
            /** @type {?} */
            const valueList = values.map((/**
             * @param {?} value
             * @return {?}
             */
            (value) => value.trim()));
            return valueList.join(valueSeparator);
        }
        return (/** @type {?} */ (values));
    }
}
MultiValuePipe.DEFAULT_SEPARATOR = ', ';
MultiValuePipe.decorators = [
    { type: Pipe, args: [{ name: 'multiValue' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PipeModule {
}
PipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    FullNamePipe,
                    NodeNameTooltipPipe,
                    FormatSpacePipe,
                    FileTypePipe,
                    MultiValuePipe
                ],
                providers: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    NodeNameTooltipPipe,
                    FormatSpacePipe,
                    FileTypePipe,
                    MultiValuePipe
                ],
                exports: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    FullNamePipe,
                    NodeNameTooltipPipe,
                    FormatSpacePipe,
                    FileTypePipe,
                    MultiValuePipe
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HighlightDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} highlightTransformService
     */
    constructor(el, renderer, highlightTransformService) {
        this.el = el;
        this.renderer = renderer;
        this.highlightTransformService = highlightTransformService;
        /**
         * Class selector for highlightable elements.
         */
        this.selector = '';
        /**
         * Text to highlight.
         */
        this.search = '';
        /**
         * CSS class used to apply highlighting.
         */
        this.classToApply = 'adf-highlight';
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.highlight();
    }
    /**
     * @param {?=} search
     * @param {?=} selector
     * @param {?=} classToApply
     * @return {?}
     */
    highlight(search = this.search, selector = this.selector, classToApply = this.classToApply) {
        if (search && selector) {
            /** @type {?} */
            const elements = this.el.nativeElement.querySelectorAll(selector);
            elements.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                /** @type {?} */
                const highlightTransformResult = this.highlightTransformService.highlight(element.innerHTML, search, classToApply);
                if (highlightTransformResult.changed) {
                    this.renderer.setProperty(element, 'innerHTML', highlightTransformResult.text);
                }
            }));
        }
    }
}
HighlightDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-highlight]'
            },] }
];
/** @nocollapse */
HighlightDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HighlightTransformService }
];
HighlightDirective.propDecorators = {
    selector: [{ type: Input, args: ['adf-highlight-selector',] }],
    search: [{ type: Input, args: ['adf-highlight',] }],
    classToApply: [{ type: Input, args: ['adf-highlight-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LogoutDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} router
     * @param {?} auth
     */
    constructor(elementRef, renderer, router, auth) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.router = router;
        this.auth = auth;
        /**
         * URI to redirect to after logging out.
         */
        this.redirectUri = '/login';
        /**
         * Enable redirecting after logout
         */
        this.enableRedirect = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.elementRef.nativeElement) {
            this.renderer.listen(this.elementRef.nativeElement, 'click', (/**
             * @param {?} evt
             * @return {?}
             */
            (evt) => {
                evt.preventDefault();
                this.logout();
            }));
        }
    }
    /**
     * @return {?}
     */
    logout() {
        this.auth.logout().subscribe((/**
         * @return {?}
         */
        () => this.redirectToUri()), (/**
         * @return {?}
         */
        () => this.redirectToUri()));
    }
    /**
     * @return {?}
     */
    redirectToUri() {
        if (this.enableRedirect) {
            this.router.navigate([this.redirectUri]);
        }
    }
}
LogoutDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-logout]'
            },] }
];
/** @nocollapse */
LogoutDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Router },
    { type: AuthenticationService }
];
LogoutDirective.propDecorators = {
    redirectUri: [{ type: Input }],
    enableRedirect: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodeDeleteDirective {
    /**
     * @param {?} alfrescoApiService
     * @param {?} translation
     * @param {?} elementRef
     */
    constructor(alfrescoApiService, translation, elementRef) {
        this.alfrescoApiService = alfrescoApiService;
        this.translation = translation;
        this.elementRef = elementRef;
        /**
         * If true then the nodes are deleted immediately rather than being put in the trash
         */
        this.permanent = false;
        /**
         * Emitted when the nodes have been deleted.
         */
        this.delete = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onClick() {
        this.process(this.selection);
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (!this.selection || (this.selection && this.selection.length === 0)) {
            this.setDisableAttribute(true);
        }
        else {
            if (!this.elementRef.nativeElement.hasAttribute('adf-check-allowable-operation')) {
                this.setDisableAttribute(false);
            }
        }
    }
    /**
     * @private
     * @param {?} disable
     * @return {?}
     */
    setDisableAttribute(disable) {
        this.elementRef.nativeElement.disabled = disable;
    }
    /**
     * @private
     * @param {?} selection
     * @return {?}
     */
    process(selection) {
        if (selection && selection.length) {
            /** @type {?} */
            const batch = this.getDeleteNodesBatch(selection);
            forkJoin(...batch)
                .subscribe((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                /** @type {?} */
                const processedItems = this.processStatus(data);
                /** @type {?} */
                const message = this.getMessage(processedItems);
                this.delete.emit(message);
            }));
        }
    }
    /**
     * @private
     * @param {?} selection
     * @return {?}
     */
    getDeleteNodesBatch(selection) {
        return selection.map((/**
         * @param {?} node
         * @return {?}
         */
        (node) => this.deleteNode(node)));
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    deleteNode(node) {
        /** @type {?} */
        const id = ((/** @type {?} */ (node.entry))).nodeId || node.entry.id;
        /** @type {?} */
        let promise;
        if (node.entry.hasOwnProperty('archivedAt')) {
            promise = this.alfrescoApiService.nodesApi.purgeDeletedNode(id);
        }
        else {
            promise = this.alfrescoApiService.nodesApi.deleteNode(id, { permanent: this.permanent });
        }
        return from(promise).pipe(map((/**
         * @return {?}
         */
        () => ({
            entry: node.entry,
            status: 1
        }))), catchError((/**
         * @return {?}
         */
        () => of({
            entry: node.entry,
            status: 0
        }))));
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    processStatus(data) {
        /** @type {?} */
        const deleteStatus = {
            success: [],
            failed: [],
            /**
             * @return {?}
             */
            get someFailed() {
                return !!(this.failed.length);
            },
            /**
             * @return {?}
             */
            get someSucceeded() {
                return !!(this.success.length);
            },
            /**
             * @return {?}
             */
            get oneFailed() {
                return this.failed.length === 1;
            },
            /**
             * @return {?}
             */
            get oneSucceeded() {
                return this.success.length === 1;
            },
            /**
             * @return {?}
             */
            get allSucceeded() {
                return this.someSucceeded && !this.someFailed;
            },
            /**
             * @return {?}
             */
            get allFailed() {
                return this.someFailed && !this.someSucceeded;
            }
        };
        return data.reduce((/**
         * @param {?} acc
         * @param {?} next
         * @return {?}
         */
        (acc, next) => {
            if (next.status === 1) {
                acc.success.push(next);
            }
            else {
                acc.failed.push(next);
            }
            return acc;
        }), deleteStatus);
    }
    /**
     * @private
     * @param {?} status
     * @return {?}
     */
    getMessage(status) {
        if (status.allFailed && !status.oneFailed) {
            return this.translation.instant('CORE.DELETE_NODE.ERROR_PLURAL', { number: status.failed.length });
        }
        if (status.allSucceeded && !status.oneSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.PLURAL', { number: status.success.length });
        }
        if (status.someFailed && status.someSucceeded && !status.oneSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.PARTIAL_PLURAL', {
                success: status.success.length,
                failed: status.failed.length
            });
        }
        if (status.someFailed && status.oneSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.PARTIAL_SINGULAR', {
                success: status.success.length,
                failed: status.failed.length
            });
        }
        if (status.oneFailed && !status.someSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: status.failed[0].entry.name });
        }
        if (status.oneSucceeded && !status.someFailed) {
            return this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: status.success[0].entry.name });
        }
    }
}
NodeDeleteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-delete]'
            },] }
];
/** @nocollapse */
NodeDeleteDirective.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: TranslationService },
    { type: ElementRef }
];
NodeDeleteDirective.propDecorators = {
    selection: [{ type: Input, args: ['adf-delete',] }],
    permanent: [{ type: Input }],
    delete: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodeFavoriteDirective {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
        this.favorites = [];
        /**
         * Array of nodes to toggle as favorites.
         */
        this.selection = [];
        /**
         * Emitted when the favorite setting is complete.
         */
        this.toggle = new EventEmitter();
        /**
         * Emitted when the favorite setting fails.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onClick() {
        this.toggleFavorite();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!changes.selection.currentValue.length) {
            this.favorites = [];
            return;
        }
        this.markFavoritesNodes(changes.selection.currentValue);
    }
    /**
     * @return {?}
     */
    toggleFavorite() {
        if (!this.favorites.length) {
            return;
        }
        /** @type {?} */
        const every = this.favorites.every((/**
         * @param {?} selected
         * @return {?}
         */
        (selected) => selected.entry.isFavorite));
        if (every) {
            /** @type {?} */
            const batch = this.favorites.map((/**
             * @param {?} selected
             * @return {?}
             */
            (selected) => {
                // shared files have nodeId
                /** @type {?} */
                const id = ((/** @type {?} */ (selected))).entry.nodeId || selected.entry.id;
                return from(this.alfrescoApiService.favoritesApi.removeFavoriteSite('-me-', id));
            }));
            forkJoin(batch).subscribe((/**
             * @return {?}
             */
            () => {
                this.favorites.map((/**
                 * @param {?} selected
                 * @return {?}
                 */
                (selected) => selected.entry.isFavorite = false));
                this.toggle.emit();
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => this.error.emit(error)));
        }
        if (!every) {
            /** @type {?} */
            const notFavorite = this.favorites.filter((/**
             * @param {?} node
             * @return {?}
             */
            (node) => !node.entry.isFavorite));
            /** @type {?} */
            const body = notFavorite.map((/**
             * @param {?} node
             * @return {?}
             */
            (node) => this.createFavoriteBody(node)));
            from(this.alfrescoApiService.favoritesApi.addFavorite('-me-', (/** @type {?} */ (body))))
                .subscribe((/**
             * @return {?}
             */
            () => {
                notFavorite.map((/**
                 * @param {?} selected
                 * @return {?}
                 */
                (selected) => selected.entry.isFavorite = true));
                this.toggle.emit();
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => this.error.emit(error)));
        }
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    markFavoritesNodes(selection) {
        if (selection.length <= this.favorites.length) {
            /** @type {?} */
            const newFavorites = this.reduce(this.favorites, selection);
            this.favorites = newFavorites;
        }
        /** @type {?} */
        const result = this.diff(selection, this.favorites);
        /** @type {?} */
        const batch = this.getProcessBatch(result);
        forkJoin(batch).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            this.favorites.push(...data);
        }));
    }
    /**
     * @return {?}
     */
    hasFavorites() {
        if (this.favorites && !this.favorites.length) {
            return false;
        }
        return this.favorites.every((/**
         * @param {?} selected
         * @return {?}
         */
        (selected) => selected.entry.isFavorite));
    }
    /**
     * @private
     * @param {?} selection
     * @return {?}
     */
    getProcessBatch(selection) {
        return selection.map((/**
         * @param {?} selected
         * @return {?}
         */
        (selected) => this.getFavorite(selected)));
    }
    /**
     * @private
     * @param {?} selected
     * @return {?}
     */
    getFavorite(selected) {
        /** @type {?} */
        const node = selected.entry;
        // ACS 6.x with 'isFavorite' include
        if (node && node.hasOwnProperty('isFavorite')) {
            return of(selected);
        }
        // ACS 5.x and 6.x without 'isFavorite' include
        const { name, isFile, isFolder } = (/** @type {?} */ (node));
        /** @type {?} */
        const id = ((/** @type {?} */ (node))).nodeId || node.id;
        /** @type {?} */
        const promise = this.alfrescoApiService.favoritesApi.getFavorite('-me-', id);
        return from(promise).pipe(map((/**
         * @return {?}
         */
        () => ({
            entry: {
                id,
                isFolder,
                isFile,
                name,
                isFavorite: true
            }
        }))), catchError((/**
         * @return {?}
         */
        () => {
            return of({
                entry: {
                    id,
                    isFolder,
                    isFile,
                    name,
                    isFavorite: false
                }
            });
        })));
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    createFavoriteBody(node) {
        /** @type {?} */
        const type = this.getNodeType(node);
        // shared files have nodeId
        /** @type {?} */
        const id = node.entry.nodeId || node.entry.id;
        return {
            target: {
                [type]: {
                    guid: id
                }
            }
        };
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getNodeType(node) {
        // shared could only be files
        if (!node.entry.isFile && !node.entry.isFolder) {
            return 'file';
        }
        return node.entry.isFile ? 'file' : 'folder';
    }
    /**
     * @private
     * @param {?} list
     * @param {?} patch
     * @return {?}
     */
    diff(list, patch) {
        /** @type {?} */
        const ids = patch.map((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.entry.id));
        return list.filter((/**
         * @param {?} item
         * @return {?}
         */
        (item) => ids.includes(item.entry.id) ? null : item));
    }
    /**
     * @private
     * @param {?} patch
     * @param {?} comparator
     * @return {?}
     */
    reduce(patch, comparator) {
        /** @type {?} */
        const ids = comparator.map((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.entry.id));
        return patch.filter((/**
         * @param {?} item
         * @return {?}
         */
        (item) => ids.includes(item.entry.id) ? item : null));
    }
}
NodeFavoriteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-favorite]',
                exportAs: 'adfFavorite'
            },] }
];
/** @nocollapse */
NodeFavoriteDirective.ctorParameters = () => [
    { type: AlfrescoApiService }
];
NodeFavoriteDirective.propDecorators = {
    selection: [{ type: Input, args: ['adf-node-favorite',] }],
    toggle: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const EXTENDIBLE_COMPONENT = new InjectionToken('extendible.component');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckAllowableOperationDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} contentService
     * @param {?} changeDetector
     * @param {?=} parentComponent
     */
    constructor(elementRef, renderer, contentService, changeDetector, parentComponent) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.contentService = contentService;
        this.changeDetector = changeDetector;
        this.parentComponent = parentComponent;
        /**
         * Node permission to check (create, delete, update, updatePermissions,
         * !create, !delete, !update, !updatePermissions).
         */
        this.permission = null;
        /**
         * Nodes to check permission for.
         */
        this.nodes = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.nodes && !changes.nodes.firstChange) {
            this.updateElement();
        }
    }
    /**
     * Updates disabled state for the decorated element
     *
     * \@memberof CheckAllowableOperationDirective
     * @return {?}
     */
    updateElement() {
        /** @type {?} */
        const enable = this.hasAllowableOperations(this.nodes, this.permission);
        if (enable) {
            this.enable();
        }
        else {
            this.disable();
        }
        return enable;
    }
    /**
     * @private
     * @return {?}
     */
    enable() {
        if (this.parentComponent) {
            this.parentComponent.disabled = false;
            this.changeDetector.detectChanges();
        }
        else {
            this.enableElement();
        }
    }
    /**
     * @private
     * @return {?}
     */
    disable() {
        if (this.parentComponent) {
            this.parentComponent.disabled = true;
            this.changeDetector.detectChanges();
        }
        else {
            this.disableElement();
        }
    }
    /**
     * Enables decorated element
     *
     * \@memberof CheckAllowableOperationDirective
     * @return {?}
     */
    enableElement() {
        this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');
    }
    /**
     * Disables decorated element
     *
     * \@memberof CheckAllowableOperationDirective
     * @return {?}
     */
    disableElement() {
        this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true');
    }
    /**
     * Checks whether all nodes have a particular permission
     *
     * \@memberof CheckAllowableOperationDirective
     * @param {?} nodes Node collection to check
     * @param {?} permission Permission to check for each node
     * @return {?}
     */
    hasAllowableOperations(nodes, permission) {
        if (nodes && nodes.length > 0) {
            return nodes.every((/**
             * @param {?} node
             * @return {?}
             */
            (node) => this.contentService.hasAllowableOperations(node.entry, permission)));
        }
        return false;
    }
}
CheckAllowableOperationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-check-allowable-operation]'
            },] }
];
/** @nocollapse */
CheckAllowableOperationDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ContentService },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Host }, { type: Optional }, { type: Inject, args: [EXTENDIBLE_COMPONENT,] }] }
];
CheckAllowableOperationDirective.propDecorators = {
    permission: [{ type: Input, args: ['adf-check-allowable-operation',] }],
    nodes: [{ type: Input, args: ['adf-nodes',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RestoreMessageModel {
}
class NodeRestoreDirective {
    /**
     * @param {?} alfrescoApiService
     * @param {?} translation
     */
    constructor(alfrescoApiService, translation) {
        this.alfrescoApiService = alfrescoApiService;
        this.translation = translation;
        /**
         * Emitted when restoration is complete.
         */
        this.restore = new EventEmitter();
        this.restoreProcessStatus = this.processStatus();
    }
    /**
     * @return {?}
     */
    onClick() {
        this.recover(this.selection);
    }
    /**
     * @private
     * @param {?} selection
     * @return {?}
     */
    recover(selection) {
        if (!selection.length) {
            return;
        }
        /** @type {?} */
        const nodesWithPath = this.getNodesWithPath(selection);
        if (selection.length && nodesWithPath.length) {
            this.restoreNodesBatch(nodesWithPath).pipe(tap((/**
             * @param {?} restoredNodes
             * @return {?}
             */
            (restoredNodes) => {
                /** @type {?} */
                const status = this.processStatus(restoredNodes);
                this.restoreProcessStatus.fail.push(...status.fail);
                this.restoreProcessStatus.success.push(...status.success);
            })), mergeMap((/**
             * @return {?}
             */
            () => this.getDeletedNodes())))
                .subscribe((/**
             * @param {?} deletedNodesList
             * @return {?}
             */
            (deletedNodesList) => {
                const { entries: nodeList } = deletedNodesList.list;
                const { fail: restoreErrorNodes } = this.restoreProcessStatus;
                /** @type {?} */
                const selectedNodes = this.diff(restoreErrorNodes, selection, false);
                /** @type {?} */
                const remainingNodes = this.diff(selectedNodes, nodeList);
                if (!remainingNodes.length) {
                    this.notification();
                }
                else {
                    this.recover(remainingNodes);
                }
            }));
        }
        else {
            this.restoreProcessStatus.fail.push(...selection);
            this.notification();
            return;
        }
    }
    /**
     * @private
     * @param {?} batch
     * @return {?}
     */
    restoreNodesBatch(batch) {
        return forkJoin(batch.map((/**
         * @param {?} node
         * @return {?}
         */
        (node) => this.restoreNode(node))));
    }
    /**
     * @private
     * @param {?} selection
     * @return {?}
     */
    getNodesWithPath(selection) {
        return selection.filter((/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.entry.path));
    }
    /**
     * @private
     * @return {?}
     */
    getDeletedNodes() {
        /** @type {?} */
        const promise = this.alfrescoApiService.getInstance()
            .core.nodesApi.getDeletedNodes({ include: ['path'] });
        return from(promise);
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    restoreNode(node) {
        const { entry } = node;
        /** @type {?} */
        const promise = this.alfrescoApiService.getInstance().nodes.restoreNode(entry.id);
        return from(promise).pipe(map((/**
         * @return {?}
         */
        () => ({
            status: 1,
            entry
        }))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            const { statusCode } = (JSON.parse(error.message)).error;
            return of({
                status: 0,
                statusCode,
                entry
            });
        })));
    }
    /**
     * @private
     * @param {?} selection
     * @param {?} list
     * @param {?=} fromList
     * @return {?}
     */
    diff(selection, list, fromList = true) {
        /** @type {?} */
        const ids = selection.map((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.entry.id));
        return list.filter((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (fromList) {
                return ids.includes(item.entry.id) ? item : null;
            }
            else {
                return !ids.includes(item.entry.id) ? item : null;
            }
        }));
    }
    /**
     * @private
     * @param {?=} data
     * @return {?}
     */
    processStatus(data = []) {
        /** @type {?} */
        const status = {
            fail: [],
            success: [],
            /**
             * @return {?}
             */
            get someFailed() {
                return !!(this.fail.length);
            },
            /**
             * @return {?}
             */
            get someSucceeded() {
                return !!(this.success.length);
            },
            /**
             * @return {?}
             */
            get oneFailed() {
                return this.fail.length === 1;
            },
            /**
             * @return {?}
             */
            get oneSucceeded() {
                return this.success.length === 1;
            },
            /**
             * @return {?}
             */
            get allSucceeded() {
                return this.someSucceeded && !this.someFailed;
            },
            /**
             * @return {?}
             */
            get allFailed() {
                return this.someFailed && !this.someSucceeded;
            },
            /**
             * @return {?}
             */
            reset() {
                this.fail = [];
                this.success = [];
            }
        };
        return data.reduce((/**
         * @param {?} acc
         * @param {?} node
         * @return {?}
         */
        (acc, node) => {
            if (node.status) {
                acc.success.push(node);
            }
            else {
                acc.fail.push(node);
            }
            return acc;
        }), status);
    }
    /**
     * @private
     * @return {?}
     */
    getRestoreMessage() {
        const { restoreProcessStatus: status } = this;
        if (status.someFailed && !status.oneFailed) {
            return this.translation.instant('CORE.RESTORE_NODE.PARTIAL_PLURAL', {
                number: status.fail.length
            });
        }
        if (status.oneFailed && status.fail[0].statusCode) {
            if (status.fail[0].statusCode === 409) {
                return this.translation.instant('CORE.RESTORE_NODE.NODE_EXISTS', {
                    name: status.fail[0].entry.name
                });
            }
            else {
                return this.translation.instant('CORE.RESTORE_NODE.GENERIC', {
                    name: status.fail[0].entry.name
                });
            }
        }
        if (status.oneFailed && !status.fail[0].statusCode) {
            return this.translation.instant('CORE.RESTORE_NODE.LOCATION_MISSING', {
                name: status.fail[0].entry.name
            });
        }
        if (status.allSucceeded && !status.oneSucceeded) {
            return this.translation.instant('CORE.RESTORE_NODE.PLURAL');
        }
        if (status.allSucceeded && status.oneSucceeded) {
            return this.translation.instant('CORE.RESTORE_NODE.SINGULAR', {
                name: status.success[0].entry.name
            });
        }
    }
    /**
     * @private
     * @return {?}
     */
    notification() {
        /** @type {?} */
        const status = Object.assign({}, this.restoreProcessStatus);
        /** @type {?} */
        const message = this.getRestoreMessage();
        this.reset();
        /** @type {?} */
        const action = (status.oneSucceeded && !status.someFailed) ? this.translation.instant('CORE.RESTORE_NODE.VIEW') : '';
        /** @type {?} */
        let path;
        if (status.success && status.success.length > 0) {
            path = status.success[0].entry.path;
        }
        this.restore.emit({
            message: message,
            action: action,
            path: path
        });
    }
    /**
     * @private
     * @return {?}
     */
    reset() {
        this.restoreProcessStatus.reset();
        this.selection = [];
    }
}
NodeRestoreDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-restore]'
            },] }
];
/** @nocollapse */
NodeRestoreDirective.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: TranslationService }
];
NodeRestoreDirective.propDecorators = {
    selection: [{ type: Input, args: ['adf-restore',] }],
    restore: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UploadDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} ngZone
     */
    constructor(el, renderer, ngZone) {
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Enables/disables uploading.
         */
        this.enabled = true;
        /**
         * Upload mode. Can be "drop" (receives dropped files) or "click"
         * (clicking opens a file dialog). Both modes can be active at once.
         */
        this.mode = ['drop']; // click|drop
        this.isDragging = false;
        this.cssClassName = 'adf-upload__dragging';
        this.element = el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isClickMode() && this.renderer) {
            /** @type {?} */
            const inputUpload = this.renderer.createElement('input');
            this.upload = this.el.nativeElement.parentElement.appendChild(inputUpload);
            this.upload.type = 'file';
            this.upload.style.display = 'none';
            this.upload.addEventListener('change', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.onSelectFiles(event)));
            if (this.multiple) {
                this.upload.setAttribute('multiple', '');
            }
            if (this.accept) {
                this.upload.setAttribute('accept', this.accept);
            }
            if (this.directory) {
                this.upload.setAttribute('webkitdirectory', '');
            }
        }
        if (this.isDropMode()) {
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
                this.element.addEventListener('dragover', this.onDragOver.bind(this));
                this.element.addEventListener('dragleave', this.onDragLeave.bind(this));
                this.element.addEventListener('drop', this.onDrop.bind(this));
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDrop);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.isClickMode() && this.upload) {
            event.preventDefault();
            this.upload.click();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragEnter(event) {
        if (this.isDropMode()) {
            this.element.classList.add(this.cssClassName);
            this.isDragging = true;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        event.preventDefault();
        if (this.isDropMode()) {
            this.element.classList.add(this.cssClassName);
            this.isDragging = true;
        }
        return false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragLeave(event) {
        if (this.isDropMode()) {
            this.element.classList.remove(this.cssClassName);
            this.isDragging = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDrop(event) {
        if (this.isDropMode()) {
            event.stopPropagation();
            event.preventDefault();
            this.element.classList.remove(this.cssClassName);
            this.isDragging = false;
            /** @type {?} */
            const dataTransfer = this.getDataTransfer(event);
            if (dataTransfer) {
                this.getFilesDropped(dataTransfer).then((/**
                 * @param {?} files
                 * @return {?}
                 */
                (files) => {
                    this.onUploadFiles(files);
                }));
            }
        }
        return false;
    }
    /**
     * @param {?} files
     * @return {?}
     */
    onUploadFiles(files) {
        if (this.enabled && files.length > 0) {
            /** @type {?} */
            const customEvent = new CustomEvent('upload-files', {
                detail: {
                    sender: this,
                    data: this.data,
                    files: files
                },
                bubbles: true
            });
            this.el.nativeElement.dispatchEvent(customEvent);
        }
    }
    /**
     * @protected
     * @param {?} mode
     * @return {?}
     */
    hasMode(mode) {
        return this.enabled && mode && this.mode && this.mode.indexOf(mode) > -1;
    }
    /**
     * @protected
     * @return {?}
     */
    isDropMode() {
        return this.hasMode('drop');
    }
    /**
     * @protected
     * @return {?}
     */
    isClickMode() {
        return this.hasMode('click');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getDataTransfer(event) {
        if (event && event.dataTransfer) {
            return event.dataTransfer;
        }
        if (event && event.originalEvent && event.originalEvent.dataTransfer) {
            return event.originalEvent.dataTransfer;
        }
        return null;
    }
    /**
     * Extract files from the DataTransfer object used to hold the data that is being dragged during a drag and drop operation.
     * @param {?} dataTransfer DataTransfer object
     * @return {?}
     */
    getFilesDropped(dataTransfer) {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => {
            /** @type {?} */
            const iterations = [];
            if (dataTransfer) {
                /** @type {?} */
                const items = dataTransfer.items;
                if (items) {
                    for (let i = 0; i < items.length; i++) {
                        if (typeof items[i].webkitGetAsEntry !== 'undefined') {
                            /** @type {?} */
                            const item = items[i].webkitGetAsEntry();
                            if (item) {
                                if (item.isFile) {
                                    iterations.push(Promise.resolve((/** @type {?} */ ({
                                        entry: item,
                                        file: items[i].getAsFile(),
                                        relativeFolder: '/'
                                    }))));
                                }
                                else if (item.isDirectory) {
                                    iterations.push(new Promise((/**
                                     * @param {?} resolveFolder
                                     * @return {?}
                                     */
                                    (resolveFolder) => {
                                        FileUtils.flatten(item).then((/**
                                         * @param {?} files
                                         * @return {?}
                                         */
                                        (files) => resolveFolder(files)));
                                    })));
                                }
                            }
                        }
                        else {
                            iterations.push(Promise.resolve((/** @type {?} */ ({
                                entry: null,
                                file: items[i].getAsFile(),
                                relativeFolder: '/'
                            }))));
                        }
                    }
                }
                else {
                    // safari or FF
                    /** @type {?} */
                    const files = FileUtils
                        .toFileArray(dataTransfer.files)
                        .map((/**
                     * @param {?} file
                     * @return {?}
                     */
                    (file) => (/** @type {?} */ ({
                        entry: null,
                        file: file,
                        relativeFolder: '/'
                    }))));
                    iterations.push(Promise.resolve(files));
                }
            }
            Promise.all(iterations).then((/**
             * @param {?} result
             * @return {?}
             */
            (result) => {
                resolve(result.reduce((/**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */
                (a, b) => a.concat(b)), []));
            }));
        }));
    }
    /**
     * Invoked when user selects files or folders by means of File Dialog
     * @param {?} event DOM event
     * @return {?}
     */
    onSelectFiles(event) {
        if (this.isClickMode()) {
            /** @type {?} */
            const input = ((/** @type {?} */ (event.currentTarget)));
            /** @type {?} */
            const files = FileUtils.toFileArray(input.files);
            this.onUploadFiles(files.map((/**
             * @param {?} file
             * @return {?}
             */
            (file) => (/** @type {?} */ ({
                entry: null,
                file: file,
                relativeFolder: '/'
            })))));
            event.target.value = '';
        }
    }
}
UploadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-upload]'
            },] }
];
/** @nocollapse */
UploadDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
UploadDirective.propDecorators = {
    enabled: [{ type: Input, args: ['adf-upload',] }],
    data: [{ type: Input, args: ['adf-upload-data',] }],
    mode: [{ type: Input }],
    multiple: [{ type: Input }],
    accept: [{ type: Input }],
    directory: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DownloadZipService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Creates a new download.
     * @param {?} payload Object containing the node IDs of the items to add to the ZIP file
     * @return {?} Status object for the download
     */
    createDownload(payload) {
        return from(this.apiService.getInstance().core.downloadsApi.createDownload(payload)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a content URL for the given node.
     * @param {?} nodeId Node to get URL for.
     * @param {?=} attachment Toggles whether to retrieve content as an attachment for download
     * @return {?} URL string
     */
    getContentUrl(nodeId, attachment) {
        return this.apiService.getInstance().content.getContentUrl(nodeId, attachment);
    }
    /**
     * Gets a Node via its node ID.
     * @param {?} nodeId ID of the target node
     * @return {?} Details of the node
     */
    getNode(nodeId) {
        return from(this.apiService.getInstance().core.nodesApi.getNode(nodeId));
    }
    /**
     * Gets status information for a download node.
     * @param {?} downloadId ID of the download node
     * @return {?} Status object for the download
     */
    getDownload(downloadId) {
        return from(this.apiService.getInstance().core.downloadsApi.getDownload(downloadId));
    }
    /**
     * Cancels a download.
     * @param {?} downloadId ID of the target download node
     * @return {?}
     */
    cancelDownload(downloadId) {
        this.apiService.getInstance().core.downloadsApi.cancelDownload(downloadId);
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
DownloadZipService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DownloadZipService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ DownloadZipService.ngInjectableDef = defineInjectable({ factory: function DownloadZipService_Factory() { return new DownloadZipService(inject(AlfrescoApiService), inject(LogService)); }, token: DownloadZipService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DownloadZipDialogComponent {
    /**
     * @param {?} dialogRef
     * @param {?} data
     * @param {?} logService
     * @param {?} downloadZipService
     */
    constructor(dialogRef, data, logService, downloadZipService) {
        this.dialogRef = dialogRef;
        this.data = data;
        this.logService = logService;
        this.downloadZipService = downloadZipService;
        // flag for async threads
        this.cancelled = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.data && this.data.nodeIds && this.data.nodeIds.length > 0) {
            if (!this.cancelled) {
                this.downloadZip(this.data.nodeIds);
            }
            else {
                this.logService.log('Cancelled');
            }
        }
    }
    /**
     * @return {?}
     */
    cancelDownload() {
        this.cancelled = true;
        this.downloadZipService.cancelDownload(this.downloadId);
        this.dialogRef.close(false);
    }
    /**
     * @param {?} nodeIds
     * @return {?}
     */
    downloadZip(nodeIds) {
        if (nodeIds && nodeIds.length > 0) {
            this.downloadZipService.createDownload({ nodeIds }).subscribe((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                if (data && data.entry && data.entry.id) {
                    /** @type {?} */
                    const url = this.downloadZipService.getContentUrl(data.entry.id, true);
                    this.downloadZipService.getNode(data.entry.id).subscribe((/**
                     * @param {?} downloadNode
                     * @return {?}
                     */
                    (downloadNode) => {
                        this.logService.log(downloadNode);
                        /** @type {?} */
                        const fileName = downloadNode.entry.name;
                        this.downloadId = data.entry.id;
                        this.waitAndDownload(data.entry.id, url, fileName);
                    }));
                }
            }));
        }
    }
    /**
     * @param {?} downloadId
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    waitAndDownload(downloadId, url, fileName) {
        if (this.cancelled) {
            return;
        }
        this.downloadZipService.getDownload(downloadId).subscribe((/**
         * @param {?} downloadEntry
         * @return {?}
         */
        (downloadEntry) => {
            if (downloadEntry.entry) {
                if (downloadEntry.entry.status === 'DONE') {
                    this.download(url, fileName);
                }
                else {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        this.waitAndDownload(downloadId, url, fileName);
                    }), 1000);
                }
            }
        }));
    }
    /**
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    download(url, fileName) {
        if (url && fileName) {
            /** @type {?} */
            const link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        this.dialogRef.close(true);
    }
}
DownloadZipDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-download-zip-dialog',
                template: "<h1 matDialogTitle>{{ 'CORE.DIALOG.DOWNLOAD_ZIP.TITLE' | translate }}</h1>\n<div mat-dialog-content>\n    <mat-progress-bar color=\"primary\" mode=\"indeterminate\"></mat-progress-bar>\n</div>\n<div mat-dialog-actions>\n    <span class=\"adf-spacer\"></span>\n    <button mat-button color=\"primary\" id=\"cancel-button\" (click)=\"cancelDownload()\">\n        {{ 'CORE.DIALOG.DOWNLOAD_ZIP.ACTIONS.CANCEL' | translate }}\n    </button>\n</div>\n",
                host: { 'class': 'adf-download-zip-dialog' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-spacer{flex:1 1 auto}.adf-download-zip-dialog .mat-dialog-actions .mat-button-wrapper{text-transform:uppercase}"]
            }] }
];
/** @nocollapse */
DownloadZipDialogComponent.ctorParameters = () => [
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: LogService },
    { type: DownloadZipService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class NodeDownloadDirective {
    /**
     * @param {?} apiService
     * @param {?} dialog
     */
    constructor(apiService, dialog) {
        this.apiService = apiService;
        this.dialog = dialog;
    }
    /**
     * @return {?}
     */
    onClick() {
        this.downloadNodes(this.nodes);
    }
    /**
     * Downloads multiple selected nodes.
     * Packs result into a .ZIP archive if there is more than one node selected.
     * @param {?} selection Multiple selected nodes to download
     * @return {?}
     */
    downloadNodes(selection) {
        if (!this.isSelectionValid(selection)) {
            return;
        }
        if (selection instanceof Array) {
            if (selection.length === 1) {
                this.downloadNode(selection[0]);
            }
            else {
                this.downloadZip(selection);
            }
        }
        else {
            this.downloadNode(selection);
        }
    }
    /**
     * Downloads a single node.
     * Packs result into a .ZIP archive is the node is a Folder.
     * @param {?} node Node to download
     * @return {?}
     */
    downloadNode(node) {
        if (node && node.entry) {
            /** @type {?} */
            const entry = node.entry;
            if (entry.isFile) {
                this.downloadFile(node);
            }
            if (entry.isFolder) {
                this.downloadZip([node]);
            }
            // Check if there's nodeId for Shared Files
            if (!entry.isFile && !entry.isFolder && ((/** @type {?} */ (entry))).nodeId) {
                this.downloadFile(node);
            }
        }
    }
    /**
     * @private
     * @param {?} selection
     * @return {?}
     */
    isSelectionValid(selection) {
        return selection || (selection instanceof Array && selection.length > 0);
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    downloadFile(node) {
        if (node && node.entry) {
            /** @type {?} */
            const contentApi = this.apiService.getInstance().content;
            // nodeId for Shared node
            /** @type {?} */
            const id = ((/** @type {?} */ (node.entry))).nodeId || node.entry.id;
            /** @type {?} */
            const url = contentApi.getContentUrl(id, true);
            /** @type {?} */
            const fileName = node.entry.name;
            this.download(url, fileName);
        }
    }
    /**
     * @private
     * @param {?} selection
     * @return {?}
     */
    downloadZip(selection) {
        if (selection && selection.length > 0) {
            // nodeId for Shared node
            /** @type {?} */
            const nodeIds = selection.map((/**
             * @param {?} node
             * @return {?}
             */
            (node) => (node.entry.nodeId || node.entry.id)));
            this.dialog.open(DownloadZipDialogComponent, {
                width: '600px',
                disableClose: true,
                data: {
                    nodeIds
                }
            });
        }
    }
    /**
     * @private
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    download(url, fileName) {
        if (url && fileName) {
            /** @type {?} */
            const link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
}
NodeDownloadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-download], [adfNodeDownload]'
            },] }
];
/** @nocollapse */
NodeDownloadDirective.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: MatDialog }
];
NodeDownloadDirective.propDecorators = {
    nodes: [{ type: Input, args: ['adfNodeDownload',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DirectiveModule {
}
DirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    HighlightDirective,
                    LogoutDirective,
                    NodeDeleteDirective,
                    NodeFavoriteDirective,
                    CheckAllowableOperationDirective,
                    NodeRestoreDirective,
                    NodeDownloadDirective,
                    UploadDirective
                ],
                exports: [
                    HighlightDirective,
                    LogoutDirective,
                    NodeDeleteDirective,
                    NodeFavoriteDirective,
                    CheckAllowableOperationDirective,
                    NodeRestoreDirective,
                    NodeDownloadDirective,
                    UploadDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataTableCellComponent {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
        this.value$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateValue();
        this.sub = this.alfrescoApiService.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (this.row) {
                if (this.row['node'].entry.id === node.id) {
                    this.row['node'].entry = node;
                    this.row['cache'][this.column.key] = this.column.key.split('.').reduce((/**
                     * @param {?} source
                     * @param {?} key
                     * @return {?}
                     */
                    (source, key) => source[key]), node);
                    this.updateValue();
                }
            }
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    updateValue() {
        if (this.column && this.column.key && this.row && this.data) {
            /** @type {?} */
            const value = this.data.getValue(this.row, this.column);
            this.value$.next(value);
            if (!this.tooltip) {
                this.tooltip = value;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    }
}
DataTableCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <span *ngIf="copyContent; else defaultCell"
                adf-clipboard="CLIPBOARD.CLICK_TO_COPY"
                [clipboard-notification]="'CLIPBOARD.SUCCESS_COPY'"
                [attr.aria-label]="value$ | async"
                [title]="tooltip"
                class="adf-datatable-cell-value"
                >{{ value$ | async }}</span>
        </ng-container>
        <ng-template #defaultCell>
            <span
                [attr.aria-label]="value$ | async"
                [title]="tooltip"
                class="adf-datatable-cell-value"
            >{{ value$ | async }}</span>
        </ng-template>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable-content-cell' }
            }] }
];
/** @nocollapse */
DataTableCellComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];
DataTableCellComponent.propDecorators = {
    data: [{ type: Input }],
    column: [{ type: Input }],
    row: [{ type: Input }],
    copyContent: [{ type: Input }],
    tooltip: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataColumnComponent {
    constructor() {
        /**
         * Value type for the column. Possible settings are 'text', 'image',
         * 'date', 'fileSize', 'location', and 'json'.
         */
        this.type = 'text';
        /**
         * Toggles ability to sort by this column, for example by clicking the column header.
         */
        this.sortable = true;
        /**
         * Display title of the column, typically used for column headers. You can use the
         * i18n resource key to get it translated automatically.
         */
        this.title = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    }
}
DataColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-column',
                template: ''
            }] }
];
DataColumnComponent.propDecorators = {
    key: [{ type: Input }],
    type: [{ type: Input }],
    format: [{ type: Input }],
    sortable: [{ type: Input }],
    title: [{ type: Input }],
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    formatTooltip: [{ type: Input }],
    srTitle: [{ type: Input, args: ['sr-title',] }],
    cssClass: [{ type: Input, args: ['class',] }],
    copyContent: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataColumnListComponent {
}
DataColumnListComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-columns',
                template: ''
            }] }
];
DataColumnListComponent.propDecorators = {
    columns: [{ type: ContentChildren, args: [DataColumnComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Base cancellable event implementation
 * @template T
 */
class BaseEvent {
    constructor() {
        this.isDefaultPrevented = false;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this.isDefaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this.isDefaultPrevented = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Base container for any event which takes place in the DOM
 * @template T
 */
class BaseUIEvent extends BaseEvent {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileUploadOptions {
}
/** @enum {number} */
const FileUploadStatus = {
    Pending: 0,
    Complete: 1,
    Starting: 2,
    Progress: 3,
    Cancelled: 4,
    Aborted: 5,
    Error: 6,
    Deleted: 7,
};
FileUploadStatus[FileUploadStatus.Pending] = 'Pending';
FileUploadStatus[FileUploadStatus.Complete] = 'Complete';
FileUploadStatus[FileUploadStatus.Starting] = 'Starting';
FileUploadStatus[FileUploadStatus.Progress] = 'Progress';
FileUploadStatus[FileUploadStatus.Cancelled] = 'Cancelled';
FileUploadStatus[FileUploadStatus.Aborted] = 'Aborted';
FileUploadStatus[FileUploadStatus.Error] = 'Error';
FileUploadStatus[FileUploadStatus.Deleted] = 'Deleted';
class FileModel {
    /**
     * @param {?} file
     * @param {?=} options
     * @param {?=} id
     */
    constructor(file, options, id) {
        this.status = FileUploadStatus.Pending;
        this.file = file;
        this.id = id;
        this.name = file.name;
        this.size = file.size;
        this.data = null;
        this.errorCode = null;
        this.progress = {
            loaded: 0,
            total: 0,
            percent: 0
        };
        this.options = Object.assign({}, {
            newVersion: false
        }, options);
    }
    /**
     * @return {?}
     */
    get extension() {
        return this.name.slice((Math.max(0, this.name.lastIndexOf('.')) || Infinity) + 1);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileUploadEvent {
    /**
     * @param {?} file
     * @param {?=} status
     * @param {?=} error
     */
    constructor(file, status = FileUploadStatus.Pending, error = null) {
        this.file = file;
        this.status = status;
        this.error = error;
    }
}
class FileUploadCompleteEvent extends FileUploadEvent {
    /**
     * @param {?} file
     * @param {?=} totalComplete
     * @param {?=} data
     * @param {?=} totalAborted
     */
    constructor(file, totalComplete = 0, data, totalAborted = 0) {
        super(file, FileUploadStatus.Complete);
        this.totalComplete = totalComplete;
        this.data = data;
        this.totalAborted = totalAborted;
    }
}
class FileUploadDeleteEvent extends FileUploadEvent {
    /**
     * @param {?} file
     * @param {?=} totalComplete
     */
    constructor(file, totalComplete = 0) {
        super(file, FileUploadStatus.Deleted);
        this.totalComplete = totalComplete;
    }
}
class FileUploadErrorEvent extends FileUploadEvent {
    /**
     * @param {?} file
     * @param {?} error
     * @param {?=} totalError
     */
    constructor(file, error, totalError = 0) {
        super(file, FileUploadStatus.Error);
        this.error = error;
        this.totalError = totalError;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataRowEvent extends BaseUIEvent {
    /**
     * @param {?} value
     * @param {?} domEvent
     * @param {?=} sender
     */
    constructor(value, domEvent, sender) {
        super();
        this.value = value;
        this.event = domEvent;
        this.sender = sender;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataCellEventModel {
    /**
     * @param {?} row
     * @param {?} col
     * @param {?} actions
     */
    constructor(row, col, actions) {
        this.row = row;
        this.col = col;
        this.actions = actions || [];
    }
}
class DataCellEvent extends BaseEvent {
    /**
     * @param {?} row
     * @param {?} col
     * @param {?} actions
     */
    constructor(row, col, actions) {
        super();
        this.value = new DataCellEventModel(row, col, actions);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataRowActionModel {
    /**
     * @param {?} row
     * @param {?} action
     */
    constructor(row, action) {
        this.row = row;
        this.action = action;
    }
}
class DataRowActionEvent extends BaseEvent {
    // backwards compatibility with 1.2.0 and earlier
    /**
     * @return {?}
     */
    get args() {
        return this.value;
    }
    /**
     * @param {?} row
     * @param {?} action
     */
    constructor(row, action) {
        super();
        this.value = new DataRowActionModel(row, action);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const DisplayMode = {
    List: 'list',
    Gallery: 'gallery',
};
class DataTableComponent {
    /**
     * @param {?} elementRef
     * @param {?} differs
     */
    constructor(elementRef, differs) {
        this.elementRef = elementRef;
        /**
         * Selects the display mode of the table. Can be "list" or "gallery".
         */
        this.display = DisplayMode.List;
        /**
         * The rows that the datatable will show.
         */
        this.rows = [];
        /**
         * Define the sort order of the datatable. Possible values are :
         * [`created`, `desc`], [`created`, `asc`], [`due`, `desc`], [`due`, `asc`]
         */
        this.sorting = [];
        /**
         * The columns that the datatable will show.
         */
        this.columns = [];
        /**
         * Row selection mode. Can be none, `single` or `multiple`. For `multiple` mode,
         * you can use Cmd (macOS) or Ctrl (Win) modifier key to toggle selection for multiple rows.
         */
        this.selectionMode = 'single'; // none|single|multiple
        // none|single|multiple
        /**
         * Toggles multiple row selection, which renders checkboxes at the beginning of each row.
         */
        this.multiselect = false;
        /**
         * Toggles the data actions column.
         */
        this.actions = false;
        /**
         * Position of the actions dropdown menu. Can be "left" or "right".
         */
        this.actionsPosition = 'right'; // left|right
        /**
         * Toggles custom context menu for the component.
         */
        this.contextMenu = false;
        /**
         * Toggles file drop support for rows (see
         * [Upload directive](upload.directive.md) for further details).
         */
        this.allowDropFiles = false;
        /**
         * The CSS class to apply to every row.
         */
        this.rowStyleClass = '';
        /**
         * Toggles the header.
         */
        this.showHeader = true;
        /**
         * Toggles the sticky header mode.
         */
        this.stickyHeader = false;
        /**
         * Emitted when the user clicks a row.
         */
        this.rowClick = new EventEmitter();
        /**
         * Emitted when the user double-clicks a row.
         */
        this.rowDblClick = new EventEmitter();
        /**
         * Emitted before the context menu is displayed for a row.
         */
        this.showRowContextMenu = new EventEmitter();
        /**
         * Emitted before the actions menu is displayed for a row.
         */
        this.showRowActionsMenu = new EventEmitter();
        /**
         * Emitted when the user executes a row action.
         */
        this.executeRowAction = new EventEmitter();
        /**
         * Flag that indicates if the datatable is in loading state and needs to show the
         * loading template (see the docs to learn how to configure a loading template).
         */
        this.loading = false;
        /**
         * Flag that indicates if the datatable should show the "no permission" template.
         */
        this.noPermission = false;
        /**
         * Should the items for the row actions menu be cached for reuse after they are loaded
         * the first time?
         */
        this.rowMenuCacheEnabled = true;
        this.isSelectAllChecked = false;
        this.selection = new Array();
        /**
         * This array of fake rows fix the flex layout for the gallery view
         */
        this.fakeRows = [];
        this.rowMenuCache = {};
        this.subscriptions = [];
        if (differs) {
            this.differ = differs.find([]).create(null);
        }
        this.click$ = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => this.clickObserver = observer))
            .pipe(share());
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.columnList) {
            this.subscriptions.push(this.columnList.columns.changes.subscribe((/**
             * @return {?}
             */
            () => {
                this.setTableSchema();
            })));
        }
        this.datatableLayoutFix();
        this.setTableSchema();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.initAndSubscribeClickStream();
        if (this.isPropertyChanged(changes['data'])) {
            if (this.isTableEmpty()) {
                this.initTable();
            }
            else {
                this.data = changes['data'].currentValue;
                this.resetSelection();
            }
            return;
        }
        if (this.isPropertyChanged(changes['rows'])) {
            if (this.isTableEmpty()) {
                this.initTable();
            }
            else {
                this.setTableRows(changes['rows'].currentValue);
            }
            return;
        }
        if (changes.selectionMode && !changes.selectionMode.isFirstChange()) {
            this.resetSelection();
            this.emitRowSelectionEvent('row-unselect', null);
        }
        if (this.isPropertyChanged(changes['sorting'])) {
            this.setTableSorting(changes['sorting'].currentValue);
        }
        if (this.isPropertyChanged(changes['display'])) {
            this.datatableLayoutFix();
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const changes = this.differ.diff(this.rows);
        if (changes) {
            this.setTableRows(this.rows);
        }
    }
    /**
     * @param {?} property
     * @return {?}
     */
    isPropertyChanged(property) {
        return property && property.currentValue ? true : false;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    convertToRowsData(rows) {
        return rows.map((/**
         * @param {?} row
         * @return {?}
         */
        (row) => new ObjectDataRow(row, row.isSelected)));
    }
    /**
     * @param {?} sorting
     * @return {?}
     */
    convertToDataSorting(sorting) {
        if (sorting && sorting.length > 0) {
            return new DataSorting(sorting[0], sorting[1]);
        }
    }
    /**
     * @private
     * @return {?}
     */
    initAndSubscribeClickStream() {
        this.unsubscribeClickStream();
        /** @type {?} */
        const singleClickStream = this.click$
            .pipe(buffer(this.click$.pipe(debounceTime(250))), map((/**
         * @param {?} list
         * @return {?}
         */
        (list) => list)), filter((/**
         * @param {?} x
         * @return {?}
         */
        (x) => x.length === 1)));
        this.singleClickStreamSub = singleClickStream.subscribe((/**
         * @param {?} dataRowEvents
         * @return {?}
         */
        (dataRowEvents) => {
            /** @type {?} */
            const event = dataRowEvents[0];
            this.handleRowSelection(event.value, (/** @type {?} */ (event.event)));
            this.rowClick.emit(event);
            if (!event.defaultPrevented) {
                this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-click', {
                    detail: event,
                    bubbles: true
                }));
            }
        }));
        /** @type {?} */
        const multiClickStream = this.click$
            .pipe(buffer(this.click$.pipe(debounceTime(250))), map((/**
         * @param {?} list
         * @return {?}
         */
        (list) => list)), filter((/**
         * @param {?} x
         * @return {?}
         */
        (x) => x.length >= 2)));
        this.multiClickStreamSub = multiClickStream.subscribe((/**
         * @param {?} dataRowEvents
         * @return {?}
         */
        (dataRowEvents) => {
            /** @type {?} */
            const event = dataRowEvents[0];
            this.rowDblClick.emit(event);
            if (!event.defaultPrevented) {
                this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-dblclick', {
                    detail: event,
                    bubbles: true
                }));
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    unsubscribeClickStream() {
        if (this.singleClickStreamSub) {
            this.singleClickStreamSub.unsubscribe();
            this.singleClickStreamSub = null;
        }
        if (this.multiClickStreamSub) {
            this.multiClickStreamSub.unsubscribe();
            this.multiClickStreamSub = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    initTable() {
        this.data = new ObjectDataTableAdapter(this.rows, this.columns);
        this.setTableSorting(this.sorting);
        this.resetSelection();
        this.rowMenuCache = {};
    }
    /**
     * @return {?}
     */
    isTableEmpty() {
        return this.data === undefined || this.data === null;
    }
    /**
     * @private
     * @param {?} rows
     * @return {?}
     */
    setTableRows(rows) {
        if (this.data) {
            this.resetSelection();
            this.data.setRows(this.convertToRowsData(rows));
        }
    }
    /**
     * @private
     * @return {?}
     */
    setTableSchema() {
        /** @type {?} */
        let schema = [];
        if (!this.columns || this.columns.length === 0) {
            schema = this.getSchemaFromHtml();
        }
        else {
            schema = this.columns.concat(this.getSchemaFromHtml());
        }
        this.columns = schema;
        if (this.data && this.columns && this.columns.length > 0) {
            this.data.setColumns(this.columns);
        }
    }
    /**
     * @private
     * @param {?} sorting
     * @return {?}
     */
    setTableSorting(sorting) {
        if (this.data) {
            this.data.setSorting(this.convertToDataSorting(sorting));
        }
    }
    /**
     * @return {?}
     */
    getSchemaFromHtml() {
        /** @type {?} */
        let schema = [];
        if (this.columnList && this.columnList.columns && this.columnList.columns.length > 0) {
            schema = this.columnList.columns.map((/**
             * @param {?} c
             * @return {?}
             */
            (c) => (/** @type {?} */ (c))));
        }
        return schema;
    }
    /**
     * @param {?} row
     * @param {?} mouseEvent
     * @return {?}
     */
    onRowClick(row, mouseEvent) {
        if (mouseEvent) {
            mouseEvent.preventDefault();
        }
        if (row) {
            /** @type {?} */
            const dataRowEvent = new DataRowEvent(row, mouseEvent, this);
            this.clickObserver.next(dataRowEvent);
        }
    }
    /**
     * @param {?} row
     * @param {?} e
     * @return {?}
     */
    onEnterKeyPressed(row, e) {
        if (row) {
            this.handleRowSelection(row, e);
        }
    }
    /**
     * @private
     * @param {?} row
     * @param {?} e
     * @return {?}
     */
    handleRowSelection(row, e) {
        if (this.data) {
            if (this.isSingleSelectionMode()) {
                this.resetSelection();
                this.selectRow(row, true);
                this.emitRowSelectionEvent('row-select', row);
            }
            if (this.isMultiSelectionMode()) {
                /** @type {?} */
                const modifier = e && (e.metaKey || e.ctrlKey);
                /** @type {?} */
                let newValue;
                if (this.selection.length === 1) {
                    newValue = !row.isSelected;
                }
                else {
                    newValue = modifier ? !row.isSelected : true;
                }
                /** @type {?} */
                const domEventName = newValue ? 'row-select' : 'row-unselect';
                if (!modifier) {
                    this.resetSelection();
                }
                this.selectRow(row, newValue);
                this.emitRowSelectionEvent(domEventName, row);
            }
        }
    }
    /**
     * @return {?}
     */
    resetSelection() {
        if (this.data) {
            /** @type {?} */
            const rows = this.data.getRows();
            if (rows && rows.length > 0) {
                rows.forEach((/**
                 * @param {?} r
                 * @return {?}
                 */
                (r) => r.isSelected = false));
            }
            this.selection = [];
        }
        this.isSelectAllChecked = false;
    }
    /**
     * @param {?} row
     * @param {?=} event
     * @return {?}
     */
    onRowDblClick(row, event) {
        if (event) {
            event.preventDefault();
        }
        /** @type {?} */
        const dataRowEvent = new DataRowEvent(row, event, this);
        this.clickObserver.next(dataRowEvent);
    }
    /**
     * @param {?} row
     * @param {?} e
     * @return {?}
     */
    onRowKeyUp(row, e) {
        /** @type {?} */
        const event = new CustomEvent('row-keyup', {
            detail: {
                row: row,
                keyboardEvent: e,
                sender: this
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(event);
        if (event.defaultPrevented) {
            e.preventDefault();
        }
        else {
            if (e.key === 'Enter') {
                this.onKeyboardNavigate(row, e);
            }
        }
    }
    /**
     * @private
     * @param {?} row
     * @param {?} keyboardEvent
     * @return {?}
     */
    onKeyboardNavigate(row, keyboardEvent) {
        if (keyboardEvent) {
            keyboardEvent.preventDefault();
        }
        /** @type {?} */
        const event = new DataRowEvent(row, keyboardEvent, this);
        this.rowDblClick.emit(event);
        this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-dblclick', {
            detail: event,
            bubbles: true
        }));
    }
    /**
     * @param {?} column
     * @return {?}
     */
    onColumnHeaderClick(column) {
        if (column && column.sortable) {
            /** @type {?} */
            const current = this.data.getSorting();
            /** @type {?} */
            let newDirection = 'asc';
            if (current && column.key === current.key) {
                newDirection = current.direction === 'asc' ? 'desc' : 'asc';
            }
            this.data.setSorting(new DataSorting(column.key, newDirection));
            this.emitSortingChangedEvent(column.key, newDirection);
        }
    }
    /**
     * @param {?} matCheckboxChange
     * @return {?}
     */
    onSelectAllClick(matCheckboxChange) {
        this.isSelectAllChecked = matCheckboxChange.checked;
        if (this.multiselect) {
            /** @type {?} */
            const rows = this.data.getRows();
            if (rows && rows.length > 0) {
                for (let i = 0; i < rows.length; i++) {
                    this.selectRow(rows[i], matCheckboxChange.checked);
                }
            }
            /** @type {?} */
            const domEventName = matCheckboxChange.checked ? 'row-select' : 'row-unselect';
            /** @type {?} */
            const row = this.selection.length > 0 ? this.selection[0] : null;
            this.emitRowSelectionEvent(domEventName, row);
        }
    }
    /**
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    onCheckboxChange(row, event) {
        /** @type {?} */
        const newValue = event.checked;
        this.selectRow(row, newValue);
        /** @type {?} */
        const domEventName = newValue ? 'row-select' : 'row-unselect';
        this.emitRowSelectionEvent(domEventName, row);
    }
    /**
     * @param {?} event
     * @param {?} row
     * @return {?}
     */
    onImageLoadingError(event, row) {
        if (event) {
            /** @type {?} */
            const element = (/** @type {?} */ (event.target));
            if (this.fallbackThumbnail) {
                element.src = this.fallbackThumbnail;
            }
            else {
                element.src = row.imageErrorResolver(event);
            }
        }
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    isIconValue(row, col) {
        if (row && col) {
            /** @type {?} */
            const value = row.getValue(col.key);
            return value && value.startsWith('material-icons://');
        }
        return false;
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    asIconValue(row, col) {
        if (this.isIconValue(row, col)) {
            /** @type {?} */
            const value = row.getValue(col.key) || '';
            return value.replace('material-icons://', '');
        }
        return null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    iconAltTextKey(value) {
        return value ? 'ICONS.' + value.substring(value.lastIndexOf('/') + 1).replace(/\.[a-z]+/, '') : '';
    }
    /**
     * @param {?} col
     * @param {?} direction
     * @return {?}
     */
    isColumnSorted(col, direction) {
        if (col && direction) {
            /** @type {?} */
            const sorting = this.data.getSorting();
            return sorting && sorting.key === col.key && sorting.direction === direction;
        }
        return false;
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getContextMenuActions(row, col) {
        /** @type {?} */
        const event = new DataCellEvent(row, col, []);
        this.showRowContextMenu.emit(event);
        return event.value.actions;
    }
    /**
     * @param {?} row
     * @param {?=} col
     * @return {?}
     */
    getRowActions(row, col) {
        /** @type {?} */
        const id = row.getValue('id');
        if (!this.rowMenuCache[id]) {
            /** @type {?} */
            const event = new DataCellEvent(row, col, []);
            this.showRowActionsMenu.emit(event);
            if (!this.rowMenuCacheEnabled) {
                return event.value.actions;
            }
            this.rowMenuCache[id] = event.value.actions;
        }
        return this.rowMenuCache[id];
    }
    /**
     * @param {?} row
     * @param {?} action
     * @return {?}
     */
    onExecuteRowAction(row, action) {
        if (action.disabled || action.disabled) {
            event.stopPropagation();
        }
        else {
            this.executeRowAction.emit(new DataRowActionEvent(row, action));
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    rowAllowsDrop(row) {
        return row.isDropTarget === true;
    }
    /**
     * @return {?}
     */
    hasSelectionMode() {
        return this.isSingleSelectionMode() || this.isMultiSelectionMode();
    }
    /**
     * @return {?}
     */
    isSingleSelectionMode() {
        return this.selectionMode && this.selectionMode.toLowerCase() === 'single';
    }
    /**
     * @return {?}
     */
    isMultiSelectionMode() {
        return this.selectionMode && this.selectionMode.toLowerCase() === 'multiple';
    }
    /**
     * @param {?} row
     * @return {?}
     */
    getRowStyle(row) {
        row.cssClass = row.cssClass ? row.cssClass : '';
        this.rowStyleClass = this.rowStyleClass ? this.rowStyleClass : '';
        return `${row.cssClass} ${this.rowStyleClass}`;
    }
    /**
     * @return {?}
     */
    getSortingKey() {
        if (this.data.getSorting()) {
            return this.data.getSorting().key;
        }
    }
    /**
     * @param {?} row
     * @param {?} value
     * @return {?}
     */
    selectRow(row, value) {
        if (row) {
            row.isSelected = value;
            /** @type {?} */
            const idx = this.selection.indexOf(row);
            if (value) {
                if (idx < 0) {
                    this.selection.push(row);
                }
            }
            else {
                if (idx > -1) {
                    this.selection.splice(idx, 1);
                }
            }
        }
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getCellTooltip(row, col) {
        if (row && col && col.formatTooltip) {
            /** @type {?} */
            const result = col.formatTooltip(row, col);
            if (result) {
                return result;
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    getSortableColumns() {
        return this.data.getColumns().filter((/**
         * @param {?} column
         * @return {?}
         */
        (column) => {
            return column.sortable === true;
        }));
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.data.getRows().length === 0;
    }
    /**
     * @return {?}
     */
    isHeaderVisible() {
        return !this.loading && !this.isEmpty() && !this.noPermission;
    }
    /**
     * @private
     * @param {?} name
     * @param {?} row
     * @return {?}
     */
    emitRowSelectionEvent(name, row) {
        /** @type {?} */
        const domEvent = new CustomEvent(name, {
            detail: {
                row: row,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    /**
     * @private
     * @param {?} key
     * @param {?} direction
     * @return {?}
     */
    emitSortingChangedEvent(key, direction) {
        /** @type {?} */
        const domEvent = new CustomEvent('sorting-changed', {
            detail: {
                key,
                direction
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribeClickStream();
        this.subscriptions.forEach((/**
         * @param {?} s
         * @return {?}
         */
        (s) => s.unsubscribe()));
        this.subscriptions = [];
        if (this.dataRowsChanged) {
            this.dataRowsChanged.unsubscribe();
            this.dataRowsChanged = null;
        }
    }
    /**
     * @return {?}
     */
    datatableLayoutFix() {
        /** @type {?} */
        const maxGalleryRows = 25;
        if (this.display === 'gallery') {
            for (let i = 0; i < maxGalleryRows; i++) {
                this.fakeRows.push('');
            }
        }
        else {
            this.fakeRows = [];
        }
    }
    /**
     * @return {?}
     */
    getNameColumnValue() {
        return this.data.getColumns().find((/**
         * @param {?} el
         * @return {?}
         */
        (el) => {
            return el.key.includes('name');
        }));
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getAutomationValue(row, col) {
        /** @type {?} */
        const name = this.getNameColumnValue();
        return name ? row.getValue(name.key) : '';
    }
}
DataTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable',
                template: "<div\n    role=\"grid\"\n    *ngIf=\"data\" class=\"adf-full-width\"\n    [class.adf-datatable-card]=\"display === 'gallery'\"\n    [class.adf-datatable-list]=\"display === 'list'\"\n    [class.adf-sticky-header]=\"stickyHeader\"\n    [class.adf-datatable--empty]=\"!isHeaderVisible()\">\n    <div *ngIf=\"showHeader && isHeaderVisible()\" class=\"adf-datatable-header\" role=\"rowgroup\">\n        <div class=\"adf-datatable-row\" *ngIf=\"display === 'list'\" role=\"row\">\n            <!-- Actions (left) -->\n            <div *ngIf=\"actions && actionsPosition === 'left'\" class=\"adf-actions-column adf-datatable-cell-header\">\n                <span class=\"adf-sr-only\">Actions</span>\n            </div>\n            <!-- Columns -->\n            <div *ngIf=\"multiselect\" class=\"adf-datatable-cell-header adf-datatable-checkbox\">\n                <mat-checkbox [checked]=\"isSelectAllChecked\" (change)=\"onSelectAllClick($event)\" class=\"adf-checkbox-sr-only\">{{ 'ADF-DATATABLE.ACCESSIBILITY.SELECT_ALL' | translate }}</mat-checkbox>\n            </div>\n            <div class=\"adf-datatable-cell--{{col.type || 'text'}} {{col.cssClass}} adf-datatable-cell-header\"\n                 *ngFor=\"let col of data.getColumns()\"\n                 [class.adf-sortable]=\"col.sortable\"\n                 [attr.data-automation-id]=\"'auto_id_' + col.key\"\n                 [class.adf-datatable__header--sorted-asc]=\"isColumnSorted(col, 'asc')\"\n                 [class.adf-datatable__header--sorted-desc]=\"isColumnSorted(col, 'desc')\"\n                 (click)=\"onColumnHeaderClick(col)\"\n                 (keyup.enter)=\"onColumnHeaderClick(col)\"\n                 role=\"columnheader\"\n                 tabindex=\"0\"\n                 title=\"{{ col.title | translate }}\"\n                 adf-drop-zone dropTarget=\"header\" [dropColumn]=\"col\">\n                <span *ngIf=\"col.srTitle\" class=\"adf-sr-only\">{{ col.srTitle | translate }}</span>\n                <span *ngIf=\"col.title\" class=\"adf-datatable-cell-value\">{{ col.title | translate}}</span>\n            </div>\n            <!-- Actions (right) -->\n            <div *ngIf=\"actions && actionsPosition === 'right'\" class=\"adf-actions-column adf-datatable-cell-header adf-datatable__actions-cell\">\n                <span class=\"adf-sr-only\">Actions</span>\n            </div>\n        </div>\n        <mat-form-field *ngIf=\"display === 'gallery'\">\n            <mat-select [value]=\"getSortingKey()\" [attr.data-automation-id]=\"'grid-view-sorting'\">\n                <mat-option *ngFor=\"let col of getSortableColumns()\"\n                            [value]=\"col.key\"\n                            [attr.data-automation-id]=\"'grid-view-sorting-'+col.title\"\n                            (click)=\"onColumnHeaderClick(col)\"\n                            (keyup.enter)=\"onColumnHeaderClick(col)\">\n                    {{ col.title | translate}}\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n    </div>\n\n    <div class=\"adf-datatable-body\" role=\"rowgroup\">\n        <ng-container *ngIf=\"!loading && !noPermission\">\n            <div *ngFor=\"let row of data.getRows(); let idx = index\"\n                 class=\"adf-datatable-row\"\n                 role=\"row\"\n                 [class.adf-is-selected]=\"row.isSelected\"\n                 [adf-upload]=\"allowDropFiles && rowAllowsDrop(row)\" [adf-upload-data]=\"row\"\n                 [ngStyle]=\"rowStyle\"\n                 [ngClass]=\"getRowStyle(row)\"\n                 (keyup)=\"onRowKeyUp(row, $event)\">\n                <!-- Actions (left) -->\n                <div *ngIf=\"actions && actionsPosition === 'left'\" role=\"gridcell\" class=\"adf-datatable-cell\">\n                    <button mat-icon-button [matMenuTriggerFor]=\"menu\"\n                            [title]=\"'ADF-DATATABLE.CONTENT-ACTIONS.TOOLTIP' | translate\"\n                            [attr.id]=\"'action_menu_left_' + idx\"\n                            [attr.data-automation-id]=\"'action_menu_' + idx\">\n                        <mat-icon>more_vert</mat-icon>\n                    </button>\n                    <mat-menu #menu=\"matMenu\">\n                        <button mat-menu-item *ngFor=\"let action of getRowActions(row)\"\n                                [attr.data-automation-id]=\"action.title\"\n                                [disabled]=\"action.disabled\"\n                                (click)=\"onExecuteRowAction(row, action)\">\n                            <mat-icon *ngIf=\"action.icon\">{{ action.icon }}</mat-icon>\n                            <span>{{ action.title | translate }}</span>\n                        </button>\n                    </mat-menu>\n                </div>\n\n                <div *ngIf=\"multiselect\" class=\"adf-datatable-cell adf-datatable-checkbox\">\n                    <mat-checkbox\n                        [checked]=\"row.isSelected\"\n                        [attr.aria-checked]=\"row.isSelected\"\n                        role=\"checkbox\"\n                        (change)=\"onCheckboxChange(row, $event)\"\n                        class=\"adf-checkbox-sr-only\">\n                        {{ 'ADF-DATATABLE.ACCESSIBILITY.SELECT_FILE' | translate }}\n                    </mat-checkbox>\n                </div>\n                <div *ngFor=\"let col of data.getColumns()\"\n                     role=\"gridcell\"\n                     class=\" adf-datatable-cell adf-datatable-cell--{{col.type || 'text'}} {{col.cssClass}}\"\n                     [attr.title]=\"col.title | translate\"\n                     [attr.data-automation-id]=\"getAutomationValue(row, col)\"\n                     tabindex=\"0\"\n                     (click)=\"onRowClick(row, $event)\"\n                     (keydown.enter)=\"onEnterKeyPressed(row, $event)\"\n                     [adf-context-menu]=\"getContextMenuActions(row, col)\"\n                     [adf-context-menu-enabled]=\"contextMenu\"\n                     adf-drop-zone dropTarget=\"cell\" [dropColumn]=\"col\" [dropRow]=\"row\">\n                    <div *ngIf=\"!col.template\" class=\"adf-datatable-cell-container\">\n                        <ng-container [ngSwitch]=\"col.type\">\n                            <div *ngSwitchCase=\"'image'\" class=\"adf-cell-value\">\n                                <mat-icon *ngIf=\"isIconValue(row, col); else no_iconvalue\">{{ asIconValue(row, col) }}\n                                </mat-icon>\n                                <ng-template #no_iconvalue>\n                                    <mat-icon class=\"adf-datatable-selected\"\n                                              *ngIf=\"row.isSelected && !multiselect; else no_selected_row\" svgIcon=\"selected\">\n                                    </mat-icon>\n                                    <ng-template #no_selected_row>\n                                        <img class=\"adf-datatable-center-img-ie\"\n                                            [attr.aria-label]=\"data.getValue(row, col) | fileType\"\n                                            alt=\"{{ iconAltTextKey(data.getValue(row, col)) | translate }}\"\n                                            src=\"{{ data.getValue(row, col) }}\"\n                                            (error)=\"onImageLoadingError($event, row)\">\n                                    </ng-template>\n                                </ng-template>\n                            </div>\n                            <div *ngSwitchCase=\"'icon'\" class=\"adf-cell-value\">\n                                <span class=\"adf-sr-only\">{{ iconAltTextKey(data.getValue(row, col)) | translate }}</span>\n                                <mat-icon>{{ data.getValue(row, col) }}</mat-icon>\n                            </div>\n                            <div *ngSwitchCase=\"'date'\" class=\"adf-cell-value\"\n                                 [attr.data-automation-id]=\"'date_' + (data.getValue(row, col) | date: 'medium') \">\n                                <adf-date-cell class = \"adf-datatable-center-date-column-ie\"\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [row]=\"row\"\n                                    [tooltip]=\"getCellTooltip(row, col)\">\n                                </adf-date-cell>\n                            </div>\n                            <div *ngSwitchCase=\"'location'\" class=\"adf-cell-value\"\n                                 [attr.data-automation-id]=\"'location' + data.getValue(row, col)\">\n                                <adf-location-cell\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [row]=\"row\"\n                                    [tooltip]=\"getCellTooltip(row, col)\">\n                                </adf-location-cell>\n                            </div>\n                            <div *ngSwitchCase=\"'fileSize'\" class=\"adf-cell-value\"\n                                 [attr.data-automation-id]=\"'fileSize_' + data.getValue(row, col)\">\n                                <adf-filesize-cell class=\"adf-datatable-center-size-column-ie\"\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [row]=\"row\"\n                                    [tooltip]=\"getCellTooltip(row, col)\">\n                                </adf-filesize-cell>\n                            </div>\n                            <div *ngSwitchCase=\"'text'\" class=\"adf-cell-value\"\n                                 [attr.data-automation-id]=\"'text_' + data.getValue(row, col)\">\n                                <adf-datatable-cell\n                                    [copyContent]=\"col.copyContent\"\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [row]=\"row\"\n                                    [tooltip]=\"getCellTooltip(row, col)\">\n                                </adf-datatable-cell>\n                            </div>\n                            <div *ngSwitchCase=\"'json'\" class=\"adf-cell-value\">\n                                <adf-json-cell\n                                    [copyContent]=\"col.copyContent\"\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [row]=\"row\">\n                                </adf-json-cell>\n                            </div>\n                            <span *ngSwitchDefault class=\"adf-cell-value\">\n                    <!-- empty cell for unknown column type -->\n                    </span>\n                        </ng-container>\n                    </div>\n                    <div *ngIf=\"col.template\" class=\"adf-datatable-cell-container\">\n                        <div class=\"adf-cell-value\">\n                            <ng-container\n                                [ngTemplateOutlet]=\"col.template\"\n                                [ngTemplateOutletContext]=\"{ $implicit: { data: data, row: row, col: col }, value: data.getValue(row, col) }\">\n                            </ng-container>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Actions (right) -->\n                <div *ngIf=\"actions && actionsPosition === 'right'\"\n                     role=\"gridcell\"\n                     class=\"adf-datatable-cell adf-datatable__actions-cell adf-datatable-center-actions-column-ie\">\n                    <button mat-icon-button [matMenuTriggerFor]=\"menu\"\n                            [title]=\"'ADF-DATATABLE.CONTENT-ACTIONS.TOOLTIP' | translate\"\n                            [attr.id]=\"'action_menu_right_' + idx\"\n                            [attr.data-automation-id]=\"'action_menu_' + idx\">\n                        <mat-icon>more_vert</mat-icon>\n                    </button>\n                    <mat-menu #menu=\"matMenu\">\n                        <button mat-menu-item *ngFor=\"let action of getRowActions(row)\"\n                                [attr.data-automation-id]=\"action.title\"\n                                [attr.aria-label]=\"action.title | translate\"\n                                [disabled]=\"action.disabled\"\n                                (click)=\"onExecuteRowAction(row, action)\">\n                            <mat-icon *ngIf=\"action.icon\">{{ action.icon }}</mat-icon>\n                            <span>{{ action.title | translate }}</span>\n                        </button>\n                    </mat-menu>\n                </div>\n\n            </div>\n            <div *ngIf=\"isEmpty()\"\n                 role=\"row\"\n                 [class.adf-datatable-row]=\"display === 'list'\"\n                 [class.adf-datatable-card-empty]=\"display === 'gallery'\">\n                <div class=\"adf-no-content-container adf-datatable-cell\" role=\"gridcell\">\n                    <ng-template *ngIf=\"noContentTemplate\"\n                                 ngFor [ngForOf]=\"[data]\"\n                                 [ngForTemplate]=\"noContentTemplate\">\n                    </ng-template>\n                    <ng-content select=\"adf-empty-list\"></ng-content>\n                </div>\n            </div>\n            <div *ngFor=\"let row of fakeRows\"\n                 class=\"adf-datatable-row adf-datatable-row-empty-card\">\n            </div>\n        </ng-container>\n        <div *ngIf=\"!loading && noPermission\"\n             role=\"row\"\n             [class.adf-datatable-row]=\"display === 'list'\"\n             [class.adf-datatable-card-permissions]=\"display === 'gallery'\"\n             class=\"adf-no-permission__row\">\n            <div class=\"adf-no-permission__cell adf-no-content-container adf-datatable-cell\">\n                <ng-template *ngIf=\"noPermissionTemplate\"\n                             ngFor [ngForOf]=\"[data]\"\n                             [ngForTemplate]=\"noPermissionTemplate\">\n                </ng-template>\n            </div>\n        </div>\n        <div *ngIf=\"loading\"\n             [class.adf-datatable-row]=\"display === 'list'\"\n             [class.adf-datatable-card-loading]=\"display === 'gallery'\">\n            <div class=\"adf-no-content-container adf-datatable-cell\">\n                <ng-template *ngIf=\"loadingTemplate\"\n                             ngFor [ngForOf]=\"[data]\"\n                             [ngForTemplate]=\"loadingTemplate\">\n                </ng-template>\n            </div>\n        </div>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable' },
                styles: [""]
            }] }
];
/** @nocollapse */
DataTableComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IterableDiffers }
];
DataTableComponent.propDecorators = {
    columnList: [{ type: ContentChild, args: [DataColumnListComponent,] }],
    data: [{ type: Input }],
    display: [{ type: Input }],
    rows: [{ type: Input }],
    sorting: [{ type: Input }],
    columns: [{ type: Input }],
    selectionMode: [{ type: Input }],
    multiselect: [{ type: Input }],
    actions: [{ type: Input }],
    actionsPosition: [{ type: Input }],
    fallbackThumbnail: [{ type: Input }],
    contextMenu: [{ type: Input }],
    allowDropFiles: [{ type: Input }],
    rowStyle: [{ type: Input }],
    rowStyleClass: [{ type: Input }],
    showHeader: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    rowClick: [{ type: Output }],
    rowDblClick: [{ type: Output }],
    showRowContextMenu: [{ type: Output }],
    showRowActionsMenu: [{ type: Output }],
    executeRowAction: [{ type: Output }],
    loading: [{ type: Input }],
    noPermission: [{ type: Input }],
    rowMenuCacheEnabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateCellComponent extends DataTableCellComponent {
    /**
     * @param {?} userPreferenceService
     * @param {?} alfrescoApiService
     */
    constructor(userPreferenceService, alfrescoApiService) {
        super(alfrescoApiService);
        if (userPreferenceService) {
            userPreferenceService
                .select(UserPreferenceValues.Locale)
                .subscribe((/**
             * @param {?} locale
             * @return {?}
             */
            (locale) => {
                this.currentLocale = locale;
            }));
        }
    }
    /**
     * @return {?}
     */
    get format() {
        if (this.column) {
            return this.column.format || 'medium';
        }
        return 'medium';
    }
}
DateCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-cell',
                template: `
        <ng-container>
            <span
                [attr.aria-label]="value$ | async | adfTimeAgo: currentLocale"
                title="{{ tooltip | date: 'medium' }}"
                class="adf-datatable-cell-value"
                *ngIf="format === 'timeAgo'; else standard_date"
            >
                {{ value$ | async | adfTimeAgo: currentLocale }}
            </span>
        </ng-container>
        <ng-template #standard_date>
            <span
                title="{{ tooltip | date: format }}"
                class="adf-datatable-cell-value"
                [attr.aria-label]="value$ | async | date: format"
            >
                {{ value$ | async | date: format }}
            </span>
        </ng-template>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-date-cell adf-datatable-content-cell' }
            }] }
];
/** @nocollapse */
DateCellComponent.ctorParameters = () => [
    { type: UserPreferencesService },
    { type: AlfrescoApiService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EmptyListComponent {
}
EmptyListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-empty-list',
                template: "<div class=\"adf-empty-list_template\">\n    <ng-content select=\"[adf-empty-list-header]\"></ng-content>\n    <ng-content select=\"[adf-empty-list-body]\"></ng-content>\n    <ng-content select=\"[adf-empty-list-footer]\"></ng-content>\n    <ng-content></ng-content>\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-empty-list_template{text-align:center;margin-top:20px;margin-bottom:20px}"]
            }] }
];
class EmptyListHeaderDirective {
}
EmptyListHeaderDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-header]' },] }
];
class EmptyListBodyDirective {
}
EmptyListBodyDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-body]' },] }
];
class EmptyListFooterDirective {
}
EmptyListFooterDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-footer]' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileSizeCellComponent extends DataTableCellComponent {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        super(alfrescoApiService);
    }
}
FileSizeCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-filesize-cell',
                template: `
        <ng-container>
            <span
                [title]="tooltip"
                [attr.aria-label]="value$ | async | adfFileSize"
                >{{ value$ | async | adfFileSize }}</span
            >
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-filesize-cell' }
            }] }
];
/** @nocollapse */
FileSizeCellComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LocationCellComponent extends DataTableCellComponent {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        super(alfrescoApiService);
    }
    /**
     * @override
     * @return {?}
     */
    ngOnInit() {
        if (this.column && this.column.key && this.row && this.data) {
            /** @type {?} */
            const path = this.data.getValue(this.row, this.column);
            if (path && path.name && path.elements) {
                this.value$.next(path.name.split('/').pop());
                if (!this.tooltip) {
                    this.tooltip = path.name;
                }
                /** @type {?} */
                const parent = path.elements[path.elements.length - 1];
                this.link = [this.column.format, parent.id];
            }
        }
    }
}
LocationCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-location-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <a href="" [title]="tooltip" [routerLink]="link">
                {{ value$ | async }}
            </a>
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-location-cell adf-datatable-content-cell' }
            }] }
];
/** @nocollapse */
LocationCellComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];
LocationCellComponent.propDecorators = {
    link: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class LoadingContentTemplateDirective {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.loadingTemplate = this.template;
        }
    }
}
LoadingContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-loading-content-template, loading-content-template'
            },] }
];
/** @nocollapse */
LoadingContentTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent }
];
LoadingContentTemplateDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class NoContentTemplateDirective {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.noContentTemplate = this.template;
        }
    }
}
NoContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-no-content-template, no-content-template'
            },] }
];
/** @nocollapse */
NoContentTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent }
];
NoContentTemplateDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class NoPermissionTemplateDirective {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.noPermissionTemplate = this.template;
        }
    }
}
NoPermissionTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-no-permission-template, no-permission-template'
            },] }
];
/** @nocollapse */
NoPermissionTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent }
];
NoPermissionTemplateDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0.
 * The empty-folder-content selector will be deprecated as it has been replace by
 * adf-custom-empty-content-template.
 */
class CustomEmptyContentTemplateDirective {
}
CustomEmptyContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-custom-empty-content-template, empty-folder-content'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomLoadingContentTemplateDirective {
}
CustomLoadingContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-custom-loading-content-template'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0.
 * The no-permission-content selector will be deprecated as it has been replace by
 * adf-custom-no-permission-template.
 */
class CustomNoPermissionTemplateDirective {
}
CustomNoPermissionTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-custom-no-permission-template, no-permission-content'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JsonCellComponent extends DataTableCellComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.column && this.column.key && this.row && this.data) {
            this.value$.next(this.data.getValue(this.row, this.column));
        }
    }
}
JsonCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-json-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <span *ngIf="copyContent; else defaultJsonTemplate" class="adf-datatable-cell-value">
                <pre
                    class="adf-datatable-json-cell"
                    [adf-clipboard]="'CLIPBOARD.CLICK_TO_COPY'"
                    [clipboard-notification]="'CLIPBOARD.SUCCESS_COPY'">{{ value$ | async | json }}</pre>
            </span>
        </ng-container>
        <ng-template #defaultJsonTemplate>
            <span class="adf-datatable-cell-value">
                <pre class="adf-datatable-json-cell">{{ value$ | async | json }}</pre>
            </span>
        </ng-template>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable-content-cell' },
                styles: [".adf-datatable-json-cell{white-space:pre-wrap;word-wrap:break-word}.adf-datatable-cell-value{position:relative}"]
            }] }
];
JsonCellComponent.propDecorators = {
    copyContent: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NotificationService {
    /**
     * @param {?} snackBar
     * @param {?} translationService
     * @param {?} appConfigService
     */
    constructor(snackBar, translationService, appConfigService) {
        this.snackBar = snackBar;
        this.translationService = translationService;
        this.appConfigService = appConfigService;
        this.DEFAULT_DURATION_MESSAGE = 5000;
        this.DEFAULT_DURATION_MESSAGE = this.appConfigService.get(AppConfigValues.NOTIFY_DURATION) || this.DEFAULT_DURATION_MESSAGE;
    }
    /**
     * Opens a SnackBar notification to show a message.
     * @param {?} message The message (or resource key) to show.
     * @param {?=} config Time before notification disappears after being shown or MatSnackBarConfig object
     * @return {?} Information/control object for the SnackBar
     */
    openSnackMessage(message, config) {
        if (!config) {
            config = this.DEFAULT_DURATION_MESSAGE;
        }
        /** @type {?} */
        const translatedMessage = this.translationService.instant(message);
        if (typeof config === 'number') {
            config = {
                duration: config
            };
        }
        return this.snackBar.open(translatedMessage, null, config);
    }
    /**
     * Opens a SnackBar notification with a message and a response button.
     * @param {?} message The message (or resource key) to show.
     * @param {?} action Caption for the response button
     * @param {?=} config Time before notification disappears after being shown or MatSnackBarConfig object
     * @return {?} Information/control object for the SnackBar
     */
    openSnackMessageAction(message, action, config) {
        if (!config) {
            config = this.DEFAULT_DURATION_MESSAGE;
        }
        /** @type {?} */
        const translatedMessage = this.translationService.instant(message);
        if (typeof config === 'number') {
            config = {
                duration: config
            };
        }
        return this.snackBar.open(translatedMessage, action, config);
    }
    /**
     *  dismiss the notification snackbar
     * @return {?}
     */
    dismissSnackMessageAction() {
        return this.snackBar.dismiss();
    }
}
NotificationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NotificationService.ctorParameters = () => [
    { type: MatSnackBar },
    { type: TranslationService },
    { type: AppConfigService }
];
/** @nocollapse */ NotificationService.ngInjectableDef = defineInjectable({ factory: function NotificationService_Factory() { return new NotificationService(inject(MatSnackBar$1), inject(TranslationService), inject(AppConfigService)); }, token: NotificationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClipboardService {
    /**
     * @param {?} document
     * @param {?} logService
     * @param {?} notificationService
     */
    constructor(document, logService, notificationService) {
        this.document = document;
        this.logService = logService;
        this.notificationService = notificationService;
    }
    /**
     * Checks if the target element can have its text copied.
     * @param {?} target Target HTML element
     * @return {?} True if the text can be copied, false otherwise
     */
    isTargetValid(target) {
        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
            return !target.hasAttribute('disabled');
        }
        return false;
    }
    /**
     * Copies text from an HTML element to the clipboard.
     * @param {?} target HTML element to be copied
     * @param {?=} message Snackbar message to alert when copying happens
     * @return {?}
     */
    copyToClipboard(target, message) {
        if (this.isTargetValid(target)) {
            try {
                target.select();
                target.setSelectionRange(0, target.value.length);
                this.document.execCommand('copy');
                this.notify(message);
            }
            catch (error) {
                this.logService.error(error);
            }
        }
    }
    /**
     * Copies a text string to the clipboard.
     * @param {?} content Text to copy
     * @param {?} message Snackbar message to alert when copying happens
     * @return {?}
     */
    copyContentToClipboard(content, message) {
        try {
            document.addEventListener('copy', (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                e.clipboardData.setData('text/plain', (content));
                e.preventDefault();
                document.removeEventListener('copy', null);
            }));
            document.execCommand('copy');
            this.notify(message);
        }
        catch (error) {
            this.logService.error(error);
        }
    }
    /**
     * @private
     * @param {?} message
     * @return {?}
     */
    notify(message) {
        if (message) {
            this.notificationService.openSnackMessage(message);
        }
    }
}
ClipboardService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ClipboardService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: LogService },
    { type: NotificationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClipboardDirective {
    /**
     * @param {?} clipboardService
     * @param {?} viewContainerRef
     * @param {?} resolver
     */
    constructor(clipboardService, viewContainerRef, resolver) {
        this.clipboardService = clipboardService;
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleClickEvent(event) {
        event.preventDefault();
        event.stopPropagation();
        this.copyToClipboard();
    }
    /**
     * @return {?}
     */
    showTooltip() {
        if (this.placeholder) {
            /** @type {?} */
            const componentFactory = this.resolver.resolveComponentFactory(ClipboardComponent);
            /** @type {?} */
            const componentRef = this.viewContainerRef.createComponent(componentFactory).instance;
            componentRef.placeholder = this.placeholder;
        }
    }
    /**
     * @return {?}
     */
    closeTooltip() {
        this.viewContainerRef.remove();
    }
    /**
     * @private
     * @return {?}
     */
    copyToClipboard() {
        /** @type {?} */
        const isValidTarget = this.clipboardService.isTargetValid(this.target);
        if (isValidTarget) {
            this.clipboardService.copyToClipboard(this.target, this.message);
        }
        else {
            this.copyContentToClipboard(this.viewContainerRef.element.nativeElement.innerHTML);
        }
    }
    /**
     * @private
     * @param {?} content
     * @return {?}
     */
    copyContentToClipboard(content) {
        this.clipboardService.copyContentToClipboard(content, this.message);
    }
}
ClipboardDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-clipboard]',
                exportAs: 'adfClipboard'
            },] }
];
/** @nocollapse */
ClipboardDirective.ctorParameters = () => [
    { type: ClipboardService },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
ClipboardDirective.propDecorators = {
    placeholder: [{ type: Input, args: ['adf-clipboard',] }],
    target: [{ type: Input }],
    message: [{ type: Input, args: ['clipboard-notification',] }],
    handleClickEvent: [{ type: HostListener, args: ['click', ['$event'],] }],
    showTooltip: [{ type: HostListener, args: ['mouseenter',] }],
    closeTooltip: [{ type: HostListener, args: ['mouseleave',] }]
};
class ClipboardComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.placeholder = this.placeholder || 'CLIPBOARD.CLICK_TO_COPY';
    }
}
ClipboardComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-copy-content-tooltip',
                template: `
        <span class='adf-copy-tooltip'>{{ placeholder | translate }} </span>
        `,
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClipboardModule {
}
ClipboardModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TranslateModule.forChild()
                ],
                providers: [
                    ClipboardService
                ],
                declarations: [
                    ClipboardDirective,
                    ClipboardComponent
                ],
                exports: [
                    ClipboardDirective
                ],
                entryComponents: [ClipboardComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DropZoneDirective {
    /**
     * @param {?} elementRef
     * @param {?} ngZone
     */
    constructor(elementRef, ngZone) {
        this.ngZone = ngZone;
        this.dropTarget = 'cell';
        this.element = elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.element.addEventListener('dragover', this.onDragOver.bind(this));
            this.element.addEventListener('drop', this.onDrop.bind(this));
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('drop', this.onDrop);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        /** @type {?} */
        const domEvent = new CustomEvent(`${this.dropTarget}-dragover`, {
            detail: {
                target: this.dropTarget,
                event,
                column: this.dropColumn,
                row: this.dropRow
            },
            bubbles: true
        });
        this.element.dispatchEvent(domEvent);
        if (domEvent.defaultPrevented) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDrop(event) {
        /** @type {?} */
        const domEvent = new CustomEvent(`${this.dropTarget}-drop`, {
            detail: {
                target: this.dropTarget,
                event,
                column: this.dropColumn,
                row: this.dropRow
            },
            bubbles: true
        });
        this.element.dispatchEvent(domEvent);
        if (domEvent.defaultPrevented) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
}
DropZoneDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-drop-zone]'
            },] }
];
/** @nocollapse */
DropZoneDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
DropZoneDirective.propDecorators = {
    dropTarget: [{ type: Input }],
    dropRow: [{ type: Input }],
    dropColumn: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataTableModule {
}
DataTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    RouterModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule.forChild(),
                    ContextMenuModule,
                    PipeModule,
                    DirectiveModule,
                    ClipboardModule
                ],
                declarations: [
                    DataTableComponent,
                    EmptyListComponent,
                    EmptyListHeaderDirective,
                    EmptyListBodyDirective,
                    EmptyListFooterDirective,
                    DataTableCellComponent,
                    DateCellComponent,
                    FileSizeCellComponent,
                    LocationCellComponent,
                    JsonCellComponent,
                    NoContentTemplateDirective,
                    NoPermissionTemplateDirective,
                    LoadingContentTemplateDirective,
                    CustomEmptyContentTemplateDirective,
                    CustomLoadingContentTemplateDirective,
                    CustomNoPermissionTemplateDirective,
                    DropZoneDirective
                ],
                exports: [
                    DataTableComponent,
                    EmptyListComponent,
                    EmptyListHeaderDirective,
                    EmptyListBodyDirective,
                    EmptyListFooterDirective,
                    DataTableCellComponent,
                    DateCellComponent,
                    FileSizeCellComponent,
                    LocationCellComponent,
                    JsonCellComponent,
                    NoContentTemplateDirective,
                    NoPermissionTemplateDirective,
                    LoadingContentTemplateDirective,
                    CustomEmptyContentTemplateDirective,
                    CustomLoadingContentTemplateDirective,
                    CustomNoPermissionTemplateDirective,
                    DropZoneDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataColumnModule {
}
DataColumnModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    DataColumnComponent,
                    DataColumnListComponent
                ],
                exports: [
                    DataColumnComponent,
                    DataColumnListComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AboutModule {
}
AboutModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild(),
                    DataTableModule,
                    DataColumnModule
                ],
                declarations: [
                    AboutComponent
                ],
                exports: [
                    AboutComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewUtilService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        /**
         * Based on ViewerComponent Implementation, this value is used to determine how many times we try
         * to get the rendition of a file for preview, or printing.
         */
        this.maxRetries = 5;
        /**
         * Mime-type grouping based on the ViewerComponent.
         */
        this.mimeTypes = {
            text: ['text/plain', 'text/csv', 'text/xml', 'text/html', 'application/x-javascript'],
            pdf: ['application/pdf'],
            image: ['image/png', 'image/jpeg', 'image/gif', 'image/bmp', 'image/svg+xml'],
            media: ['video/mp4', 'video/webm', 'video/ogg', 'audio/mpeg', 'audio/ogg', 'audio/wav']
        };
    }
    /**
     * This method takes a url to trigger the print dialog against, and the type of artifact that it
     * is.
     * This URL should be one that can be rendered in the browser, for example PDF, Image, or Text
     * @param {?} url
     * @param {?} type
     * @return {?}
     */
    printFile(url, type) {
        /** @type {?} */
        const pwa = window.open(url, ViewUtilService.TARGET);
        if (pwa) {
            // Because of the way chrome focus and close image window vs. pdf preview window
            if (type === ViewUtilService.ContentGroup.IMAGE) {
                pwa.onfocus = (/**
                 * @return {?}
                 */
                () => {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        pwa.close();
                    }), 500);
                });
            }
            pwa.onload = (/**
             * @return {?}
             */
            () => {
                pwa.print();
            });
        }
    }
    /**
     * Launch the File Print dialog from anywhere other than the preview service, which resolves the
     * rendition of the object that can be printed from a web browser.
     * These are: images, PDF files, or PDF rendition of files.
     * We also force PDF rendition for TEXT type objects, otherwise the default URL is to download.
     * TODO there are different TEXT type objects, (HTML, plaintext, xml, etc. we should determine how these are handled)
     * @param {?} objectId
     * @param {?} mimeType
     * @return {?}
     */
    printFileGeneric(objectId, mimeType) {
        /** @type {?} */
        const nodeId = objectId;
        /** @type {?} */
        const type = this.getViewerTypeByMimeType(mimeType);
        this.getRendition(nodeId, ViewUtilService.ContentGroup.PDF)
            .then((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            /** @type {?} */
            const url = this.getRenditionUrl(nodeId, type, (value ? true : false));
            /** @type {?} */
            const printType = (type === ViewUtilService.ContentGroup.PDF
                || type === ViewUtilService.ContentGroup.TEXT)
                ? ViewUtilService.ContentGroup.PDF : type;
            this.printFile(url, printType);
        }))
            .catch((/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.logService.error('Error with Printing');
            this.logService.error(err);
        }));
    }
    /**
     * @param {?} nodeId
     * @param {?} type
     * @param {?} renditionExists
     * @return {?}
     */
    getRenditionUrl(nodeId, type, renditionExists) {
        return (renditionExists && type !== ViewUtilService.ContentGroup.IMAGE) ?
            this.apiService.contentApi.getRenditionUrl(nodeId, ViewUtilService.ContentGroup.PDF) :
            this.apiService.contentApi.getContentUrl(nodeId, false);
    }
    /**
     * @private
     * @param {?} nodeId
     * @param {?} renditionId
     * @param {?} retries
     * @return {?}
     */
    waitRendition(nodeId, renditionId, retries) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const rendition = yield this.apiService.renditionsApi.getRendition(nodeId, renditionId);
            if (this.maxRetries < retries) {
                /** @type {?} */
                const status = rendition.entry.status.toString();
                if (status === 'CREATED') {
                    return rendition;
                }
                else {
                    retries += 1;
                    yield this.wait(1000);
                    return yield this.waitRendition(nodeId, renditionId, retries);
                }
            }
        });
    }
    /**
     * @param {?} mimeType
     * @return {?}
     */
    getViewerTypeByMimeType(mimeType) {
        if (mimeType) {
            mimeType = mimeType.toLowerCase();
            /** @type {?} */
            const editorTypes = Object.keys(this.mimeTypes);
            for (const type of editorTypes) {
                if (this.mimeTypes[type].indexOf(mimeType) >= 0) {
                    return type;
                }
            }
        }
        return 'unknown';
    }
    /**
     * @param {?} ms
     * @return {?}
     */
    wait(ms) {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => setTimeout(resolve, ms)));
    }
    /**
     * @param {?} nodeId
     * @param {?} renditionId
     * @return {?}
     */
    getRendition(nodeId, renditionId) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const renditionPaging = yield this.apiService.renditionsApi.getRenditions(nodeId);
            /** @type {?} */
            let rendition = renditionPaging.list.entries.find((/**
             * @param {?} renditionEntry
             * @return {?}
             */
            (renditionEntry) => renditionEntry.entry.id.toLowerCase() === renditionId));
            if (rendition) {
                /** @type {?} */
                const status = rendition.entry.status.toString();
                if (status === 'NOT_CREATED') {
                    try {
                        yield this.apiService.renditionsApi.createRendition(nodeId, { id: renditionId });
                        rendition = yield this.waitRendition(nodeId, renditionId, 0);
                    }
                    catch (err) {
                        this.logService.error(err);
                    }
                }
            }
            return new Promise((/**
             * @param {?} resolve
             * @return {?}
             */
            (resolve) => resolve(rendition)));
        });
    }
}
ViewUtilService.TARGET = '_new';
/**
 * Content groups based on categorization of files that can be viewed in the web browser. This
 * implementation or grouping is tied to the definition the ng component: ViewerComponent
 */
// tslint:disable-next-line:variable-name
ViewUtilService.ContentGroup = {
    IMAGE: 'image',
    MEDIA: 'media',
    PDF: 'pdf',
    TEXT: 'text'
};
ViewUtilService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ViewUtilService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ ViewUtilService.ngInjectableDef = defineInjectable({ factory: function ViewUtilService_Factory() { return new ViewUtilService(inject(AlfrescoApiService), inject(LogService)); }, token: ViewUtilService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PreviousRouteService {
    /**
     * @param {?} router
     */
    constructor(router) {
        this.router = router;
        this.currentUrl = this.router.url;
        this.router.events.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (event instanceof NavigationEnd) {
                this.previousUrl = this.currentUrl;
                this.currentUrl = event.url;
            }
        }));
    }
    /**
     * @return {?}
     */
    getPreviousUrl() {
        return this.previousUrl;
    }
}
PreviousRouteService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PreviousRouteService.ctorParameters = () => [
    { type: Router }
];
/** @nocollapse */ PreviousRouteService.ngInjectableDef = defineInjectable({ factory: function PreviousRouteService_Factory() { return new PreviousRouteService(inject(Router)); }, token: PreviousRouteService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewerMoreActionsComponent {
}
ViewerMoreActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-more-actions',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-more-actions' },
                template: `<ng-content></ng-content>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewerOpenWithComponent {
}
ViewerOpenWithComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-open-with',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-open-with' },
                template: `<ng-content></ng-content>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewerSidebarComponent {
}
ViewerSidebarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-sidebar',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-sidebar' },
                template: `<ng-content></ng-content>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewerToolbarComponent {
}
ViewerToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-toolbar',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-toolbar' },
                template: `<ng-content></ng-content>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewerComponent {
    /**
     * @param {?} apiService
     * @param {?} viewUtils
     * @param {?} logService
     * @param {?} location
     * @param {?} extensionService
     * @param {?} el
     * @param {?} router
     * @param {?} previousRouteService
     */
    constructor(apiService, viewUtils, logService, location, extensionService, el, router, previousRouteService) {
        this.apiService = apiService;
        this.viewUtils = viewUtils;
        this.logService = logService;
        this.location = location;
        this.extensionService = extensionService;
        this.el = el;
        this.router = router;
        this.previousRouteService = previousRouteService;
        /**
         * If you want to load an external file that does not come from ACS you
         * can use this URL to specify where to load the file from.
         */
        this.urlFile = '';
        /**
         * Viewer to use with the `urlFile` address (`pdf`, `image`, `media`, `text`).
         * Used when `urlFile` has no filename and extension.
         */
        this.urlFileViewer = null;
        /**
         * Node Id of the file to load.
         */
        this.nodeId = null;
        /**
         * Shared link id (to display shared file).
         */
        this.sharedLinkId = null;
        /**
         * If `true` then show the Viewer as a full page over the current content.
         * Otherwise fit inside the parent div.
         */
        this.overlayMode = false;
        /**
         * Hide or show the viewer
         */
        this.showViewer = true;
        /**
         * Hide or show the toolbar
         */
        this.showToolbar = true;
        /**
         * Allows `back` navigation
         */
        this.allowGoBack = true;
        /**
         * Toggles downloading.
         */
        this.allowDownload = true;
        /**
         * Toggles printing.
         */
        this.allowPrint = false;
        /**
         * Toggles the 'Full Screen' feature.
         */
        this.allowFullScreen = true;
        /**
         * Toggles before/next navigation. You can use the arrow buttons to navigate
         * between documents in the collection.
         */
        this.allowNavigate = false;
        /**
         * Toggles the "before" ("<") button. Requires `allowNavigate` to be enabled.
         */
        this.canNavigateBefore = true;
        /**
         * Toggles the next (">") button. Requires `allowNavigate` to be enabled.
         */
        this.canNavigateNext = true;
        /**
         * Allow the left the sidebar.
         */
        this.allowLeftSidebar = false;
        /**
         * Allow the right sidebar.
         */
        this.allowRightSidebar = false;
        /**
         * Toggles PDF thumbnails.
         */
        this.allowThumbnails = true;
        /**
         * Toggles right sidebar visibility. Requires `allowRightSidebar` to be set to `true`.
         */
        this.showRightSidebar = false;
        /**
         * Toggles left sidebar visibility. Requires `allowLeftSidebar` to be set to `true`.
         */
        this.showLeftSidebar = false;
        /**
         * The template for the right sidebar. The template context contains the loaded node data.
         */
        this.sidebarRightTemplate = null;
        /**
         * The template for the left sidebar. The template context contains the loaded node data.
         */
        this.sidebarLeftTemplate = null;
        /**
         * The template for the pdf thumbnails.
         */
        this.thumbnailsTemplate = null;
        /**
         * Number of times the Viewer will retry fetching content Rendition.
         * There is a delay of at least one second between attempts.
         */
        this.maxRetries = 10;
        /**
         * Emitted when user clicks the 'Back' button.
         */
        this.goBack = new EventEmitter();
        /**
         * Emitted when user clicks the 'Print' button.
         */
        this.print = new EventEmitter();
        /**
         * Emitted when the viewer is shown or hidden.
         */
        this.showViewerChange = new EventEmitter();
        /**
         * Emitted when the filename extension changes.
         */
        this.extensionChange = new EventEmitter();
        /**
         * Emitted when user clicks 'Navigate Before' ("<") button.
         */
        this.navigateBefore = new EventEmitter();
        /**
         * Emitted when user clicks 'Navigate Next' (">") button.
         */
        this.navigateNext = new EventEmitter();
        /**
         * Emitted when the shared link used is not valid.
         */
        this.invalidSharedLink = new EventEmitter();
        this.viewerType = 'unknown';
        this.isLoading = false;
        this.extensionTemplates = [];
        this.externalExtensions = [];
        this.sidebarRightTemplateContext = { node: null };
        this.sidebarLeftTemplateContext = { node: null };
        this.viewerExtensions = [];
        this.subscriptions = [];
        // Extensions that are supported by the Viewer without conversion
        this.extensions = {
            image: ['png', 'jpg', 'jpeg', 'gif', 'bpm', 'svg'],
            media: ['wav', 'mp4', 'mp3', 'webm', 'ogg'],
            text: ['txt', 'xml', 'html', 'json', 'ts', 'css', 'md'],
            pdf: ['pdf']
        };
        // Mime types that are supported by the Viewer without conversion
        this.mimeTypes = {
            text: ['text/plain', 'text/csv', 'text/xml', 'text/html', 'application/x-javascript'],
            pdf: ['application/pdf'],
            image: ['image/png', 'image/jpeg', 'image/gif', 'image/bmp', 'image/svg+xml'],
            media: ['video/mp4', 'video/webm', 'video/ogg', 'audio/mpeg', 'audio/ogg', 'audio/wav']
        };
    }
    /**
     * @return {?}
     */
    isSourceDefined() {
        return (this.urlFile || this.blobFile || this.nodeId || this.sharedLinkId) ? true : false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.apiService.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => this.onNodeUpdated(node))));
        this.loadExtensions();
    }
    /**
     * @private
     * @return {?}
     */
    loadExtensions() {
        this.viewerExtensions = this.extensionService.getViewerExtensions();
        this.viewerExtensions
            .forEach((/**
         * @param {?} extension
         * @return {?}
         */
        (extension) => {
            this.externalExtensions.push(extension.fileExtension);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => subscription.unsubscribe()));
        this.subscriptions = [];
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    onNodeUpdated(node) {
        if (node && node.id === this.nodeId) {
            this.generateCacheBusterNumber();
            this.isLoading = true;
            this.setUpNodeFile(node).then((/**
             * @return {?}
             */
            () => {
                this.isLoading = false;
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.showViewer) {
            if (!this.isSourceDefined()) {
                throw new Error('A content source attribute value is missing.');
            }
            this.isLoading = true;
            if (this.blobFile) {
                this.setUpBlobData();
                this.isLoading = false;
            }
            else if (this.urlFile) {
                this.setUpUrlFile();
                this.isLoading = false;
            }
            else if (this.nodeId) {
                this.apiService.nodesApi.getNode(this.nodeId, { include: ['allowableOperations'] }).then((/**
                 * @param {?} node
                 * @return {?}
                 */
                (node) => {
                    this.nodeEntry = node;
                    this.setUpNodeFile(node.entry).then((/**
                     * @return {?}
                     */
                    () => {
                        this.isLoading = false;
                    }));
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                (error) => {
                    this.isLoading = false;
                    this.logService.error('This node does not exist');
                }));
            }
            else if (this.sharedLinkId) {
                this.allowGoBack = false;
                this.apiService.sharedLinksApi.getSharedLink(this.sharedLinkId).then((/**
                 * @param {?} sharedLinkEntry
                 * @return {?}
                 */
                (sharedLinkEntry) => {
                    this.setUpSharedLinkFile(sharedLinkEntry);
                    this.isLoading = false;
                }), (/**
                 * @return {?}
                 */
                () => {
                    this.isLoading = false;
                    this.logService.error('This sharedLink does not exist');
                    this.invalidSharedLink.next();
                }));
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    setUpBlobData() {
        this.fileTitle = this.getDisplayName('Unknown');
        this.mimeType = this.blobFile.type;
        this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
        this.allowDownload = false;
        // TODO: wrap blob into the data url and allow downloading
        this.extensionChange.emit(this.mimeType);
        this.scrollTop();
    }
    /**
     * @private
     * @return {?}
     */
    setUpUrlFile() {
        /** @type {?} */
        const filenameFromUrl = this.getFilenameFromUrl(this.urlFile);
        this.fileTitle = this.getDisplayName(filenameFromUrl);
        this.extension = this.getFileExtension(filenameFromUrl);
        this.urlFileContent = this.urlFile;
        this.fileName = this.displayName;
        this.viewerType = this.urlFileViewer || this.getViewerTypeByExtension(this.extension);
        if (this.viewerType === 'unknown') {
            this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
        }
        this.extensionChange.emit(this.extension);
        this.scrollTop();
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    setUpNodeFile(data) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            let setupNode;
            if (data.content) {
                this.mimeType = data.content.mimeType;
            }
            this.fileTitle = this.getDisplayName(data.name);
            this.urlFileContent = this.apiService.contentApi.getContentUrl(data.id);
            this.urlFileContent = this.cacheBusterNumber ? this.urlFileContent + '&' + this.cacheBusterNumber : this.urlFileContent;
            this.extension = this.getFileExtension(data.name);
            this.fileName = data.name;
            this.viewerType = this.getViewerTypeByExtension(this.extension);
            if (this.viewerType === 'unknown') {
                this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
            }
            if (this.viewerType === 'unknown') {
                setupNode = this.displayNodeRendition(data.id);
            }
            this.extensionChange.emit(this.extension);
            this.sidebarRightTemplateContext.node = data;
            this.sidebarLeftTemplateContext.node = data;
            this.scrollTop();
            return setupNode;
        });
    }
    /**
     * @private
     * @param {?} details
     * @return {?}
     */
    setUpSharedLinkFile(details) {
        this.mimeType = details.entry.content.mimeType;
        this.fileTitle = this.getDisplayName(details.entry.name);
        this.extension = this.getFileExtension(details.entry.name);
        this.fileName = details.entry.name;
        this.urlFileContent = this.apiService.contentApi.getSharedLinkContentUrl(this.sharedLinkId, false);
        this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
        if (this.viewerType === 'unknown') {
            this.viewerType = this.getViewerTypeByExtension(this.extension);
        }
        if (this.viewerType === 'unknown') {
            this.displaySharedLinkRendition(this.sharedLinkId);
        }
        this.extensionChange.emit(this.extension);
    }
    /**
     * @return {?}
     */
    toggleSidebar() {
        this.showRightSidebar = !this.showRightSidebar;
        if (this.showRightSidebar && this.nodeId) {
            this.apiService.getInstance().nodes.getNode(this.nodeId, { include: ['allowableOperations'] })
                .then((/**
             * @param {?} nodeEntry
             * @return {?}
             */
            (nodeEntry) => {
                this.sidebarRightTemplateContext.node = nodeEntry.entry;
            }));
        }
    }
    /**
     * @return {?}
     */
    toggleLeftSidebar() {
        this.showLeftSidebar = !this.showLeftSidebar;
        if (this.showRightSidebar && this.nodeId) {
            this.apiService.getInstance().nodes.getNode(this.nodeId, { include: ['allowableOperations'] })
                .then((/**
             * @param {?} nodeEntry
             * @return {?}
             */
            (nodeEntry) => {
                this.sidebarLeftTemplateContext.node = nodeEntry.entry;
            }));
        }
    }
    /**
     * @private
     * @param {?} name
     * @return {?}
     */
    getDisplayName(name) {
        return this.displayName || name;
    }
    /**
     * @return {?}
     */
    scrollTop() {
        window.scrollTo(0, 1);
    }
    /**
     * @param {?} mimeType
     * @return {?}
     */
    getViewerTypeByMimeType(mimeType) {
        if (mimeType) {
            mimeType = mimeType.toLowerCase();
            /** @type {?} */
            const editorTypes = Object.keys(this.mimeTypes);
            for (const type of editorTypes) {
                if (this.mimeTypes[type].indexOf(mimeType) >= 0) {
                    return type;
                }
            }
        }
        return 'unknown';
    }
    /**
     * @param {?} extension
     * @return {?}
     */
    getViewerTypeByExtension(extension) {
        if (extension) {
            extension = extension.toLowerCase();
        }
        if (this.isCustomViewerExtension(extension)) {
            return 'custom';
        }
        if (this.extensions.image.indexOf(extension) >= 0) {
            return 'image';
        }
        if (this.extensions.media.indexOf(extension) >= 0) {
            return 'media';
        }
        if (this.extensions.text.indexOf(extension) >= 0) {
            return 'text';
        }
        if (this.extensions.pdf.indexOf(extension) >= 0) {
            return 'pdf';
        }
        return 'unknown';
    }
    /**
     * @return {?}
     */
    onBackButtonClick() {
        if (this.overlayMode) {
            this.close();
        }
        else {
            /** @type {?} */
            const event = new BaseEvent();
            this.goBack.next(event);
            if (!event.defaultPrevented) {
                /** @type {?} */
                const previousUrl = this.previousRouteService.getPreviousUrl();
                if (previousUrl && previousUrl.includes('login') || window.history.length <= 2) {
                    this.router.navigate([{ outlets: { overlay: null, primary: ['home'] } }]);
                }
                else {
                    this.location.back();
                }
            }
        }
    }
    /**
     * @return {?}
     */
    onNavigateBeforeClick() {
        this.navigateBefore.next();
    }
    /**
     * @return {?}
     */
    onNavigateNextClick() {
        this.navigateNext.next();
    }
    /**
     * close the viewer
     * @return {?}
     */
    close() {
        if (this.otherMenu) {
            this.otherMenu.hidden = false;
        }
        this.showViewer = false;
        this.showViewerChange.emit(this.showViewer);
    }
    /**
     * get File name from url
     *
     * @param {?} url - url file
     * @return {?}
     */
    getFilenameFromUrl(url) {
        /** @type {?} */
        const anchor = url.indexOf('#');
        /** @type {?} */
        const query$$1 = url.indexOf('?');
        /** @type {?} */
        const end = Math.min(anchor > 0 ? anchor : url.length, query$$1 > 0 ? query$$1 : url.length);
        return url.substring(url.lastIndexOf('/', end) + 1, end);
    }
    /**
     * Get file extension from the string.
     * Supports the URL formats like:
     * http://localhost/test.jpg?cache=1000
     * http://localhost/test.jpg#cache=1000
     *
     * @param {?} fileName - file name
     * @return {?}
     */
    getFileExtension(fileName) {
        if (fileName) {
            /** @type {?} */
            const match = fileName.match(/\.([^\./\?\#]+)($|\?|\#)/);
            return match ? match[1] : null;
        }
        return null;
    }
    /**
     * @param {?} extension
     * @return {?}
     */
    isCustomViewerExtension(extension) {
        /** @type {?} */
        const extensions = this.externalExtensions || [];
        if (extension && extensions.length > 0) {
            extension = extension.toLowerCase();
            return extensions.flat().indexOf(extension) >= 0;
        }
        return false;
    }
    /**
     * Keyboard event listener
     * @param {?} event
     * @return {?}
     */
    handleKeyboardEvent(event) {
        /** @type {?} */
        const key = event.keyCode;
        // Esc
        if (key === 27 && this.overlayMode) { // esc
            this.close();
        }
        // Left arrow
        if (key === 37 && this.canNavigateBefore) {
            event.preventDefault();
            this.onNavigateBeforeClick();
        }
        // Right arrow
        if (key === 39 && this.canNavigateNext) {
            event.preventDefault();
            this.onNavigateNextClick();
        }
        // Ctrl+F
        if (key === 70 && event.ctrlKey) {
            event.preventDefault();
            this.enterFullScreen();
        }
    }
    /**
     * @return {?}
     */
    printContent() {
        if (this.allowPrint) {
            /** @type {?} */
            const args = new BaseEvent();
            this.print.next(args);
            if (!args.defaultPrevented) {
                this.viewUtils.printFileGeneric(this.nodeId, this.mimeType);
            }
        }
    }
    /**
     * Triggers full screen mode with a main content area displayed.
     * @return {?}
     */
    enterFullScreen() {
        if (this.allowFullScreen) {
            /** @type {?} */
            const container = this.el.nativeElement.querySelector('.adf-viewer__fullscreen-container');
            if (container) {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                }
                else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                }
                else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                }
                else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
            }
        }
    }
    /**
     * @private
     * @param {?} nodeId
     * @return {?}
     */
    displayNodeRendition(nodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                /** @type {?} */
                const rendition = yield this.resolveRendition(nodeId, 'pdf');
                if (rendition) {
                    /** @type {?} */
                    const renditionId = rendition.entry.id;
                    if (renditionId === 'pdf') {
                        this.viewerType = 'pdf';
                    }
                    else if (renditionId === 'imgpreview') {
                        this.viewerType = 'image';
                    }
                    this.urlFileContent = this.apiService.contentApi.getRenditionUrl(nodeId, renditionId);
                }
            }
            catch (err) {
                this.logService.error(err);
            }
        });
    }
    /**
     * @private
     * @param {?} sharedId
     * @return {?}
     */
    displaySharedLinkRendition(sharedId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                /** @type {?} */
                const rendition = yield this.apiService.renditionsApi.getSharedLinkRendition(sharedId, 'pdf');
                if (rendition.entry.status.toString() === 'CREATED') {
                    this.viewerType = 'pdf';
                    this.urlFileContent = this.apiService.contentApi.getSharedLinkRenditionUrl(sharedId, 'pdf');
                }
            }
            catch (error) {
                this.logService.error(error);
                try {
                    /** @type {?} */
                    const rendition = yield this.apiService.renditionsApi.getSharedLinkRendition(sharedId, 'imgpreview');
                    if (rendition.entry.status.toString() === 'CREATED') {
                        this.viewerType = 'image';
                        this.urlFileContent = this.apiService.contentApi.getSharedLinkRenditionUrl(sharedId, 'imgpreview');
                    }
                }
                catch (error) {
                    this.logService.error(error);
                }
            }
        });
    }
    /**
     * @private
     * @param {?} nodeId
     * @param {?} renditionId
     * @return {?}
     */
    resolveRendition(nodeId, renditionId) {
        return __awaiter(this, void 0, void 0, function* () {
            renditionId = renditionId.toLowerCase();
            /** @type {?} */
            const supportedRendition = yield this.apiService.renditionsApi.getRenditions(nodeId);
            /** @type {?} */
            let rendition = supportedRendition.list.entries.find((/**
             * @param {?} renditionEntry
             * @return {?}
             */
            (renditionEntry) => renditionEntry.entry.id.toLowerCase() === renditionId));
            if (!rendition) {
                renditionId = 'imgpreview';
                rendition = supportedRendition.list.entries.find((/**
                 * @param {?} renditionEntry
                 * @return {?}
                 */
                (renditionEntry) => renditionEntry.entry.id.toLowerCase() === renditionId));
            }
            if (rendition) {
                /** @type {?} */
                const status = rendition.entry.status.toString();
                if (status === 'NOT_CREATED') {
                    try {
                        yield this.apiService.renditionsApi.createRendition(nodeId, { id: renditionId }).then((/**
                         * @return {?}
                         */
                        () => {
                            this.viewerType = 'in_creation';
                        }));
                        rendition = yield this.waitRendition(nodeId, renditionId);
                    }
                    catch (err) {
                        this.logService.error(err);
                    }
                }
            }
            return rendition;
        });
    }
    /**
     * @private
     * @param {?} nodeId
     * @param {?} renditionId
     * @return {?}
     */
    waitRendition(nodeId, renditionId) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            let currentRetry = 0;
            return new Promise((/**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */
            (resolve, reject) => {
                /** @type {?} */
                const intervalId = setInterval((/**
                 * @return {?}
                 */
                () => {
                    currentRetry++;
                    if (this.maxRetries >= currentRetry) {
                        this.apiService.renditionsApi.getRendition(nodeId, renditionId).then((/**
                         * @param {?} rendition
                         * @return {?}
                         */
                        (rendition) => {
                            /** @type {?} */
                            const status = rendition.entry.status.toString();
                            if (status === 'CREATED') {
                                if (renditionId === 'pdf') {
                                    this.viewerType = 'pdf';
                                }
                                else if (renditionId === 'imgpreview') {
                                    this.viewerType = 'image';
                                }
                                this.urlFileContent = this.apiService.contentApi.getRenditionUrl(nodeId, renditionId);
                                clearInterval(intervalId);
                                return resolve(rendition);
                            }
                        }), (/**
                         * @return {?}
                         */
                        () => {
                            this.viewerType = 'error_in_creation';
                            return reject();
                        }));
                    }
                }), 1000);
            }));
        });
    }
    /**
     * @param {?} extensionAllowed
     * @return {?}
     */
    checkExtensions(extensionAllowed) {
        if (typeof extensionAllowed === 'string') {
            return this.extension.toLowerCase() === extensionAllowed.toLowerCase();
        }
        else if (extensionAllowed.length > 0) {
            return extensionAllowed.find((/**
             * @param {?} currentExtension
             * @return {?}
             */
            (currentExtension) => {
                return this.extension.toLowerCase() === currentExtension.toLowerCase();
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    generateCacheBusterNumber() {
        this.cacheBusterNumber = Date.now();
    }
}
ViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer',
                template: "<div *ngIf=\"showViewer\"\n     class=\"adf-viewer-container\"\n     [class.adf-viewer-overlay-container]=\"overlayMode\"\n     [class.adf-viewer-inline-container]=\"!overlayMode\">\n\n    <div class=\"adf-viewer-content\" fxLayout=\"column\">\n        <ng-content select=\"adf-viewer-toolbar\"></ng-content>\n        <ng-container *ngIf=\"showToolbar && !toolbar\">\n            <adf-toolbar color=\"default\" id=\"adf-viewer-toolbar\" class=\"adf-viewer-toolbar\">\n\n                <adf-toolbar-title>\n\n                    <ng-container *ngIf=\"allowLeftSidebar\">\n                        <button\n                            mat-icon-button\n                            title=\"{{ 'ADF_VIEWER.ACTIONS.INFO' | translate }}\"\n                            data-automation-id=\"adf-toolbar-left-sidebar\"\n                            [color]=\"showLeftSidebar ? 'accent' : 'default'\"\n                            (click)=\"toggleLeftSidebar()\">\n                            <mat-icon>info_outline</mat-icon>\n                        </button>\n                    </ng-container>\n\n                    <button *ngIf=\"allowGoBack\"\n                            class=\"adf-viewer-close-button\"\n                            data-automation-id=\"adf-toolbar-back\"\n                            mat-icon-button\n                            title=\"{{ 'ADF_VIEWER.ACTIONS.CLOSE' | translate }}\"\n                            (click)=\"onBackButtonClick()\">\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </adf-toolbar-title>\n\n                <div fxFlex=\"1 1 auto\" class=\"adf-viewer__file-title\">\n                    <button\n                        *ngIf=\"allowNavigate && canNavigateBefore\"\n                        data-automation-id=\"adf-toolbar-pref-file\"\n                        mat-icon-button\n                        title=\"{{ 'ADF_VIEWER.ACTIONS.PREV_FILE' | translate }}\"\n                        (click)=\"onNavigateBeforeClick()\">\n                        <mat-icon>navigate_before</mat-icon>\n                    </button>\n                    <img class=\"adf-viewer__mimeicon\" [alt]=\"mimeType | adfMimeTypeIcon\" [src]=\"mimeType | adfMimeTypeIcon\" data-automation-id=\"adf-file-thumbnail\">\n                    <span class=\"adf-viewer__display-name\" id=\"adf-viewer-display-name\">{{ fileTitle }}</span>\n                    <button\n                        *ngIf=\"allowNavigate && canNavigateNext\"\n                        data-automation-id=\"adf-toolbar-next-file\"\n                        mat-icon-button\n                        title=\"{{ 'ADF_VIEWER.ACTIONS.NEXT_FILE' | translate }}\"\n                        (click)=\"onNavigateNextClick()\">\n                        <mat-icon>navigate_next</mat-icon>\n                    </button>\n                </div>\n\n                <ng-content select=\"adf-viewer-toolbar-actions\"></ng-content>\n\n                <ng-container *ngIf=\"mnuOpenWith\" data-automation-id='adf-toolbar-custom-btn'>\n                    <button\n                        id=\"adf-viewer-openwith\"\n                        mat-button\n                        [matMenuTriggerFor]=\"mnuOpenWith\"\n                        data-automation-id=\"adf-toolbar-open-with\">\n                        <span>{{ 'ADF_VIEWER.ACTIONS.OPEN_WITH' | translate }}</span>\n                        <mat-icon>arrow_drop_down</mat-icon>\n                    </button>\n                    <mat-menu #mnuOpenWith=\"matMenu\" [overlapTrigger]=\"false\">\n                        <ng-content select=\"adf-viewer-open-with\"></ng-content>\n                    </mat-menu>\n                </ng-container>\n\n                <adf-toolbar-divider></adf-toolbar-divider>\n\n                <button\n                    id=\"adf-viewer-download\"\n                    *ngIf=\"allowDownload\"\n                    mat-icon-button\n                    title=\"{{ 'ADF_VIEWER.ACTIONS.DOWNLOAD' | translate }}\"\n                    data-automation-id=\"adf-toolbar-download\"\n                    [adfNodeDownload]=\"nodeEntry\">\n                    <mat-icon>file_download</mat-icon>\n                </button>\n\n                <button\n                    id=\"adf-viewer-print\"\n                    *ngIf=\"allowPrint\"\n                    mat-icon-button\n                    title=\"{{ 'ADF_VIEWER.ACTIONS.PRINT' | translate }}\"\n                    data-automation-id=\"adf-toolbar-print\"\n                    (click)=\"printContent()\">\n                    <mat-icon>print</mat-icon>\n                </button>\n\n                <button\n                    id=\"adf-viewer-fullscreen\"\n                    *ngIf=\"viewerType !== 'media' && allowFullScreen\"\n                    mat-icon-button\n                    title=\"{{ 'ADF_VIEWER.ACTIONS.FULLSCREEN' | translate }}\"\n                    data-automation-id=\"adf-toolbar-fullscreen\"\n                    (click)=\"enterFullScreen()\">\n                    <mat-icon>fullscreen</mat-icon>\n                </button>\n\n                <ng-container *ngIf=\"allowRightSidebar\">\n                    <adf-toolbar-divider></adf-toolbar-divider>\n\n                    <button\n                        mat-icon-button\n                        title=\"{{ 'ADF_VIEWER.ACTIONS.INFO' | translate }}\"\n                        data-automation-id=\"adf-toolbar-sidebar\"\n                        [color]=\"showRightSidebar ? 'accent' : 'default'\"\n                        (click)=\"toggleSidebar()\">\n                        <mat-icon>info_outline</mat-icon>\n                    </button>\n\n                </ng-container>\n\n                <ng-container *ngIf=\"mnuMoreActions\">\n                    <button\n                        id=\"adf-viewer-moreactions\"\n                        mat-icon-button\n                        [matMenuTriggerFor]=\"mnuMoreActions\"\n                        title=\"{{ 'ADF_VIEWER.ACTIONS.MORE_ACTIONS' | translate }}\"\n                        data-automation-id=\"adf-toolbar-more-actions\">\n                        <mat-icon>more_vert</mat-icon>\n                    </button>\n                    <mat-menu #mnuMoreActions=\"matMenu\" [overlapTrigger]=\"false\">\n                        <ng-content select=\"adf-viewer-more-actions\"></ng-content>\n                    </mat-menu>\n                </ng-container>\n\n            </adf-toolbar>\n        </ng-container>\n\n        <div fxLayout=\"row\" fxFlex=\"1 1 auto\">\n            <ng-container *ngIf=\"allowRightSidebar && showRightSidebar\">\n                <div class=\"adf-viewer__sidebar\" [ngClass]=\"'adf-viewer__sidebar__right'\" fxFlexOrder=\"4\"  id=\"adf-right-sidebar\" >\n                    <ng-container *ngIf=\"sidebarRightTemplate\">\n                        <ng-container *ngTemplateOutlet=\"sidebarRightTemplate;context:sidebarRightTemplateContext\"></ng-container>\n                    </ng-container>\n                    <ng-content *ngIf=\"!sidebarRightTemplate\" select=\"adf-viewer-sidebar\"></ng-content>\n                </div>\n            </ng-container>\n\n            <ng-container *ngIf=\"allowLeftSidebar && showLeftSidebar\">\n                <div class=\"adf-viewer__sidebar\" [ngClass]=\"'adf-viewer__sidebar__left'\" fxFlexOrder=\"1\"  id=\"adf-left-sidebar\" >\n                    <ng-container *ngIf=\"sidebarLeftTemplate\">\n                        <ng-container *ngTemplateOutlet=\"sidebarLeftTemplate;context:sidebarLeftTemplateContext\"></ng-container>\n                    </ng-container>\n                    <ng-content *ngIf=\"!sidebarLeftTemplate\" select=\"adf-viewer-sidebar\"></ng-content>\n                </div>\n            </ng-container>\n\n            <div  *ngIf=\"isLoading\"  class=\"adf-viewer-main\" fxFlexOrder=\"1\" fxFlex=\"1 1 auto\">\n                <div class=\"adf-viewer-layout-content adf-viewer__fullscreen-container\">\n                    <div class=\"adf-viewer-content-container\">\n                        <ng-container *ngIf=\"isLoading\">\n                            <div class=\"adf-viewer__loading-screen\" fxFlex=\"1 1 auto\">\n                                <h2>{{ 'ADF_VIEWER.LOADING' | translate }}</h2>\n                                <div>\n                                    <mat-spinner></mat-spinner>\n                                </div>\n                            </div>\n                        </ng-container>\n\n                    </div>\n                </div>\n            </div>\n\n            <div  *ngIf=\"!isLoading\"  class=\"adf-viewer-main\" fxFlexOrder=\"1\" fxFlex=\"1 1 auto\">\n                <div class=\"adf-viewer-layout-content adf-viewer__fullscreen-container\">\n                    <div class=\"adf-viewer-content-container\" [ngSwitch]=\"viewerType\">\n\n                        <ng-container *ngSwitchCase=\"'pdf'\">\n                            <adf-pdf-viewer [thumbnailsTemplate]=\"thumbnailsTemplate\" [allowThumbnails]=\"allowThumbnails\" [blobFile]=\"blobFile\" [urlFile]=\"urlFileContent\" [nameFile]=\"displayName\"></adf-pdf-viewer>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'image'\">\n                            <adf-img-viewer [urlFile]=\"urlFileContent\" [nameFile]=\"displayName\" [blobFile]=\"blobFile\"></adf-img-viewer>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'media'\">\n                            <adf-media-player id=\"adf-mdedia-player\" [urlFile]=\"urlFileContent\" [mimeType]=\"mimeType\" [blobFile]=\"blobFile\" [nameFile]=\"displayName\"></adf-media-player>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'text'\">\n                            <adf-txt-viewer [urlFile]=\"urlFileContent\" [blobFile]=\"blobFile\"></adf-txt-viewer>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'in_creation'\">\n                            <div class=\"adf-viewer__loading-screen\" fxFlex=\"1 1 auto\">\n                                <h2>{{ 'ADF_VIEWER.LOADING' | translate }}</h2>\n                                <div>\n                                    <mat-spinner></mat-spinner>\n                                </div>\n                            </div>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'custom'\">\n                            <ng-container *ngFor=\"let ext of viewerExtensions\">\n                                <adf-preview-extension\n                                    *ngIf=\"checkExtensions(ext.fileExtension)\"\n                                    [id]=\"ext.component\"\n                                    [node]=\"nodeEntry.entry\"\n                                    [url]=\"urlFileContent\"\n                                    [extension]=\"extension\"\n                                    [attr.data-automation-id]=\"ext.component\">\n                                </adf-preview-extension>\n                            </ng-container>\n\n                            <span class=\"adf-viewer-custom-content\" *ngFor=\"let extensionTemplate of extensionTemplates\">\n                                <ng-template\n                                    *ngIf=\"extensionTemplate.isVisible\"\n                                    [ngTemplateOutlet]=\"extensionTemplate.template\"\n                                    [ngTemplateOutletContext]=\"{ urlFileContent: urlFileContent, extension:extension }\">\n                                </ng-template>\n                            </span>\n                        </ng-container>\n\n                        <ng-container *ngSwitchDefault>\n                            <adf-viewer-unknown-format></adf-viewer-unknown-format>\n                        </ng-container>\n                    </div>\n                </div>\n            </div>\n\n        </div>\n    </div>\n</div>\n",
                host: { 'class': 'adf-viewer' },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
ViewerComponent.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: ViewUtilService },
    { type: LogService },
    { type: Location },
    { type: AppExtensionService },
    { type: ElementRef },
    { type: Router },
    { type: PreviousRouteService }
];
ViewerComponent.propDecorators = {
    toolbar: [{ type: ContentChild, args: [ViewerToolbarComponent,] }],
    sidebar: [{ type: ContentChild, args: [ViewerSidebarComponent,] }],
    mnuOpenWith: [{ type: ContentChild, args: [ViewerOpenWithComponent,] }],
    mnuMoreActions: [{ type: ContentChild, args: [ViewerMoreActionsComponent,] }],
    urlFile: [{ type: Input }],
    urlFileViewer: [{ type: Input }],
    blobFile: [{ type: Input }],
    nodeId: [{ type: Input }],
    sharedLinkId: [{ type: Input }],
    overlayMode: [{ type: Input }],
    showViewer: [{ type: Input }],
    showToolbar: [{ type: Input }],
    displayName: [{ type: Input }],
    allowGoBack: [{ type: Input }],
    allowDownload: [{ type: Input }],
    allowPrint: [{ type: Input }],
    allowFullScreen: [{ type: Input }],
    allowNavigate: [{ type: Input }],
    canNavigateBefore: [{ type: Input }],
    canNavigateNext: [{ type: Input }],
    allowLeftSidebar: [{ type: Input }],
    allowRightSidebar: [{ type: Input }],
    allowThumbnails: [{ type: Input }],
    showRightSidebar: [{ type: Input }],
    showLeftSidebar: [{ type: Input }],
    sidebarRightTemplate: [{ type: Input }],
    sidebarLeftTemplate: [{ type: Input }],
    thumbnailsTemplate: [{ type: Input }],
    mimeType: [{ type: Input }],
    fileName: [{ type: Input }],
    maxRetries: [{ type: Input }],
    goBack: [{ type: Output }],
    print: [{ type: Output }],
    showViewerChange: [{ type: Output }],
    extensionChange: [{ type: Output }],
    navigateBefore: [{ type: Output }],
    navigateNext: [{ type: Output }],
    invalidSharedLink: [{ type: Output }],
    handleKeyboardEvent: [{ type: HostListener, args: ['document:keyup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImgViewerComponent {
    /**
     * @param {?} appConfigService
     * @param {?} contentService
     * @param {?} el
     */
    constructor(appConfigService, contentService, el) {
        this.appConfigService = appConfigService;
        this.contentService = contentService;
        this.el = el;
        this.showToolbar = true;
        this.rotate = 0;
        this.scaleX = 1.0;
        this.scaleY = 1.0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.isDragged = false;
        this.drag = { x: 0, y: 0 };
        this.delta = { x: 0, y: 0 };
        this.initializeScaling();
    }
    /**
     * @return {?}
     */
    get transform() {
        return `scale(${this.scaleX}, ${this.scaleY}) rotate(${this.rotate}deg) translate(${this.offsetX}px, ${this.offsetY}px)`;
    }
    /**
     * @return {?}
     */
    get currentScaleText() {
        return Math.round(this.scaleX * 100) + '%';
    }
    /**
     * @return {?}
     */
    initializeScaling() {
        /** @type {?} */
        const scaling = this.appConfigService.get('adf-viewer.image-viewer-scaling', undefined) / 100;
        if (scaling) {
            this.scaleX = scaling;
            this.scaleY = scaling;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.element = (/** @type {?} */ (this.el.nativeElement.querySelector('#viewer-image')));
        if (this.element) {
            this.element.addEventListener('mousedown', this.onMouseDown.bind(this));
            this.element.addEventListener('mouseup', this.onMouseUp.bind(this));
            this.element.addEventListener('mouseleave', this.onMouseLeave.bind(this));
            this.element.addEventListener('mouseout', this.onMouseOut.bind(this));
            this.element.addEventListener('mousemove', this.onMouseMove.bind(this));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.element) {
            this.element.removeEventListener('mousedown', this.onMouseDown);
            this.element.removeEventListener('mouseup', this.onMouseUp);
            this.element.removeEventListener('mouseleave', this.onMouseLeave);
            this.element.removeEventListener('mouseout', this.onMouseOut);
            this.element.removeEventListener('mousemove', this.onMouseMove);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        event.preventDefault();
        this.isDragged = true;
        this.drag = { x: event.pageX, y: event.pageY };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        if (this.isDragged) {
            event.preventDefault();
            this.delta.x = event.pageX - this.drag.x;
            this.delta.y = event.pageY - this.drag.y;
            this.drag.x = event.pageX;
            this.drag.y = event.pageY;
            /** @type {?} */
            const scaleX = (this.scaleX !== 0 ? this.scaleX : 1.0);
            /** @type {?} */
            const scaleY = (this.scaleY !== 0 ? this.scaleY : 1.0);
            this.offsetX += (this.delta.x / scaleX);
            this.offsetY += (this.delta.y / scaleY);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        if (this.isDragged) {
            event.preventDefault();
            this.isDragged = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseLeave(event) {
        if (this.isDragged) {
            event.preventDefault();
            this.isDragged = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseOut(event) {
        if (this.isDragged) {
            event.preventDefault();
            this.isDragged = false;
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            this.urlFile = this.contentService.createTrustedUrl(this.blobFile);
            return;
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    /**
     * @return {?}
     */
    zoomIn() {
        /** @type {?} */
        const ratio = +((this.scaleX + 0.2).toFixed(1));
        this.scaleX = this.scaleY = ratio;
    }
    /**
     * @return {?}
     */
    zoomOut() {
        /** @type {?} */
        let ratio = +((this.scaleX - 0.2).toFixed(1));
        if (ratio < 0.2) {
            ratio = 0.2;
        }
        this.scaleX = this.scaleY = ratio;
    }
    /**
     * @return {?}
     */
    rotateLeft() {
        /** @type {?} */
        const angle = this.rotate - 90;
        this.rotate = Math.abs(angle) < 360 ? angle : 0;
    }
    /**
     * @return {?}
     */
    rotateRight() {
        /** @type {?} */
        const angle = this.rotate + 90;
        this.rotate = Math.abs(angle) < 360 ? angle : 0;
    }
    /**
     * @return {?}
     */
    reset() {
        this.rotate = 0;
        this.scaleX = 1.0;
        this.scaleY = 1.0;
        this.offsetX = 0;
        this.offsetY = 0;
    }
}
ImgViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-img-viewer',
                template: "<div class=\"adf-image-container\" tabindex=\"0\" role=\"img\" [attr.aria-label]=\"nameFile\" [ngStyle]=\"{ transform: transform }\" data-automation-id=\"adf-image-container\">\n    <img id=\"viewer-image\" [src]=\"urlFile\" [alt]=\"nameFile\" [ngStyle]=\"{ 'cursor' : isDragged ? 'move': 'default' } \" />\n</div>\n\n<div class=\"adf-image-viewer__toolbar\" *ngIf=\"showToolbar\">\n    <adf-toolbar>\n        <button\n            id=\"viewer-zoom-in-button\"\n            mat-icon-button\n            title=\"{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}\"\n            (click)=\"zoomIn()\">\n            <mat-icon>zoom_in</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-zoom-out-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}\"\n            mat-icon-button\n            (click)=\"zoomOut()\">\n            <mat-icon>zoom_out</mat-icon>\n        </button>\n\n        <div class=\"adf-viewer__toolbar-page-scale\" data-automation-id=\"adf-page-scale\">\n            {{ currentScaleText }}\n        </div>\n\n        <button\n            id=\"viewer-rotate-left-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.ROTATE_LEFT' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ROTATE_LEFT' | translate }}\"\n            mat-icon-button\n            (click)=\"rotateLeft()\">\n            <mat-icon>rotate_left</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-rotate-right-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.ROTATE_RIGHT' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ROTATE_RIGHT' | translate }}\"\n            mat-icon-button\n            (click)=\"rotateRight()\">\n            <mat-icon>rotate_right</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-reset-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.RESET' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.RESET' | translate }}\"\n            mat-icon-button\n            (click)=\"reset()\">\n            <mat-icon>zoom_out_map</mat-icon>\n        </button>\n    </adf-toolbar>\n</div>\n",
                host: { 'class': 'adf-image-viewer' },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
ImgViewerComponent.ctorParameters = () => [
    { type: AppConfigService },
    { type: ContentService },
    { type: ElementRef }
];
ImgViewerComponent.propDecorators = {
    showToolbar: [{ type: Input }],
    urlFile: [{ type: Input }],
    blobFile: [{ type: Input }],
    nameFile: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MediaPlayerComponent {
    /**
     * @param {?} contentService
     */
    constructor(contentService) {
        this.contentService = contentService;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            this.urlFile = this.contentService.createTrustedUrl(this.blobFile);
            return;
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
}
MediaPlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-media-player',
                template: "<video controls>\n    <source [src]=\"urlFile\" [type]=\"mimeType\" />\n</video>\n",
                host: { 'class': 'adf-media-player' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-media-player{display:flex}.adf-media-player video{display:flex;flex:1;max-height:90vh;max-width:100%}"]
            }] }
];
/** @nocollapse */
MediaPlayerComponent.ctorParameters = () => [
    { type: ContentService }
];
MediaPlayerComponent.propDecorators = {
    urlFile: [{ type: Input }],
    blobFile: [{ type: Input }],
    mimeType: [{ type: Input }],
    nameFile: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * RenderingQueueServices rendering of the views for pages and thumbnails.
 *
 */
class RenderingQueueServices {
    constructor() {
        this.renderingStates = {
            INITIAL: 0,
            RUNNING: 1,
            PAUSED: 2,
            FINISHED: 3
        };
        this.CLEANUP_TIMEOUT = 30000;
        this.pdfViewer = null;
        this.pdfThumbnailViewer = null;
        this.onIdle = null;
        this.highestPriorityPage = null;
        this.idleTimeout = null;
        this.printing = false;
        this.isThumbnailViewEnabled = false;
    }
    /**
     * @param {?} pdfViewer
     * @return {?}
     */
    setViewer(pdfViewer) {
        this.pdfViewer = pdfViewer;
    }
    /**
     * @param {?} pdfThumbnailViewer
     * @return {?}
     */
    setThumbnailViewer(pdfThumbnailViewer) {
        this.pdfThumbnailViewer = pdfThumbnailViewer;
    }
    /**
     * @param {?} view
     * @return {?}
     */
    isHighestPriority(view) {
        return this.highestPriorityPage === view.renderingId;
    }
    /**
     * @param {?} currentlyVisiblePages
     * @return {?}
     */
    renderHighestPriority(currentlyVisiblePages) {
        if (this.idleTimeout) {
            clearTimeout(this.idleTimeout);
            this.idleTimeout = null;
        }
        // Pages have a higher priority than thumbnails, so check them first.
        if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
            return;
        }
        // No pages needed rendering so check thumbnails.
        if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
            if (this.pdfThumbnailViewer.forceRendering()) {
                return;
            }
        }
        if (this.printing) {
            // If printing is currently ongoing do not reschedule cleanup.
            return;
        }
        if (this.onIdle) {
            this.idleTimeout = setTimeout(this.onIdle.bind(this), this.CLEANUP_TIMEOUT);
        }
    }
    /**
     * @param {?} visible
     * @param {?} views
     * @param {?} scrolledDown
     * @return {?}
     */
    getHighestPriority(visible, views, scrolledDown) {
        // The state has changed figure out which page has the highest priority to
        // render next (if any).
        // Priority:
        // 1 visible pages
        // 2 if last scrolled down page after the visible pages
        // 2 if last scrolled up page before the visible pages
        /** @type {?} */
        const visibleViews = visible.views;
        /** @type {?} */
        const numVisible = visibleViews.length;
        if (numVisible === 0) {
            return false;
        }
        for (let i = 0; i < numVisible; ++i) {
            /** @type {?} */
            const view = visibleViews[i].view;
            if (!this.isViewFinished(view)) {
                return view;
            }
        }
        // All the visible views have rendered, try to render next/previous pages.
        if (scrolledDown) {
            /** @type {?} */
            const nextPageIndex = visible.last.id;
            // ID's start at 1 so no need to add 1.
            if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {
                return views[nextPageIndex];
            }
        }
        else {
            /** @type {?} */
            const previousPageIndex = visible.first.id - 2;
            if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {
                return views[previousPageIndex];
            }
        }
        // Everything that needs to be rendered has been.
        return null;
    }
    /**
     * @param {?} view
     * @return {?}
     */
    isViewFinished(view) {
        return view.renderingState === this.renderingStates.FINISHED;
    }
    /**
     * Render a page or thumbnail view. This calls the appropriate function
     * based on the views state. If the view is already rendered it will return
     * false.
     * @param {?} view
     * @return {?}
     */
    renderView(view) {
        /** @type {?} */
        const state$$1 = view.renderingState;
        switch (state$$1) {
            case this.renderingStates.FINISHED:
                return false;
            case this.renderingStates.PAUSED:
                this.highestPriorityPage = view.renderingId;
                view.resume();
                break;
            case this.renderingStates.RUNNING:
                this.highestPriorityPage = view.renderingId;
                break;
            case this.renderingStates.INITIAL:
                this.highestPriorityPage = view.renderingId;
                /** @type {?} */
                const continueRendering = (/**
                 * @return {?}
                 */
                function () {
                    this.renderHighestPriority();
                }).bind(this);
                view.draw().then(continueRendering, continueRendering);
                break;
            default:
                break;
        }
        return true;
    }
}
RenderingQueueServices.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PdfPasswordDialogComponent {
    /**
     * @param {?} dialogRef
     * @param {?} data
     */
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.passwordFormControl = new FormControl('', [Validators.required]);
    }
    /**
     * @return {?}
     */
    isError() {
        return this.data.reason === pdfjsLib.PasswordResponses.INCORRECT_PASSWORD;
    }
    /**
     * @return {?}
     */
    isValid() {
        return !this.passwordFormControl.hasError('required');
    }
    /**
     * @return {?}
     */
    submit() {
        this.dialogRef.close(this.passwordFormControl.value);
    }
}
PdfPasswordDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-viewer-password-dialog',
                template: "<div mat-dialog-title>\n    <mat-icon>lock</mat-icon>\n</div>\n\n<mat-dialog-content>\n    <form (submit)=\"submit()\">\n        <mat-form-field class=\"adf-full-width\">\n            <input matInput\n                   data-automation-id='adf-password-dialog-input'\n                   type=\"password\"\n                   placeholder=\"{{ 'ADF_VIEWER.PDF_DIALOG.PLACEHOLDER' | translate }}\"\n                   [formControl]=\"passwordFormControl\" />\n        </mat-form-field>\n\n        <mat-error *ngIf=\"isError()\" data-automation-id='adf-password-dialog-error'>{{ 'ADF_VIEWER.PDF_DIALOG.ERROR' | translate }}</mat-error>\n    </form>\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button mat-button mat-dialog-close>{{ 'ADF_VIEWER.PDF_DIALOG.CLOSE' | translate }}</button>\n\n    <button mat-button\n            data-automation-id='adf-password-dialog-submit'\n            class=\"adf-dialog-action-button\"\n            [disabled]=\"!isValid()\"\n            (click)=\"submit()\">\n        {{ 'ADF_VIEWER.PDF_DIALOG.SUBMIT' | translate }}\n    </button>\n</mat-dialog-actions>\n",
                styles: [".adf-fill-remaining-space{flex:1 1 auto}.adf-full-width{width:100%}"]
            }] }
];
/** @nocollapse */
PdfPasswordDialogComponent.ctorParameters = () => [
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PdfViewerComponent {
    /**
     * @param {?} dialog
     * @param {?} renderingQueueServices
     * @param {?} logService
     * @param {?} appConfigService
     */
    constructor(dialog, renderingQueueServices, logService, appConfigService) {
        this.dialog = dialog;
        this.renderingQueueServices = renderingQueueServices;
        this.logService = logService;
        this.appConfigService = appConfigService;
        this.showToolbar = true;
        this.allowThumbnails = false;
        this.thumbnailsTemplate = null;
        this.rendered = new EventEmitter();
        this.error = new EventEmitter();
        this.currentScaleMode = 'auto';
        this.currentScale = 1;
        this.MAX_AUTO_SCALE = 1.25;
        this.DEFAULT_SCALE_DELTA = 1.1;
        this.MIN_SCALE = 0.25;
        this.MAX_SCALE = 10.0;
        this.isPanelDisabled = true;
        this.showThumbnails = false;
        this.pdfThumbnailsContext = { viewer: null };
        // needed to preserve "this" context
        this.onPageChange = this.onPageChange.bind(this);
        this.onPagesLoaded = this.onPagesLoaded.bind(this);
        this.onPageRendered = this.onPageRendered.bind(this);
        this.randomPdfId = this.generateUuid();
        this.currentScale = this.getUserScaling();
    }
    /**
     * @return {?}
     */
    get currentScaleText() {
        return Math.round(this.currentScale * 100) + '%';
    }
    /**
     * @return {?}
     */
    getUserScaling() {
        /** @type {?} */
        const scaleConfig = this.appConfigService.get('adf-viewer.pdf-viewer-scaling', undefined) / 100;
        if (scaleConfig) {
            return this.checkLimits(scaleConfig);
        }
        else {
            return 1;
        }
    }
    /**
     * @param {?} scaleConfig
     * @return {?}
     */
    checkLimits(scaleConfig) {
        if (scaleConfig > this.MAX_SCALE) {
            return this.MAX_SCALE;
        }
        else if (scaleConfig < this.MIN_SCALE) {
            return this.MIN_SCALE;
        }
        else {
            return scaleConfig;
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            /** @type {?} */
            const reader = new FileReader();
            reader.onload = (/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const options = {
                    data: reader.result,
                    withCredentials: this.appConfigService.get('auth.withCredentials', undefined)
                };
                this.executePdf(options);
            });
            reader.readAsArrayBuffer(blobFile.currentValue);
        }
        /** @type {?} */
        const urlFile = changes['urlFile'];
        if (urlFile && urlFile.currentValue) {
            /** @type {?} */
            const options = {
                url: urlFile.currentValue,
                withCredentials: this.appConfigService.get('auth.withCredentials', undefined)
            };
            this.executePdf(options);
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    /**
     * @param {?} pdfOptions
     * @return {?}
     */
    executePdf(pdfOptions) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.min.js';
        this.loadingTask = pdfjsLib.getDocument(pdfOptions);
        this.loadingTask.onPassword = (/**
         * @param {?} callback
         * @param {?} reason
         * @return {?}
         */
        (callback, reason) => {
            this.onPdfPassword(callback, reason);
        });
        this.loadingTask.onProgress = (/**
         * @param {?} progressData
         * @return {?}
         */
        (progressData) => {
            /** @type {?} */
            const level = progressData.loaded / progressData.total;
            this.loadingPercent = Math.round(level * 100);
        });
        this.loadingTask.then((/**
         * @param {?} pdfDocument
         * @return {?}
         */
        (pdfDocument) => {
            this.currentPdfDocument = pdfDocument;
            this.totalPages = pdfDocument.numPages;
            this.page = 1;
            this.displayPage = 1;
            this.initPDFViewer(this.currentPdfDocument);
            this.currentPdfDocument.getPage(1).then((/**
             * @return {?}
             */
            () => {
                this.scalePage('auto');
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                this.error.emit();
            }));
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit();
        }));
    }
    /**
     * @param {?} pdfDocument
     * @return {?}
     */
    initPDFViewer(pdfDocument) {
        /** @type {?} */
        const viewer = document.getElementById(`${this.randomPdfId}-viewer-viewerPdf`);
        /** @type {?} */
        const container = document.getElementById(`${this.randomPdfId}-viewer-pdf-viewer`);
        if (viewer && container) {
            this.documentContainer = container;
            // cspell: disable-next
            this.documentContainer.addEventListener('pagechange', this.onPageChange, true);
            // cspell: disable-next
            this.documentContainer.addEventListener('pagesloaded', this.onPagesLoaded, true);
            // cspell: disable-next
            this.documentContainer.addEventListener('textlayerrendered', this.onPageRendered, true);
            this.pdfViewer = new pdfjsViewer.PDFViewer({
                container: this.documentContainer,
                viewer: viewer,
                renderingQueue: this.renderingQueueServices
            });
            this.renderingQueueServices.setViewer(this.pdfViewer);
            this.pdfViewer.setDocument(pdfDocument);
            this.pdfThumbnailsContext.viewer = this.pdfViewer;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.documentContainer) {
            // cspell: disable-next
            this.documentContainer.removeEventListener('pagechange', this.onPageChange, true);
            // cspell: disable-next
            this.documentContainer.removeEventListener('pagesloaded', this.onPagesLoaded, true);
            // cspell: disable-next
            this.documentContainer.removeEventListener('textlayerrendered', this.onPageRendered, true);
        }
        if (this.loadingTask) {
            try {
                this.loadingTask.destroy();
            }
            catch (_a) {
            }
            this.loadingTask = null;
        }
    }
    /**
     * @return {?}
     */
    toggleThumbnails() {
        this.showThumbnails = !this.showThumbnails;
    }
    /**
     * Method to scale the page current support implementation
     *
     * @param {?} scaleMode - new scale mode
     * @return {?}
     */
    scalePage(scaleMode) {
        this.currentScaleMode = scaleMode;
        /** @type {?} */
        const viewerContainer = document.getElementById(`${this.randomPdfId}-viewer-main-container`);
        /** @type {?} */
        const documentContainer = document.getElementById(`${this.randomPdfId}-viewer-pdf-viewer`);
        if (this.pdfViewer && documentContainer) {
            /** @type {?} */
            let widthContainer;
            /** @type {?} */
            let heightContainer;
            if (viewerContainer && viewerContainer.clientWidth <= documentContainer.clientWidth) {
                widthContainer = viewerContainer.clientWidth;
                heightContainer = viewerContainer.clientHeight;
            }
            else {
                widthContainer = documentContainer.clientWidth;
                heightContainer = documentContainer.clientHeight;
            }
            /** @type {?} */
            const currentPage = this.pdfViewer._pages[this.pdfViewer._currentPageNumber - 1];
            /** @type {?} */
            const padding = 20;
            /** @type {?} */
            const pageWidthScale = (widthContainer - padding) / currentPage.width * currentPage.scale;
            /** @type {?} */
            const pageHeightScale = (heightContainer - padding) / currentPage.width * currentPage.scale;
            /** @type {?} */
            let scale = this.getUserScaling();
            if (!scale) {
                switch (this.currentScaleMode) {
                    case 'page-actual':
                        scale = 1;
                        break;
                    case 'page-width':
                        scale = pageWidthScale;
                        break;
                    case 'page-height':
                        scale = pageHeightScale;
                        break;
                    case 'page-fit':
                        scale = Math.min(pageWidthScale, pageHeightScale);
                        break;
                    case 'auto':
                        /** @type {?} */
                        let horizontalScale;
                        if (this.isLandscape) {
                            horizontalScale = Math.min(pageHeightScale, pageWidthScale);
                        }
                        else {
                            horizontalScale = pageWidthScale;
                        }
                        horizontalScale = Math.round(horizontalScale);
                        scale = Math.min(this.MAX_AUTO_SCALE, horizontalScale);
                        break;
                    default:
                        this.logService.error('pdfViewSetScale: \'' + scaleMode + '\' is an unknown zoom value.');
                        return;
                }
                this.setScaleUpdatePages(scale);
            }
            else {
                this.currentScale = 0;
                this.setScaleUpdatePages(scale);
            }
        }
    }
    /**
     * Update all the pages with the newScale scale
     *
     * @param {?} newScale - new scale page
     * @return {?}
     */
    setScaleUpdatePages(newScale) {
        if (this.pdfViewer) {
            if (!this.isSameScale(this.currentScale, newScale)) {
                this.currentScale = newScale;
                this.pdfViewer._pages.forEach((/**
                 * @param {?} currentPage
                 * @return {?}
                 */
                function (currentPage) {
                    currentPage.update(newScale);
                }));
            }
            this.pdfViewer.update();
        }
    }
    /**
     * Check if the request scale of the page is the same for avoid useless re-rendering
     *
     * @param {?} oldScale - old scale page
     * @param {?} newScale - new scale page
     *
     * @return {?}
     */
    isSameScale(oldScale, newScale) {
        return (newScale === oldScale);
    }
    /**
     * Check if is a land scape view
     *
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    isLandscape(width, height) {
        return (width > height);
    }
    /**
     * Method triggered when the page is resized
     * @return {?}
     */
    onResize() {
        this.scalePage(this.currentScaleMode);
    }
    /**
     * toggle the fit page pdf
     * @return {?}
     */
    pageFit() {
        if (this.currentScaleMode !== 'page-fit') {
            this.scalePage('page-fit');
        }
        else {
            this.scalePage('auto');
        }
    }
    /**
     * zoom in page pdf
     *
     * @param {?=} ticks
     * @return {?}
     */
    zoomIn(ticks) {
        /** @type {?} */
        let newScale = this.currentScale;
        do {
            newScale = (newScale * this.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.ceil(newScale * 10) / 10;
            newScale = Math.min(this.MAX_SCALE, newScale);
        } while (--ticks > 0 && newScale < this.MAX_SCALE);
        this.currentScaleMode = 'auto';
        this.setScaleUpdatePages(newScale);
    }
    /**
     * zoom out page pdf
     *
     * @param {?=} ticks
     * @return {?}
     */
    zoomOut(ticks) {
        /** @type {?} */
        let newScale = this.currentScale;
        do {
            newScale = (newScale / this.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.floor(newScale * 10) / 10;
            newScale = Math.max(this.MIN_SCALE, newScale);
        } while (--ticks > 0 && newScale > this.MIN_SCALE);
        this.currentScaleMode = 'auto';
        this.setScaleUpdatePages(newScale);
    }
    /**
     * load the previous page
     * @return {?}
     */
    previousPage() {
        if (this.pdfViewer && this.page > 1) {
            this.page--;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
    }
    /**
     * load the next page
     * @return {?}
     */
    nextPage() {
        if (this.pdfViewer && this.page < this.totalPages) {
            this.page++;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
    }
    /**
     * load the page in input
     *
     * @param {?} page to load
     * @return {?}
     */
    inputPage(page) {
        /** @type {?} */
        const pageInput = parseInt(page, 10);
        if (!isNaN(pageInput) && pageInput > 0 && pageInput <= this.totalPages) {
            this.page = pageInput;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
        else {
            this.displayPage = this.page;
        }
    }
    /**
     * Page Change Event
     *
     * @param {?} event
     * @return {?}
     */
    onPageChange(event) {
        this.page = event.pageNumber;
        this.displayPage = event.pageNumber;
    }
    /**
     * @param {?} callback
     * @param {?} reason
     * @return {?}
     */
    onPdfPassword(callback, reason) {
        this.dialog
            .open(PdfPasswordDialogComponent, {
            width: '400px',
            disableClose: true,
            data: { reason }
        })
            .afterClosed().subscribe((/**
         * @param {?} password
         * @return {?}
         */
        (password) => {
            if (password) {
                callback(password);
            }
        }));
    }
    /**
     * Page Rendered Event
     * @return {?}
     */
    onPageRendered() {
        this.rendered.emit();
    }
    /**
     * Pages Loaded Event
     *
     * @param {?} event
     * @return {?}
     */
    onPagesLoaded(event) {
        this.isPanelDisabled = false;
    }
    /**
     * Keyboard Event Listener
     * @param {?} event
     * @return {?}
     */
    handleKeyboardEvent(event) {
        /** @type {?} */
        const key = event.keyCode;
        if (key === 39) { // right arrow
            this.nextPage();
        }
        else if (key === 37) { // left arrow
            this.previousPage();
        }
    }
    /**
     * @private
     * @return {?}
     */
    generateUuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (/**
         * @param {?} c
         * @return {?}
         */
        function (c) {
            /** @type {?} */
            const r = Math.random() * 16 | 0;
            /** @type {?} */
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        }));
    }
}
PdfViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-viewer',
                template: "<div class=\"adf-pdf-viewer__container\">\n    <ng-container *ngIf=\"showThumbnails\">\n        <div class=\"adf-pdf-viewer__thumbnails\">\n            <div class=\"adf-thumbnails-template__container\">\n                <div class=\"adf-thumbnails-template__buttons\">\n                    <button mat-icon-button data-automation-id='adf-thumbnails-close' (click)=\"toggleThumbnails()\">\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </div>\n\n                <ng-container *ngIf=\"thumbnailsTemplate\">\n                    <ng-container *ngTemplateOutlet=\"thumbnailsTemplate;context:pdfThumbnailsContext\"></ng-container>\n                </ng-container>\n\n                <ng-container *ngIf=\"!thumbnailsTemplate\">\n                    <adf-pdf-thumbnails [pdfViewer]=\"pdfViewer\"></adf-pdf-thumbnails>\n                </ng-container>\n            </div>\n        </div>\n    </ng-container>\n\n    <div class=\"adf-pdf-viewer__content\">\n        <div [id]=\"randomPdfId+'-viewer-pdf-viewer'\" class=\"adf-viewer-pdf-viewer\" (window:resize)=\"onResize()\">\n            <div [id]=\"randomPdfId+'-viewer-viewerPdf'\" class=\"adf-pdfViewer\" role=\"document\" tabindex=\"0\" aria-expanded=\"true\">\n                <div id=\"loader-container\" class=\"adf-loader-container\">\n                    <div class=\"adf-loader-item\">\n                        <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n\n<div class=\"adf-pdf-viewer__toolbar\" *ngIf=\"showToolbar\">\n    <adf-toolbar>\n\n        <ng-container *ngIf=\"allowThumbnails\">\n            <button mat-icon-button\n                    data-automation-id=\"adf-thumbnails-button\"\n                    [disabled]=\"isPanelDisabled\"\n                    (click)=\"toggleThumbnails()\">\n                <mat-icon>dashboard</mat-icon>\n            </button>\n            <adf-toolbar-divider></adf-toolbar-divider>\n        </ng-container>\n\n        <button\n            id=\"viewer-previous-page-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.PREVIOUS_PAGE' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.PREVIOUS_PAGE' | translate }}\"\n            mat-icon-button\n            (click)=\"previousPage()\">\n            <mat-icon>keyboard_arrow_up</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-next-page-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.NEXT_PAGE' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.NEXT_PAGE' | translate }}\"\n            mat-icon-button\n            (click)=\"nextPage()\">\n            <mat-icon>keyboard_arrow_down</mat-icon>\n        </button>\n\n        <div class=\"adf-pdf-viewer__toolbar-page-selector\">\n            <span>{{ 'ADF_VIEWER.PAGE_LABEL.SHOWING' | translate }}</span>\n            <input #page\n                   type=\"text\"\n                   data-automation-id=\"adf-page-selector\"\n                   pattern=\"-?[0-9]*(\\.[0-9]+)?\"\n                   value=\"{{ displayPage }}\"\n                   (keyup.enter)=\"inputPage(page.value)\">\n            <span>{{ 'ADF_VIEWER.PAGE_LABEL.OF' | translate }} {{ totalPages }}</span>\n        </div>\n\n        <div class=\"adf-viewer__toolbar-page-scale\" data-automation-id=\"adf-page-scale\">\n            {{ currentScaleText }}\n        </div>\n\n        <button\n            id=\"viewer-zoom-in-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}\"\n            mat-icon-button\n            (click)=\"zoomIn()\">\n            <mat-icon>zoom_in</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-zoom-out-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}\"\n            mat-icon-button\n            (click)=\"zoomOut()\">\n            <mat-icon>zoom_out</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-scale-page-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.FIT_PAGE' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.FIT_PAGE' | translate }}\"\n            mat-icon-button\n            (click)=\"pageFit()\">\n            <mat-icon>zoom_out_map</mat-icon>\n        </button>\n\n    </adf-toolbar>\n</div>\n",
                providers: [RenderingQueueServices],
                host: { 'class': 'adf-pdf-viewer' },
                encapsulation: ViewEncapsulation.None,
                styles: ["", ".adf-pdf-viewer .textLayer{position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;opacity:.2;line-height:1;border:1px solid gray}.adf-pdf-viewer .textLayer>div{color:transparent;position:absolute;white-space:pre;cursor:text;-webkit-transform-origin:0 0;transform-origin:0 0}.adf-pdf-viewer .textLayer .adf-highlight{margin:-1px;padding:1px;background-color:#b400aa;border-radius:4px}.adf-pdf-viewer .textLayer .adf-highlight.adf-begin{border-radius:4px 0 0 4px}.adf-pdf-viewer .textLayer .adf-highlight.adf-end{border-radius:0 4px 4px 0}.adf-pdf-viewer .textLayer .adf-highlight.adf-middle{border-radius:0}.adf-pdf-viewer .textLayer .adf-highlight.adf-selected{background-color:#006400}.adf-pdf-viewer .textLayer::selection{background:#00f}.adf-pdf-viewer .textLayer::-moz-selection{background:#00f}.adf-pdf-viewer .textLayer .adf-endOfContent{display:block;position:absolute;left:0;top:100%;right:0;bottom:0;z-index:-1;cursor:default;user-select:none;-webkit-user-select:none;-ms-user-select:none;-moz-user-select:none}.adf-pdf-viewer .textLayer .adf-endOfContent.adf-active{top:0}.adf-pdf-viewer .adf-annotationLayer section{position:absolute}.adf-pdf-viewer .adf-annotationLayer .adf-linkAnnotation>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%;background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)}.adf-pdf-viewer .adf-annotationLayer .adf-linkAnnotation>a:hover{opacity:.2;background:#ff0;box-shadow:0 2px 10px #ff0}.adf-pdf-viewer .adf-annotationLayer .adf-textAnnotation img{position:absolute;cursor:pointer}.adf-pdf-viewer .adf-annotationLayer .adf-popupWrapper{position:absolute;width:20em}.adf-pdf-viewer .adf-annotationLayer .adf-popup{position:absolute;z-index:200;max-width:20em;background-color:#ff9;box-shadow:0 2px 5px #333;border-radius:2px;padding:.6em;margin-left:5px;cursor:pointer;word-wrap:break-word}.adf-pdf-viewer .adf-annotationLayer .adf-popup h1{font-size:1em;border-bottom:1px solid #000;padding-bottom:.2em}.adf-pdf-viewer .adf-annotationLayer .adf-popup p{padding-top:.2em}.adf-pdf-viewer .adf-annotationLayer .adf-fileAttachmentAnnotation,.adf-pdf-viewer .adf-annotationLayer .adf-highlightAnnotation,.adf-pdf-viewer .adf-annotationLayer .adf-squigglyAnnotation,.adf-pdf-viewer .adf-annotationLayer .adf-strikeoutAnnotation,.adf-pdf-viewer .adf-annotationLayer .adf-underlineAnnotation{cursor:pointer}.adf-pdf-viewer .adf-pdfViewer .canvasWrapper{overflow:hidden}.adf-pdf-viewer .adf-pdfViewer .page{direction:ltr;width:816px;height:1056px;margin:1px auto -8px;position:relative;overflow:visible;border:9px solid transparent;background-clip:content-box;background-color:#fff}.adf-pdf-viewer .adf-pdfViewer .page canvas{margin:0;display:block}.adf-pdf-viewer .adf-pdfViewer .page .adf-loadingIcon{position:absolute;display:block;left:0;top:0;right:0;bottom:0}.adf-pdf-viewer .adf-pdfViewer .page *{padding:0;margin:0}.adf-pdf-viewer .adf-pdfViewer.adf-removePageBorders .adf-page{margin:0 auto 10px;border:none}.adf-pdf-viewer .adf-pdfViewer .adf-loadingIcon{width:100px;height:100px;left:50%!important;top:50%!important;margin-top:-50px;margin-left:-50px;font-size:5px;text-indent:-9999em;border-top:1.1em solid rgba(3,0,2,.2);border-right:1.1em solid rgba(3,0,2,.2);border-bottom:1.1em solid rgba(3,0,2,.2);border-left:1.1em solid #030002;-webkit-transform:translateZ(0);transform:translateZ(0);-webkit-animation:1.1s linear infinite load8;animation:1.1s linear infinite load8;border-radius:50%}.adf-pdf-viewer .adf-pdfViewer .adf-loadingIcon::after{border-radius:50%}.adf-pdf-viewer .adf-hidden,.adf-pdf-viewer [hidden]{display:none!important}@-webkit-keyframes load8{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes load8{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.adf-viewer-pdf-viewer{overflow:auto;-webkit-overflow-scrolling:touch;position:absolute;top:0;right:0;bottom:0;left:0;outline:0}html[dir=ltr] .adf-viewer-pdf-viewer{box-shadow:inset 1px 0 0 rgba(255,255,255,.05)}html[dir=rtl] .adf-viewer-pdf-viewer{box-shadow:inset -1px 0 0 rgba(255,255,255,.05)}"]
            }] }
];
/** @nocollapse */
PdfViewerComponent.ctorParameters = () => [
    { type: MatDialog },
    { type: RenderingQueueServices },
    { type: LogService },
    { type: AppConfigService }
];
PdfViewerComponent.propDecorators = {
    urlFile: [{ type: Input }],
    blobFile: [{ type: Input }],
    nameFile: [{ type: Input }],
    showToolbar: [{ type: Input }],
    allowThumbnails: [{ type: Input }],
    thumbnailsTemplate: [{ type: Input }],
    rendered: [{ type: Output }],
    error: [{ type: Output }],
    handleKeyboardEvent: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PdfThumbListComponent {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.virtualHeight = 0;
        this.translateY = 0;
        this.renderItems = [];
        this.width = 91;
        this.currentHeight = 0;
        this.items = [];
        this.margin = 15;
        this.itemHeight = 114 + this.margin;
        this.calculateItems = this.calculateItems.bind(this);
        this.onPageChange = this.onPageChange.bind(this);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.calculateItems();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /* cspell:disable-next-line */
        this.pdfViewer.eventBus.on('pagechange', this.onPageChange);
        this.element.nativeElement.addEventListener('scroll', this.calculateItems, true);
        this.setHeight(this.pdfViewer.currentPageNumber);
        this.items = this.getPages();
        this.calculateItems();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => this.scrollInto(this.pdfViewer.currentPageNumber)), 0);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.element.nativeElement.removeEventListener('scroll', this.calculateItems, true);
        /* cspell:disable-next-line */
        this.pdfViewer.eventBus.off('pagechange', this.onPageChange);
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByFn(index, item) {
        return item.id;
    }
    /**
     * @param {?} pageNum
     * @return {?}
     */
    isSelected(pageNum) {
        return this.pdfViewer.currentPageNumber === pageNum;
    }
    /**
     * @param {?} pageNum
     * @return {?}
     */
    goTo(pageNum) {
        this.pdfViewer.currentPageNumber = pageNum;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    scrollInto(item) {
        if (this.items.length) {
            /** @type {?} */
            const index = this.items.findIndex((/**
             * @param {?} element
             * @return {?}
             */
            (element) => element.id === item));
            if (index < 0 || index >= this.items.length) {
                return;
            }
            this.element.nativeElement.scrollTop = index * this.itemHeight;
            this.calculateItems();
        }
    }
    /**
     * @return {?}
     */
    getPages() {
        return this.pdfViewer._pages.map((/**
         * @param {?} page
         * @return {?}
         */
        (page) => ({
            id: page.id,
            getWidth: (/**
             * @return {?}
             */
            () => { return this.width; }),
            getHeight: (/**
             * @return {?}
             */
            () => { return this.currentHeight; }),
            getPage: (/**
             * @return {?}
             */
            () => this.pdfViewer.pdfDocument.getPage(page.id))
        })));
    }
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    setHeight(id) {
        /** @type {?} */
        const height = this.pdfViewer.pdfDocument.getPage(id).then((/**
         * @param {?} page
         * @return {?}
         */
        (page) => this.calculateHeight(page)));
        return height;
    }
    /**
     * @private
     * @param {?} page
     * @return {?}
     */
    calculateHeight(page) {
        /** @type {?} */
        const viewport = page.getViewport(1);
        /** @type {?} */
        const pageRatio = viewport.width / viewport.height;
        /** @type {?} */
        const height = Math.floor(this.width / pageRatio);
        this.currentHeight = height;
        this.itemHeight = height + this.margin;
    }
    /**
     * @private
     * @return {?}
     */
    calculateItems() {
        const { element, viewPort, itemsInView } = this.getContainerSetup();
        /** @type {?} */
        const indexByScrollTop = element.scrollTop / viewPort * this.items.length / itemsInView;
        /** @type {?} */
        const start = Math.floor(indexByScrollTop);
        /** @type {?} */
        const end = Math.ceil(indexByScrollTop) + (itemsInView);
        this.translateY = this.itemHeight * Math.ceil(start);
        this.virtualHeight = this.itemHeight * this.items.length - this.translateY;
        this.renderItems = this.items.slice(start, end);
    }
    /**
     * @private
     * @return {?}
     */
    getContainerSetup() {
        /** @type {?} */
        const element = this.element.nativeElement;
        /** @type {?} */
        const elementRec = element.getBoundingClientRect();
        /** @type {?} */
        const itemsInView = Math.ceil(elementRec.height / this.itemHeight);
        /** @type {?} */
        const viewPort = (this.itemHeight * this.items.length) / itemsInView;
        return {
            element,
            viewPort,
            itemsInView
        };
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onPageChange(event) {
        /** @type {?} */
        const index = this.renderItems.findIndex((/**
         * @param {?} element
         * @return {?}
         */
        (element) => element.id === event.pageNumber));
        if (index < 0) {
            this.scrollInto(event.pageNumber);
        }
        if (index >= this.renderItems.length - 1) {
            this.element.nativeElement.scrollTop += this.itemHeight;
        }
    }
}
PdfThumbListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-thumbnails',
                template: "<div class=\"adf-pdf-thumbnails__content\"\n    data-automation-id='adf-thumbnails-content'\n    [style.height.px]=\"virtualHeight\"\n    [style.transform]=\"'translate(-50%, ' + translateY + 'px)'\">\n    <adf-pdf-thumb *ngFor=\"let page of renderItems; trackBy: trackByFn\"\n        class=\"adf-pdf-thumbnails__thumb\"\n        [ngClass]=\"{'adf-pdf-thumbnails__thumb--selected' : isSelected(page.id)}\"\n        [page]=\"page\"\n        (click)=\"goTo(page.id)\">\n    </adf-pdf-thumb>\n</div>\n",
                host: { 'class': 'adf-pdf-thumbnails' },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
PdfThumbListComponent.ctorParameters = () => [
    { type: ElementRef }
];
PdfThumbListComponent.propDecorators = {
    pdfViewer: [{ type: Input }],
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PdfThumbComponent {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.page = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.image$ = this.page.getPage().then((/**
         * @param {?} page
         * @return {?}
         */
        (page) => this.getThumb(page)));
    }
    /**
     * @private
     * @param {?} page
     * @return {?}
     */
    getThumb(page) {
        /** @type {?} */
        const viewport = page.getViewport(1);
        /** @type {?} */
        const pageRatio = viewport.width / viewport.height;
        /** @type {?} */
        const canvas = this.getCanvas(pageRatio);
        /** @type {?} */
        const scale = Math.min((canvas.height / viewport.height), (canvas.width / viewport.width));
        return page.render({
            canvasContext: canvas.getContext('2d'),
            viewport: page.getViewport(scale)
        })
            .then((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const imageSource = canvas.toDataURL();
            return this.sanitizer.bypassSecurityTrustUrl(imageSource);
        }));
    }
    /**
     * @private
     * @param {?} pageRatio
     * @return {?}
     */
    getCanvas(pageRatio) {
        /** @type {?} */
        const canvas = document.createElement('canvas');
        canvas.width = this.page.getWidth();
        canvas.height = this.page.getHeight();
        return canvas;
    }
}
PdfThumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-thumb',
                template: "<ng-container *ngIf=\"image$ | async as image\">\n    <img [src]=\"image\" [alt]=\"'ADF_VIEWER.SIDEBAR.THUMBNAILS.PAGE' | translate: { pageNum: page.id }\"\n        title=\"{{ 'ADF_VIEWER.SIDEBAR.THUMBNAILS.PAGE' | translate: { pageNum: page.id } }}\">\n</ng-container>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
PdfThumbComponent.ctorParameters = () => [
    { type: DomSanitizer }
];
PdfThumbComponent.propDecorators = {
    page: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TxtViewerComponent {
    /**
     * @param {?} http
     * @param {?} appConfigService
     */
    constructor(http, appConfigService) {
        this.http = http;
        this.appConfigService = appConfigService;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            return this.readBlob(blobFile.currentValue);
        }
        /** @type {?} */
        const urlFile = changes['urlFile'];
        if (urlFile && urlFile.currentValue) {
            return this.getUrlContent(urlFile.currentValue);
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    getUrlContent(url) {
        /** @type {?} */
        const withCredentialsMode = this.appConfigService.get('auth.withCredentials', false);
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.http.get(url, { responseType: 'text', withCredentials: withCredentialsMode }).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.content = res;
                resolve();
            }), (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                reject(event);
            }));
        }));
    }
    /**
     * @private
     * @param {?} blob
     * @return {?}
     */
    readBlob(blob) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const reader = new FileReader();
            reader.onload = (/**
             * @return {?}
             */
            () => {
                this.content = reader.result;
                resolve();
            });
            reader.onerror = (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                reject(error);
            });
            reader.readAsText(blob);
        }));
    }
}
TxtViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-txt-viewer',
                template: "<pre class=\"adf-txt-viewer-content\">\n    {{content}}\n</pre>\n",
                host: { 'class': 'adf-txt-viewer' },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
TxtViewerComponent.ctorParameters = () => [
    { type: HttpClient },
    { type: AppConfigService }
];
TxtViewerComponent.propDecorators = {
    urlFile: [{ type: Input }],
    blobFile: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UnknownFormatComponent {
}
UnknownFormatComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-unknown-format',
                template: "<div class=\"adf-viewer__unknown-format-view\">\n    <div>\n        <mat-icon class=\"icon\">wifi_tethering</mat-icon>\n        <div class=\"label\">{{ 'ADF_VIEWER.UNKNOWN_FORMAT' | translate }}</div>\n    </div>\n</div>\n",
                styles: [".adf-viewer__unknown-format-view{height:90vh;text-align:center;display:flex;flex:1;flex-direction:column;justify-content:center}"]
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewerToolbarActionsComponent {
}
ViewerToolbarActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-toolbar-actions',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-toolbar-actions' },
                template: `<ng-content></ng-content>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewerExtensionDirective {
    /**
     * @param {?} viewerComponent
     */
    constructor(viewerComponent) {
        this.viewerComponent = viewerComponent;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.templateModel = { template: this.template, isVisible: false };
        this.viewerComponent.extensionTemplates.push(this.templateModel);
        this.viewerComponent.extensionChange.subscribe((/**
         * @param {?} fileExtension
         * @return {?}
         */
        (fileExtension) => {
            this.templateModel.isVisible = this.isVisible(fileExtension);
        }));
        if (this.supportedExtensions instanceof Array) {
            this.supportedExtensions.forEach((/**
             * @param {?} extension
             * @return {?}
             */
            (extension) => {
                this.viewerComponent.externalExtensions.push(extension);
            }));
        }
    }
    /**
     * check if the current extension in the viewer is compatible with this extension checking against supportedExtensions
     * @param {?} fileExtension
     * @return {?}
     */
    isVisible(fileExtension) {
        /** @type {?} */
        let supportedExtension;
        if (this.supportedExtensions && (this.supportedExtensions instanceof Array)) {
            supportedExtension = this.supportedExtensions.find((/**
             * @param {?} extension
             * @return {?}
             */
            (extension) => {
                return extension.toLowerCase() === fileExtension;
            }));
        }
        return !!supportedExtension;
    }
}
ViewerExtensionDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-viewer-extension'
            },] }
];
/** @nocollapse */
ViewerExtensionDirective.ctorParameters = () => [
    { type: ViewerComponent }
];
ViewerExtensionDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    urlFileContent: [{ type: Input }],
    extension: [{ type: Input }],
    supportedExtensions: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToolbarDividerComponent {
}
ToolbarDividerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar-divider',
                template: '<div></div>',
                host: { 'class': 'adf-toolbar-divider' },
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
        .adf-toolbar-divider > div {
            height: 24px;
            width: 1px;
            background: rgba(0, 0, 0, 0.26);
            margin-left: 5px;
            margin-right: 5px;
        }
    `]
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToolbarTitleComponent {
}
ToolbarTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar-title',
                template: '<ng-content></ng-content>',
                host: { 'class': 'adf-toolbar-title' }
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToolbarComponent {
    constructor() {
        /**
         * Toolbar title.
         */
        this.title = '';
    }
}
ToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar',
                template: "<mat-toolbar [color]=\"color\">\n    <span *ngIf=\"title\">{{ title }}</span>\n    <ng-content select=\"adf-toolbar-title\"></ng-content>\n    <ng-content></ng-content>\n</mat-toolbar>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-toolbar' },
                styles: [""]
            }] }
];
ToolbarComponent.propDecorators = {
    title: [{ type: Input }],
    color: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToolbarModule {
}
ToolbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    ToolbarComponent,
                    ToolbarTitleComponent,
                    ToolbarDividerComponent
                ],
                exports: [
                    ToolbarComponent,
                    ToolbarTitleComponent,
                    ToolbarDividerComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewerModule {
}
ViewerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ExtensionsModule,
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild(),
                    FormsModule,
                    ReactiveFormsModule,
                    ToolbarModule,
                    PipeModule,
                    FlexLayoutModule,
                    DirectiveModule
                ],
                declarations: [
                    PdfPasswordDialogComponent,
                    ViewerComponent,
                    ImgViewerComponent,
                    TxtViewerComponent,
                    MediaPlayerComponent,
                    PdfViewerComponent,
                    PdfThumbComponent,
                    PdfThumbListComponent,
                    ViewerExtensionDirective,
                    UnknownFormatComponent,
                    ViewerToolbarComponent,
                    ViewerSidebarComponent,
                    ViewerOpenWithComponent,
                    ViewerMoreActionsComponent,
                    ViewerToolbarActionsComponent
                ],
                entryComponents: [
                    PdfPasswordDialogComponent
                ],
                exports: [
                    ViewerComponent,
                    ImgViewerComponent,
                    TxtViewerComponent,
                    MediaPlayerComponent,
                    PdfViewerComponent,
                    PdfPasswordDialogComponent,
                    PdfThumbComponent,
                    PdfThumbListComponent,
                    ViewerExtensionDirective,
                    UnknownFormatComponent,
                    ViewerToolbarComponent,
                    ViewerSidebarComponent,
                    ViewerOpenWithComponent,
                    ViewerMoreActionsComponent,
                    ViewerToolbarActionsComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BpmUserModel {
    /**
     * @param {?=} input
     */
    constructor(input) {
        if (input) {
            this.apps = input.apps;
            this.capabilities = input.capabilities;
            this.company = input.company;
            this.created = input.created;
            this.email = input.email;
            this.externalId = input.externalId;
            this.firstName = input.firstName;
            this.lastName = input.lastName;
            this.fullname = input.fullname;
            this.groups = input.groups;
            this.id = input.id;
            this.lastUpdate = input.lastUpdate;
            this.latestSyncTimeStamp = input.latestSyncTimeStamp;
            this.password = input.password;
            this.pictureId = input.pictureId;
            this.status = input.status;
            this.tenantId = input.tenantId;
            this.tenantName = input.tenantName;
            this.tenantPictureId = input.tenantPictureId;
            this.type = input.type;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * BPMUserService retrieve all the information of an Ecm user.
 *
 */
class BpmUserService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Gets information about the current user.
     * @return {?} User information object
     */
    getCurrentUserInfo() {
        return from(this.apiService.getInstance().activiti.profileApi.getProfile())
            .pipe(map((/**
         * @param {?} userRepresentation
         * @return {?}
         */
        (userRepresentation) => {
            return new BpmUserModel(userRepresentation);
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the current user's profile image as a URL.
     * @return {?} URL string
     */
    getCurrentUserProfileImage() {
        return this.apiService.getInstance().activiti.profileApi.getProfilePictureUrl();
    }
    /**
     * Throw the error
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        // in a real world app, we may send the error to some remote logging infrastructure
        // instead of just logging it to the console
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
BpmUserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
BpmUserService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ BpmUserService.ngInjectableDef = defineInjectable({ factory: function BpmUserService_Factory() { return new BpmUserService(inject(AlfrescoApiService), inject(LogService)); }, token: BpmUserService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EcmUserModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.id = obj && obj.id || null;
        this.firstName = obj && obj.firstName;
        this.lastName = obj && obj.lastName;
        this.description = obj && obj.description || null;
        this.avatarId = obj && obj.avatarId || null;
        this.email = obj && obj.email || null;
        this.skypeId = obj && obj.skypeId;
        this.googleId = obj && obj.googleId;
        this.instantMessageId = obj && obj.instantMessageId;
        this.jobTitle = obj && obj.jobTitle || null;
        this.location = obj && obj.location || null;
        this.company = obj && obj.company;
        this.mobile = obj && obj.mobile;
        this.telephone = obj && obj.telephone;
        this.statusUpdatedAt = obj && obj.statusUpdatedAt;
        this.userStatus = obj && obj.userStatus;
        this.enabled = obj && obj.enabled;
        this.emailNotificationsEnabled = obj && obj.emailNotificationsEnabled;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EcmUserService {
    /**
     * @param {?} apiService
     * @param {?} contentService
     * @param {?} logService
     */
    constructor(apiService, contentService, logService) {
        this.apiService = apiService;
        this.contentService = contentService;
        this.logService = logService;
    }
    /**
     * Gets information about a user identified by their username.
     * @param {?} userName Target username
     * @return {?} User information
     */
    getUserInfo(userName) {
        return from(this.apiService.getInstance().core.peopleApi.getPerson(userName))
            .pipe(map((/**
         * @param {?} personEntry
         * @return {?}
         */
        (personEntry) => {
            return new EcmUserModel(personEntry.entry);
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets information about the user who is currently logged-in.
     * @return {?} User information as for getUserInfo
     */
    getCurrentUserInfo() {
        return this.getUserInfo('-me-');
    }
    /**
     * Returns a profile image as a URL.
     * @param {?} avatarId Target avatar
     * @return {?} Image URL
     */
    getUserProfileImage(avatarId) {
        if (avatarId) {
            /** @type {?} */
            const nodeObj = { entry: { id: avatarId } };
            return this.contentService.getContentUrl(nodeObj);
        }
    }
    /**
     * Throw the error
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
EcmUserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
EcmUserService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: ContentService },
    { type: LogService }
];
/** @nocollapse */ EcmUserService.ngInjectableDef = defineInjectable({ factory: function EcmUserService_Factory() { return new EcmUserService(inject(AlfrescoApiService), inject(ContentService), inject(LogService)); }, token: EcmUserService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IdentityUserModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.firstName = obj.firstName || null;
            this.lastName = obj.lastName || null;
            this.email = obj.email || null;
            this.username = obj.username || null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JwtHelperService {
    constructor() { }
    /**
     * Decodes a JSON web token into a JS object.
     * @param {?} token Token in encoded form
     * @return {?} Decoded token data object
     */
    decodeToken(token) {
        /** @type {?} */
        const parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('JWT must have 3 parts');
        }
        /** @type {?} */
        const decoded = this.urlBase64Decode(parts[1]);
        if (!decoded) {
            throw new Error('Cannot decode the token');
        }
        return JSON.parse(decoded);
    }
    /**
     * @private
     * @param {?} token
     * @return {?}
     */
    urlBase64Decode(token) {
        /** @type {?} */
        let output = token.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0: {
                break;
            }
            case 2: {
                output += '==';
                break;
            }
            case 3: {
                output += '=';
                break;
            }
            default: {
                throw new Error('Illegal base64url string!');
            }
        }
        return decodeURIComponent(escape(window.atob(output)));
    }
}
JwtHelperService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
JwtHelperService.ctorParameters = () => [];
/** @nocollapse */ JwtHelperService.ngInjectableDef = defineInjectable({ factory: function JwtHelperService_Factory() { return new JwtHelperService(); }, token: JwtHelperService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IdentityUserService {
    /**
     * @param {?} helper
     * @param {?} apiService
     * @param {?} appConfigService
     */
    constructor(helper, apiService, appConfigService) {
        this.helper = helper;
        this.apiService = apiService;
        this.appConfigService = appConfigService;
    }
    /**
     * Gets the name and other basic details of the current user.
     * @return {?} The user's details
     */
    getCurrentUserInfo() {
        /** @type {?} */
        const familyName = this.getValueFromToken(IdentityUserService.FAMILY_NAME);
        /** @type {?} */
        const givenName = this.getValueFromToken(IdentityUserService.GIVEN_NAME);
        /** @type {?} */
        const email = this.getValueFromToken(IdentityUserService.USER_EMAIL);
        /** @type {?} */
        const username = this.getValueFromToken(IdentityUserService.USER_PREFERRED_USERNAME);
        /** @type {?} */
        const user = { firstName: givenName, lastName: familyName, email: email, username: username };
        return new IdentityUserModel(user);
    }
    /**
     * Gets a named value from the user access token.
     * @template T
     * @param {?} key Key name of the field to retrieve
     * @return {?} Value from the token
     */
    getValueFromToken(key) {
        /** @type {?} */
        let value;
        /** @type {?} */
        const token = localStorage.getItem(IdentityUserService.USER_ACCESS_TOKEN);
        if (token) {
            /** @type {?} */
            const tokenPayload = this.helper.decodeToken(token);
            value = tokenPayload[key];
        }
        return (/** @type {?} */ (value));
    }
    /**
     * Find users based on search input.
     * @param {?} search Search query string
     * @return {?} List of users
     */
    findUsersByName(search) {
        if (search === '') {
            return of([]);
        }
        /** @type {?} */
        const url = this.buildUserUrl();
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = { search: search };
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return (from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null)));
    }
    /**
     * Find users based on username input.
     * @param {?} username Search query string
     * @return {?} List of users
     */
    findUserByUsername(username) {
        if (username === '') {
            return of([]);
        }
        /** @type {?} */
        const url = this.buildUserUrl();
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = { username: username };
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return (from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null)));
    }
    /**
     * Find users based on email input.
     * @param {?} email Search query string
     * @return {?} List of users
     */
    findUserByEmail(email) {
        if (email === '') {
            return of([]);
        }
        /** @type {?} */
        const url = this.buildUserUrl();
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = { email: email };
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return (from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null)));
    }
    /**
     * Find users based on id input.
     * @param {?} id Search query string
     * @return {?} users object
     */
    findUserById(id) {
        if (id === '') {
            return of([]);
        }
        /** @type {?} */
        const url = this.buildUserUrl() + '/' + id;
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = {};
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return (from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null)));
    }
    /**
     * Get client roles of a user for a particular client.
     * @param {?} userId ID of the target user
     * @param {?} clientId ID of the client app
     * @return {?} List of client roles
     */
    getClientRoles(userId, clientId) {
        /** @type {?} */
        const url = this.buildUserClientRoleMapping(userId, clientId);
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = {};
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null));
    }
    /**
     * Checks whether user has access to a client app.
     * @param {?} userId ID of the target user
     * @param {?} clientId ID of the client app
     * @return {?} True if the user has access, false otherwise
     */
    checkUserHasClientApp(userId, clientId) {
        return this.getClientRoles(userId, clientId).pipe(map((/**
         * @param {?} clientRoles
         * @return {?}
         */
        (clientRoles) => {
            if (clientRoles.length > 0) {
                return true;
            }
            return false;
        })));
    }
    /**
     * Checks whether a user has any of the client app roles.
     * @param {?} userId ID of the target user
     * @param {?} clientId ID of the client app
     * @param {?} roleNames List of role names to check for
     * @return {?} True if the user has one or more of the roles, false otherwise
     */
    checkUserHasAnyClientAppRole(userId, clientId, roleNames) {
        return this.getClientRoles(userId, clientId).pipe(map((/**
         * @param {?} clientRoles
         * @return {?}
         */
        (clientRoles) => {
            /** @type {?} */
            let hasRole = false;
            if (clientRoles.length > 0) {
                roleNames.forEach((/**
                 * @param {?} roleName
                 * @return {?}
                 */
                (roleName) => {
                    /** @type {?} */
                    const role = clientRoles.find((/**
                     * @param {?} availableRole
                     * @return {?}
                     */
                    (availableRole) => {
                        return availableRole.name === roleName;
                    }));
                    if (role) {
                        hasRole = true;
                        return;
                    }
                }));
            }
            return hasRole;
        })));
    }
    /**
     * Gets the client ID for an application.
     * @param {?} applicationName Name of the application
     * @return {?} Client ID string
     */
    getClientIdByApplicationName(applicationName) {
        /** @type {?} */
        const url = this.buildGetClientsUrl();
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = { clientId: applicationName };
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return from(this.apiService.getInstance()
            .oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null)).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const clientId = response && response.length > 0 ? response[0].id : '';
            return clientId;
        })));
    }
    /**
     * Checks if a user has access to an application.
     * @param {?} userId ID of the user
     * @param {?} applicationName Name of the application
     * @return {?} True if the user has access, false otherwise
     */
    checkUserHasApplicationAccess(userId, applicationName) {
        return this.getClientIdByApplicationName(applicationName).pipe(switchMap((/**
         * @param {?} clientId
         * @return {?}
         */
        (clientId) => {
            return this.checkUserHasClientApp(userId, clientId);
        })));
    }
    /**
     * Checks if a user has any application role.
     * @param {?} userId ID of the target user
     * @param {?} applicationName Name of the application
     * @param {?} roleNames List of role names to check for
     * @return {?} True if the user has one or more of the roles, false otherwise
     */
    checkUserHasAnyApplicationRole(userId, applicationName, roleNames) {
        return this.getClientIdByApplicationName(applicationName).pipe(switchMap((/**
         * @param {?} clientId
         * @return {?}
         */
        (clientId) => {
            return this.checkUserHasAnyClientAppRole(userId, clientId, roleNames);
        })));
    }
    /**
     * Gets details for all users.
     * @return {?} Array of user info objects
     */
    getUsers() {
        /** @type {?} */
        const url = this.buildUserUrl();
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = {};
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const authNames = [];
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, authNames, contentTypes, accepts, null, null)).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return response;
        })));
    }
    /**
     * Gets a list of roles for a user.
     * @param {?} userId ID of the user
     * @return {?} Array of role info objects
     */
    getUserRoles(userId) {
        /** @type {?} */
        const url = this.buildRolesUrl(userId);
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = {};
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null)).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return response;
        })));
    }
    /**
     * Gets an array of users (including the current user) who have any of the roles in the supplied list.
     * @param {?} roleNames List of role names to look for
     * @return {?} Array of user info objects
     */
    getUsersByRolesWithCurrentUser(roleNames) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const filteredUsers = [];
            if (roleNames && roleNames.length > 0) {
                /** @type {?} */
                const users = yield this.getUsers().toPromise();
                for (let i = 0; i < users.length; i++) {
                    /** @type {?} */
                    const hasAnyRole = yield this.userHasAnyRole(users[i].id, roleNames);
                    if (hasAnyRole) {
                        filteredUsers.push(users[i]);
                    }
                }
            }
            return filteredUsers;
        });
    }
    /**
     * Gets an array of users (not including the current user) who have any of the roles in the supplied list.
     * @param {?} roleNames List of role names to look for
     * @return {?} Array of user info objects
     */
    getUsersByRolesWithoutCurrentUser(roleNames) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const filteredUsers = [];
            if (roleNames && roleNames.length > 0) {
                /** @type {?} */
                const currentUser = this.getCurrentUserInfo();
                /** @type {?} */
                let users = yield this.getUsers().toPromise();
                users = users.filter((/**
                 * @param {?} user
                 * @return {?}
                 */
                (user) => { return user.username !== currentUser.username; }));
                for (let i = 0; i < users.length; i++) {
                    /** @type {?} */
                    const hasAnyRole = yield this.userHasAnyRole(users[i].id, roleNames);
                    if (hasAnyRole) {
                        filteredUsers.push(users[i]);
                    }
                }
            }
            return filteredUsers;
        });
    }
    /**
     * @private
     * @param {?} userId
     * @param {?} roleNames
     * @return {?}
     */
    userHasAnyRole(userId, roleNames) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const userRoles = yield this.getUserRoles(userId).toPromise();
            /** @type {?} */
            const hasAnyRole = roleNames.some((/**
             * @param {?} roleName
             * @return {?}
             */
            (roleName) => {
                /** @type {?} */
                const filteredRoles = userRoles.filter((/**
                 * @param {?} userRole
                 * @return {?}
                 */
                (userRole) => {
                    return userRole.name.toLocaleLowerCase() === roleName.toLocaleLowerCase();
                }));
                return filteredRoles.length > 0;
            }));
            return hasAnyRole;
        });
    }
    /**
     * Checks if a user has one of the roles from a list.
     * @param {?} userId ID of the target user
     * @param {?} roleNames Array of roles to check for
     * @return {?} True if the user has one of the roles, false otherwise
     */
    checkUserHasRole(userId, roleNames) {
        return this.getUserRoles(userId).pipe(map((/**
         * @param {?} userRoles
         * @return {?}
         */
        (userRoles) => {
            /** @type {?} */
            let hasRole = false;
            if (userRoles && userRoles.length > 0) {
                roleNames.forEach((/**
                 * @param {?} roleName
                 * @return {?}
                 */
                (roleName) => {
                    /** @type {?} */
                    const role = userRoles.find((/**
                     * @param {?} userRole
                     * @return {?}
                     */
                    (userRole) => {
                        return roleName === userRole.name;
                    }));
                    if (role) {
                        hasRole = true;
                        return;
                    }
                }));
            }
            return hasRole;
        })));
    }
    /**
     * @private
     * @return {?}
     */
    buildUserUrl() {
        return `${this.appConfigService.get('identityHost')}/users`;
    }
    /**
     * @private
     * @param {?} userId
     * @param {?} clientId
     * @return {?}
     */
    buildUserClientRoleMapping(userId, clientId) {
        return `${this.appConfigService.get('identityHost')}/users/${userId}/role-mappings/clients/${clientId}`;
    }
    /**
     * @private
     * @param {?} userId
     * @return {?}
     */
    buildRolesUrl(userId) {
        return `${this.appConfigService.get('identityHost')}/users/${userId}/role-mappings/realm/composite`;
    }
    /**
     * @private
     * @return {?}
     */
    buildGetClientsUrl() {
        return `${this.appConfigService.get('identityHost')}/clients`;
    }
}
IdentityUserService.USER_NAME = 'name';
IdentityUserService.FAMILY_NAME = 'family_name';
IdentityUserService.GIVEN_NAME = 'given_name';
IdentityUserService.USER_EMAIL = 'email';
IdentityUserService.USER_ACCESS_TOKEN = 'access_token';
IdentityUserService.USER_PREFERRED_USERNAME = 'preferred_username';
IdentityUserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
IdentityUserService.ctorParameters = () => [
    { type: JwtHelperService },
    { type: AlfrescoApiService },
    { type: AppConfigService }
];
/** @nocollapse */ IdentityUserService.ngInjectableDef = defineInjectable({ factory: function IdentityUserService_Factory() { return new IdentityUserService(inject(JwtHelperService), inject(AlfrescoApiService), inject(AppConfigService)); }, token: IdentityUserService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserInfoComponent {
    /**
     * @param {?} ecmUserService
     * @param {?} bpmUserService
     * @param {?} identityUserService
     * @param {?} authService
     */
    constructor(ecmUserService, bpmUserService, identityUserService, authService) {
        this.ecmUserService = ecmUserService;
        this.bpmUserService = bpmUserService;
        this.identityUserService = identityUserService;
        this.authService = authService;
        /**
         * Custom path for the background banner image for ACS users.
         */
        this.ecmBackgroundImage = './assets/images/ecm-background.png';
        /**
         * Custom path for the background banner image for APS users.
         */
        this.bpmBackgroundImage = './assets/images/bpm-background.png';
        /**
         * Custom choice for opening the menu at the bottom. Can be `before` or `after`.
         */
        this.menuPositionX = 'after';
        /**
         * Custom choice for opening the menu at the bottom. Can be `above` or `below`.
         */
        this.menuPositionY = 'below';
        /**
         * Shows/hides the username next to the user info button.
         */
        this.showName = true;
        /**
         * When the username is shown, this defines its position relative to the user info button.
         * Can be `right` or `left`.
         */
        this.namePosition = 'right';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.getUserInfo();
    }
    /**
     * @return {?}
     */
    getUserInfo() {
        if (this.authService.isOauth()) {
            this.loadIdentityUserInfo();
        }
        else if (this.authService.isEcmLoggedIn() && this.authService.isBpmLoggedIn()) {
            this.loadEcmUserInfo();
            this.loadBpmUserInfo();
        }
        else if (this.authService.isEcmLoggedIn()) {
            this.loadEcmUserInfo();
        }
        else if (this.authService.isBpmLoggedIn()) {
            this.loadBpmUserInfo();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyPress(event) {
        this.closeUserModal(event);
    }
    /**
     * @private
     * @param {?} $event
     * @return {?}
     */
    closeUserModal($event) {
        if ($event.keyCode === 27) {
            this.trigger.closeMenu();
        }
    }
    /**
     * @return {?}
     */
    isLoggedIn() {
        return this.authService.isLoggedIn();
    }
    /**
     * @return {?}
     */
    loadEcmUserInfo() {
        this.ecmUser$ = this.ecmUserService.getCurrentUserInfo();
    }
    /**
     * @return {?}
     */
    loadBpmUserInfo() {
        this.bpmUser$ = this.bpmUserService.getCurrentUserInfo();
    }
    /**
     * @return {?}
     */
    loadIdentityUserInfo() {
        this.identityUser$ = of(this.identityUserService.getCurrentUserInfo());
    }
    /**
     * @param {?} event
     * @return {?}
     */
    stopClosing(event) {
        event.stopPropagation();
    }
    /**
     * @param {?} avatarId
     * @return {?}
     */
    getEcmAvatar(avatarId) {
        return this.ecmUserService.getUserProfileImage(avatarId);
    }
    /**
     * @return {?}
     */
    getBpmUserImage() {
        return this.bpmUserService.getCurrentUserProfileImage();
    }
    /**
     * @return {?}
     */
    showOnRight() {
        return this.namePosition === 'right';
    }
}
UserInfoComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-userinfo',
                template: "<div id=\"userinfo_container\" [class.adf-userinfo-name-right]=\"showOnRight()\" (keyup)=\"onKeyPress($event)\"\n    class=\"adf-userinfo-container\" *ngIf=\"isLoggedIn()\">\n\n    <ng-container *ngIf=\"showName\">\n        <span *ngIf=\"identityUser$ | async as identityUser; else showBpmAndEcmUserFullNames\" id=\"adf-userinfo-identity-name-display\"\n            class=\"adf-userinfo-name\">{{identityUser | fullName}}</span>\n        <ng-template #showBpmAndEcmUserFullNames>\n            <span *ngIf=\"ecmUser$ | async as ecmUser; else showBpmUserFullName\" id=\"adf-userinfo-ecm-name-display\"\n                class=\"adf-userinfo-name\">{{ecmUser | fullName}}</span>\n            <ng-template #showBpmUserFullName>\n                <span *ngIf=\"bpmUser$ | async as bpmUser\" id=\"adf-userinfo-bpm-name-display\"\n                    class=\"adf-userinfo-name\">{{bpmUser | fullName}}</span>\n            </ng-template>\n        </ng-template>\n    </ng-container>\n\n    <button mat-button [matMenuTriggerFor]=\"menu\" class=\"adf-userinfo-menu_button\" data-automation-id=\"adf-user-profile\">\n        <div class=\"adf-userinfo-button-profile\" id=\"user-profile\">\n            <div *ngIf=\"identityUser$ | async as identityUser; else showBpmAndEcmUserImage\" id=\"identity-user-image\">\n                <div [outerHTML]=\"identityUser | usernameInitials:'adf-userinfo-pic'\"></div>\n            </div>\n            <ng-template #showBpmAndEcmUserImage>\n                <div *ngIf=\"ecmUser$ | async as ecmUser; else showBpmUserImage\" id=\"ecm-user-image\">\n                    <div *ngIf=\"ecmUser.avatarId; else initialTemplate\" class=\"adf-userinfo-profile-container\">\n                        <img id=\"logged-user-img\" [src]=\"getEcmAvatar(ecmUser.avatarId)\" alt=\"user-info-profile-button\"\n                            class=\"adf-userinfo-profile-image\"/>\n                    </div>\n                    <ng-template #initialTemplate>\n                        <div [outerHTML]=\"ecmUser | usernameInitials:'adf-userinfo-pic'\"></div>\n                    </ng-template>\n                </div>\n                <ng-template #showBpmUserImage>\n                    <div *ngIf=\"bpmUser$ | async as bpmUser\" id=\"bpm-user-image\">\n                            <div *ngIf=\"bpmUser.pictureId; else initialTemplate\" class=\"adf-userinfo-profile-container\">\n                                <img id=\"logged-user-img\" [src]=\"getBpmUserImage()\" alt=\"user-info-profile-button\"\n                                    class=\"adf-userinfo-profile-image\"/>\n                            </div>\n                            <ng-template #initialTemplate>\n                                <div [outerHTML]=\"bpmUser | usernameInitials:'adf-userinfo-pic'\"></div>\n                            </ng-template>\n                    </div>\n                </ng-template>\n            </ng-template>\n        </div>\n    </button>\n    <mat-menu #menu=\"matMenu\" id=\"user-profile-lists\" [xPosition]=\"menuPositionX\" [yPosition]=\"menuPositionY\" [overlapTrigger]=\"false\" class=\"adf-userinfo-menu\">\n        <mat-tab-group id=\"tab-group-env\" (click)=\"stopClosing($event)\"\n            class=\"adf-userinfo-tab\" [class.adf-hide-tab]=\"!(bpmUser$ | async) || !(ecmUser$ | async)\">\n            <mat-tab id=\"ecm-panel\" label=\"{{ 'USER_PROFILE.TAB.CS' | translate }}\" *ngIf=\"ecmUser$ | async as ecmUser\">\n                <mat-card class=\"adf-userinfo-card\">\n                    <mat-card-header class=\"adf-userinfo-card-header\" [style.background-image]=\"'url(' + ecmBackgroundImage + ')'\">\n                        <div *ngIf=\"ecmUser.avatarId; else initialTemplate\" class=\"adf-userinfo-profile-container adf-hide-small\">\n                            <img class=\"adf-userinfo-profile-picture\" id=\"ecm-user-detail-image\"\n                                alt=\"ecm-profile-image\" [src]=\"getEcmAvatar(ecmUser.avatarId)\" />\n                        </div>\n                        <ng-template #initialTemplate>\n                            <div [outerHTML]=\"ecmUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'\"></div>\n                        </ng-template>\n\n                       <div class=\"adf-userinfo-title\" id=\"ecm-username\">{{ecmUser | fullName}}</div>\n                    </mat-card-header>\n                    <mat-card-content>\n                        <div class=\"adf-userinfo-supporting-text\">\n                                <div class=\"adf-userinfo-detail\">\n                                    <span id=\"ecm-full-name\" class=\"adf-userinfo__detail-title\">{{ecmUser | fullName}}</span>\n                                    <span class=\"adf-userinfo__detail-profile\" id=\"ecm-email\"> {{ecmUser.email}} </span>\n                                </div>\n                                <div class=\"adf-userinfo-detail\">\n                                    <span class=\"adf-userinfo__secondary-info\" id=\"ecm-job-title-label\">\n                                        {{ 'USER_PROFILE.LABELS.ECM.JOB_TITLE' | translate }}\n                                        <span id=\"ecm-job-title\" class=\"adf-userinfo__detail-profile\"> {{ ecmUser.jobTitle ? ecmUser.jobTitle : 'N/A' }} </span>\n                                    </span>\n                                </div>\n                        </div>\n                    </mat-card-content>\n                </mat-card>\n            </mat-tab>\n            <mat-tab id=\"bpm-panel\" label=\"{{ 'USER_PROFILE.TAB.PS' | translate }}\" *ngIf=\"bpmUser$ | async as bpmUser\">\n            <mat-card class=\"adf-userinfo-card\">\n                <mat-card-header class=\"adf-userinfo-card-header\" [style.background-image]=\"'url(' + bpmBackgroundImage + ')'\">\n                    <img *ngIf=\"bpmUser.pictureId; else initialTemplate\" class=\"adf-userinfo-profile-picture adf-hide-small\" id=\"bpm-user-detail-image\"\n                            alt=\"bpm-profile-image\" [src]=\"getBpmUserImage()\"/>\n                    <ng-template #initialTemplate>\n                        <div [outerHTML]=\"bpmUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'\"></div>\n                    </ng-template>\n                   <div class=\"adf-userinfo-title\" id=\"bpm-username\">{{bpmUser | fullName}}</div>\n                </mat-card-header>\n                <mat-card-content>\n                    <div class=\"adf-userinfo-supporting-text\">\n                            <div class=\"adf-userinfo-detail\">\n                                <span id=\"bpm-full-name\" class=\"adf-userinfo__detail-title\">{{ bpmUser | fullName }}</span>\n                                <span class=\"adf-userinfo__detail-profile\" id=\"bpm-email\"> {{bpmUser.email}} </span>\n                            </div>\n                            <div class=\"adf-userinfo-detail\">\n                                <span id=\"bpm-tenant\" class=\"adf-userinfo__secondary-info\">\n                                    {{ 'USER_PROFILE.LABELS.BPM.TENANT' | translate }}\n                                    <span class=\"adf-userinfo__detail-profile\">{{ bpmUser.tenantName ? bpmUser.tenantName : '' }}</span>\n                                </span>\n                            </div>\n                    </div>\n                </mat-card-content>\n            </mat-card>\n            </mat-tab>\n            <mat-tab id=\"identity-panel\" *ngIf=\"identityUser$ | async as identityUser\">\n                <mat-card class=\"adf-userinfo-card\">\n                    <mat-card-header class=\"adf-userinfo-card-header\" [style.background-image]=\"'url(' + bpmBackgroundImage + ')'\">\n                        <div\n                            [outerHTML]=\"identityUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'\">\n                        </div>\n                       <div class=\"adf-userinfo-title\" id=\"identity-username\">{{identityUser | fullName}}</div>\n                    </mat-card-header>\n                    <mat-card-content>\n                        <div class=\"adf-userinfo-supporting-text\">\n                                <div class=\"adf-userinfo-detail\">\n                                    <span id=\"identity-full-name\" class=\"adf-userinfo__detail-title\">{{identityUser | fullName}}</span>\n                                    <span class=\"adf-userinfo__detail-profile\" id=\"identity-email\"> {{identityUser.email}} </span>\n                                </div>\n                        </div>\n                    </mat-card-content>\n                </mat-card>\n            </mat-tab>\n        </mat-tab-group>\n    </mat-menu>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
UserInfoComponent.ctorParameters = () => [
    { type: EcmUserService },
    { type: BpmUserService },
    { type: IdentityUserService },
    { type: AuthenticationService }
];
UserInfoComponent.propDecorators = {
    trigger: [{ type: ViewChild, args: [MatMenuTrigger,] }],
    ecmBackgroundImage: [{ type: Input }],
    bpmBackgroundImage: [{ type: Input }],
    menuPositionX: [{ type: Input }],
    menuPositionY: [{ type: Input }],
    showName: [{ type: Input }],
    namePosition: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IdentityRoleModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.name = obj.name || null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserInfoModule {
}
UserInfoModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild(),
                    PipeModule
                ],
                declarations: [
                    UserInfoComponent
                ],
                exports: [
                    UserInfoComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HostSettingsComponent {
    /**
     * @param {?} formBuilder
     * @param {?} storageService
     * @param {?} alfrescoApiService
     * @param {?} appConfig
     */
    constructor(formBuilder, storageService, alfrescoApiService, appConfig) {
        this.formBuilder = formBuilder;
        this.storageService = storageService;
        this.alfrescoApiService = alfrescoApiService;
        this.appConfig = appConfig;
        this.HOST_REGEX = '^(http|https):\/\/.*[^/]$';
        /**
         * Tells the component which provider options are available. Possible valid values
         * are "ECM" (Content), "BPM" (Process) , "ALL" (Content and Process), 'OAUTH2' SSO.
         */
        this.providers = ['BPM', 'ECM', 'ALL'];
        this.showSelectProviders = true;
        /**
         * Emitted when the URL is invalid.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the user cancels the changes.
         */
        this.cancel = new EventEmitter();
        /**
         * Emitted when the changes are successfully applied.
         */
        this.success = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.providers.length === 1) {
            this.showSelectProviders = false;
        }
        /** @type {?} */
        const providerSelected = this.appConfig.get(AppConfigValues.PROVIDERS);
        /** @type {?} */
        const authType = this.appConfig.get(AppConfigValues.AUTHTYPE, 'BASIC');
        this.form = this.formBuilder.group({
            providersControl: [providerSelected, Validators.required],
            authType: authType
        });
        this.addFormGroups();
        if (authType === 'OAUTH') {
            this.addOAuthFormGroup();
            this.addIdentityHostFormControl();
        }
        this.form.get('authType').valueChanges.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            if (value === 'BASIC') {
                this.form.removeControl('oauthConfig');
                this.form.removeControl('identityHost');
            }
            else {
                this.addOAuthFormGroup();
                this.addIdentityHostFormControl();
            }
        }));
        this.providersControl.valueChanges.subscribe((/**
         * @return {?}
         */
        () => {
            this.removeFormGroups();
            this.addFormGroups();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    removeFormGroups() {
        this.form.removeControl('bpmHost');
        this.form.removeControl('ecmHost');
    }
    /**
     * @private
     * @return {?}
     */
    addFormGroups() {
        this.addBPMFormControl();
        this.addECMFormControl();
    }
    /**
     * @private
     * @return {?}
     */
    addOAuthFormGroup() {
        /** @type {?} */
        const oauthFormGroup = this.createOAuthFormGroup();
        this.form.addControl('oauthConfig', oauthFormGroup);
    }
    /**
     * @private
     * @return {?}
     */
    addBPMFormControl() {
        if ((this.isBPM() || this.isALL() || this.isOAUTH()) && !this.bpmHost) {
            /** @type {?} */
            const bpmFormControl = this.createBPMFormControl();
            this.form.addControl('bpmHost', bpmFormControl);
        }
    }
    /**
     * @private
     * @return {?}
     */
    addIdentityHostFormControl() {
        /** @type {?} */
        const identityHostFormControl = this.createIdentityFormControl();
        this.form.addControl('identityHost', identityHostFormControl);
    }
    /**
     * @private
     * @return {?}
     */
    addECMFormControl() {
        if ((this.isECM() || this.isALL()) && !this.ecmHost) {
            /** @type {?} */
            const ecmFormControl = this.createECMFormControl();
            this.form.addControl('ecmHost', ecmFormControl);
        }
    }
    /**
     * @private
     * @return {?}
     */
    createOAuthFormGroup() {
        /** @type {?} */
        const oauth = (/** @type {?} */ (this.appConfig.get(AppConfigValues.OAUTHCONFIG, {})));
        return this.formBuilder.group({
            host: [oauth.host, [Validators.required, Validators.pattern(this.HOST_REGEX)]],
            clientId: [oauth.clientId, Validators.required],
            redirectUri: [oauth.redirectUri, Validators.required],
            redirectUriLogout: [oauth.redirectUriLogout],
            scope: [oauth.scope, Validators.required],
            secret: oauth.secret,
            silentLogin: oauth.silentLogin,
            implicitFlow: oauth.implicitFlow
        });
    }
    /**
     * @private
     * @return {?}
     */
    createBPMFormControl() {
        return new FormControl(this.appConfig.get(AppConfigValues.BPMHOST), [Validators.required, Validators.pattern(this.HOST_REGEX)]);
    }
    /**
     * @private
     * @return {?}
     */
    createIdentityFormControl() {
        return new FormControl(this.appConfig.get(AppConfigValues.IDENTITY_HOST), [Validators.required, Validators.pattern(this.HOST_REGEX)]);
    }
    /**
     * @private
     * @return {?}
     */
    createECMFormControl() {
        return new FormControl(this.appConfig.get(AppConfigValues.ECMHOST), [Validators.required, Validators.pattern(this.HOST_REGEX)]);
    }
    /**
     * @return {?}
     */
    onCancel() {
        this.cancel.emit(true);
    }
    /**
     * @param {?} values
     * @return {?}
     */
    onSubmit(values) {
        this.storageService.setItem(AppConfigValues.PROVIDERS, values.providersControl);
        if (this.isBPM()) {
            this.saveBPMValues(values);
        }
        else if (this.isECM()) {
            this.saveECMValues(values);
        }
        else if (this.isALL()) {
            this.saveECMValues(values);
            this.saveBPMValues(values);
        }
        if (this.isOAUTH()) {
            this.saveOAuthValues(values);
        }
        this.storageService.setItem(AppConfigValues.AUTHTYPE, values.authType);
        this.alfrescoApiService.reset();
        this.alfrescoApiService.getInstance().invalidateSession();
        this.success.emit(true);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    keyDownFunction(event) {
        if (event.keyCode === ENTER && this.form.valid) {
            this.onSubmit(this.form.value);
        }
    }
    /**
     * @private
     * @param {?} values
     * @return {?}
     */
    saveOAuthValues(values) {
        this.storageService.setItem(AppConfigValues.OAUTHCONFIG, JSON.stringify(values.oauthConfig));
        this.storageService.setItem(AppConfigValues.IDENTITY_HOST, values.identityHost);
    }
    /**
     * @private
     * @param {?} values
     * @return {?}
     */
    saveBPMValues(values) {
        this.storageService.setItem(AppConfigValues.BPMHOST, values.bpmHost);
    }
    /**
     * @private
     * @param {?} values
     * @return {?}
     */
    saveECMValues(values) {
        this.storageService.setItem(AppConfigValues.ECMHOST, values.ecmHost);
    }
    /**
     * @return {?}
     */
    isBPM() {
        return this.providersControl.value === 'BPM';
    }
    /**
     * @return {?}
     */
    isECM() {
        return this.providersControl.value === 'ECM';
    }
    /**
     * @return {?}
     */
    isALL() {
        return this.providersControl.value === 'ALL';
    }
    /**
     * @return {?}
     */
    isOAUTH() {
        return this.form.get('authType').value === 'OAUTH';
    }
    /**
     * @return {?}
     */
    get providersControl() {
        return this.form.get('providersControl');
    }
    /**
     * @return {?}
     */
    get bpmHost() {
        return this.form.get('bpmHost');
    }
    /**
     * @return {?}
     */
    get ecmHost() {
        return this.form.get('ecmHost');
    }
    /**
     * @return {?}
     */
    get host() {
        return this.oauthConfig.get('host');
    }
    /**
     * @return {?}
     */
    get identityHost() {
        return this.form.get('identityHost');
    }
    /**
     * @return {?}
     */
    get clientId() {
        return this.oauthConfig.get('clientId');
    }
    /**
     * @return {?}
     */
    get scope() {
        return this.oauthConfig.get('scope');
    }
    /**
     * @return {?}
     */
    get secretId() {
        return this.oauthConfig.get('secretId');
    }
    /**
     * @return {?}
     */
    get implicitFlow() {
        return this.oauthConfig.get('implicitFlow');
    }
    /**
     * @return {?}
     */
    get silentLogin() {
        return this.oauthConfig.get('silentLogin');
    }
    /**
     * @return {?}
     */
    get redirectUri() {
        return this.oauthConfig.get('redirectUri');
    }
    /**
     * @return {?}
     */
    get redirectUriLogout() {
        return this.oauthConfig.get('redirectUriLogout');
    }
    /**
     * @return {?}
     */
    get oauthConfig() {
        return this.form.get('oauthConfig');
    }
}
HostSettingsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-host-settings',
                template: "<div class=\"adf-setting-container\">\n    <mat-toolbar color=\"primary\" class=\"adf-setting-toolbar\">\n        <h3>{{'CORE.HOST_SETTINGS.TITLE' | translate}}</h3>\n    </mat-toolbar>\n    <mat-card class=\"adf-setting-card\">\n        <form id=\"host-form\" [formGroup]=\"form\" (submit)=\"onSubmit(form.value)\" (keydown)=\"keyDownFunction($event)\">\n\n            <mat-form-field floatLabel=\"{{'CORE.HOST_SETTINGS.PROVIDER' | translate }}\" *ngIf=\"showSelectProviders\">\n                <mat-select  id=\"adf-provider-selector\" placeholder=\"Provider\" [formControl]=\"providersControl\">\n                    <mat-option *ngFor=\"let provider of providers\" [value]=\"provider\">\n                        {{ provider }}\n                    </mat-option>\n                </mat-select>\n            </mat-form-field>\n\n            <div class=\"adf-authentication-type\">\n                <div> {{'CORE.HOST_SETTINGS.TYPE-AUTH' | translate }} : </div>\n                <mat-radio-group formControlName=\"authType\" >\n                <mat-radio-button value=\"BASIC\">{{'CORE.HOST_SETTINGS.BASIC' | translate }}\n                </mat-radio-button>\n                <mat-radio-button value=\"OAUTH\">{{'CORE.HOST_SETTINGS.SSO' | translate }}\n                </mat-radio-button>\n            </mat-radio-group>\n            </div>\n\n            <ng-container *ngIf=\"isALL() || isECM()\">\n                <mat-card-content>\n                    <mat-form-field class=\"adf-full-width\" floatLabel=\"{{'CORE.HOST_SETTINGS.CS-HOST' | translate }}\">\n                        <mat-label>{{'CORE.HOST_SETTINGS.CS-HOST' | translate }}</mat-label>\n                        <input matInput [formControl]=\"ecmHost\" data-automation-id=\"ecmHost\" type=\"text\"\n                               id=\"ecmHost\" placeholder=\"http(s)://host|ip:port(/path)\">\n                        <mat-error *ngIf=\"ecmHost.hasError('pattern')\">\n                            {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"ecmHost.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n                    <p>\n                </mat-card-content>\n            </ng-container>\n\n            <ng-container *ngIf=\"isALL() || isBPM()\">\n                <mat-card-content>\n                    <mat-form-field class=\"adf-full-width\" floatLabel=\"{{'CORE.HOST_SETTINGS.BP-HOST' | translate }}\">\n                        <mat-label>{{'CORE.HOST_SETTINGS.BP-HOST' | translate }}</mat-label>\n                        <input matInput [formControl]=\"bpmHost\" data-automation-id=\"bpmHost\" type=\"text\"\n                               id=\"bpmHost\" placeholder=\"http(s)://host|ip:port(/path)\">\n                        <mat-error *ngIf=\"bpmHost.hasError('pattern')\">\n                            {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"bpmHost.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n                </mat-card-content>\n            </ng-container>\n\n            <ng-container *ngIf=\"isOAUTH()\">\n                <mat-card-content>\n                    <mat-form-field class=\"adf-full-width\" floatLabel=\"Identity Host\">\n                        <mat-label>Identity Host</mat-label>\n                        <input matInput name=\"identityHost\" id=\"identityHost\" formControlName=\"identityHost\"\n                                placeholder=\"http(s)://host|ip:port(/path)\">\n                        <mat-error *ngIf=\"identityHost.hasError('pattern')\">\n                            {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"identityHost.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n                </mat-card-content>\n            </ng-container>\n\n            <ng-container *ngIf=\"isOAUTH()\">\n                <div formGroupName=\"oauthConfig\">\n                    <mat-form-field class=\"adf-full-width\" floatLabel=\"Auth Host\">\n                        <mat-label>Auth Host</mat-label>\n                        <input matInput name=\"host\" id=\"oauthHost\" formControlName=\"host\"\n                               placeholder=\"http(s)://host|ip:port(/path)\">\n                        <mat-error *ngIf=\"host.hasError('pattern')\">\n                            {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"host.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n                    <mat-form-field class=\"adf-full-width\" floatLabel=\"Client Id\">\n                        <mat-label>{{ 'CORE.HOST_SETTINGS.CLIENT'| translate }}</mat-label>\n                        <input matInput name=\"clientId\" id=\"clientId\" formControlName=\"clientId\"\n                               placeholder=\"Client Id\">\n                        <mat-error *ngIf=\"clientId.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n\n                    <mat-form-field class=\"adf-full-width\" floatLabel=\"Scope\">\n                        <mat-label>{{ 'CORE.HOST_SETTINGS.SCOPE'| translate }}</mat-label>\n                        <input matInput name=\"{{ 'CORE.HOST_SETTINGS.SCOPE'| translate }}\"\n                               formControlName=\"scope\" placeholder=\"Scope Id\">\n                        <mat-error *ngIf=\"scope.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n\n                    <label for=\"silentLogin\">{{ 'CORE.HOST_SETTINGS.SILENT'| translate }}</label>\n                    <mat-slide-toggle class=\"adf-full-width\" name=\"silentLogin\" [color]=\"'primary'\"\n                                      formControlName=\"silentLogin\">\n                    </mat-slide-toggle>\n\n                    <label for=\"implicitFlow\">{{ 'CORE.HOST_SETTINGS.IMPLICIT-FLOW'| translate }}</label>\n                    <mat-slide-toggle class=\"adf-full-width\" name=\"implicitFlow\" [color]=\"'primary'\"\n                                      formControlName=\"implicitFlow\">\n                    </mat-slide-toggle>\n\n\n                    <mat-form-field class=\"adf-full-width\" floatLabel=\"Redirect Uri\">\n                        <mat-label>{{ 'CORE.HOST_SETTINGS.REDIRECT'| translate }}</mat-label>\n                        <input matInput placeholder=\"{{ 'CORE.HOST_SETTINGS.REDIRECT'| translate }}\"\n                               name=\"redirectUri\" formControlName=\"redirectUri\">\n                        <mat-error *ngIf=\"redirectUri.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n\n                    <mat-form-field class=\"adf-full-width\" floatLabel=\"Redirect Uri Logout\">\n                        <mat-label>{{ 'CORE.HOST_SETTINGS.REDIRECT_LOGOUT'| translate }}</mat-label>\n                        <input id=\"logout-url\" matInput placeholder=\"{{ 'CORE.HOST_SETTINGS.REDIRECT_LOGOUT'| translate }}\"\n                               name=\"redirectUriLogout\" formControlName=\"redirectUriLogout\">\n                    </mat-form-field>\n                </div>\n            </ng-container>\n            <mat-card-actions class=\"adf-actions\">\n                <button mat-button (click)=\"onCancel()\" color=\"primary\">\n                    {{'CORE.HOST_SETTINGS.BACK' | translate }}\n                </button>\n                <button type=\"submit\" id=\"host-button\" class=\"adf-login-button\" mat-raised-button\n                        color=\"primary\" data-automation-id=\"host-button\"\n                        [disabled]=\"!form.valid\">\n                    {{'CORE.HOST_SETTINGS.APPLY' | translate }}\n                </button>\n            </mat-card-actions>\n        </form>\n    </mat-card>\n</div>\n",
                host: {
                    'class': 'adf-host-settings'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
HostSettingsComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: StorageService },
    { type: AlfrescoApiService },
    { type: AppConfigService }
];
HostSettingsComponent.propDecorators = {
    providers: [{ type: Input }],
    error: [{ type: Output }],
    cancel: [{ type: Output }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HostSettingsModule {
}
HostSettingsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild(),
                    FormsModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    HostSettingsComponent
                ],
                exports: [
                    HostSettingsComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationModel extends Pagination {
    /**
     * @param {?=} input
     */
    constructor(input) {
        super(input);
        if (input) {
            this.count = input.count;
            this.hasMoreItems = input.hasMoreItems ? input.hasMoreItems : false;
            this.merge = input.merge ? input.merge : false;
            this.totalItems = input.totalItems;
            this.skipCount = input.skipCount;
            this.maxItems = input.maxItems;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationComponent {
    /**
     * @param {?} cdr
     * @param {?} userPreferencesService
     */
    constructor(cdr, userPreferencesService) {
        this.cdr = cdr;
        this.userPreferencesService = userPreferencesService;
        /**
         * Pagination object.
         */
        this.pagination = PaginationComponent.DEFAULT_PAGINATION;
        /**
         * Emitted when pagination changes in any way.
         */
        this.change = new EventEmitter();
        /**
         * Emitted when the page number changes.
         */
        this.changePageNumber = new EventEmitter();
        /**
         * Emitted when the page size changes.
         */
        this.changePageSize = new EventEmitter();
        /**
         * Emitted when the next page is requested.
         */
        this.nextPage = new EventEmitter();
        /**
         * Emitted when the previous page is requested.
         */
        this.prevPage = new EventEmitter();
        this.userPreferencesService.select(UserPreferenceValues.PaginationSize).subscribe((/**
         * @param {?} pagSize
         * @return {?}
         */
        (pagSize) => {
            this.pagination.maxItems = pagSize;
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.supportedPageSizes) {
            this.supportedPageSizes = this.userPreferencesService.supportedPageSizes;
        }
        if (this.target) {
            this.paginationSubscription = this.target.pagination.subscribe((/**
             * @param {?} pagination
             * @return {?}
             */
            (pagination) => {
                if (pagination.count === 0 && !this.isFirstPage) {
                    this.goPrevious();
                }
                this.pagination = pagination;
                this.cdr.detectChanges();
            }));
        }
        if (!this.pagination) {
            this.pagination = PaginationComponent.DEFAULT_PAGINATION;
        }
    }
    /**
     * @return {?}
     */
    get lastPage() {
        const { maxItems, totalItems } = this.pagination;
        return (totalItems && maxItems)
            ? Math.ceil(totalItems / maxItems)
            : 1;
    }
    /**
     * @return {?}
     */
    get current() {
        const { maxItems, skipCount } = this.pagination;
        return (skipCount && maxItems)
            ? Math.floor(skipCount / maxItems) + 1
            : 1;
    }
    /**
     * @return {?}
     */
    get isLastPage() {
        return this.current === this.lastPage;
    }
    /**
     * @return {?}
     */
    get isFirstPage() {
        return this.current === 1;
    }
    /**
     * @return {?}
     */
    get next() {
        return this.isLastPage ? this.current : this.current + 1;
    }
    /**
     * @return {?}
     */
    get previous() {
        return this.isFirstPage ? 1 : this.current - 1;
    }
    /**
     * @return {?}
     */
    get hasItems() {
        return this.pagination && this.pagination.count > 0;
    }
    /**
     * @return {?}
     */
    get isEmpty() {
        return !this.hasItems;
    }
    /**
     * @return {?}
     */
    get range() {
        const { skipCount, maxItems, totalItems } = this.pagination;
        const { isLastPage } = this;
        /** @type {?} */
        const start = totalItems ? skipCount + 1 : 0;
        /** @type {?} */
        const end = isLastPage ? totalItems : skipCount + maxItems;
        return [start, end];
    }
    /**
     * @return {?}
     */
    get pages() {
        return Array(this.lastPage)
            .fill('n')
            .map((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        (item, index) => (index + 1)));
    }
    /**
     * @return {?}
     */
    goNext() {
        if (this.hasItems) {
            /** @type {?} */
            const maxItems = this.pagination.maxItems;
            /** @type {?} */
            const skipCount = (this.next - 1) * maxItems;
            this.pagination.skipCount = skipCount;
            this.handlePaginationEvent(PaginationComponent.ACTIONS.NEXT_PAGE, {
                skipCount,
                maxItems
            });
        }
    }
    /**
     * @return {?}
     */
    goPrevious() {
        if (this.hasItems) {
            /** @type {?} */
            const maxItems = this.pagination.maxItems;
            /** @type {?} */
            const skipCount = (this.previous - 1) * maxItems;
            this.pagination.skipCount = skipCount;
            this.handlePaginationEvent(PaginationComponent.ACTIONS.PREV_PAGE, {
                skipCount,
                maxItems
            });
        }
    }
    /**
     * @param {?} pageNumber
     * @return {?}
     */
    onChangePageNumber(pageNumber) {
        if (this.hasItems) {
            /** @type {?} */
            const maxItems = this.pagination.maxItems;
            /** @type {?} */
            const skipCount = (pageNumber - 1) * maxItems;
            this.pagination.skipCount = skipCount;
            this.handlePaginationEvent(PaginationComponent.ACTIONS.CHANGE_PAGE_NUMBER, {
                skipCount,
                maxItems
            });
        }
    }
    /**
     * @param {?} maxItems
     * @return {?}
     */
    onChangePageSize(maxItems) {
        this.pagination.skipCount = 0;
        this.userPreferencesService.paginationSize = maxItems;
        this.handlePaginationEvent(PaginationComponent.ACTIONS.CHANGE_PAGE_SIZE, {
            skipCount: 0,
            maxItems
        });
    }
    /**
     * @param {?} action
     * @param {?} params
     * @return {?}
     */
    handlePaginationEvent(action, params) {
        const { NEXT_PAGE, PREV_PAGE, CHANGE_PAGE_NUMBER, CHANGE_PAGE_SIZE } = PaginationComponent.ACTIONS;
        const { change, changePageNumber, changePageSize, nextPage, prevPage, pagination } = this;
        /** @type {?} */
        const paginationModel = Object.assign({}, pagination, params);
        if (action === NEXT_PAGE) {
            nextPage.emit(paginationModel);
        }
        if (action === PREV_PAGE) {
            prevPage.emit(paginationModel);
        }
        if (action === CHANGE_PAGE_NUMBER) {
            changePageNumber.emit(paginationModel);
        }
        if (action === CHANGE_PAGE_SIZE) {
            changePageSize.emit(paginationModel);
        }
        change.emit(params);
        if (this.target) {
            this.target.updatePagination(params);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.paginationSubscription) {
            this.paginationSubscription.unsubscribe();
        }
    }
}
PaginationComponent.DEFAULT_PAGINATION = new Pagination({
    skipCount: 0,
    maxItems: 25,
    totalItems: 0
});
PaginationComponent.ACTIONS = {
    NEXT_PAGE: 'NEXT_PAGE',
    PREV_PAGE: 'PREV_PAGE',
    CHANGE_PAGE_SIZE: 'CHANGE_PAGE_SIZE',
    CHANGE_PAGE_NUMBER: 'CHANGE_PAGE_NUMBER'
};
PaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pagination',
                host: { 'class': 'adf-pagination' },
                template: "<ng-container *ngIf=\"hasItems\">\n    <div class=\"adf-pagination__block adf-pagination__range-block\">\n        <span class=\"adf-pagination__range\">\n            {{\n                'CORE.PAGINATION.ITEMS_RANGE' | translate: {\n                    range: range.join('-'),\n                    total: pagination.totalItems\n                }\n            }}\n        </span>\n    </div>\n\n    <div class=\"adf-pagination__block adf-pagination__perpage-block\">\n        <span>\n            {{ 'CORE.PAGINATION.ITEMS_PER_PAGE' | translate }}\n        </span>\n\n        <span class=\"adf-pagination__max-items\">\n            {{ pagination.maxItems }}\n        </span>\n\n        <button\n            mat-icon-button\n            [attr.aria-label]=\"'CORE.PAGINATION.ARIA.ITEMS_PER_PAGE' | translate\"\n            [matMenuTriggerFor]=\"pageSizeMenu\">\n            <mat-icon>arrow_drop_down</mat-icon>\n        </button>\n\n        <mat-menu #pageSizeMenu=\"matMenu\" class=\"adf-pagination__page-selector\">\n            <button\n                mat-menu-item\n                *ngFor=\"let pageSize of supportedPageSizes\"\n                (click)=\"onChangePageSize(pageSize)\">\n                {{ pageSize }}\n            </button>\n        </mat-menu>\n    </div>\n\n    <div class=\"adf-pagination__block adf-pagination__actualinfo-block\">\n        <span class=\"adf-pagination__current-page\">\n            {{ 'CORE.PAGINATION.CURRENT_PAGE' | translate: { number: current } }}\n        </span>\n\n        <button\n            mat-icon-button\n            data-automation-id=\"page-selector\"\n            [attr.aria-label]=\"'CORE.PAGINATION.ARIA.CURRENT_PAGE' | translate\"\n            [matMenuTriggerFor]=\"pagesMenu\"\n            *ngIf=\"pages.length > 1\">\n            <mat-icon>arrow_drop_down</mat-icon>\n        </button>\n\n        <span class=\"adf-pagination__total-pages\">\n            {{ 'CORE.PAGINATION.TOTAL_PAGES' | translate: { total: pages.length } }}\n        </span>\n\n        <mat-menu #pagesMenu=\"matMenu\" class=\"adf-pagination__page-selector\">\n            <button\n                mat-menu-item\n                *ngFor=\"let pageNumber of pages\"\n                (click)=\"onChangePageNumber(pageNumber)\">\n                {{ pageNumber }}\n            </button>\n        </mat-menu>\n    </div>\n\n    <div class=\"adf-pagination__block adf-pagination__controls-block\">\n        <button\n            class=\"adf-pagination__previous-button\"\n            mat-icon-button\n            [attr.aria-label]=\"'CORE.PAGINATION.ARIA.PREVIOUS_PAGE' | translate\"\n            [disabled]=\"isFirstPage\"\n            (click)=\"goPrevious()\">\n            <mat-icon>keyboard_arrow_left</mat-icon>\n        </button>\n\n        <button\n            class=\"adf-pagination__next-button\"\n            mat-icon-button\n            [attr.aria-label]=\"'CORE.PAGINATION.ARIA.NEXT_PAGE' | translate\"\n            [disabled]=\"isLastPage\"\n            (click)=\"goNext()\">\n            <mat-icon>keyboard_arrow_right</mat-icon>\n        </button>\n    </div>\n</ng-container>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
PaginationComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: UserPreferencesService }
];
PaginationComponent.propDecorators = {
    target: [{ type: Input }],
    supportedPageSizes: [{ type: Input }],
    pagination: [{ type: Input }],
    change: [{ type: Output }],
    changePageNumber: [{ type: Output }],
    changePageSize: [{ type: Output }],
    nextPage: [{ type: Output }],
    prevPage: [{ type: Output }],
    isEmpty: [{ type: HostBinding, args: ['class.adf-pagination__empty',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InfinitePaginationComponent {
    /**
     * @param {?} cdr
     * @param {?} userPreferencesService
     */
    constructor(cdr, userPreferencesService) {
        this.cdr = cdr;
        this.userPreferencesService = userPreferencesService;
        /**
         * Is a new page loading?
         */
        this.isLoading = false;
        /**
         * Emitted when the "Load More" button is clicked.
         */
        this.loadMore = new EventEmitter();
        this.pagination = InfinitePaginationComponent.DEFAULT_PAGINATION;
        this.requestPaginationModel = {
            skipCount: 0,
            merge: true
        };
    }
    /**
     * Component that provides custom pagination support.
     * @param {?} target
     * @return {?}
     */
    set target(target) {
        if (target) {
            this._target = target;
            this.paginationSubscription = target.pagination.subscribe((/**
             * @param {?} pagination
             * @return {?}
             */
            (pagination) => {
                this.isLoading = false;
                this.pagination = pagination;
                if (!this.pagination.hasMoreItems) {
                    this.pagination.hasMoreItems = false;
                }
                this.cdr.detectChanges();
            }));
        }
    }
    /**
     * @return {?}
     */
    get target() {
        return this._target;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.userPreferencesService.select(UserPreferenceValues.PaginationSize).subscribe((/**
         * @param {?} pageSize
         * @return {?}
         */
        (pageSize) => {
            this.pageSize = this.pageSize || pageSize;
            this.requestPaginationModel.maxItems = this.pageSize;
        }));
    }
    /**
     * @return {?}
     */
    onLoadMore() {
        this.requestPaginationModel.skipCount = 0;
        this.requestPaginationModel.merge = false;
        this.requestPaginationModel.maxItems += this.pageSize;
        this.loadMore.next(this.requestPaginationModel);
        if (this._target) {
            this.isLoading = true;
            this._target.updatePagination((/** @type {?} */ (this.requestPaginationModel)));
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.pagination.skipCount = 0;
        this.pagination.maxItems = this.pageSize;
        if (this._target) {
            this._target.updatePagination(this.pagination);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.paginationSubscription) {
            this.paginationSubscription.unsubscribe();
        }
    }
}
InfinitePaginationComponent.DEFAULT_PAGINATION = new Pagination({
    skipCount: 0,
    maxItems: 25,
    totalItems: 0
});
InfinitePaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-infinite-pagination',
                host: { 'class': 'infinite-adf-pagination' },
                template: "<div *ngIf=\"pagination?.hasMoreItems || isLoading\" class=\"adf-infinite-pagination\">\n\n    <button mat-button\n        *ngIf=\"!isLoading\"\n        class=\"adf-infinite-pagination-load-more\"\n        (click)=\"onLoadMore()\"\n        data-automation-id=\"adf-infinite-pagination-button\">\n            <ng-content></ng-content>\n    </button>\n\n    <mat-progress-bar *ngIf=\"isLoading\"\n        mode=\"indeterminate\"\n        class=\"adf-infinite-pagination-spinner\"\n        data-automation-id=\"adf-infinite-pagination-spinner\"></mat-progress-bar>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-infinite-pagination{display:flex;justify-content:space-around;min-height:56px}.adf-infinite-pagination-load-more{margin-bottom:10px;margin-top:10px}"]
            }] }
];
/** @nocollapse */
InfinitePaginationComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: UserPreferencesService }
];
InfinitePaginationComponent.propDecorators = {
    target: [{ type: Input }],
    pageSize: [{ type: Input }],
    isLoading: [{ type: Input, args: ['loading',] }],
    loadMore: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationModule {
}
PaginationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild()
                ],
                declarations: [
                    InfinitePaginationComponent,
                    PaginationComponent
                ],
                exports: [
                    InfinitePaginationComponent,
                    PaginationComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginErrorEvent {
    /**
     * @param {?} err
     */
    constructor(err) {
        this.err = err;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginSubmitEvent {
    /**
     * @param {?} _values
     */
    constructor(_values) {
        this._defaultPrevented = false;
        this._values = _values;
    }
    /**
     * @return {?}
     */
    get values() {
        return this._values;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this._defaultPrevented = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginSuccessEvent {
    /**
     * @param {?} token
     * @param {?} username
     * @param {?} password
     */
    constructor(token, username, password) {
        this.token = token;
        this.username = username;
        this.password = password;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const LoginSteps = {
    Landing: 0,
    Checking: 1,
    Welcome: 2,
};
LoginSteps[LoginSteps.Landing] = 'Landing';
LoginSteps[LoginSteps.Checking] = 'Checking';
LoginSteps[LoginSteps.Welcome] = 'Welcome';
class LoginComponent {
    /**
     * Constructor
     * @param {?} _fb
     * @param {?} authService
     * @param {?} translateService
     * @param {?} logService
     * @param {?} router
     * @param {?} appConfig
     * @param {?} userPreferences
     * @param {?} location
     * @param {?} route
     */
    constructor(_fb, authService, translateService, logService, router, appConfig, userPreferences, location, route) {
        this._fb = _fb;
        this.authService = authService;
        this.translateService = translateService;
        this.logService = logService;
        this.router = router;
        this.appConfig = appConfig;
        this.userPreferences = userPreferences;
        this.location = location;
        this.route = route;
        this.isPasswordShow = false;
        /**
         * Should the `Remember me` checkbox be shown? When selected, this
         * option will remember the logged-in user after the browser is closed
         * to avoid logging in repeatedly.
         */
        this.showRememberMe = true;
        /**
         * Should the extra actions (`Need Help`, `Register`, etc) be shown?
         */
        this.showLoginActions = true;
        /**
         * Sets the URL of the NEED HELP link in the footer.
         */
        this.needHelpLink = '';
        /**
         * Sets the URL of the REGISTER link in the footer.
         */
        this.registerLink = '';
        /**
         * Path to a custom logo image.
         */
        this.logoImageUrl = './assets/images/alfresco-logo.svg';
        /**
         * Path to a custom background image.
         */
        this.backgroundImageUrl = './assets/images/background.svg';
        /**
         * The copyright text below the login box.
         */
        this.copyrightText = '\u00A9 2016 Alfresco Software, Inc. All Rights Reserved.';
        /**
         * Route to redirect to on successful login.
         */
        this.successRoute = null;
        /**
         * Emitted when the login is successful.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when the login fails.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the login form is submitted.
         */
        this.executeSubmit = new EventEmitter();
        this.implicitFlow = false;
        this.isError = false;
        this.actualLoginStep = LoginSteps.Landing;
        this.LoginSteps = LoginSteps;
        this.rememberMe = true;
        this.minLength = 2;
        this.initFormError();
        this.initFormFieldsMessages();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.authService.isOauth()) {
            /** @type {?} */
            const oauth = this.appConfig.get(AppConfigValues.OAUTHCONFIG, null);
            if (oauth && oauth.implicitFlow) {
                this.implicitFlow = true;
            }
        }
        if (this.authService.isEcmLoggedIn() || this.authService.isBpmLoggedIn()) {
            this.location.forward();
        }
        else {
            this.route.queryParams.subscribe((/**
             * @param {?} params
             * @return {?}
             */
            (params) => {
                /** @type {?} */
                const url = params['redirectUrl'];
                /** @type {?} */
                const provider = this.appConfig.get(AppConfigValues.PROVIDERS);
                this.authService.setRedirect({ provider, url });
            }));
        }
        if (this.hasCustomFieldsValidation()) {
            this.form = this._fb.group(this.fieldsValidation);
        }
        else {
            this.initFormFieldsDefault();
            this.initFormFieldsMessagesDefault();
        }
        this.form.valueChanges.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => this.onValueChanged(data)));
    }
    /**
     * @return {?}
     */
    submit() {
        this.onSubmit(this.form.value);
    }
    /**
     * Method called on submit form
     * @param {?} values
     * @return {?}
     */
    onSubmit(values) {
        this.disableError();
        if (this.authService.isOauth() && !this.authService.isSSODiscoveryConfigured()) {
            this.errorMsg = 'LOGIN.MESSAGES.SSO-WRONG-CONFIGURATION';
            this.isError = true;
        }
        else {
            /** @type {?} */
            const args = new LoginSubmitEvent({
                controls: { username: this.form.controls.username }
            });
            this.executeSubmit.emit(args);
            if (args.defaultPrevented) {
                return false;
            }
            else {
                this.performLogin(values);
            }
        }
    }
    /**
     * @return {?}
     */
    implicitLogin() {
        if (this.authService.isOauth() && !this.authService.isSSODiscoveryConfigured()) {
            this.errorMsg = 'LOGIN.MESSAGES.SSO-WRONG-CONFIGURATION';
            this.isError = true;
        }
        else {
            this.authService.ssoImplicitLogin();
        }
    }
    /**
     * The method check the error in the form and push the error in the formError object
     * @param {?} data
     * @return {?}
     */
    onValueChanged(data) {
        this.disableError();
        for (const field in this.formError) {
            if (field) {
                this.formError[field] = '';
                /** @type {?} */
                const hasError = (this.form.controls[field].errors && data[field] !== '') ||
                    (this.form.controls[field].dirty &&
                        !this.form.controls[field].valid);
                if (hasError) {
                    for (const key in this.form.controls[field].errors) {
                        if (key) {
                            /** @type {?} */
                            const message = this._message[field][key];
                            if (message && message.value) {
                                /** @type {?} */
                                const translated = this.translateService.instant(message.value, message.params);
                                this.formError[field] += translated;
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * @private
     * @param {?} values
     * @return {?}
     */
    performLogin(values) {
        this.actualLoginStep = LoginSteps.Checking;
        this.authService
            .login(values.username, values.password, this.rememberMe)
            .subscribe((/**
         * @param {?} token
         * @return {?}
         */
        (token) => {
            /** @type {?} */
            const redirectUrl = this.authService.getRedirect();
            this.actualLoginStep = LoginSteps.Welcome;
            this.userPreferences.setStoragePrefix(values.username);
            values.password = null;
            this.success.emit(new LoginSuccessEvent(token, values.username, null));
            if (redirectUrl) {
                this.authService.setRedirect(null);
                this.router.navigateByUrl(redirectUrl);
            }
            else if (this.successRoute) {
                this.router.navigate([this.successRoute]);
            }
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.actualLoginStep = LoginSteps.Landing;
            this.displayErrorMessage(err);
            this.isError = true;
            this.error.emit(new LoginErrorEvent(err));
        }), (/**
         * @return {?}
         */
        () => this.logService.info('Login done')));
    }
    /**
     * Check and display the right error message in the UI
     * @private
     * @param {?} err
     * @return {?}
     */
    displayErrorMessage(err) {
        if (err.error &&
            err.error.crossDomain &&
            err.error.message.indexOf('Access-Control-Allow-Origin') !== -1) {
            this.errorMsg = err.error.message;
        }
        else if (err.status === 403 &&
            err.message.indexOf('Invalid CSRF-token') !== -1) {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-CSRF';
        }
        else if (err.status === 403 &&
            err.message.indexOf('The system is currently in read-only mode') !==
                -1) {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ECM-LICENSE';
        }
        else {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-CREDENTIALS';
        }
    }
    /**
     * Add a custom form error for a field
     * @param {?} field
     * @param {?} msg
     * @return {?}
     */
    addCustomFormError(field, msg) {
        this.formError[field] += msg;
    }
    /**
     * Add a custom validation rule error for a field
     * @param {?} field
     * @param {?} ruleId - i.e. required | minlength | maxlength
     * @param {?} msg
     * @param {?=} params
     * @return {?}
     */
    addCustomValidationError(field, ruleId, msg, params) {
        this._message[field][ruleId] = {
            value: msg,
            params
        };
    }
    /**
     * Display and hide the password value.
     * @return {?}
     */
    toggleShowPassword() {
        this.isPasswordShow = !this.isPasswordShow;
    }
    /**
     * The method return if a field is valid or not
     * @param {?} field
     * @return {?}
     */
    isErrorStyle(field) {
        return !field.valid && field.dirty && !field.pristine;
    }
    /**
     * Trim username
     * @param {?} event
     * @return {?}
     */
    trimUsername(event) {
        event.target.value = event.target.value.trim();
    }
    /**
     * Default formError values
     * @private
     * @return {?}
     */
    initFormError() {
        this.formError = {
            username: '',
            password: ''
        };
    }
    /**
     * Init form fields messages
     * @private
     * @return {?}
     */
    initFormFieldsMessages() {
        this._message = {
            username: {},
            password: {}
        };
    }
    /**
     * Default form fields messages
     * @private
     * @return {?}
     */
    initFormFieldsMessagesDefault() {
        this._message = {
            username: {
                required: {
                    value: 'LOGIN.MESSAGES.USERNAME-REQUIRED'
                },
                minLength: {
                    value: 'LOGIN.MESSAGES.USERNAME-MIN',
                    params: {
                        /**
                         * @return {?}
                         */
                        get minLength() {
                            return this.minLength;
                        }
                    }
                }
            },
            password: {
                required: {
                    value: 'LOGIN.MESSAGES.PASSWORD-REQUIRED'
                }
            }
        };
    }
    /**
     * @private
     * @return {?}
     */
    initFormFieldsDefault() {
        this.form = this._fb.group({
            username: ['', Validators.required],
            password: ['', Validators.required]
        });
    }
    /**
     * Disable the error flag
     * @private
     * @return {?}
     */
    disableError() {
        this.isError = false;
        this.initFormError();
    }
    /**
     * @private
     * @return {?}
     */
    hasCustomFieldsValidation() {
        return this.fieldsValidation !== undefined;
    }
}
LoginComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-login',
                template: "<div class=\"adf-login-content\" [style.background-image]=\"'url(' + backgroundImageUrl + ')'\">\n    <div class=\"adf-ie11FixerParent\">\n        <div class=\"adf-ie11FixerChild\">\n\n            <mat-card class=\"adf-login-card-wide\">\n                <form id=\"adf-login-form\" [formGroup]=\"form\" (submit)=\"onSubmit(form.value)\" autocomplete=\"off\">\n                    <mat-card-header>\n                        <mat-card-title>\n                            <div class=\"adf-alfresco-logo\">\n                                <!--HEADER TEMPLATE-->\n                                <ng-template *ngIf=\"headerTemplate\"\n                                             ngFor [ngForOf]=\"[data]\"\n                                             [ngForTemplate]=\"headerTemplate\">\n                                </ng-template>\n                                <img *ngIf=\"!headerTemplate\" id=\"adf-login-img-logo\" class=\"adf-img-logo\" [src]=\"logoImageUrl\"\n                                     alt=\"{{'LOGIN.LOGO' | translate }}\">\n                            </div>\n                        </mat-card-title>\n                    </mat-card-header>\n\n                    <mat-card-content class=\"adf-login-controls\">\n\n                        <!--ERRORS AREA-->\n                        <div class=\"adf-error-container\">\n                            <div *ngIf=\"isError\" id=\"login-error\" data-automation-id=\"login-error\"\n                                 class=\"adf-error  adf-error-message\">\n                                <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n                                <span class=\"adf-login-error-message\">{{errorMsg | translate }}</span>\n                            </div>\n                        </div>\n\n                        <div *ngIf=\"!implicitFlow\">\n\n                            <!--USERNAME FIELD-->\n                            <div class=\"adf-login__field\"\n                                 [ngClass]=\"{'adf-is-invalid': isErrorStyle(form.controls.username)}\">\n                                <mat-form-field class=\"adf-full-width\" floatPlaceholder=\"never\" color=\"primary\">\n                                    <input matInput placeholder=\"{{'LOGIN.LABEL.USERNAME' | translate }}\"\n                                           type=\"text\"\n                                           class=\"adf-full-width\"\n                                           [formControl]=\"form.controls['username']\"\n                                           autocapitalize=\"none\"\n                                           id=\"username\"\n                                           data-automation-id=\"username\"\n                                           (blur)=\"trimUsername($event)\">\n                                </mat-form-field>\n\n                                <span class=\"adf-login-validation\" for=\"username\" *ngIf=\"formError['username']\">\n                                <span id=\"username-error\" class=\"adf-login-error\" data-automation-id=\"username-error\">{{formError['username'] | translate }}</span>\n                            </span>\n                            </div>\n\n                            <!--PASSWORD FIELD-->\n                            <div class=\"adf-login__field\">\n                                <mat-form-field class=\"adf-full-width\" floatPlaceholder=\"never\" color=\"primary\">\n                                    <input matInput placeholder=\"{{'LOGIN.LABEL.PASSWORD' | translate }}\"\n                                           [type]=\"isPasswordShow ? 'text' : 'password'\"\n                                           [formControl]=\"form.controls['password']\"\n                                           id=\"password\"\n                                           data-automation-id=\"password\">\n                                    <mat-icon *ngIf=\"isPasswordShow\" matSuffix class=\"adf-login-password-icon\"\n                                              data-automation-id=\"hide_password\" (click)=\"toggleShowPassword()\" (keyup.enter)=\"toggleShowPassword()\">\n                                        visibility\n                                    </mat-icon>\n                                    <mat-icon *ngIf=\"!isPasswordShow\" matSuffix class=\"adf-login-password-icon\"\n                                              data-automation-id=\"show_password\" (click)=\"toggleShowPassword()\" (keyup.enter)=\"toggleShowPassword()\">\n                                        visibility_off\n                                    </mat-icon>\n                                </mat-form-field>\n                                <span class=\"adf-login-validation\" for=\"password\" *ngIf=\"formError['password']\">\n                                <span id=\"password-required\" class=\"adf-login-error\"\n                                      data-automation-id=\"password-required\">{{formError['password'] | translate }}</span>\n                            </span>\n                            </div>\n\n                            <!--CUSTOM CONTENT-->\n                            <ng-content></ng-content>\n\n                            <br>\n                            <button type=\"submit\" id=\"login-button\"\n                                    class=\"adf-login-button\"\n                                    mat-raised-button color=\"primary\"\n                                    [class.adf-isChecking]=\"actualLoginStep === LoginSteps.Checking\"\n                                    [class.adf-isWelcome]=\"actualLoginStep === LoginSteps.Welcome\"\n                                    data-automation-id=\"login-button\" [disabled]=\"!form.valid\">\n\n                                <span *ngIf=\"actualLoginStep === LoginSteps.Landing\" class=\"adf-login-button-label\">{{ 'LOGIN.BUTTON.LOGIN' | translate }}</span>\n\n                                <div *ngIf=\"actualLoginStep === LoginSteps.Checking\"\n                                     class=\"adf-interactive-login-label\">\n                                    <span\n                                        class=\"adf-login-button-label\">{{ 'LOGIN.BUTTON.CHECKING' | translate }}</span>\n                                    <div class=\"adf-login-spinner-container\">\n                                        <mat-spinner id=\"checking-spinner\" class=\"adf-login-checking-spinner\"\n                                                     [diameter]=\"25\"></mat-spinner>\n                                    </div>\n                                </div>\n\n\n                                <div *ngIf=\"actualLoginStep === LoginSteps.Welcome\" class=\"adf-interactive-login-label\">\n                                    <span class=\"adf-login-button-label\">{{ 'LOGIN.BUTTON.WELCOME' | translate }}</span>\n                                    <mat-icon class=\"adf-welcome-icon\">done</mat-icon>\n                                </div>\n\n                            </button>\n                            <div *ngIf=\"showRememberMe\" class=\"adf-login__remember-me\">\n                                <mat-checkbox id=\"adf-login-remember\" color=\"primary\" class=\"adf-login-remember-me\"\n                                              [checked]=\"rememberMe\"\n                                              (change)=\"rememberMe = !rememberMe\">{{ 'LOGIN.LABEL.REMEMBER' | translate }}\n                                </mat-checkbox>\n                            </div>\n                        </div>\n\n                        <div *ngIf=\"implicitFlow\">\n                            <button type=\"button\" (click)=\"implicitLogin()\" id=\"login-button-sso\"\n                                    class=\"adf-login-button\"\n                                    mat-raised-button color=\"primary\"\n                                    data-automation-id=\"login-button-sso\">\n                                <span  class=\"adf-login-button-label\">{{ 'LOGIN.BUTTON.SSO' | translate }}</span>\n                            </button>\n                        </div>\n\n                    </mat-card-content>\n\n                    <mat-card-actions *ngIf=\"footerTemplate || showLoginActions\">\n\n                        <div class=\"adf-login-action-container\">\n                            <!--FOOTER TEMPLATE-->\n                            <ng-template *ngIf=\"footerTemplate\"\n                                         ngFor [ngForOf]=\"[data]\"\n                                         [ngForTemplate]=\"footerTemplate\">\n                            </ng-template>\n                            <div class=\"adf-login-action\" *ngIf=\"!footerTemplate && showLoginActions\">\n                                <div id=\"adf-login-action-left\" class=\"adf-login-action-left\">\n                                    <a href=\"{{needHelpLink}}\">{{'LOGIN.ACTION.HELP' | translate }}</a>\n                                </div>\n                                <div id=\"adf-login-action-right\" class=\"adf-login-action-right\">\n                                    <a href=\"{{registerLink}}\">{{'LOGIN.ACTION.REGISTER' | translate }}</a>\n                                </div>\n                            </div>\n                        </div>\n                    </mat-card-actions>\n\n                </form>\n            </mat-card>\n\n            <div class=\"adf-copyright\" data-automation-id=\"login-copyright\">\n                {{ copyrightText }}\n            </div>\n\n        </div>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    class: 'adf-login'
                },
                styles: [""]
            }] }
];
/** @nocollapse */
LoginComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: AuthenticationService },
    { type: TranslationService },
    { type: LogService },
    { type: Router },
    { type: AppConfigService },
    { type: UserPreferencesService },
    { type: Location },
    { type: ActivatedRoute }
];
LoginComponent.propDecorators = {
    showRememberMe: [{ type: Input }],
    showLoginActions: [{ type: Input }],
    needHelpLink: [{ type: Input }],
    registerLink: [{ type: Input }],
    logoImageUrl: [{ type: Input }],
    backgroundImageUrl: [{ type: Input }],
    copyrightText: [{ type: Input }],
    fieldsValidation: [{ type: Input }],
    successRoute: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    executeSubmit: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class LoginHeaderDirective {
    /**
     * @param {?} alfrescoLoginComponent
     */
    constructor(alfrescoLoginComponent) {
        this.alfrescoLoginComponent = alfrescoLoginComponent;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.alfrescoLoginComponent.headerTemplate = this.template;
    }
}
LoginHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-login-header, login-header'
            },] }
];
/** @nocollapse */
LoginHeaderDirective.ctorParameters = () => [
    { type: LoginComponent }
];
LoginHeaderDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class LoginFooterDirective {
    /**
     * @param {?} alfrescoLoginComponent
     */
    constructor(alfrescoLoginComponent) {
        this.alfrescoLoginComponent = alfrescoLoginComponent;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.alfrescoLoginComponent.footerTemplate = this.template;
    }
}
LoginFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-login-footer, login-footer'
            },] }
];
/** @nocollapse */
LoginFooterDirective.ctorParameters = () => [
    { type: LoginComponent }
];
LoginFooterDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoginDialogPanelComponent {
    constructor() {
        /**
         * Emitted when the login succeeds.
         */
        this.success = new EventEmitter();
    }
    /**
     * @return {?}
     */
    submitForm() {
        this.login.submit();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onLoginSuccess(event) {
        this.success.emit(event);
    }
    /**
     * @return {?}
     */
    isValid() {
        return this.login && this.login.form ? this.login.form.valid : false;
    }
}
LoginDialogPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-login-dialog-panel',
                template: "<div>\n    <adf-login #adfLogin\n               class=\"adf-panel-login-dialog-component\"\n               [showRememberMe]=\"false\"\n               [showLoginActions]=\"false\"\n               [backgroundImageUrl]=\"''\"\n               (success)=\"onLoginSuccess($event)\">\n        <adf-login-header><ng-template></ng-template></adf-login-header>\n        <adf-login-footer><ng-template></ng-template></adf-login-footer>\n    </adf-login>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
LoginDialogPanelComponent.propDecorators = {
    success: [{ type: Output }],
    login: [{ type: ViewChild, args: ['adfLogin',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoginDialogComponent {
    /**
     * @param {?} data
     */
    constructor(data) {
        this.data = data;
        this.buttonActionName = '';
        this.buttonActionName = data.actionName ? `LOGIN.DIALOG.${data.actionName.toUpperCase()}` : 'LOGIN.DIALOG.CHOOSE';
    }
    /**
     * @return {?}
     */
    close() {
        this.data.logged.complete();
    }
    /**
     * @return {?}
     */
    submitForm() {
        this.loginPanel.submitForm();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onLoginSuccess(event) {
        this.data.logged.next(event);
        this.close();
    }
    /**
     * @return {?}
     */
    isFormValid() {
        return this.loginPanel ? this.loginPanel.isValid() : false;
    }
}
LoginDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-login-dialog',
                template: "<header\n    mat-dialog-title\n    data-automation-id=\"login-dialog-title\">{{data?.title}}\n</header>\n\n<mat-dialog-content class=\"adf-login-dialog-content\">\n    <adf-login-dialog-panel #adfLoginPanel\n                            (success)=\"onLoginSuccess($event)\">\n    </adf-login-dialog-panel>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n    <button\n        mat-button\n        (click)=\"close()\"\n        data-automation-id=\"login-dialog-actions-cancel\">{{ 'LOGIN.DIALOG.CANCEL' | translate }}\n    </button>\n\n    <button mat-button\n        class=\"choose-action\"\n        data-automation-id=\"login-dialog-actions-perform\"\n        [disabled]=\"!isFormValid()\"\n        (click)=\"submitForm()\">{{ buttonActionName | translate}}\n    </button>\n</mat-dialog-actions>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
LoginDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
LoginDialogComponent.propDecorators = {
    loginPanel: [{ type: ViewChild, args: ['adfLoginPanel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoginModule {
}
LoginModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    RouterModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CommonModule,
                    TranslateModule.forChild()
                ],
                declarations: [
                    LoginComponent,
                    LoginFooterDirective,
                    LoginHeaderDirective,
                    LoginDialogComponent,
                    LoginDialogPanelComponent
                ],
                entryComponents: [LoginDialogComponent, LoginDialogPanelComponent],
                exports: [
                    LoginComponent,
                    LoginFooterDirective,
                    LoginHeaderDirective,
                    LoginDialogComponent,
                    LoginDialogPanelComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LanguageMenuComponent {
    /**
     * @param {?} appConfig
     * @param {?} userPreference
     */
    constructor(appConfig, userPreference) {
        this.appConfig = appConfig;
        this.userPreference = userPreference;
        this.languages = [
            { key: 'en', label: 'English' }
        ];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const languagesConfigApp = this.appConfig.get(AppConfigValues.APP_CONFIG_LANGUAGES_KEY);
        if (languagesConfigApp) {
            this.languages = languagesConfigApp;
        }
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    changeLanguage(lang) {
        this.userPreference.locale = lang;
    }
}
LanguageMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-language-menu',
                template: "<button mat-menu-item *ngFor=\"let language of languages\" (click)=\"changeLanguage(language.key)\">{{language.label}}\n</button>\n"
            }] }
];
/** @nocollapse */
LanguageMenuComponent.ctorParameters = () => [
    { type: AppConfigService },
    { type: UserPreferencesService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LanguageMenuModule {
}
LanguageMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    LanguageMenuComponent
                ],
                exports: [
                    LanguageMenuComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InfoDrawerLayoutComponent {
}
InfoDrawerLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer-layout',
                template: "<div class=\"adf-info-drawer-layout-header\">\n    <div class=\"adf-info-drawer-layout-header-title\">\n        <ng-content select=\"[info-drawer-title]\"></ng-content>\n    </div>\n    <div class=\"adf-info-drawer-layout-header-buttons\">\n        <ng-content select=\"[info-drawer-buttons]\"></ng-content>\n    </div>\n</div>\n<div class=\"adf-info-drawer-layout-content\">\n    <ng-content select=\"[info-drawer-content]\"></ng-content>\n</div>",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-info-drawer-layout' },
                styles: [""]
            }] }
];
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class InfoDrawerTitleDirective {
}
InfoDrawerTitleDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-info-drawer-title], [info-drawer-title]' },] }
];
class InfoDrawerButtonsDirective {
}
InfoDrawerButtonsDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-info-drawer-buttons], [info-drawer-buttons]' },] }
];
class InfoDrawerContentDirective {
}
InfoDrawerContentDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-info-drawer-content], [info-drawer-content]' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InfoDrawerTabComponent {
    constructor() {
        /**
         * The title of the tab.
         */
        this.label = '';
        /**
         * Icon to render for the tab.
         */
        this.icon = null;
    }
}
InfoDrawerTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer-tab',
                template: '<ng-template><ng-content></ng-content></ng-template>'
            }] }
];
InfoDrawerTabComponent.propDecorators = {
    label: [{ type: Input }],
    icon: [{ type: Input }],
    content: [{ type: ViewChild, args: [TemplateRef,] }]
};
class InfoDrawerComponent {
    constructor() {
        /**
         * The title of the info drawer.
         */
        this.title = null;
        /**
         * The selected index tab.
         */
        this.selectedIndex = 0;
        /**
         * Emitted when the currently active tab changes.
         */
        this.currentTab = new EventEmitter();
    }
    /**
     * @return {?}
     */
    showTabLayout() {
        return this.contentBlocks.length > 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTabChange(event) {
        this.currentTab.emit(event.index);
    }
}
InfoDrawerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer',
                template: "<adf-info-drawer-layout>\n    <div *ngIf=\"title\" info-drawer-title>{{title}}</div>\n    <ng-content *ngIf=\"!title\" info-drawer-title select=\"[info-drawer-title]\"></ng-content>\n\n    <ng-content info-drawer-buttons select=\"[info-drawer-buttons]\"></ng-content>\n\n    <ng-container info-drawer-content *ngIf=\"showTabLayout(); then tabLayout else singleLayout\"></ng-container>\n\n    <ng-template #tabLayout>\n        <mat-tab-group [(selectedIndex)]=\"selectedIndex\" class=\"adf-info-drawer-tabs\" (selectedTabChange)=\"onTabChange($event)\">\n            <mat-tab *ngFor=\"let contentBlock of contentBlocks\"\n                [label]=\"contentBlock.label\"\n                class=\"adf-info-drawer-tab\">\n\n                <ng-template mat-tab-label>\n                    <mat-icon *ngIf=\"contentBlock.icon\">{{ contentBlock.icon }}</mat-icon>\n                    <span *ngIf=\"contentBlock.label\">{{ contentBlock.label }}</span>\n                </ng-template>\n\n                <ng-container *ngTemplateOutlet=\"contentBlock.content\"></ng-container>\n            </mat-tab>\n        </mat-tab-group>\n    </ng-template>\n\n    <ng-template #singleLayout>\n        <ng-content select=\"[info-drawer-content]\"></ng-content>\n    </ng-template>\n</adf-info-drawer-layout>\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-info-drawer' },
                styles: [".adf-info-drawer{display:block}.adf-info-drawer .mat-tab-label{min-width:0}.adf-info-drawer .adf-info-drawer-layout-content{padding:0}.adf-info-drawer .adf-info-drawer-layout-content>:not(.adf-info-drawer-tabs){padding:10px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content>*,.adf-info-drawer .adf-info-drawer-layout-content>:not(.adf-info-drawer-tabs)>*{margin-bottom:20px;display:block}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content>:last-child{margin-bottom:0}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-label{flex-grow:1}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-label .mat-icon+span{padding-left:5px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-ink-bar{height:4px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body{padding:10px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content{overflow:initial}"]
            }] }
];
InfoDrawerComponent.propDecorators = {
    title: [{ type: Input }],
    selectedIndex: [{ type: Input }],
    currentTab: [{ type: Output }],
    contentBlocks: [{ type: ContentChildren, args: [InfoDrawerTabComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function declarations() {
    return [
        InfoDrawerLayoutComponent,
        InfoDrawerTabComponent,
        InfoDrawerComponent,
        InfoDrawerTitleDirective,
        InfoDrawerButtonsDirective,
        InfoDrawerContentDirective
    ];
}
class InfoDrawerModule {
}
InfoDrawerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: declarations(),
                exports: declarations()
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class DataTableSchema {
    /**
     * @param {?} appConfigService
     * @param {?} presetKey
     * @param {?} presetsModel
     */
    constructor(appConfigService, presetKey, presetsModel) {
        this.appConfigService = appConfigService;
        this.presetKey = presetKey;
        this.presetsModel = presetsModel;
        this.layoutPresets = {};
    }
    /**
     * @return {?}
     */
    createDatatableSchema() {
        this.loadLayoutPresets();
        if (!this.columns || this.columns.length === 0) {
            this.columns = this.mergeJsonAndHtmlSchema();
        }
    }
    /**
     * @return {?}
     */
    loadLayoutPresets() {
        /** @type {?} */
        const externalSettings = this.appConfigService.get(this.presetKey, null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, this.presetsModel, externalSettings);
        }
        else {
            this.layoutPresets = this.presetsModel;
        }
    }
    /**
     * @return {?}
     */
    mergeJsonAndHtmlSchema() {
        /** @type {?} */
        let customSchemaColumns = this.getSchemaFromConfig(this.presetColumn).concat(this.getSchemaFromHtml(this.columnList));
        if (customSchemaColumns.length === 0) {
            customSchemaColumns = this.getDefaultLayoutPreset();
        }
        return customSchemaColumns;
    }
    /**
     * @param {?} columnList
     * @return {?}
     */
    getSchemaFromHtml(columnList) {
        /** @type {?} */
        let schema = [];
        if (columnList && columnList.columns && columnList.columns.length > 0) {
            schema = columnList.columns.map((/**
             * @param {?} c
             * @return {?}
             */
            (c) => (/** @type {?} */ (c))));
        }
        return schema;
    }
    /**
     * @param {?} presetColumn
     * @return {?}
     */
    getSchemaFromConfig(presetColumn) {
        return presetColumn ? (this.layoutPresets[presetColumn]).map((/**
         * @param {?} col
         * @return {?}
         */
        (col) => new ObjectDataColumn(col))) : [];
    }
    /**
     * @private
     * @return {?}
     */
    getDefaultLayoutPreset() {
        return (this.layoutPresets['default']).map((/**
         * @param {?} col
         * @return {?}
         */
        (col) => new ObjectDataColumn(col)));
    }
}
DataTableSchema.propDecorators = {
    columnList: [{ type: ContentChild, args: [DataColumnListComponent,] }],
    presetColumn: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewComponent {
    constructor() {
        /**
         * Toggles whether or not to show empty items in non-editable mode.
         */
        this.displayEmpty = true;
    }
}
CardViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view',
                template: "<div class=\"adf-property-list\">\n    <div *ngFor=\"let property of properties\">\n        <div [attr.data-automation-id]=\"'header-'+property.key\" class=\"adf-property\">\n            <adf-card-view-item-dispatcher\n                [property]=\"property\"\n                [editable]=\"editable\"\n                [displayEmpty]=\"displayEmpty\">\n            </adf-card-view-item-dispatcher>\n        </div>\n    </div>\n</div>\n",
                styles: [""]
            }] }
];
CardViewComponent.propDecorators = {
    properties: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @abstract
 */
class CardViewBaseItemModel {
    /**
     * @param {?} cardViewItemProperties
     */
    constructor(cardViewItemProperties) {
        this.label = cardViewItemProperties.label || '';
        this.value = cardViewItemProperties.value;
        this.key = cardViewItemProperties.key;
        this.default = cardViewItemProperties.default;
        this.editable = !!cardViewItemProperties.editable;
        this.clickable = !!cardViewItemProperties.clickable;
        this.icon = cardViewItemProperties.icon || '';
        this.validators = cardViewItemProperties.validators || [];
        this.data = cardViewItemProperties.data || null;
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.value === undefined || this.value === null || this.value === '';
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    isValid(newValue) {
        if (!this.validators.length) {
            return true;
        }
        return this.validators
            .map((/**
         * @param {?} validator
         * @return {?}
         */
        (validator) => validator.isValid(newValue)))
            .reduce((/**
         * @param {?} isValidUntilNow
         * @param {?} isValid
         * @return {?}
         */
        (isValidUntilNow, isValid) => isValidUntilNow && isValid), true);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getValidationErrors(value) {
        if (!this.validators.length) {
            return [];
        }
        return this.validators.filter((/**
         * @param {?} validator
         * @return {?}
         */
        (validator) => !validator.isValid(value))).map((/**
         * @param {?} validator
         * @return {?}
         */
        (validator) => validator.message));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewBoolItemModel extends CardViewBaseItemModel {
    /**
     * @param {?} cardViewBoolItemProperties
     */
    constructor(cardViewBoolItemProperties) {
        super(cardViewBoolItemProperties);
        this.type = 'bool';
        this.value = false;
        if (cardViewBoolItemProperties.value !== undefined) {
            this.value = !!JSON.parse(cardViewBoolItemProperties.value);
        }
    }
    /**
     * @return {?}
     */
    get displayValue() {
        if (this.isEmpty()) {
            return this.default;
        }
        else {
            return this.value;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
function transformKeyToObject(key, value) {
    /** @type {?} */
    const objectLevels = key.split('.').reverse();
    return objectLevels.reduce((/**
     * @param {?} previousValue
     * @param {?} currentValue
     * @return {?}
     */
    (previousValue, currentValue) => {
        return { [currentValue]: previousValue };
    }), value);
}
class CardViewUpdateService {
    constructor() {
        // Observable sources
        this.itemUpdatedSource = new Subject();
        this.itemClickedSource = new Subject();
        // Observable streams
        this.itemUpdated$ = (/** @type {?} */ (this.itemUpdatedSource.asObservable()));
        this.itemClicked$ = (/** @type {?} */ (this.itemClickedSource.asObservable()));
    }
    /**
     * @param {?} property
     * @param {?} newValue
     * @return {?}
     */
    update(property, newValue) {
        this.itemUpdatedSource.next({
            target: property,
            changed: transformKeyToObject(property.key, newValue)
        });
    }
    /**
     * @param {?} property
     * @return {?}
     */
    clicked(property) {
        this.itemClickedSource.next({
            target: property
        });
    }
}
CardViewUpdateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ CardViewUpdateService.ngInjectableDef = defineInjectable({ factory: function CardViewUpdateService_Factory() { return new CardViewUpdateService(); }, token: CardViewUpdateService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewBoolItemComponent {
    /**
     * @param {?} cardViewUpdateService
     */
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
    }
    /**
     * @return {?}
     */
    isEditable() {
        return this.editable && this.property.editable;
    }
    /**
     * @param {?} change
     * @return {?}
     */
    changed(change) {
        this.cardViewUpdateService.update(this.property, change.checked);
        this.property.value = change.checked;
    }
}
CardViewBoolItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-boolitem',
                template: "<ng-container *ngIf=\"!property.isEmpty() || isEditable()\">\n    <div [attr.data-automation-id]=\"'card-boolean-label-' + property.key\" class=\"adf-property-label\">{{ property.label | translate }}</div>\n    <div class=\"adf-property-value\">\n        <mat-checkbox\n            [attr.data-automation-id]=\"'card-boolean-' + property.key\"\n            [attr.title]=\"'CORE.METADATA.ACTIONS.TOGGLE' | translate\"\n            [checked]=\"property.displayValue\"\n            [disabled]=\"!isEditable()\"\n            (change)=\"changed($event)\">\n        </mat-checkbox>\n    </div>\n</ng-container>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
CardViewBoolItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService }
];
CardViewBoolItemComponent.propDecorators = {
    property: [{ type: Input }],
    editable: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewDateItemModel extends CardViewBaseItemModel {
    /**
     * @param {?} cardViewDateItemProperties
     */
    constructor(cardViewDateItemProperties) {
        super(cardViewDateItemProperties);
        this.type = 'date';
        this.format = 'MMM DD YYYY';
        if (cardViewDateItemProperties.format) {
            this.format = cardViewDateItemProperties.format;
        }
    }
    /**
     * @return {?}
     */
    get displayValue() {
        if (!this.value) {
            return this.default;
        }
        else {
            return moment(this.value).format(this.format);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = MOMENT_DATE_FORMATS, ɵ1 = MAT_MOMENT_DATETIME_FORMATS;
class CardViewDateItemComponent {
    /**
     * @param {?} cardViewUpdateService
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(cardViewUpdateService, dateAdapter, userPreferencesService) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.SHOW_FORMAT = 'MMM DD YY';
        this.editable = false;
        this.displayEmpty = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            this.dateAdapter.setLocale(locale);
        }));
        ((/** @type {?} */ (this.dateAdapter))).overrideDisplayFormat = this.SHOW_FORMAT;
        if (this.property.value) {
            this.valueDate = moment(this.property.value, this.SHOW_FORMAT);
        }
    }
    /**
     * @return {?}
     */
    showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    /**
     * @return {?}
     */
    isEditable() {
        return this.editable && this.property.editable;
    }
    /**
     * @return {?}
     */
    showDatePicker() {
        this.datepicker.open();
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        if (newDateValue) {
            /** @type {?} */
            const momentDate = moment(newDateValue.value, this.SHOW_FORMAT, true);
            if (momentDate.isValid()) {
                this.valueDate = momentDate;
                this.cardViewUpdateService.update(this.property, momentDate.toDate());
                this.property.value = momentDate.toDate();
            }
        }
    }
}
CardViewDateItemComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 },
                    { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1 }
                ],
                selector: 'adf-card-view-dateitem',
                template: "<div [attr.data-automation-id]=\"'card-dateitem-label-' + property.key\" class=\"adf-property-label\" *ngIf=\"showProperty() || isEditable()\">{{ property.label | translate }}</div>\n<div class=\"adf-property-value\">\n    <span *ngIf=\"!isEditable()\" [attr.data-automation-id]=\"'card-' + property.type + '-value-' + property.key\">\n        <span [attr.data-automation-id]=\"'card-dateitem-' + property.key\">\n            <span *ngIf=\"showProperty()\">{{ property.displayValue }}</span>\n        </span>\n    </span>\n    <div *ngIf=\"isEditable()\" class=\"adf-dateitem-editable\">\n        <div class=\"adf-dateitem-editable-controls\">\n            <span\n                class=\"adf-datepicker-toggle\"\n                [attr.data-automation-id]=\"'datepicker-label-toggle-' + property.key\"\n                (click)=\"showDatePicker()\">\n                <span [attr.data-automation-id]=\"'card-' + property.type + '-value-' + property.key\" *ngIf=\"showProperty(); else elseEmptyValueBlock\">{{ property.displayValue }}</span>\n            </span>\n            <mat-datetimepicker-toggle\n                [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                [attr.data-automation-id]=\"'datepickertoggle-' + property.key\"\n                [for]=\"datetimePicker\">\n            </mat-datetimepicker-toggle>\n        </div>\n\n        <input class=\"adf-invisible-date-input\"\n            [matDatetimepicker]=\"datetimePicker\"\n            [value]=\"valueDate\"\n            (dateChange)=\"onDateChanged($event)\">\n\n        <mat-datetimepicker #datetimePicker\n            [type]=\"property.type\"\n            timeInterval=\"5\"\n            [attr.data-automation-id]=\"'datepicker-' + property.key\"\n            [startAt]=\"valueDate\">\n        </mat-datetimepicker>\n    </div>\n    <ng-template #elseEmptyValueBlock>\n        {{ property.default | translate }}\n    </ng-template>\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
CardViewDateItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService },
    { type: DateAdapter },
    { type: UserPreferencesService }
];
CardViewDateItemComponent.propDecorators = {
    property: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    datepicker: [{ type: ViewChild, args: ['datetimePicker',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewMapItemModel extends CardViewBaseItemModel {
    constructor() {
        super(...arguments);
        this.type = 'map';
    }
    /**
     * @return {?}
     */
    get displayValue() {
        if (this.value && this.value.size > 0) {
            return this.value.values().next().value;
        }
        else {
            return this.default;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewMapItemComponent {
    /**
     * @param {?} cardViewUpdateService
     */
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.displayEmpty = true;
    }
    /**
     * @return {?}
     */
    showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    /**
     * @return {?}
     */
    isClickable() {
        return this.property.clickable;
    }
    /**
     * @return {?}
     */
    clicked() {
        this.cardViewUpdateService.clicked(this.property);
    }
}
CardViewMapItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-mapitem',
                template: "<div [attr.data-automation-id]=\"'card-mapitem-label-' + property.key\" class=\"adf-property-label\" *ngIf=\"showProperty()\">{{ property.label | translate }}</div>\n<div class=\"adf-property-value\">\n    <div>\n        <span *ngIf=\"!isClickable(); else elseBlock\" [attr.data-automation-id]=\"'card-mapitem-value-' + property.key\">\n            <span *ngIf=\"showProperty();\">{{ property.displayValue }}</span>\n        </span>\n        <ng-template #elseBlock>\n            <span class=\"adf-mapitem-clickable-value\" (click)=\"clicked()\" [attr.data-automation-id]=\"'card-mapitem-value-' + property.key\">\n                <span *ngIf=\"showProperty(); else elseEmptyValueBlock\">{{ property.displayValue }}</span>\n            </span>\n        </ng-template>\n    </div>\n    <ng-template #elseEmptyValueBlock>\n        {{ property.default | translate }}\n    </ng-template>\n</div>\n",
                styles: [".adf-mapitem-clickable-value{cursor:pointer!important}"]
            }] }
];
/** @nocollapse */
CardViewMapItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService }
];
CardViewMapItemComponent.propDecorators = {
    property: [{ type: Input }],
    displayEmpty: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewTextItemModel extends CardViewBaseItemModel {
    /**
     * @param {?} cardViewTextItemProperties
     */
    constructor(cardViewTextItemProperties) {
        super(cardViewTextItemProperties);
        this.type = 'text';
        this.multiline = !!cardViewTextItemProperties.multiline;
        this.multivalued = !!cardViewTextItemProperties.multivalued;
        this.pipes = cardViewTextItemProperties.pipes || [];
        this.clickCallBack = cardViewTextItemProperties.clickCallBack ? cardViewTextItemProperties.clickCallBack : null;
    }
    /**
     * @return {?}
     */
    get displayValue() {
        if (this.isEmpty()) {
            return this.default;
        }
        else {
            return this.applyPipes(this.value);
        }
    }
    /**
     * @private
     * @param {?} displayValue
     * @return {?}
     */
    applyPipes(displayValue) {
        if (this.pipes.length) {
            displayValue = this.pipes.reduce((/**
             * @param {?} accumulator
             * @param {?} __1
             * @return {?}
             */
            (accumulator, { pipe, params = [] }) => {
                return pipe.transform(accumulator, ...params);
            }), displayValue);
        }
        return displayValue;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewTextItemComponent {
    /**
     * @param {?} cardViewUpdateService
     * @param {?} appConfig
     */
    constructor(cardViewUpdateService, appConfig) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.appConfig = appConfig;
        this.editable = false;
        this.displayEmpty = true;
        this.inEdit = false;
        this.valueSeparator = this.appConfig.get('content-metadata.multi-value-pipe-separator') || CardViewTextItemComponent.DEFAULT_SEPARATOR;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.editedValue = this.property.multiline ? this.property.displayValue : this.property.value;
    }
    /**
     * @return {?}
     */
    showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    /**
     * @return {?}
     */
    isEditable() {
        return this.editable && this.property.editable;
    }
    /**
     * @return {?}
     */
    isClickable() {
        return !!this.property.clickable;
    }
    /**
     * @return {?}
     */
    hasIcon() {
        return !!this.property.icon;
    }
    /**
     * @return {?}
     */
    hasErrors() {
        return this.errorMessages && this.errorMessages.length > 0;
    }
    /**
     * @param {?} editStatus
     * @return {?}
     */
    setEditMode(editStatus) {
        this.inEdit = editStatus;
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.editorInput) {
                this.editorInput.nativeElement.click();
            }
        }), 0);
    }
    /**
     * @return {?}
     */
    reset() {
        this.editedValue = this.property.multiline ? this.property.displayValue : this.property.value;
        this.setEditMode(false);
        this.resetErrorMessages();
    }
    /**
     * @private
     * @return {?}
     */
    resetErrorMessages() {
        this.errorMessages = [];
    }
    /**
     * @return {?}
     */
    update() {
        if (this.property.isValid(this.editedValue)) {
            /** @type {?} */
            const updatedValue = this.prepareValueForUpload(this.property, this.editedValue);
            this.cardViewUpdateService.update(this.property, updatedValue);
            this.property.value = updatedValue;
            this.setEditMode(false);
            this.resetErrorMessages();
        }
        else {
            this.errorMessages = this.property.getValidationErrors(this.editedValue);
        }
    }
    /**
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    prepareValueForUpload(property, value) {
        if (property.multivalued) {
            /** @type {?} */
            const listOfValues = value.split(this.valueSeparator.trim()).map((/**
             * @param {?} item
             * @return {?}
             */
            (item) => item.trim()));
            return listOfValues;
        }
        return value;
    }
    /**
     * @return {?}
     */
    onTextAreaInputChange() {
        this.errorMessages = this.property.getValidationErrors(this.editedValue);
    }
    /**
     * @return {?}
     */
    clicked() {
        if (typeof this.property.clickCallBack === 'function') {
            this.property.clickCallBack();
        }
        else {
            this.cardViewUpdateService.clicked(this.property);
        }
    }
}
CardViewTextItemComponent.DEFAULT_SEPARATOR = ', ';
CardViewTextItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-textitem',
                template: "<div [attr.data-automation-id]=\"'card-textitem-label-' + property.key\" class=\"adf-property-label\" *ngIf=\"showProperty() || isEditable()\">{{ property.label | translate }}</div>\n<div class=\"adf-property-value\">\n    <span *ngIf=\"!isEditable()\">\n        <span *ngIf=\"!isClickable(); else elseBlock\" [attr.data-automation-id]=\"'card-textitem-value-' + property.key\">\n            <span *ngIf=\"showProperty()\" class=\"adf-textitem-ellipsis\">{{ property.displayValue }}</span>\n        </span>\n        <ng-template #elseBlock>\n            <div class=\"adf-textitem-clickable\" (click)=\"clicked()\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n                <span class=\"adf-textitem-clickable-value\" [attr.data-automation-id]=\"'card-textitem-value-' + property.key\">\n                    <span *ngIf=\"showProperty(); else elseEmptyValueBlock\">{{ property.displayValue }}</span>\n                </span>\n            </div>\n        </ng-template>\n    </span>\n    <span *ngIf=\"isEditable()\">\n        <div *ngIf=\"!inEdit\" (click)=\"setEditMode(true)\" class=\"adf-textitem-readonly\" [attr.data-automation-id]=\"'card-textitem-edit-toggle-' + property.key\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n            <span [attr.data-automation-id]=\"'card-textitem-value-' + property.key\">\n                <span *ngIf=\"showProperty(); else elseEmptyValueBlock\">{{ property.displayValue }}</span>\n            </span>\n            <mat-icon fxFlex=\"0 0 auto\"\n                [attr.data-automation-id]=\"'card-textitem-edit-icon-' + property.key\"\n                [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                class=\"adf-textitem-icon\">create</mat-icon>\n        </div>\n        <div *ngIf=\"inEdit\" class=\"adf-textitem-editable\">\n            <div class=\"adf-textitem-editable-controls\">\n                <mat-form-field floatPlaceholder=\"never\" class=\"adf-input-container\">\n                    <input *ngIf=\"!property.multiline\" #editorInput\n                        matInput\n                        class=\"adf-input\"\n                        [placeholder]=\"property.default | translate\"\n                        [(ngModel)]=\"editedValue\"\n                        [attr.data-automation-id]=\"'card-textitem-editinput-' + property.key\">\n                    <textarea *ngIf=\"property.multiline\" #editorInput\n                        matInput\n                        matTextareaAutosize\n                        matAutosizeMaxRows=\"1\"\n                        matAutosizeMaxRows=\"5\"\n                        class=\"adf-textarea\"\n                        [placeholder]=\"property.default | translate\"\n                        [(ngModel)]=\"editedValue\"\n                        (input)=\"onTextAreaInputChange()\"\n                        [attr.data-automation-id]=\"'card-textitem-edittextarea-' + property.key\"></textarea>\n                </mat-form-field>\n                <mat-icon\n                    [ngClass]=\"{'disable': hasErrors()}\"\n                    (click)=\"update()\"\n                    [attr.data-automation-id]=\"'card-textitem-update-' + property.key\"\n                    class=\"adf-textitem-icon adf-update-icon\"\n                    [class.adf-button-disabled]=\"hasErrors()\"\n                    [attr.title]=\"'CORE.METADATA.ACTIONS.SAVE' | translate\">done</mat-icon>\n                <mat-icon\n                    class=\"adf-textitem-icon adf-reset-icon\"\n                    (click)=\"reset()\"\n                    [attr.title]=\"'CORE.METADATA.ACTIONS.CANCEL' | translate\"\n                    [attr.data-automation-id]=\"'card-textitem-reset-' + property.key\">clear</mat-icon>\n\n            </div>\n            <mat-error  [attr.data-automation-id]=\"'card-textitem-error-' + property.key\" class=\"adf-textitem-editable-error\" *ngIf=\"hasErrors()\">\n                <ul>\n                    <li *ngFor=\"let errorMessage of errorMessages\">{{ errorMessage | translate }}</li>\n                </ul>\n            </mat-error>\n        </div>\n    </span>\n    <ng-template #elseEmptyValueBlock>\n        <span class=\"adf-textitem-default-value\">{{ property.default | translate }}</span>\n    </ng-template>\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
CardViewTextItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService },
    { type: AppConfigService }
];
CardViewTextItemComponent.propDecorators = {
    property: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    editorInput: [{ type: ViewChild, args: ['editorInput',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class CardViewSelectItemModel extends CardViewBaseItemModel {
    /**
     * @param {?} cardViewSelectItemProperties
     */
    constructor(cardViewSelectItemProperties) {
        super(cardViewSelectItemProperties);
        this.type = 'select';
        this.options$ = cardViewSelectItemProperties.options$;
    }
    /**
     * @return {?}
     */
    get displayValue() {
        return this.options$.pipe(switchMap((/**
         * @param {?} options
         * @return {?}
         */
        (options) => {
            /** @type {?} */
            const option = options.find((/**
             * @param {?} o
             * @return {?}
             */
            (o) => o.key === this.value));
            return of(option ? option.label : '');
        })));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewSelectItemComponent {
    /**
     * @param {?} cardViewUpdateService
     */
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.editable = false;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.value = this.property.value;
    }
    /**
     * @return {?}
     */
    isEditable() {
        return this.editable && this.property.editable;
    }
    /**
     * @return {?}
     */
    getOptions() {
        return this.options$ || this.property.options$;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        this.cardViewUpdateService.update(this.property, event.value);
        this.property.value = event.value;
    }
}
CardViewSelectItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-selectitem',
                template: "<div [attr.data-automation-id]=\"'card-select-label-' + property.key\" class=\"adf-property-label\">{{ property.label | translate }}</div>\n<div class=\"adf-property-value\">\n    <div *ngIf=\"!isEditable()\" data-automation-class=\"read-only-value\">{{ property.displayValue | async }}</div>\n    <div *ngIf=\"isEditable()\">\n        <mat-form-field>\n            <mat-select [(value)]=\"value\" (selectionChange)=\"onChange($event)\" data-automation-class=\"select-box\">\n              <mat-option *ngFor=\"let option of getOptions() | async\" [value]=\"option.key\">\n                {{ option.label | translate }}\n              </mat-option>\n            </mat-select>\n          </mat-form-field>\n    </div>\n</div>\n",
                styles: [".mat-form-field-type-mat-select{width:100%}"]
            }] }
];
/** @nocollapse */
CardViewSelectItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService }
];
CardViewSelectItemComponent.propDecorators = {
    property: [{ type: Input }],
    editable: [{ type: Input }],
    options$: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewDatetimeItemModel extends CardViewDateItemModel {
    constructor() {
        super(...arguments);
        this.type = 'datetime';
        this.format = 'MMM DD YYYY HH:mm';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewItemIntValidator {
    constructor() {
        this.message = 'CORE.CARDVIEW.VALIDATORS.INT_VALIDATION_ERROR';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isValid(value) {
        return !isNaN(value) && ((/**
         * @param {?} x
         * @return {?}
         */
        function (x) { return (x | 0) === x; }))(parseFloat(value));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewItemFloatValidator {
    constructor() {
        this.message = 'CORE.CARDVIEW.VALIDATORS.FLOAT_VALIDATION_ERROR';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isValid(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewFloatItemModel extends CardViewTextItemModel {
    /**
     * @param {?} cardViewTextItemProperties
     */
    constructor(cardViewTextItemProperties) {
        super(cardViewTextItemProperties);
        this.type = 'float';
        this.validators.push(new CardViewItemFloatValidator());
        if (cardViewTextItemProperties.value) {
            this.value = parseFloat(cardViewTextItemProperties.value);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewIntItemModel extends CardViewTextItemModel {
    /**
     * @param {?} cardViewTextItemProperties
     */
    constructor(cardViewTextItemProperties) {
        super(cardViewTextItemProperties);
        this.type = 'int';
        this.validators.push(new CardViewItemIntValidator());
        if (cardViewTextItemProperties.value) {
            this.value = parseInt(cardViewTextItemProperties.value, 10);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewKeyValuePairsItemModel extends CardViewBaseItemModel {
    /**
     * @param {?} cardViewKeyValuePairsItemProperties
     */
    constructor(cardViewKeyValuePairsItemProperties) {
        super(cardViewKeyValuePairsItemProperties);
        this.type = 'keyvaluepairs';
    }
    /**
     * @return {?}
     */
    get displayValue() {
        return this.value;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewKeyValuePairsItemComponent {
    /**
     * @param {?} cardViewUpdateService
     */
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.editable = false;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.values = this.property.value || [];
        this.matTableValues = new MatTableDataSource(this.values);
    }
    /**
     * @return {?}
     */
    isEditable() {
        return this.editable && this.property.editable;
    }
    /**
     * @return {?}
     */
    add() {
        this.values.push({ name: '', value: '' });
    }
    /**
     * @param {?} index
     * @return {?}
     */
    remove(index) {
        this.values.splice(index, 1);
        this.save(true);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onBlur(value) {
        if (value.length) {
            this.save();
        }
    }
    /**
     * @param {?=} remove
     * @return {?}
     */
    save(remove) {
        /** @type {?} */
        const validValues = this.values.filter((/**
         * @param {?} i
         * @return {?}
         */
        (i) => i.name.length && i.value.length));
        if (remove || validValues.length) {
            this.cardViewUpdateService.update(this.property, validValues);
            this.property.value = validValues;
        }
    }
}
CardViewKeyValuePairsItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-boolitem',
                template: "<div [attr.data-automation-id]=\"'card-key-value-pairs-label-' + property.key\" class=\"adf-property-label\">{{ property.label | translate }}</div>\n<div class=\"adf-property-value\">\n\n    <div *ngIf=\"isEditable()\">\n        {{ 'CORE.CARDVIEW.KEYVALUEPAIRS.ADD' | translate }}\n        <button (click)=\"add()\" mat-icon-button class=\"adf-card-view__key-value-pairs__add-btn\" [attr.data-automation-id]=\"'card-key-value-pairs-button-' + property.key\">\n            <mat-icon>add</mat-icon>\n        </button>\n    </div>\n\n    <div *ngIf=\"!isEditable()\" class=\"adf-card-view__key-value-pairs__read-only\">\n        <mat-table #table [dataSource]=\"matTableValues\" class=\"mat-elevation-z8\">\n            <ng-container matColumnDef=\"name\">\n                <mat-header-cell *matHeaderCellDef>{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.NAME' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let item\">{{item.name}}</mat-cell>\n            </ng-container>\n            <ng-container matColumnDef=\"value\">\n                <mat-header-cell *matHeaderCellDef>{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.VALUE' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let item\">{{item.value}}</mat-cell>\n            </ng-container>\n\n            <mat-header-row *matHeaderRowDef=\"['name', 'value']\"></mat-header-row>\n            <mat-row *matRowDef=\"let row; columns: ['name', 'value'];\"></mat-row>\n        </mat-table>\n    </div>\n\n\n    <div class=\"adf-card-view__key-value-pairs\" *ngIf=\"isEditable() && values && values.length\">\n        <div class=\"adf-card-view__key-value-pairs__row\">\n            <div class=\"adf-card-view__key-value-pairs__col\">{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.NAME' | translate }}</div>\n            <div class=\"adf-card-view__key-value-pairs__col\">{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.VALUE' | translate }}</div>\n        </div>\n\n        <div class=\"adf-card-view__key-value-pairs__row\" *ngFor=\"let item of values; let i = index\">\n            <div class=\"adf-card-view__key-value-pairs__col\">\n                <mat-form-field class=\"adf-example-full-width\">\n                    <input matInput\n                           placeholder=\"{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.NAME' | translate }}\"\n                           (blur)=\"onBlur(item.value)\"\n                           [attr.data-automation-id]=\"'card-'+ property.key +'-name-input-' + i\"\n                           [(ngModel)]=\"values[i].name\">\n                </mat-form-field>\n            </div>\n            <div class=\"adf-card-view__key-value-pairs__col\">\n                <mat-form-field class=\"adf-example-full-width\">\n                    <input matInput\n                           placeholder=\"{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.VALUE' | translate }}\"\n                           (blur)=\"onBlur(item.value)\"\n                           [attr.data-automation-id]=\"'card-'+ property.key +'-value-input-' + i\"\n                           [(ngModel)]=\"values[i].value\">\n                </mat-form-field>\n            </div>\n            <button mat-icon-button (click)=\"remove(i)\" class=\"adf-card-view__key-value-pairs__remove-btn\">\n                <mat-icon>close</mat-icon>\n            </button>\n        </div>\n    </div>\n</div>\n",
                styles: [".adf-card-view__key-value-pairs__col{display:inline-block;width:39%}.adf-card-view__key-value-pairs__col .mat-form-field{width:100%}.adf-card-view__key-value-pairs__read-only .mat-table{box-shadow:none}.adf-card-view__key-value-pairs__read-only .mat-header-row,.adf-card-view__key-value-pairs__read-only .mat-row{padding:0}"]
            }] }
];
/** @nocollapse */
CardViewKeyValuePairsItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService }
];
CardViewKeyValuePairsItemComponent.propDecorators = {
    property: [{ type: Input }],
    editable: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {?} type
 * @return {?}
 */
function getType(type) {
    return (/**
     * @return {?}
     */
    () => type);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicComponentResolver {
    /**
     * @param {?} type
     * @return {?}
     */
    static fromType(type) {
        return getType(type);
    }
}
/**
 * @abstract
 */
class DynamicComponentMapper {
    constructor() {
        this.defaultValue = undefined;
        this.types = {};
    }
    /**
     * Gets the currently active DynamicComponentResolveFunction for a field type.
     * @param {?} type The type whose resolver you want
     * @param {?=} defaultValue Default type returned for types that are not yet mapped
     * @return {?} Resolver function
     */
    getComponentTypeResolver(type, defaultValue = this.defaultValue) {
        if (type) {
            return this.types[type] || DynamicComponentResolver.fromType(defaultValue);
        }
        return DynamicComponentResolver.fromType(defaultValue);
    }
    /**
     * Sets or optionally replaces a DynamicComponentResolveFunction for a field type.
     * @param {?} type The type whose resolver you want to set
     * @param {?} resolver The new resolver function
     * @param {?=} override The new resolver will only replace an existing one if this parameter is true
     * @return {?}
     */
    setComponentTypeResolver(type, resolver, override = true) {
        if (!type) {
            throw new Error(`type is null or not defined`);
        }
        if (!resolver) {
            throw new Error(`resolver is null or not defined`);
        }
        /** @type {?} */
        const existing = this.types[type];
        if (existing && !override) {
            throw new Error(`already mapped, use override option if you intend replacing existing mapping.`);
        }
        this.types[type] = resolver;
    }
    /**
     * Finds the component type that is needed to render a form field.
     * @param {?} model Form field model for the field to render
     * @param {?=} defaultValue Default type returned for field types that are not yet mapped.
     * @return {?} Component type
     */
    resolveComponentType(model, defaultValue = this.defaultValue) {
        if (model) {
            /** @type {?} */
            const resolver = this.getComponentTypeResolver(model.type, defaultValue);
            return resolver(model);
        }
        return defaultValue;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardItemTypeService extends DynamicComponentMapper {
    constructor() {
        super(...arguments);
        this.defaultValue = CardViewTextItemComponent;
        this.types = {
            'text': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'select': DynamicComponentResolver.fromType(CardViewSelectItemComponent),
            'int': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'float': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'date': DynamicComponentResolver.fromType(CardViewDateItemComponent),
            'datetime': DynamicComponentResolver.fromType(CardViewDateItemComponent),
            'bool': DynamicComponentResolver.fromType(CardViewBoolItemComponent),
            'map': DynamicComponentResolver.fromType(CardViewMapItemComponent),
            'keyvaluepairs': DynamicComponentResolver.fromType(CardViewKeyValuePairsItemComponent)
        };
    }
}
CardItemTypeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ CardItemTypeService.ngInjectableDef = defineInjectable({ factory: function CardItemTypeService_Factory() { return new CardItemTypeService(); }, token: CardItemTypeService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewContentProxyDirective {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
CardViewContentProxyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-card-view-content-proxy]'
            },] }
];
/** @nocollapse */
CardViewContentProxyDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewItemDispatcherComponent {
    /**
     * @param {?} cardItemTypeService
     * @param {?} resolver
     */
    constructor(cardItemTypeService, resolver) {
        this.cardItemTypeService = cardItemTypeService;
        this.resolver = resolver;
        this.displayEmpty = true;
        this.loaded = false;
        this.componentReference = null;
        /** @type {?} */
        const dynamicLifeCycleMethods = [
            'ngOnInit',
            'ngDoCheck',
            'ngAfterContentInit',
            'ngAfterContentChecked',
            'ngAfterViewInit',
            'ngAfterViewChecked',
            'ngOnDestroy'
        ];
        dynamicLifeCycleMethods.forEach((/**
         * @param {?} method
         * @return {?}
         */
        (method) => {
            this[method] = this.proxy.bind(this, method);
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.loaded) {
            this.loadComponent();
            this.loaded = true;
        }
        Object.keys(changes)
            .map((/**
         * @param {?} changeName
         * @return {?}
         */
        (changeName) => [changeName, changes[changeName]]))
            .forEach((/**
         * @param {?} __0
         * @return {?}
         */
        ([inputParamName, simpleChange]) => {
            this.componentReference.instance[inputParamName] = simpleChange.currentValue;
        }));
        this.proxy('ngOnChanges', changes);
    }
    /**
     * @private
     * @return {?}
     */
    loadComponent() {
        /** @type {?} */
        const factoryClass = this.cardItemTypeService.resolveComponentType(this.property);
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(factoryClass);
        this.componentReference = this.content.viewContainerRef.createComponent(factory);
        this.componentReference.instance.editable = this.editable;
        this.componentReference.instance.property = this.property;
        this.componentReference.instance.displayEmpty = this.displayEmpty;
    }
    /**
     * @private
     * @param {?} methodName
     * @param {...?} args
     * @return {?}
     */
    proxy(methodName, ...args) {
        if (this.componentReference.instance[methodName]) {
            this.componentReference.instance[methodName].apply(this.componentReference.instance, args);
        }
    }
}
CardViewItemDispatcherComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-item-dispatcher',
                template: '<ng-template adf-card-view-content-proxy></ng-template>'
            }] }
];
/** @nocollapse */
CardViewItemDispatcherComponent.ctorParameters = () => [
    { type: CardItemTypeService },
    { type: ComponentFactoryResolver }
];
CardViewItemDispatcherComponent.propDecorators = {
    property: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    content: [{ type: ViewChild, args: [CardViewContentProxyDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardViewModule {
}
CardViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FlexLayoutModule,
                    TranslateModule.forChild(),
                    MatDatepickerModule,
                    MatNativeDateModule,
                    MatCheckboxModule,
                    MatInputModule,
                    MatTableModule,
                    MatIconModule,
                    MatSelectModule,
                    MatButtonModule,
                    MatDatetimepickerModule,
                    MatNativeDatetimeModule
                ],
                declarations: [
                    CardViewComponent,
                    CardViewBoolItemComponent,
                    CardViewDateItemComponent,
                    CardViewMapItemComponent,
                    CardViewTextItemComponent,
                    CardViewKeyValuePairsItemComponent,
                    CardViewSelectItemComponent,
                    CardViewItemDispatcherComponent,
                    CardViewContentProxyDirective
                ],
                entryComponents: [
                    CardViewBoolItemComponent,
                    CardViewDateItemComponent,
                    CardViewMapItemComponent,
                    CardViewTextItemComponent,
                    CardViewSelectItemComponent,
                    CardViewKeyValuePairsItemComponent
                ],
                exports: [
                    CardViewComponent,
                    CardViewBoolItemComponent,
                    CardViewDateItemComponent,
                    CardViewMapItemComponent,
                    CardViewTextItemComponent,
                    CardViewSelectItemComponent,
                    CardViewKeyValuePairsItemComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DebugAppConfigService extends AppConfigService {
    /**
     * @param {?} http
     */
    constructor(http) {
        super(http);
    }
    /**
     * @override
     * @template T
     * @param {?} key
     * @param {?=} defaultValue
     * @return {?}
     */
    get(key, defaultValue) {
        if (key === AppConfigValues.OAUTHCONFIG) {
            return (/** @type {?} */ ((JSON.parse(this.getItem(key)) || super.get(key, defaultValue))));
        }
        else if (key === AppConfigValues.APPLICATION) {
            return undefined;
        }
        else {
            return (/** @type {?} */ (((/** @type {?} */ (this.getItem(key))) || super.get(key, defaultValue))));
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        return localStorage.getItem(key);
    }
}
DebugAppConfigService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DebugAppConfigService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppConfigPipe {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} value
     * @param {?} fallback
     * @return {?}
     */
    transform(value, fallback) {
        return this.config.get(value, fallback);
    }
}
AppConfigPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfAppConfig'
            },] }
];
/** @nocollapse */
AppConfigPipe.ctorParameters = () => [
    { type: AppConfigService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppConfigModule {
}
AppConfigModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule
                ],
                declarations: [
                    AppConfigPipe
                ],
                exports: [
                    AppConfigPipe
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormDefinitionModel extends FormSaveRepresentation {
    /**
     * @param {?} id
     * @param {?} name
     * @param {?} lastUpdatedByFullName
     * @param {?} lastUpdated
     * @param {?} metadata
     */
    constructor(id, name, lastUpdatedByFullName, lastUpdated, metadata) {
        super();
        this.reusable = false;
        this.newVersion = false;
        this.formImageBase64 = '';
        this.formRepresentation = {
            id: id,
            name: name,
            description: '',
            version: 1,
            lastUpdatedBy: 1,
            lastUpdatedByFullName: lastUpdatedByFullName,
            lastUpdated: lastUpdated,
            stencilSetId: 0,
            referenceId: null,
            formDefinition: {
                fields: [{
                        name: 'Label',
                        type: 'container',
                        fieldType: 'ContainerRepresentation',
                        numberOfColumns: 2,
                        required: false,
                        readOnly: false,
                        sizeX: 2,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        fields: { '1': this.metadataToFields(metadata) }
                    }],
                gridsterForm: false,
                javascriptEvents: [],
                metadata: {},
                outcomes: [],
                className: '',
                style: '',
                tabs: [],
                variables: []
            }
        };
    }
    /**
     * @private
     * @param {?} metadata
     * @return {?}
     */
    metadataToFields(metadata) {
        /** @type {?} */
        const fields = [];
        if (metadata) {
            metadata.forEach((/**
             * @param {?} property
             * @return {?}
             */
            function (property) {
                if (property) {
                    /** @type {?} */
                    const field = {
                        type: 'text',
                        id: property.name,
                        name: property.name,
                        required: false,
                        readOnly: false,
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        colspan: 1,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        layout: {
                            colspan: 1,
                            row: -1,
                            column: -1
                        }
                    };
                    fields.push(field);
                }
            }));
        }
        return fields;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class FormFieldTypes {
    /**
     * @param {?} type
     * @return {?}
     */
    static isReadOnlyType(type) {
        return FormFieldTypes.READONLY_TYPES.indexOf(type) > -1;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    static isContainerType(type) {
        return type === FormFieldTypes.CONTAINER || type === FormFieldTypes.GROUP;
    }
}
FormFieldTypes.CONTAINER = 'container';
FormFieldTypes.GROUP = 'group';
FormFieldTypes.DYNAMIC_TABLE = 'dynamic-table';
FormFieldTypes.TEXT = 'text';
FormFieldTypes.MULTILINE_TEXT = 'multi-line-text';
FormFieldTypes.DROPDOWN = 'dropdown';
FormFieldTypes.HYPERLINK = 'hyperlink';
FormFieldTypes.RADIO_BUTTONS = 'radio-buttons';
FormFieldTypes.DISPLAY_VALUE = 'readonly';
FormFieldTypes.READONLY_TEXT = 'readonly-text';
FormFieldTypes.UPLOAD = 'upload';
FormFieldTypes.TYPEAHEAD = 'typeahead';
FormFieldTypes.FUNCTIONAL_GROUP = 'functional-group';
FormFieldTypes.PEOPLE = 'people';
FormFieldTypes.BOOLEAN = 'boolean';
FormFieldTypes.NUMBER = 'integer';
FormFieldTypes.DATE = 'date';
FormFieldTypes.AMOUNT = 'amount';
FormFieldTypes.DOCUMENT = 'document';
FormFieldTypes.DATETIME = 'datetime';
FormFieldTypes.ATTACH_FOLDER = 'select-folder';
FormFieldTypes.READONLY_TYPES = [
    FormFieldTypes.HYPERLINK,
    FormFieldTypes.DISPLAY_VALUE,
    FormFieldTypes.READONLY_TEXT
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
/**
 * @abstract
 */
class FormWidgetModel {
    /**
     * @param {?} form
     * @param {?} json
     */
    constructor(form, json) {
        this.form = form;
        this.json = json;
        if (json) {
            this.fieldType = json.fieldType;
            this.id = json.id;
            this.name = json.name;
            this.type = json.type;
            this.tab = json.tab;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class ContainerColumnModel {
    constructor() {
        this.size = 12;
        this.fields = [];
        this.colspan = 1;
        this.rowspan = 1;
    }
    /**
     * @return {?}
     */
    hasFields() {
        return this.fields && this.fields.length > 0;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class ErrorMessageModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.message = '';
        this.attributes = null;
        this.message = obj && obj.message ? obj.message : '';
        this.attributes = new Map();
    }
    /**
     * @return {?}
     */
    isActive() {
        return this.message ? true : false;
    }
    /**
     * @return {?}
     */
    getAttributesAsJsonObj() {
        /** @type {?} */
        let result = {};
        if (this.attributes.size > 0) {
            /** @type {?} */
            const obj = Object.create(null);
            this.attributes.forEach((/**
             * @param {?} value
             * @param {?} key
             * @return {?}
             */
            (value, key) => {
                obj[key] = value;
            }));
            result = JSON.stringify(obj);
        }
        return result;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RequiredFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT,
            FormFieldTypes.NUMBER,
            FormFieldTypes.BOOLEAN,
            FormFieldTypes.TYPEAHEAD,
            FormFieldTypes.DROPDOWN,
            FormFieldTypes.PEOPLE,
            FormFieldTypes.FUNCTIONAL_GROUP,
            FormFieldTypes.RADIO_BUTTONS,
            FormFieldTypes.UPLOAD,
            FormFieldTypes.AMOUNT,
            FormFieldTypes.DYNAMIC_TABLE,
            FormFieldTypes.DATE,
            FormFieldTypes.DATETIME,
            FormFieldTypes.ATTACH_FOLDER
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.required;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.isVisible) {
            if (field.type === FormFieldTypes.DROPDOWN) {
                if (field.hasEmptyValue && field.emptyOption) {
                    if (field.value === field.emptyOption.id) {
                        return false;
                    }
                }
            }
            if (field.type === FormFieldTypes.RADIO_BUTTONS) {
                /** @type {?} */
                const option = field.options.find((/**
                 * @param {?} opt
                 * @return {?}
                 */
                (opt) => opt.id === field.value));
                return !!option;
            }
            if (field.type === FormFieldTypes.UPLOAD) {
                return field.value && field.value.length > 0;
            }
            if (field.type === FormFieldTypes.DYNAMIC_TABLE) {
                return field.value && field.value instanceof Array && field.value.length > 0;
            }
            if (field.type === FormFieldTypes.BOOLEAN) {
                return field.value ? true : false;
            }
            if (field.value === null || field.value === undefined || field.value === '') {
                return false;
            }
        }
        return true;
    }
}
class NumberFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isNumber(value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        return !isNaN(+value);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.isVisible) {
            if (field.value === null ||
                field.value === undefined ||
                field.value === '') {
                return true;
            }
            /** @type {?} */
            const valueStr = '' + field.value;
            /** @type {?} */
            let pattern = new RegExp(/^-?\d+$/);
            if (field.enableFractions) {
                pattern = new RegExp(/^-?[0-9]+(\.[0-9]{1,2})?$/);
            }
            if (valueStr.match(pattern)) {
                return true;
            }
            field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_NUMBER';
            return false;
        }
        return true;
    }
}
class DateFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    // Validates that the input string is a valid date formatted as <dateFormat> (default D-M-YYYY)
    /**
     * @param {?} inputDate
     * @param {?=} dateFormat
     * @return {?}
     */
    static isValidDate(inputDate, dateFormat = 'D-M-YYYY') {
        if (inputDate) {
            /** @type {?} */
            const d = moment(inputDate, dateFormat, true);
            return d.isValid();
        }
        return false;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (DateFieldValidator.isValidDate(field.value, field.dateDisplayFormat)) {
                return true;
            }
            field.validationSummary.message = field.dateDisplayFormat;
            return false;
        }
        return true;
    }
}
class MinDateFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.minValue;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        /** @type {?} */
        let isValid = true;
        if (this.isSupported(field) && field.value && field.isVisible) {
            /** @type {?} */
            const dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                isValid = false;
            }
            else {
                isValid = this.checkDate(field, dateFormat);
            }
        }
        return isValid;
    }
    /**
     * @private
     * @param {?} field
     * @param {?} dateFormat
     * @return {?}
     */
    checkDate(field, dateFormat) {
        /** @type {?} */
        const MIN_DATE_FORMAT = 'DD-MM-YYYY';
        /** @type {?} */
        let isValid = true;
        // remove time and timezone info
        /** @type {?} */
        let fieldValueData;
        if (typeof field.value === 'string') {
            fieldValueData = moment(field.value.split('T')[0], dateFormat);
        }
        else {
            fieldValueData = field.value;
        }
        /** @type {?} */
        const min = moment(field.minValue, MIN_DATE_FORMAT);
        if (fieldValueData.isBefore(min)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', min.format(field.dateDisplayFormat).toLocaleUpperCase());
            isValid = false;
        }
        return isValid;
    }
}
class MaxDateFieldValidator {
    constructor() {
        this.MAX_DATE_FORMAT = 'DD-MM-YYYY';
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.maxValue;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            /** @type {?} */
            const dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                return false;
            }
            // remove time and timezone info
            /** @type {?} */
            let d;
            if (typeof field.value === 'string') {
                d = moment(field.value.split('T')[0], dateFormat);
            }
            else {
                d = field.value;
            }
            /** @type {?} */
            const max = moment(field.maxValue, this.MAX_DATE_FORMAT);
            if (d.isAfter(max)) {
                field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
                field.validationSummary.attributes.set('maxValue', max.format(field.dateDisplayFormat).toLocaleUpperCase());
                return false;
            }
        }
        return true;
    }
}
class MinDateTimeFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATETIME
        ];
        this.MIN_DATETIME_FORMAT = 'YYYY-MM-DD hh:mm AZ';
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.minValue;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        /** @type {?} */
        let isValid = true;
        if (this.isSupported(field) && field.value && field.isVisible) {
            /** @type {?} */
            const dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                isValid = false;
            }
            else {
                isValid = this.checkDateTime(field, dateFormat);
            }
        }
        return isValid;
    }
    /**
     * @private
     * @param {?} field
     * @param {?} dateFormat
     * @return {?}
     */
    checkDateTime(field, dateFormat) {
        /** @type {?} */
        let isValid = true;
        /** @type {?} */
        let fieldValueDate;
        if (typeof field.value === 'string') {
            fieldValueDate = moment(field.value, dateFormat);
        }
        else {
            fieldValueDate = field.value;
        }
        /** @type {?} */
        const min = moment(field.minValue, this.MIN_DATETIME_FORMAT);
        if (fieldValueDate.isBefore(min)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', min.format(field.dateDisplayFormat).replace(':', '-'));
            isValid = false;
        }
        return isValid;
    }
}
class MaxDateTimeFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATETIME
        ];
        this.MAX_DATETIME_FORMAT = 'YYYY-MM-DD hh:mm AZ';
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.maxValue;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        /** @type {?} */
        let isValid = true;
        if (this.isSupported(field) && field.value && field.isVisible) {
            /** @type {?} */
            const dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                isValid = false;
            }
            else {
                isValid = this.checkDateTime(field, dateFormat);
            }
        }
        return isValid;
    }
    /**
     * @private
     * @param {?} field
     * @param {?} dateFormat
     * @return {?}
     */
    checkDateTime(field, dateFormat) {
        /** @type {?} */
        let isValid = true;
        /** @type {?} */
        let fieldValueDate;
        if (typeof field.value === 'string') {
            fieldValueDate = moment(field.value, dateFormat);
        }
        else {
            fieldValueDate = field.value;
        }
        /** @type {?} */
        const max = moment(field.maxValue, this.MAX_DATETIME_FORMAT);
        if (fieldValueDate.isAfter(max)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
            field.validationSummary.attributes.set('maxValue', max.format(field.dateDisplayFormat).replace(':', '-'));
            isValid = false;
        }
        return isValid;
    }
}
class MinLengthFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.minLength > 0;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (field.value.length >= field.minLength) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.AT_LEAST_LONG`;
            field.validationSummary.attributes.set('minLength', field.minLength.toLocaleString());
            return false;
        }
        return true;
    }
}
class MaxLengthFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.maxLength > 0;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (field.value.length <= field.maxLength) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NO_LONGER_THAN`;
            field.validationSummary.attributes.set('maxLength', field.maxLength.toLocaleString());
            return false;
        }
        return true;
    }
}
class MinValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            NumberFieldValidator.isNumber(field.minValue);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            /** @type {?} */
            const value = +field.value;
            /** @type {?} */
            const minValue = +field.minValue;
            if (value >= minValue) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', field.minValue.toLocaleString());
            return false;
        }
        return true;
    }
}
class MaxValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            NumberFieldValidator.isNumber(field.maxValue);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            /** @type {?} */
            const value = +field.value;
            /** @type {?} */
            const maxValue = +field.maxValue;
            if (value <= maxValue) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
            field.validationSummary.attributes.set('maxValue', field.maxValue.toLocaleString());
            return false;
        }
        return true;
    }
}
class RegExFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.regexPattern;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (field.value.length > 0 && field.value.match(new RegExp('^' + field.regexPattern + '$'))) {
                return true;
            }
            field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
            return false;
        }
        return true;
    }
}
class FixedValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TYPEAHEAD
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasValidNameOrValidId(field) {
        return this.hasValidName(field) || this.hasValidId(field);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasValidName(field) {
        return field.options.find((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.name && item.name.toLocaleLowerCase() === field.value.toLocaleLowerCase())) ? true : false;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasValidId(field) {
        return field.options.find((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.id === field.value)) ? true : false;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasStringValue(field) {
        return field.value && typeof field.value === 'string';
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hasOptions(field) {
        return field.options && field.options.length > 0;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    validate(field) {
        if (this.isSupported(field) && field.isVisible) {
            if (this.hasStringValue(field) && this.hasOptions(field) && !this.hasValidNameOrValidId(field)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
                return false;
            }
        }
        return true;
    }
}
/** @type {?} */
const FORM_FIELD_VALIDATORS = [
    new RequiredFieldValidator(),
    new NumberFieldValidator(),
    new MinLengthFieldValidator(),
    new MaxLengthFieldValidator(),
    new MinValueFieldValidator(),
    new MaxValueFieldValidator(),
    new RegExFieldValidator(),
    new DateFieldValidator(),
    new MinDateFieldValidator(),
    new MaxDateFieldValidator(),
    new FixedValueFieldValidator(),
    new MinDateTimeFieldValidator(),
    new MaxDateTimeFieldValidator()
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Maps to FormFieldRepresentation
class FormFieldModel extends FormWidgetModel {
    /**
     * @param {?} form
     * @param {?=} json
     */
    constructor(form, json) {
        super(form, json);
        this._readOnly = false;
        this._isValid = true;
        this._required = false;
        this.defaultDateFormat = 'D-M-YYYY';
        this.defaultDateTimeFormat = 'D-M-YYYY hh:mm A';
        this.rowspan = 1;
        this.colspan = 1;
        this.placeholder = null;
        this.minLength = 0;
        this.maxLength = 0;
        this.options = [];
        this.params = {};
        this.isVisible = true;
        this.visibilityCondition = null;
        this.enableFractions = false;
        this.currency = null;
        this.dateDisplayFormat = this.dateDisplayFormat || this.defaultDateFormat;
        // container model members
        this.numberOfColumns = 1;
        this.fields = [];
        this.columns = [];
        if (json) {
            this.fieldType = json.fieldType;
            this.id = json.id;
            this.name = json.name;
            this.type = json.type;
            this._required = (/** @type {?} */ (json.required));
            this._readOnly = (/** @type {?} */ (json.readOnly)) || json.type === 'readonly';
            this.overrideId = (/** @type {?} */ (json.overrideId));
            this.tab = json.tab;
            this.restUrl = json.restUrl;
            this.restResponsePath = json.restResponsePath;
            this.restIdProperty = json.restIdProperty;
            this.restLabelProperty = json.restLabelProperty;
            this.colspan = (/** @type {?} */ (json.colspan));
            this.minLength = (/** @type {?} */ (json.minLength)) || 0;
            this.maxLength = (/** @type {?} */ (json.maxLength)) || 0;
            this.minValue = json.minValue;
            this.maxValue = json.maxValue;
            this.regexPattern = json.regexPattern;
            this.options = (/** @type {?} */ (json.options)) || [];
            this.hasEmptyValue = (/** @type {?} */ (json.hasEmptyValue));
            this.className = json.className;
            this.optionType = json.optionType;
            this.params = (/** @type {?} */ (json.params)) || {};
            this.hyperlinkUrl = json.hyperlinkUrl;
            this.displayText = json.displayText;
            this.visibilityCondition = (/** @type {?} */ (json.visibilityCondition));
            this.enableFractions = (/** @type {?} */ (json.enableFractions));
            this.currency = json.currency;
            this.dateDisplayFormat = json.dateDisplayFormat || this.getDefaultDateFormat(json);
            this._value = this.parseValue(json);
            this.validationSummary = new ErrorMessageModel();
            if (json.placeholder && json.placeholder !== '' && json.placeholder !== 'null') {
                this.placeholder = json.placeholder;
            }
            if (FormFieldTypes.isReadOnlyType(json.type)) {
                if (json.params && json.params.field) {
                    if (form.processVariables) {
                        /** @type {?} */
                        const processVariable = this.getProcessVariableValue(json.params.field, form);
                        if (processVariable) {
                            this.value = processVariable;
                        }
                    }
                    else if (json.params.field.responseVariable) {
                        /** @type {?} */
                        const formVariable = this.getVariablesValue(json.params.field.name, form);
                        if (formVariable) {
                            this.value = formVariable;
                        }
                    }
                }
            }
            if (FormFieldTypes.isContainerType(json.type)) {
                this.containerFactory(json, form);
            }
        }
        if (this.hasEmptyValue && this.options && this.options.length > 0) {
            this.emptyOption = this.options[0];
        }
        this.updateForm();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        this._value = v;
        this.updateForm();
    }
    /**
     * @return {?}
     */
    get readOnly() {
        if (this.form && this.form.readOnly) {
            return true;
        }
        return this._readOnly;
    }
    /**
     * @param {?} readOnly
     * @return {?}
     */
    set readOnly(readOnly) {
        this._readOnly = readOnly;
        this.updateForm();
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = value;
        this.updateForm();
    }
    /**
     * @return {?}
     */
    get isValid() {
        return this._isValid;
    }
    /**
     * @return {?}
     */
    markAsInvalid() {
        this._isValid = false;
    }
    /**
     * @return {?}
     */
    validate() {
        this.validationSummary = new ErrorMessageModel();
        if (!this.readOnly) {
            /** @type {?} */
            const validators = this.form.fieldValidators || [];
            for (const validator of validators) {
                if (!validator.validate(this)) {
                    this._isValid = false;
                    return this._isValid;
                }
            }
        }
        this._isValid = true;
        return this._isValid;
    }
    /**
     * @private
     * @param {?} jsonField
     * @return {?}
     */
    getDefaultDateFormat(jsonField) {
        /** @type {?} */
        let originalType = jsonField.type;
        if (FormFieldTypes.isReadOnlyType(jsonField.type) &&
            jsonField.params &&
            jsonField.params.field) {
            originalType = jsonField.params.field.type;
        }
        return originalType === FormFieldTypes.DATETIME ? this.defaultDateTimeFormat : this.defaultDateFormat;
    }
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    isTypeaheadFieldType(type) {
        return type === 'typeahead' ? true : false;
    }
    /**
     * @private
     * @param {?} name
     * @return {?}
     */
    getFieldNameWithLabel(name) {
        return name += '_LABEL';
    }
    /**
     * @private
     * @param {?} field
     * @param {?} form
     * @return {?}
     */
    getProcessVariableValue(field, form) {
        /** @type {?} */
        let fieldName = field.name;
        if (this.isTypeaheadFieldType(field.type)) {
            fieldName = this.getFieldNameWithLabel(field.id);
        }
        return this.findProcessVariableValue(fieldName, form);
    }
    /**
     * @private
     * @param {?} variableName
     * @param {?} form
     * @return {?}
     */
    getVariablesValue(variableName, form) {
        /** @type {?} */
        const variable = form.json.variables.find((/**
         * @param {?} currentVariable
         * @return {?}
         */
        (currentVariable) => {
            return currentVariable.name === variableName;
        }));
        if (variable) {
            if (variable.type === 'boolean') {
                return JSON.parse(variable.value);
            }
            return variable.value;
        }
        return null;
    }
    /**
     * @private
     * @param {?} variableName
     * @param {?} form
     * @return {?}
     */
    findProcessVariableValue(variableName, form) {
        if (form.processVariables) {
            /** @type {?} */
            const variable = form.processVariables.find((/**
             * @param {?} currentVariable
             * @return {?}
             */
            (currentVariable) => {
                return currentVariable.name === variableName;
            }));
            if (variable) {
                return variable.type === 'boolean' ? JSON.parse(variable.value) : variable.value;
            }
        }
        return undefined;
    }
    /**
     * @private
     * @param {?} json
     * @param {?} form
     * @return {?}
     */
    containerFactory(json, form) {
        this.numberOfColumns = (/** @type {?} */ (json.numberOfColumns)) || 1;
        this.fields = json.fields;
        this.rowspan = 1;
        this.colspan = 1;
        if (json.fields) {
            for (const currentField in json.fields) {
                if (json.fields.hasOwnProperty(currentField)) {
                    /** @type {?} */
                    const col = new ContainerColumnModel();
                    /** @type {?} */
                    const fields = (json.fields[currentField] || []).map((/**
                     * @param {?} f
                     * @return {?}
                     */
                    (f) => new FormFieldModel(form, f)));
                    col.fields = fields;
                    col.rowspan = json.fields[currentField].length;
                    col.fields.forEach((/**
                     * @param {?} colFields
                     * @return {?}
                     */
                    (colFields) => {
                        this.colspan = colFields.colspan > this.colspan ? colFields.colspan : this.colspan;
                    }));
                    this.rowspan = this.rowspan < col.rowspan ? col.rowspan : this.rowspan;
                    this.columns.push(col);
                }
            }
        }
    }
    /**
     * @param {?} json
     * @return {?}
     */
    parseValue(json) {
        /** @type {?} */
        let value = json.value;
        /*
         This is needed due to Activiti issue related to reading dropdown values as value string
         but saving back as object: { id: <id>, name: <name> }
         */
        if (json.type === FormFieldTypes.DROPDOWN) {
            if (json.hasEmptyValue && json.options) {
                /** @type {?} */
                const options = (/** @type {?} */ (json.options)) || [];
                if (options.length > 0) {
                    /** @type {?} */
                    const emptyOption = json.options[0];
                    if (value === '' || value === emptyOption.id || value === emptyOption.name) {
                        value = emptyOption.id;
                    }
                    else if (value.id && value.name) {
                        value = value.id;
                    }
                }
            }
        }
        /*
         This is needed due to Activiti issue related to reading radio button values as value string
         but saving back as object: { id: <id>, name: <name> }
         */
        if (json.type === FormFieldTypes.RADIO_BUTTONS) {
            // Activiti has a bug with default radio button value where initial selection passed as `name` value
            // so try resolving current one with a fallback to first entry via name or id
            // TODO: needs to be reported and fixed at Activiti side
            /** @type {?} */
            const entry = this.options.filter((/**
             * @param {?} opt
             * @return {?}
             */
            (opt) => opt.id === value || opt.name === value || (value && (opt.id === value.id || opt.name === value.name))));
            if (entry.length > 0) {
                value = entry[0].id;
            }
        }
        /*
         This is needed due to Activiti displaying/editing dates in d-M-YYYY format
         but storing on server in ISO8601 format (i.e. 2013-02-04T22:44:30.652Z)
         */
        if (this.isDateField(json) || this.isDateTimeField(json)) {
            if (value) {
                /** @type {?} */
                let dateValue;
                if (NumberFieldValidator.isNumber(value)) {
                    dateValue = moment(value);
                }
                else {
                    dateValue = this.isDateTimeField(json) ? moment(value, 'YYYY-MM-DD hh:mm A') : moment(value.split('T')[0], 'YYYY-M-D');
                }
                if (dateValue && dateValue.isValid()) {
                    value = dateValue.format(this.dateDisplayFormat);
                }
            }
        }
        return value;
    }
    /**
     * @return {?}
     */
    updateForm() {
        if (!this.form) {
            return;
        }
        switch (this.type) {
            case FormFieldTypes.DROPDOWN:
                /*
                 This is needed due to Activiti reading dropdown values as string
                 but saving back as object: { id: <id>, name: <name> }
                 */
                if (this.value === 'empty' || this.value === '') {
                    this.form.values[this.id] = {};
                }
                else {
                    /** @type {?} */
                    const entry = this.options.filter((/**
                     * @param {?} opt
                     * @return {?}
                     */
                    (opt) => opt.id === this.value));
                    if (entry.length > 0) {
                        this.form.values[this.id] = entry[0];
                    }
                }
                break;
            case FormFieldTypes.RADIO_BUTTONS:
                /*
                                 This is needed due to Activiti issue related to reading radio button values as value string
                                 but saving back as object: { id: <id>, name: <name> }
                                 */
                /** @type {?} */
                const rbEntry = this.options.filter((/**
                 * @param {?} opt
                 * @return {?}
                 */
                (opt) => opt.id === this.value));
                if (rbEntry.length > 0) {
                    this.form.values[this.id] = rbEntry[0];
                }
                break;
            case FormFieldTypes.UPLOAD:
                this.form.hasUpload = true;
                if (this.value && this.value.length > 0) {
                    this.form.values[this.id] = this.value.map((/**
                     * @param {?} elem
                     * @return {?}
                     */
                    (elem) => elem.id)).join(',');
                }
                else {
                    this.form.values[this.id] = null;
                }
                break;
            case FormFieldTypes.TYPEAHEAD:
                /** @type {?} */
                const taEntry = this.options.filter((/**
                 * @param {?} opt
                 * @return {?}
                 */
                (opt) => opt.id === this.value || opt.name === this.value));
                if (taEntry.length > 0) {
                    this.form.values[this.id] = taEntry[0];
                }
                else if (this.options.length > 0) {
                    this.form.values[this.id] = null;
                }
                break;
            case FormFieldTypes.DATE:
                /** @type {?} */
                const dateValue = moment(this.value, this.dateDisplayFormat, true);
                if (dateValue && dateValue.isValid()) {
                    this.form.values[this.id] = `${dateValue.format('YYYY-MM-DD')}T00:00:00.000Z`;
                }
                else {
                    this.form.values[this.id] = null;
                    this._value = this.value;
                }
                break;
            case FormFieldTypes.DATETIME:
                /** @type {?} */
                const dateTimeValue = moment(this.value, this.dateDisplayFormat, true);
                if (dateTimeValue && dateTimeValue.isValid()) {
                    /* cspell:disable-next-line */
                    this.form.values[this.id] = dateTimeValue.format('YYYY-MM-DDTHH:mm:ssZ');
                }
                else {
                    this.form.values[this.id] = null;
                    this._value = this.value;
                }
                break;
            case FormFieldTypes.NUMBER:
                this.form.values[this.id] = parseInt(this.value, 10);
                break;
            case FormFieldTypes.AMOUNT:
                this.form.values[this.id] = this.enableFractions ? parseFloat(this.value) : parseInt(this.value, 10);
                break;
            default:
                if (!FormFieldTypes.isReadOnlyType(this.type) && !this.isInvalidFieldType(this.type)) {
                    this.form.values[this.id] = this.value;
                }
        }
        this.form.onFormFieldChanged(this);
    }
    /**
     * Skip the invalid field type
     * @param {?} type
     * @return {?}
     */
    isInvalidFieldType(type) {
        if (type === 'container') {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @return {?}
     */
    getOptionName() {
        /** @type {?} */
        const option = this.options.find((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => opt.id === this.value));
        return option ? option.name : null;
    }
    /**
     * @return {?}
     */
    hasOptions() {
        return this.options && this.options.length > 0;
    }
    /**
     * @private
     * @param {?} json
     * @return {?}
     */
    isDateField(json) {
        return (json.params &&
            json.params.field &&
            json.params.field.type === FormFieldTypes.DATE) ||
            json.type === FormFieldTypes.DATE;
    }
    /**
     * @private
     * @param {?} json
     * @return {?}
     */
    isDateTimeField(json) {
        return (json.params &&
            json.params.field &&
            json.params.field.type === FormFieldTypes.DATETIME) ||
            json.type === FormFieldTypes.DATETIME;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormEvent {
    /**
     * @param {?} form
     */
    constructor(form) {
        this.isDefaultPrevented = false;
        this.form = form;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this.isDefaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this.isDefaultPrevented = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormFieldEvent extends FormEvent {
    /**
     * @param {?} form
     * @param {?} field
     */
    constructor(form, field) {
        super(form);
        this.field = field;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidateFormFieldEvent extends FormFieldEvent {
    /**
     * @param {?} form
     * @param {?} field
     */
    constructor(form, field) {
        super(form, field);
        this.isValid = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidateFormEvent extends FormEvent {
    /**
     * @param {?} form
     */
    constructor(form) {
        super(form);
        this.isValid = true;
        this.errorsField = [];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContainerModel extends FormWidgetModel {
    /**
     * @return {?}
     */
    get isVisible() {
        return this.field.isVisible;
    }
    /**
     * @param {?} field
     */
    constructor(field) {
        super(field.form, field.json);
        if (field) {
            this.field = field;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormOutcomeModel extends FormWidgetModel {
    /**
     * @param {?} form
     * @param {?=} json
     */
    constructor(form, json) {
        super(form, json);
        // Activiti 'Start Process' action name
        this.isSystem = false;
        this.isSelected = false;
        if (json) {
            this.isSystem = json.isSystem ? true : false;
            this.isSelected = form && json.name === form.selectedOutcome ? true : false;
        }
    }
}
FormOutcomeModel.SAVE_ACTION = 'SAVE'; // Activiti 'Save' action name
// Activiti 'Save' action name
FormOutcomeModel.COMPLETE_ACTION = 'COMPLETE'; // Activiti 'Complete' action name
// Activiti 'Complete' action name
FormOutcomeModel.START_PROCESS_ACTION = 'START PROCESS'; // Activiti 'Start Process' action name

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabModel extends FormWidgetModel {
    /**
     * @param {?} form
     * @param {?=} json
     */
    constructor(form, json) {
        super(form, json);
        this.isVisible = true;
        this.fields = [];
        if (json) {
            this.title = json.title;
            this.visibilityCondition = (/** @type {?} */ (json.visibilityCondition));
        }
    }
    /**
     * @return {?}
     */
    hasContent() {
        return this.fields && this.fields.length > 0;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FormBaseModel {
    constructor() {
        this.values = {};
        this.tabs = [];
        this.fields = [];
        this.outcomes = [];
        this.readOnly = false;
    }
    /**
     * @return {?}
     */
    hasTabs() {
        return this.tabs && this.tabs.length > 0;
    }
    /**
     * @return {?}
     */
    hasFields() {
        return this.fields && this.fields.length > 0;
    }
    /**
     * @return {?}
     */
    hasOutcomes() {
        return this.outcomes && this.outcomes.length > 0;
    }
    /**
     * @param {?} fieldId
     * @return {?}
     */
    getFieldById(fieldId) {
        return this.getFormFields().find((/**
         * @param {?} field
         * @return {?}
         */
        (field) => field.id === fieldId));
    }
    // TODO: consider evaluating and caching once the form is loaded
    /**
     * @return {?}
     */
    getFormFields() {
        /** @type {?} */
        const formFieldModel = [];
        for (let i = 0; i < this.fields.length; i++) {
            /** @type {?} */
            const field = this.fields[i];
            if (field instanceof ContainerModel) {
                /** @type {?} */
                const container = (/** @type {?} */ (field));
                formFieldModel.push(container.field);
                container.field.columns.forEach((/**
                 * @param {?} column
                 * @return {?}
                 */
                (column) => {
                    formFieldModel.push(...column.fields);
                }));
            }
        }
        return formFieldModel;
    }
}
FormBaseModel.UNSET_TASK_NAME = 'Nameless task';
FormBaseModel.SAVE_OUTCOME = '$save';
FormBaseModel.COMPLETE_OUTCOME = '$complete';
FormBaseModel.START_PROCESS_OUTCOME = '$startProcess';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormModel extends FormBaseModel {
    /**
     * @param {?=} json
     * @param {?=} formValues
     * @param {?=} readOnly
     * @param {?=} formService
     */
    constructor(json, formValues, readOnly = false, formService) {
        super();
        this.formService = formService;
        this.taskName = FormModel.UNSET_TASK_NAME;
        this._isValid = true;
        this.customFieldTemplates = {};
        this.fieldValidators = [...FORM_FIELD_VALIDATORS];
        this.readOnly = readOnly;
        if (json) {
            this.json = json;
            this.id = json.id;
            this.name = json.name;
            this.taskId = json.taskId;
            this.taskName = json.taskName || json.name || FormModel.UNSET_TASK_NAME;
            this.processDefinitionId = json.processDefinitionId;
            this.customFieldTemplates = json.customFieldTemplates || {};
            this.selectedOutcome = json.selectedOutcome || {};
            this.className = json.className || '';
            /** @type {?} */
            const tabCache = {};
            this.processVariables = json.processVariables;
            this.tabs = (json.tabs || []).map((/**
             * @param {?} t
             * @return {?}
             */
            (t) => {
                /** @type {?} */
                const model = new TabModel(this, t);
                tabCache[model.id] = model;
                return model;
            }));
            this.fields = this.parseRootFields(json);
            if (formValues) {
                this.loadData(formValues);
            }
            for (let i = 0; i < this.fields.length; i++) {
                /** @type {?} */
                const field = this.fields[i];
                if (field.tab) {
                    /** @type {?} */
                    const tab = tabCache[field.tab];
                    if (tab) {
                        tab.fields.push(field);
                    }
                }
            }
            if (json.fields) {
                /** @type {?} */
                const saveOutcome = new FormOutcomeModel(this, {
                    id: FormModel.SAVE_OUTCOME,
                    name: 'SAVE',
                    isSystem: true
                });
                /** @type {?} */
                const completeOutcome = new FormOutcomeModel(this, {
                    id: FormModel.COMPLETE_OUTCOME,
                    name: 'COMPLETE',
                    isSystem: true
                });
                /** @type {?} */
                const startProcessOutcome = new FormOutcomeModel(this, {
                    id: FormModel.START_PROCESS_OUTCOME,
                    name: 'START PROCESS',
                    isSystem: true
                });
                /** @type {?} */
                const customOutcomes = (json.outcomes || []).map((/**
                 * @param {?} obj
                 * @return {?}
                 */
                (obj) => new FormOutcomeModel(this, obj)));
                this.outcomes = [saveOutcome].concat(customOutcomes.length > 0 ? customOutcomes : [completeOutcome, startProcessOutcome]);
            }
        }
        this.validateForm();
    }
    /**
     * @return {?}
     */
    get isValid() {
        return this._isValid;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    onFormFieldChanged(field) {
        this.validateField(field);
        if (this.formService) {
            this.formService.formFieldValueChanged.next(new FormFieldEvent(this, field));
        }
    }
    /**
     * @return {?}
     */
    markAsInvalid() {
        this._isValid = false;
    }
    /**
     * Validates entire form and all form fields.
     *
     * \@memberof FormModel
     * @return {?}
     */
    validateForm() {
        /** @type {?} */
        const validateFormEvent = new ValidateFormEvent(this);
        /** @type {?} */
        const errorsField = [];
        /** @type {?} */
        const fields = this.getFormFields();
        for (let i = 0; i < fields.length; i++) {
            if (!fields[i].validate()) {
                errorsField.push(fields[i]);
            }
        }
        this._isValid = errorsField.length > 0 ? false : true;
        if (this.formService) {
            validateFormEvent.isValid = this._isValid;
            validateFormEvent.errorsField = errorsField;
            this.formService.validateForm.next(validateFormEvent);
        }
    }
    /**
     * Validates a specific form field, triggers form validation.
     *
     * \@memberof FormModel
     * @param {?} field Form field to validate.
     * @return {?}
     */
    validateField(field) {
        if (!field) {
            return;
        }
        /** @type {?} */
        const validateFieldEvent = new ValidateFormFieldEvent(this, field);
        if (this.formService) {
            this.formService.validateFormField.next(validateFieldEvent);
        }
        if (!validateFieldEvent.isValid) {
            this._isValid = false;
            return;
        }
        if (validateFieldEvent.defaultPrevented) {
            return;
        }
        if (!field.validate()) {
            this._isValid = false;
        }
        this.validateForm();
    }
    // Activiti supports 3 types of root fields: container|group|dynamic-table
    /**
     * @private
     * @param {?} json
     * @return {?}
     */
    parseRootFields(json) {
        /** @type {?} */
        let fields = [];
        if (json.fields) {
            fields = json.fields;
        }
        else if (json.formDefinition && json.formDefinition.fields) {
            fields = json.formDefinition.fields;
        }
        /** @type {?} */
        const formWidgetModel = [];
        for (const field of fields) {
            if (field.type === FormFieldTypes.DISPLAY_VALUE) {
                // workaround for dynamic table on a completed/readonly form
                if (field.params) {
                    /** @type {?} */
                    const originalField = field.params['field'];
                    if (originalField.type === FormFieldTypes.DYNAMIC_TABLE) {
                        formWidgetModel.push(new ContainerModel(new FormFieldModel(this, field)));
                    }
                }
            }
            else {
                formWidgetModel.push(new ContainerModel(new FormFieldModel(this, field)));
            }
        }
        return formWidgetModel;
    }
    // Loads external data and overrides field values
    // Typically used when form definition and form data coming from different sources
    /**
     * @private
     * @param {?} formValues
     * @return {?}
     */
    loadData(formValues) {
        for (const field of this.getFormFields()) {
            if (formValues[field.id]) {
                field.json.value = formValues[field.id];
                field.value = field.parseValue(field.json);
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class FormOutcomeEvent {
    /**
     * @param {?} outcome
     */
    constructor(outcome) {
        this._defaultPrevented = false;
        this._outcome = outcome;
    }
    /**
     * @return {?}
     */
    get outcome() {
        return this._outcome;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this._defaultPrevented = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class ContentLinkModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.contentAvailable = obj && obj.contentAvailable;
        this.created = obj && obj.created;
        this.createdBy = obj && obj.createdBy || {};
        this.id = obj && obj.id;
        this.link = obj && obj.link;
        this.mimeType = obj && obj.mimeType;
        this.name = obj && obj.name;
        this.previewStatus = obj && obj.previewStatus;
        this.relatedContent = obj && obj.relatedContent;
        this.simpleType = obj && obj.simpleType;
        this.thumbnailStatus = obj && obj.thumbnailStatus;
    }
    /**
     * @return {?}
     */
    hasPreviewStatus() {
        return this.previewStatus === 'supported' ? true : false;
    }
    /**
     * @return {?}
     */
    isTypeImage() {
        return this.simpleType === 'image' ? true : false;
    }
    /**
     * @return {?}
     */
    isTypePdf() {
        return this.simpleType === 'pdf' ? true : false;
    }
    /**
     * @return {?}
     */
    isTypeDoc() {
        return this.simpleType === 'word' || this.simpleType === 'content' ? true : false;
    }
    /**
     * @return {?}
     */
    isThumbnailReady() {
        return this.thumbnailStatus === 'created';
    }
    /**
     * @return {?}
     */
    isThumbnailSupported() {
        return this.isTypeImage() || ((this.isTypePdf() || this.isTypeDoc()) && this.isThumbnailReady());
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EcmModelService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * @param {?} formName
     * @param {?} form
     * @return {?}
     */
    createEcmTypeForActivitiForm(formName, form) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.searchActivitiEcmModel().subscribe((/**
             * @param {?} model
             * @return {?}
             */
            (model) => {
                if (!model) {
                    this.createActivitiEcmModel(formName, form).subscribe((/**
                     * @param {?} typeForm
                     * @return {?}
                     */
                    (typeForm) => {
                        observer.next(typeForm);
                        observer.complete();
                    }));
                }
                else {
                    this.saveFomType(formName, form).subscribe((/**
                     * @param {?} typeForm
                     * @return {?}
                     */
                    (typeForm) => {
                        observer.next(typeForm);
                        observer.complete();
                    }));
                }
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => this.handleError(err)));
        }));
    }
    /**
     * @return {?}
     */
    searchActivitiEcmModel() {
        return this.getEcmModels().pipe(map((/**
         * @param {?} ecmModels
         * @return {?}
         */
        function (ecmModels) {
            return ecmModels.list.entries.find((/**
             * @param {?} model
             * @return {?}
             */
            (model) => model.entry.name === EcmModelService.MODEL_NAME));
        })));
    }
    /**
     * @param {?} formName
     * @param {?} form
     * @return {?}
     */
    createActivitiEcmModel(formName, form) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.createEcmModel(EcmModelService.MODEL_NAME, EcmModelService.MODEL_NAMESPACE).subscribe((/**
             * @param {?} model
             * @return {?}
             */
            (model) => {
                this.logService.info('model created', model);
                this.activeEcmModel(EcmModelService.MODEL_NAME).subscribe((/**
                 * @param {?} modelActive
                 * @return {?}
                 */
                (modelActive) => {
                    this.logService.info('model active', modelActive);
                    this.createEcmTypeWithProperties(formName, form).subscribe((/**
                     * @param {?} typeCreated
                     * @return {?}
                     */
                    (typeCreated) => {
                        observer.next(typeCreated);
                        observer.complete();
                    }));
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => this.handleError(err)));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => this.handleError(err)));
        }));
    }
    /**
     * @param {?} formName
     * @param {?} form
     * @return {?}
     */
    saveFomType(formName, form) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.searchEcmType(formName, EcmModelService.MODEL_NAME).subscribe((/**
             * @param {?} ecmType
             * @return {?}
             */
            (ecmType) => {
                this.logService.info('custom types', ecmType);
                if (!ecmType) {
                    this.createEcmTypeWithProperties(formName, form).subscribe((/**
                     * @param {?} typeCreated
                     * @return {?}
                     */
                    (typeCreated) => {
                        observer.next(typeCreated);
                        observer.complete();
                    }));
                }
                else {
                    observer.next(ecmType);
                    observer.complete();
                }
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => this.handleError(err)));
        }));
    }
    /**
     * @param {?} formName
     * @param {?} form
     * @return {?}
     */
    createEcmTypeWithProperties(formName, form) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.createEcmType(formName, EcmModelService.MODEL_NAME, EcmModelService.TYPE_MODEL).subscribe((/**
             * @param {?} typeCreated
             * @return {?}
             */
            (typeCreated) => {
                this.logService.info('type Created', typeCreated);
                this.addPropertyToAType(EcmModelService.MODEL_NAME, formName, form).subscribe((/**
                 * @param {?} propertyAdded
                 * @return {?}
                 */
                (propertyAdded) => {
                    this.logService.info('property Added', propertyAdded);
                    observer.next(typeCreated);
                    observer.complete();
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => this.handleError(err)));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => this.handleError(err)));
        }));
    }
    /**
     * @param {?} typeName
     * @param {?} modelName
     * @return {?}
     */
    searchEcmType(typeName, modelName) {
        return this.getEcmType(modelName).pipe(map((/**
         * @param {?} customTypes
         * @return {?}
         */
        function (customTypes) {
            return customTypes.list.entries.find((/**
             * @param {?} type
             * @return {?}
             */
            (type) => type.entry.prefixedName === typeName || type.entry.title === typeName));
        })));
    }
    /**
     * @param {?} modelName
     * @return {?}
     */
    activeEcmModel(modelName) {
        return from(this.apiService.getInstance().core.customModelApi.activateCustomModel(modelName))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @param {?} modelName
     * @param {?} nameSpace
     * @return {?}
     */
    createEcmModel(modelName, nameSpace) {
        return from(this.apiService.getInstance().core.customModelApi.createCustomModel('DRAFT', '', modelName, modelName, nameSpace))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @return {?}
     */
    getEcmModels() {
        return from(this.apiService.getInstance().core.customModelApi.getAllCustomModel())
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @param {?} modelName
     * @return {?}
     */
    getEcmType(modelName) {
        return from(this.apiService.getInstance().core.customModelApi.getAllCustomType(modelName))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @param {?} typeName
     * @param {?} modelName
     * @param {?} parentType
     * @return {?}
     */
    createEcmType(typeName, modelName, parentType) {
        /** @type {?} */
        const name = this.cleanNameType(typeName);
        return from(this.apiService.getInstance().core.customModelApi.createCustomType(modelName, name, parentType, typeName, ''))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @param {?} modelName
     * @param {?} typeName
     * @param {?} formFields
     * @return {?}
     */
    addPropertyToAType(modelName, typeName, formFields) {
        /** @type {?} */
        const name = this.cleanNameType(typeName);
        /** @type {?} */
        const properties = [];
        if (formFields && formFields.values) {
            for (const key in formFields.values) {
                if (key) {
                    properties.push({
                        name: key,
                        title: key,
                        description: key,
                        dataType: 'd:text',
                        multiValued: false,
                        mandatory: false,
                        mandatoryEnforced: false
                    });
                }
            }
        }
        return from(this.apiService.getInstance().core.customModelApi.addPropertyToType(modelName, name, properties))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @param {?} name
     * @return {?}
     */
    cleanNameType(name) {
        /** @type {?} */
        let cleanName = name;
        if (name.indexOf(':') !== -1) {
            cleanName = name.split(':')[1];
        }
        return cleanName.replace(/[^a-zA-Z ]/g, '');
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    /**
     * @param {?} err
     * @return {?}
     */
    handleError(err) {
        this.logService.error(err);
    }
}
EcmModelService.MODEL_NAMESPACE = 'activitiForms';
EcmModelService.MODEL_NAME = 'activitiFormsModel';
EcmModelService.TYPE_MODEL = 'cm:folder';
EcmModelService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
EcmModelService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ EcmModelService.ngInjectableDef = defineInjectable({ factory: function EcmModelService_Factory() { return new EcmModelService(inject(AlfrescoApiService), inject(LogService)); }, token: EcmModelService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormService {
    /**
     * @param {?} ecmModelService
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(ecmModelService, apiService, logService) {
        this.ecmModelService = ecmModelService;
        this.apiService = apiService;
        this.logService = logService;
        this.formLoaded = new Subject();
        this.formDataRefreshed = new Subject();
        this.formFieldValueChanged = new Subject();
        this.formEvents = new Subject();
        this.taskCompleted = new Subject();
        this.taskCompletedError = new Subject();
        this.taskSaved = new Subject();
        this.taskSavedError = new Subject();
        this.formContentClicked = new Subject();
        this.validateForm = new Subject();
        this.validateFormField = new Subject();
        this.validateDynamicTableRow = new Subject();
        this.executeOutcome = new Subject();
    }
    /**
     * @private
     * @return {?}
     */
    get taskApi() {
        return this.apiService.getInstance().activiti.taskApi;
    }
    /**
     * @private
     * @return {?}
     */
    get modelsApi() {
        return this.apiService.getInstance().activiti.modelsApi;
    }
    /**
     * @private
     * @return {?}
     */
    get editorApi() {
        return this.apiService.getInstance().activiti.editorApi;
    }
    /**
     * @private
     * @return {?}
     */
    get processApi() {
        return this.apiService.getInstance().activiti.processApi;
    }
    /**
     * @private
     * @return {?}
     */
    get processInstanceVariablesApi() {
        return this.apiService.getInstance().activiti.processInstanceVariablesApi;
    }
    /**
     * @private
     * @return {?}
     */
    get usersWorkflowApi() {
        return this.apiService.getInstance().activiti.usersWorkflowApi;
    }
    /**
     * @private
     * @return {?}
     */
    get groupsApi() {
        return this.apiService.getInstance().activiti.groupsApi;
    }
    /**
     * Parses JSON data to create a corresponding Form model.
     * @param {?} json JSON to create the form
     * @param {?=} data Values for the form fields
     * @param {?=} readOnly Should the form fields be read-only?
     * @return {?} Form model created from input data
     */
    parseForm(json, data, readOnly = false) {
        if (json) {
            /** @type {?} */
            const form = new FormModel(json, data, readOnly, this);
            if (!json.fields) {
                form.outcomes = [
                    new FormOutcomeModel(form, {
                        id: '$save',
                        name: FormOutcomeModel.SAVE_ACTION,
                        isSystem: true
                    })
                ];
            }
            return form;
        }
        return null;
    }
    /**
     * Creates a Form with a field for each metadata property.
     * @param {?} formName Name of the new form
     * @return {?} The new form
     */
    createFormFromANode(formName) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.createForm(formName).subscribe((/**
             * @param {?} form
             * @return {?}
             */
            (form) => {
                this.ecmModelService.searchEcmType(formName, EcmModelService.MODEL_NAME).subscribe((/**
                 * @param {?} customType
                 * @return {?}
                 */
                (customType) => {
                    /** @type {?} */
                    const formDefinitionModel = new FormDefinitionModel(form.id, form.name, form.lastUpdatedByFullName, form.lastUpdated, customType.entry.properties);
                    from(this.editorApi.saveForm(form.id, formDefinitionModel)).subscribe((/**
                     * @param {?} formData
                     * @return {?}
                     */
                    (formData) => {
                        observer.next(formData);
                        observer.complete();
                    }), (/**
                     * @param {?} err
                     * @return {?}
                     */
                    (err) => this.handleError(err)));
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => this.handleError(err)));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => this.handleError(err)));
        }));
    }
    /**
     * Create a Form.
     * @param {?} formName Name of the new form
     * @return {?} The new form
     */
    createForm(formName) {
        /** @type {?} */
        const dataModel = {
            name: formName,
            description: '',
            modelType: 2,
            stencilSet: 0
        };
        return from(this.modelsApi.createModel(dataModel));
    }
    /**
     * Saves a form.
     * @param {?} formId ID of the form to save
     * @param {?} formModel Model data for the form
     * @return {?} Data for the saved form
     */
    saveForm(formId, formModel) {
        return from(this.editorApi.saveForm(formId, formModel));
    }
    /**
     * Searches for a form by name.
     * @param {?} name The form name to search for
     * @return {?} Form model(s) matching the search name
     */
    searchFrom(name) {
        /** @type {?} */
        const opts = {
            'modelType': 2
        };
        return from(this.modelsApi.getModels(opts))
            .pipe(map((/**
         * @param {?} forms
         * @return {?}
         */
        function (forms) {
            return forms.data.find((/**
             * @param {?} formData
             * @return {?}
             */
            (formData) => formData.name === name));
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets all the forms.
     * @return {?} List of form models
     */
    getForms() {
        /** @type {?} */
        const opts = {
            'modelType': 2
        };
        return from(this.modelsApi.getModels(opts))
            .pipe(map(this.toJsonArray), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets process definitions.
     * @return {?} List of process definitions
     */
    getProcessDefinitions() {
        return from(this.processApi.getProcessDefinitions({}))
            .pipe(map(this.toJsonArray), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets instance variables for a process.
     * @param {?} processInstanceId ID of the target process
     * @return {?} List of instance variable information
     */
    getProcessVariablesById(processInstanceId) {
        return from(this.processInstanceVariablesApi.getProcessInstanceVariables(processInstanceId))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets all the tasks.
     * @return {?} List of tasks
     */
    getTasks() {
        return from(this.taskApi.listTasks({}))
            .pipe(map(this.toJsonArray), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a task.
     * @param {?} taskId Task Id
     * @return {?} Task info
     */
    getTask(taskId) {
        return from(this.taskApi.getTask(taskId))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Saves a task form.
     * @param {?} taskId Task Id
     * @param {?} formValues Form Values
     * @return {?} Null response when the operation is complete
     */
    saveTaskForm(taskId, formValues) {
        /** @type {?} */
        const saveFormRepresentation = (/** @type {?} */ ({ values: formValues }));
        return from(this.taskApi.saveTaskForm(taskId, saveFormRepresentation))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Completes a Task Form.
     * @param {?} taskId Task Id
     * @param {?} formValues Form Values
     * @param {?=} outcome Form Outcome
     * @return {?} Null response when the operation is complete
     */
    completeTaskForm(taskId, formValues, outcome) {
        /** @type {?} */
        const completeFormRepresentation = (/** @type {?} */ ({ values: formValues }));
        if (outcome) {
            completeFormRepresentation.outcome = outcome;
        }
        return from(this.taskApi.completeTaskForm(taskId, completeFormRepresentation))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a form related to a task.
     * @param {?} taskId ID of the target task
     * @return {?} Form definition
     */
    getTaskForm(taskId) {
        return from(this.taskApi.getTaskForm(taskId))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a form definition.
     * @param {?} formId ID of the target form
     * @return {?} Form definition
     */
    getFormDefinitionById(formId) {
        return from(this.editorApi.getForm(formId))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the form definition with a given name.
     * @param {?} name The form name
     * @return {?} Form definition
     */
    getFormDefinitionByName(name) {
        /** @type {?} */
        const opts = {
            'filter': 'myReusableForms',
            'filterText': name,
            'modelType': 2
        };
        return from(this.modelsApi.getModels(opts))
            .pipe(map(this.getFormId), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the start form instance for a given process.
     * @param {?} processId Process definition ID
     * @return {?} Form definition
     */
    getStartFormInstance(processId) {
        return from(this.processApi.getProcessInstanceStartForm(processId))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a process instance.
     * @param {?} processId ID of the process to get
     * @return {?} Process instance
     */
    getProcessInstance(processId) {
        return from(this.processApi.getProcessInstance(processId))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the start form definition for a given process.
     * @param {?} processId Process definition ID
     * @return {?} Form definition
     */
    getStartFormDefinition(processId) {
        return from(this.processApi.getProcessDefinitionStartForm(processId))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets values of fields populated by a REST backend.
     * @param {?} taskId Task identifier
     * @param {?} field Field identifier
     * @return {?} Field values
     */
    getRestFieldValues(taskId, field) {
        return from(this.taskApi.getRestFieldValues(taskId, field))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets values of fields populated by a REST backend using a process ID.
     * @param {?} processDefinitionId Process identifier
     * @param {?} field Field identifier
     * @return {?} Field values
     */
    getRestFieldValuesByProcessId(processDefinitionId, field) {
        return from(this.processApi.getRestFieldValues(processDefinitionId, field))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets column values of fields populated by a REST backend using a process ID.
     * @param {?} processDefinitionId Process identifier
     * @param {?} field Field identifier
     * @param {?=} column Column identifier
     * @return {?} Field values
     */
    getRestFieldValuesColumnByProcessId(processDefinitionId, field, column) {
        return from(this.processApi.getRestTableFieldValues(processDefinitionId, field, column))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets column values of fields populated by a REST backend.
     * @param {?} taskId Task identifier
     * @param {?} field Field identifier
     * @param {?=} column Column identifier
     * @return {?} Field values
     */
    getRestFieldValuesColumn(taskId, field, column) {
        return from(this.taskApi.getRestFieldValuesColumn(taskId, field, column))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Returns a URL for the profile picture of a user.
     * @param {?} userId ID of the target user
     * @return {?} URL string
     */
    getUserProfileImageApi(userId) {
        return this.apiService.getInstance().activiti.userApi.getUserProfilePictureUrl(userId);
    }
    /**
     * Gets a list of workflow users.
     * @param {?} filter Filter to select specific users
     * @param {?=} groupId Group ID for the search
     * @return {?} Array of users
     */
    getWorkflowUsers(filter$$1, groupId) {
        /** @type {?} */
        const option = { filter: filter$$1 };
        if (groupId) {
            option.groupId = groupId;
        }
        return from(this.usersWorkflowApi.getUsers(option))
            .pipe(switchMap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => (/** @type {?} */ (response.data)) || [])), map((/**
         * @param {?} user
         * @return {?}
         */
        (user) => {
            user.userImage = this.getUserProfileImageApi(user.id);
            return of(user);
        })), combineAll(), defaultIfEmpty([]), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a list of groups in a workflow.
     * @param {?} filter Filter to select specific groups
     * @param {?=} groupId Group ID for the search
     * @return {?} Array of groups
     */
    getWorkflowGroups(filter$$1, groupId) {
        /** @type {?} */
        const option = { filter: filter$$1 };
        if (groupId) {
            option.groupId = groupId;
        }
        return from(this.groupsApi.getGroups(option))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => (/** @type {?} */ (response.data)) || [])), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the ID of a form.
     * @param {?} form Object representing a form
     * @return {?} ID string
     */
    getFormId(form) {
        /** @type {?} */
        let result = null;
        if (form && form.data && form.data.length > 0) {
            result = form.data[0].id;
        }
        return result;
    }
    /**
     * Creates a JSON representation of form data.
     * @param {?} res Object representing form data
     * @return {?} JSON data
     */
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    /**
     * Creates a JSON array representation of form data.
     * @param {?} res Object representing form data
     * @return {?} JSON data
     */
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    /**
     * Reports an error message.
     * @param {?} error Data object with optional `message` and `status` fields for the error
     * @return {?} Error message
     */
    handleError(error) {
        /** @type {?} */
        let errMsg = FormService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : FormService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return throwError(errMsg);
    }
}
FormService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
FormService.GENERIC_ERROR_MESSAGE = 'Server error';
FormService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FormService.ctorParameters = () => [
    { type: EcmModelService },
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ FormService.ngInjectableDef = defineInjectable({ factory: function FormService_Factory() { return new FormService(inject(EcmModelService), inject(AlfrescoApiService), inject(LogService)); }, token: FormService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const baseHost = {
    '(click)': 'event($event)',
    '(blur)': 'event($event)',
    '(change)': 'event($event)',
    '(focus)': 'event($event)',
    '(focusin)': 'event($event)',
    '(focusout)': 'event($event)',
    '(input)': 'event($event)',
    '(invalid)': 'event($event)',
    '(select)': 'event($event)'
};
/**
 * Base widget component.
 */
class WidgetComponent {
    /**
     * @param {?=} formService
     */
    constructor(formService) {
        this.formService = formService;
        /**
         * Does the widget show a read-only value? (ie, can't be edited)
         */
        this.readOnly = false;
        /**
         * Emitted when a field value changes.
         */
        this.fieldChanged = new EventEmitter();
    }
    /**
     * @return {?}
     */
    hasField() {
        return this.field ? true : false;
    }
    // Note for developers:
    // returns <any> object to be able binding it to the <element required="required"> attribute
    /**
     * @return {?}
     */
    isRequired() {
        if (this.field && this.field.required) {
            return true;
        }
        return null;
    }
    /**
     * @return {?}
     */
    isValid() {
        return this.field.validationSummary ? true : false;
    }
    /**
     * @return {?}
     */
    hasValue() {
        return this.field &&
            this.field.value !== null &&
            this.field.value !== undefined;
    }
    /**
     * @return {?}
     */
    isInvalidFieldRequired() {
        return !this.field.isValid && !this.field.validationSummary && this.isRequired();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.fieldChanged.emit(this.field);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    checkVisibility(field) {
        this.fieldChanged.emit(field);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    onFieldChanged(field) {
        this.fieldChanged.emit(field);
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    getHyperlinkUrl(field) {
        /** @type {?} */
        let url = WidgetComponent.DEFAULT_HYPERLINK_URL;
        if (field && field.hyperlinkUrl) {
            url = field.hyperlinkUrl;
            if (!/^https?:\/\//i.test(url)) {
                url = `${WidgetComponent.DEFAULT_HYPERLINK_SCHEME}${url}`;
            }
        }
        return url;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    getHyperlinkText(field) {
        if (field) {
            return field.displayText || field.hyperlinkUrl;
        }
        return null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    event(event) {
        this.formService.formEvents.next(event);
    }
}
WidgetComponent.DEFAULT_HYPERLINK_URL = '#';
WidgetComponent.DEFAULT_HYPERLINK_SCHEME = 'http://';
WidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'base-widget',
                template: '',
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
WidgetComponent.ctorParameters = () => [
    { type: FormService }
];
WidgetComponent.propDecorators = {
    readOnly: [{ type: Input }],
    field: [{ type: Input }],
    fieldChanged: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContainerWidgetComponentModel extends ContainerModel {
    /**
     * @param {?} field
     */
    constructor(field) {
        super(field);
        this.columns = [];
        this.isExpanded = true;
        this.rowspan = 1;
        this.colspan = 1;
        if (this.field) {
            this.columns = this.field.columns || [];
            this.isExpanded = !this.isCollapsedByDefault();
            this.colspan = field.colspan;
            this.rowspan = field.rowspan;
        }
    }
    /**
     * @return {?}
     */
    isGroup() {
        return this.type === FormFieldTypes.GROUP;
    }
    /**
     * @return {?}
     */
    isCollapsible() {
        /** @type {?} */
        let allowCollapse = false;
        if (this.isGroup() && this.field.params['allowCollapse']) {
            allowCollapse = (/** @type {?} */ (this.field.params['allowCollapse']));
        }
        return allowCollapse;
    }
    /**
     * @return {?}
     */
    isCollapsedByDefault() {
        /** @type {?} */
        let collapseByDefault = false;
        if (this.isCollapsible() && this.field.params['collapseByDefault']) {
            collapseByDefault = (/** @type {?} */ (this.field.params['collapseByDefault']));
        }
        return collapseByDefault;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContainerWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
    /**
     * @return {?}
     */
    onExpanderClicked() {
        if (this.content && this.content.isCollapsible()) {
            this.content.isExpanded = !this.content.isExpanded;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            this.content = new ContainerWidgetComponentModel(this.field);
        }
    }
    /**
     * Serializes column fields
     * @return {?}
     */
    get fields() {
        /** @type {?} */
        const fields = [];
        /** @type {?} */
        let rowContainsElement = true;
        /** @type {?} */
        let rowIndex = 0;
        while (rowContainsElement) {
            rowContainsElement = false;
            for (let i = 0; i < this.content.columns.length; i++) {
                /** @type {?} */
                const field = this.content.columns[i].fields[rowIndex];
                if (field) {
                    rowContainsElement = true;
                }
                fields.push(field);
            }
            rowIndex++;
        }
        return fields;
    }
    /**
     * Calculate the column width based on the numberOfColumns and current field's colspan property
     *
     * @param {?} field
     * @return {?}
     */
    getColumnWith(field) {
        /** @type {?} */
        const colspan = field ? field.colspan : 1;
        return (100 / this.content.json.numberOfColumns) * colspan + '%';
    }
}
ContainerWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'container-widget',
                template: "<div [hidden]=\"!content?.isGroup()\" class=\"adf-container-widget__header\">\n    <h4 class=\"adf-container-widget__header-text\" id=\"container-header\"\n        [class.adf-collapsible]=\"content?.isCollapsible()\">\n        <button *ngIf=\"content?.isCollapsible()\"\n                mat-icon-button\n                class=\"mdl-button--icon\"\n                (click)=\"onExpanderClicked()\">\n            <mat-icon>{{ content?.isExpanded ? 'expand_more' : 'expand_less' }}</mat-icon>\n        </button>\n        <span (click)=\"onExpanderClicked()\" id=\"container-header-label\">{{content.name}}</span>\n    </h4>\n</div>\n\n<section class=\"adf-grid-list\" *ngIf=\"content?.isExpanded\">\n    <div class=\"adf-grid-list-item\" *ngFor=\"let field of fields\" [style.width]=\"getColumnWith(field)\">\n        <adf-form-field *ngIf=\"field\" [field]=\"field\"></adf-form-field>\n    </div>\n</section>\n\n\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
ContainerWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabsWidgetComponent {
    constructor() {
        this.tabs = [];
        this.formTabChanged = new EventEmitter();
        this.visibleTabs = [];
    }
    /**
     * @return {?}
     */
    hasTabs() {
        return this.tabs && this.tabs.length > 0;
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.filterVisibleTabs();
    }
    /**
     * @return {?}
     */
    filterVisibleTabs() {
        this.visibleTabs = this.tabs.filter((/**
         * @param {?} tab
         * @return {?}
         */
        (tab) => {
            return tab.isVisible;
        }));
    }
    /**
     * @param {?} field
     * @return {?}
     */
    tabChanged(field) {
        this.formTabChanged.emit(field);
    }
}
TabsWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'tabs-widget',
                template: "<div *ngIf=\"hasTabs()\" class=\"alfresco-tabs-widget\">\n    <mat-tab-group>\n        <mat-tab *ngFor=\"let tab of visibleTabs\" [label]=\"tab.title\">\n            <div *ngFor=\"let field of tab.fields\">\n                <adf-form-field [field]=\"field.field\"></adf-form-field>\n             </div>\n        </mat-tab>\n    </mat-tab-group>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
TabsWidgetComponent.propDecorators = {
    tabs: [{ type: Input }],
    formTabChanged: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UnknownWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
UnknownWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'unknown-widget',
                template: `
            <mat-list class="adf-unknown-widget">
                <mat-list-item>
                     <mat-icon class="mat-24">error_outline</mat-icon>
                     <span class="adf-unknown-text">Unknown type: {{field.type}}</span>
                </mat-list-item>
            </mat-list>

    `,
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-unknown-text{margin-left:10px;color:red}.adf-unknown-widget{margin:42px}"]
            }] }
];
/** @nocollapse */
UnknownWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmountWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.currency = AmountWidgetComponent.DEFAULT_CURRENCY;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field && this.field.currency) {
            this.currency = this.field.currency;
        }
    }
}
AmountWidgetComponent.DEFAULT_CURRENCY = '$';
AmountWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'amount-widget',
                template: "<div class=\"adf-amount-widget__container adf-amount-widget {{field.className}}\" [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <mat-form-field class=\"adf-amount-widget__input\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n        <span matPrefix class=\"adf-amount-widget__prefix-spacing\"> {{currency }}</span>\n        <input matInput\n                class=\"adf-amount-widget\"\n                type=\"text\"\n                [id]=\"field.id\"\n                [required]=\"isRequired()\"\n                [placeholder]=\"field.placeholder\"\n                [value]=\"field.value\"\n                [(ngModel)]=\"field.value\"\n                (ngModelChange)=\"onFieldChanged(field)\"\n                [disabled]=\"field.readOnly\">\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\" ></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-amount-widget{width:100%;vertical-align:baseline!important}.adf-amount-widget .mat-input-placeholder{margin-top:5px;display:none}.adf-amount-widget .mat-form-field-flex{position:relative;padding-top:18.5px}.adf-amount-widget .mat-form-field-infix{position:static;padding-top:19px}.adf-amount-widget .adf-label{position:absolute;top:18.5px;left:0}.adf-amount-widget__container{max-width:100%}.adf-amount-widget__container .mat-form-field-label-wrapper{top:34px!important;left:13px}.adf-amount-widget__input .mat-focused{transition:none}.adf-amount-widget__prefix-spacing{padding-right:5px}"]
            }] }
];
/** @nocollapse */
AmountWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
CheckboxWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'checkbox-widget',
                template: "<div [ngClass]=\"field.className\">\n    <mat-checkbox\n        [id]=\"field.id\"\n        color=\"primary\"\n        [required]=\"field.required\"\n        [disabled]=\"field.readOnly || readOnly\"\n        [(ngModel)]=\"field.value\"\n        (ngModelChange)=\"onFieldChanged(field)\">\n        {{field.name}}\n        <span *ngIf=\"field.required\">*</span>\n    </mat-checkbox>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CheckboxWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$1 = MOMENT_DATE_FORMATS;
class DateWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(formService, dateAdapter, userPreferencesService) {
        super(formService);
        this.formService = formService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            this.dateAdapter.setLocale(locale);
        }));
        /** @type {?} */
        const momentDateAdapter = (/** @type {?} */ (this.dateAdapter));
        momentDateAdapter.overrideDisplayFormat = this.field.dateDisplayFormat;
        if (this.field) {
            if (this.field.minValue) {
                this.minDate = moment(this.field.minValue, 'DD/MM/YYYY');
            }
            if (this.field.maxValue) {
                this.maxDate = moment(this.field.maxValue, 'DD/MM/YYYY');
            }
        }
        this.displayDate = moment(this.field.value, this.field.dateDisplayFormat);
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            this.field.value = newDateValue.value.format(this.field.dateDisplayFormat);
        }
        else if (newDateValue) {
            this.field.value = newDateValue;
        }
        else {
            this.field.value = null;
        }
        this.onFieldChanged(this.field);
    }
}
DateWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'date-widget',
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$1 }
                ],
                template: "<div class=\"{{field.className}}\" id=\"data-widget\" [class.adf-invalid]=\"!field.isValid\">\n    <mat-form-field class=\"adf-date-widget\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}} ({{field.dateDisplayFormat}})<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               [id]=\"field.id\"\n               [matDatepicker]=\"datePicker\"\n               [(ngModel)]=\"displayDate\"\n               [required]=\"isRequired()\"\n               [disabled]=\"field.readOnly\"\n               [min]=\"minDate\"\n               [max]=\"maxDate\"\n               (focusout)=\"onDateChanged($event.srcElement.value)\"\n               (dateChange)=\"onDateChanged($event)\"\n               placeholder=\"{{field.placeholder}}\">\n        <mat-datepicker-toggle  matSuffix [for]=\"datePicker\" [disabled]=\"field.readOnly\" ></mat-datepicker-toggle>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n    <mat-datepicker #datePicker [touchUi]=\"true\" [startAt]=\"displayDate\" ></mat-datepicker>\n</div>\n\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-date-widget .mat-form-field-suffix{text-align:right;position:absolute;margin-top:30px;width:100%}.adf-date-widget-date-widget-button{position:relative;float:right}.adf-date-widget-date-input{padding-top:5px;padding-bottom:5px}.adf-date-widget-grid-date-widget{align-items:center;padding:0}.adf-date-widget-date-widget-button__cell{margin-top:0;margin-bottom:0}@media screen and (-ms-high-contrast:active),screen and (-ms-high-contrast:none){.adf-date-widget .mat-form-field-suffix{position:relative;width:auto}}"]
            }] }
];
/** @nocollapse */
DateWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: DateAdapter },
    { type: UserPreferencesService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DisplayTextWidgetComponentComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
DisplayTextWidgetComponentComponent.decorators = [
    { type: Component, args: [{
                selector: 'display-text-widget',
                template: "<div class=\"adf-display-text-widget {{field.className}}\">{{field.value}}</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-display-text-widget{white-space:pre-wrap}"]
            }] }
];
/** @nocollapse */
DisplayTextWidgetComponentComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DocumentWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.fileId = null;
        this.hasFile = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            /** @type {?} */
            const file = this.field.value;
            if (file) {
                this.fileId = file.id;
                this.hasFile = true;
            }
            else {
                this.fileId = null;
                this.hasFile = false;
            }
        }
    }
}
DocumentWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-document-widget',
                template: "<div class=\"adf-form-document-widget {{field.className}}\">\n    <ng-container *ngIf=\"hasFile\">\n        <adf-content [id]=\"fileId\" [showDocumentContent]=\"true\"></adf-content>\n    </ng-container>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
DocumentWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DropdownWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} logService
     */
    constructor(formService, logService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field && this.field.restUrl) {
            if (this.field.form.taskId) {
                this.getValuesByTaskId();
            }
            else {
                this.getValuesByProcessDefinitionId();
            }
        }
    }
    /**
     * @return {?}
     */
    getValuesByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((/**
         * @param {?} formFieldOption
         * @return {?}
         */
        (formFieldOption) => {
            /** @type {?} */
            const options = [];
            if (this.field.emptyOption) {
                options.push(this.field.emptyOption);
            }
            this.field.options = options.concat((formFieldOption || []));
            this.field.updateForm();
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
    }
    /**
     * @return {?}
     */
    getValuesByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((/**
         * @param {?} formFieldOption
         * @return {?}
         */
        (formFieldOption) => {
            /** @type {?} */
            const options = [];
            if (this.field.emptyOption) {
                options.push(this.field.emptyOption);
            }
            this.field.options = options.concat((formFieldOption || []));
            this.field.updateForm();
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
    }
    /**
     * @param {?} option
     * @param {?} fieldValue
     * @return {?}
     */
    getOptionValue(option, fieldValue) {
        /** @type {?} */
        let optionValue = '';
        if (option.id === 'empty' || option.name !== fieldValue) {
            optionValue = option.id;
        }
        else {
            optionValue = option.name;
        }
        return optionValue;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
    }
    /**
     * @return {?}
     */
    isReadOnlyType() {
        return this.field.type === 'readonly' ? true : false;
    }
}
DropdownWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'dropdown-widget',
                template: "<div class=\"adf-dropdown-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n    <mat-form-field>\n        <mat-select class=\"adf-select\"\n                    [id]=\"field.id\"\n                    [(ngModel)]=\"field.value\"\n                    [disabled]=\"field.readOnly\"\n                    (ngModelChange)=\"onFieldChanged(field)\">\n            <mat-option *ngFor=\"let opt of field.options\"\n                        [value]=\"getOptionValue(opt, field.value)\"\n                        [id]=\"opt.id\">{{opt.name}}\n            </mat-option>\n            <mat-option id=\"readonlyOption\" *ngIf=\"isReadOnlyType()\" [value]=\"field.value\">{{field.value}}</mat-option>\n        </mat-select>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget class=\"adf-dropdown-required-message\" *ngIf=\"isInvalidFieldRequired()\"\n                  required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-dropdown-widget{width:100%;margin-top:13px}.adf-dropdown-widget .adf-select{padding-top:0!important;width:100%}.adf-dropdown-widget .mat-select-value-text{font-size:14px}.adf-dropdown-widget-select{width:100%}.adf-dropdown-widget-dropdown-required-message .adf-error-text-container{margin-top:1px!important}"]
            }] }
];
/** @nocollapse */
DropdownWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WidgetVisibilityService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * @param {?} form
     * @return {?}
     */
    refreshVisibility(form) {
        if (form && form.tabs && form.tabs.length > 0) {
            form.tabs.map((/**
             * @param {?} tabModel
             * @return {?}
             */
            (tabModel) => this.refreshEntityVisibility(tabModel)));
        }
        if (form) {
            form.getFormFields().map((/**
             * @param {?} field
             * @return {?}
             */
            (field) => this.refreshEntityVisibility(field)));
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    refreshEntityVisibility(element) {
        /** @type {?} */
        const visible = this.evaluateVisibility(element.form, element.visibilityCondition);
        element.isVisible = visible;
    }
    /**
     * @param {?} form
     * @param {?} visibilityObj
     * @return {?}
     */
    evaluateVisibility(form, visibilityObj) {
        /** @type {?} */
        const isLeftFieldPresent = visibilityObj && (visibilityObj.leftFormFieldId || visibilityObj.leftRestResponseId);
        if (!isLeftFieldPresent || isLeftFieldPresent === 'null') {
            return true;
        }
        else {
            return this.isFieldVisible(form, visibilityObj);
        }
    }
    /**
     * @param {?} form
     * @param {?} visibilityObj
     * @return {?}
     */
    isFieldVisible(form, visibilityObj) {
        /** @type {?} */
        const leftValue = this.getLeftValue(form, visibilityObj);
        /** @type {?} */
        const rightValue = this.getRightValue(form, visibilityObj);
        /** @type {?} */
        const actualResult = this.evaluateCondition(leftValue, rightValue, visibilityObj.operator);
        if (visibilityObj.nextCondition) {
            return this.evaluateLogicalOperation(visibilityObj.nextConditionOperator, actualResult, this.isFieldVisible(form, visibilityObj.nextCondition));
        }
        else {
            return actualResult;
        }
    }
    /**
     * @param {?} form
     * @param {?} visibilityObj
     * @return {?}
     */
    getLeftValue(form, visibilityObj) {
        /** @type {?} */
        let leftValue = '';
        if (visibilityObj.leftRestResponseId && visibilityObj.leftRestResponseId !== 'null') {
            leftValue = this.getVariableValue(form, visibilityObj.leftRestResponseId, this.processVarList);
        }
        else if (visibilityObj.leftFormFieldId) {
            leftValue = this.getFormValue(form, visibilityObj.leftFormFieldId);
            leftValue = leftValue ? leftValue : this.getVariableValue(form, visibilityObj.leftFormFieldId, this.processVarList);
        }
        return leftValue;
    }
    /**
     * @param {?} form
     * @param {?} visibilityObj
     * @return {?}
     */
    getRightValue(form, visibilityObj) {
        /** @type {?} */
        let valueFound = '';
        if (visibilityObj.rightRestResponseId) {
            valueFound = this.getVariableValue(form, visibilityObj.rightRestResponseId, this.processVarList);
        }
        else if (visibilityObj.rightFormFieldId) {
            valueFound = this.getFormValue(form, visibilityObj.rightFormFieldId);
        }
        else {
            if (moment(visibilityObj.rightValue, 'YYYY-MM-DD', true).isValid()) {
                valueFound = visibilityObj.rightValue + 'T00:00:00.000Z';
            }
            else {
                valueFound = visibilityObj.rightValue;
            }
        }
        return valueFound;
    }
    /**
     * @param {?} form
     * @param {?} fieldId
     * @return {?}
     */
    getFormValue(form, fieldId) {
        /** @type {?} */
        let value = this.getFieldValue(form.values, fieldId);
        if (!value) {
            value = this.searchValueInForm(form, fieldId);
        }
        return value;
    }
    /**
     * @param {?} valueList
     * @param {?} fieldId
     * @return {?}
     */
    getFieldValue(valueList, fieldId) {
        /** @type {?} */
        let dropDownFilterByName;
        /** @type {?} */
        let valueFound;
        if (fieldId && fieldId.indexOf('_LABEL') > 0) {
            dropDownFilterByName = fieldId.substring(0, fieldId.length - 6);
            if (valueList[dropDownFilterByName]) {
                valueFound = valueList[dropDownFilterByName].name;
            }
        }
        else if (valueList[fieldId] && valueList[fieldId].id) {
            valueFound = valueList[fieldId].id;
        }
        else {
            valueFound = valueList[fieldId];
        }
        return valueFound;
    }
    /**
     * @param {?} form
     * @param {?} fieldId
     * @return {?}
     */
    searchValueInForm(form, fieldId) {
        /** @type {?} */
        let fieldValue = '';
        form.getFormFields().forEach((/**
         * @param {?} formField
         * @return {?}
         */
        (formField) => {
            if (this.isSearchedField(formField, fieldId)) {
                fieldValue = this.getObjectValue(formField, fieldId);
                if (!fieldValue) {
                    if (formField.value && formField.value.id) {
                        fieldValue = formField.value.id;
                    }
                    else {
                        fieldValue = formField.value;
                    }
                }
            }
        }));
        return fieldValue;
    }
    /**
     * @private
     * @param {?} field
     * @param {?} fieldId
     * @return {?}
     */
    getObjectValue(field, fieldId) {
        /** @type {?} */
        let value = '';
        if (field.value && field.value.name) {
            value = field.value.name;
        }
        else if (field.options) {
            /** @type {?} */
            const option = field.options.find((/**
             * @param {?} opt
             * @return {?}
             */
            (opt) => opt.id === field.value));
            if (option) {
                value = this.getValueFromOption(fieldId, option);
            }
        }
        return value;
    }
    /**
     * @private
     * @param {?} fieldId
     * @param {?} option
     * @return {?}
     */
    getValueFromOption(fieldId, option) {
        /** @type {?} */
        let optionValue = '';
        if (fieldId && fieldId.indexOf('_LABEL') > 0) {
            optionValue = option.name;
        }
        else {
            optionValue = option.id;
        }
        return optionValue;
    }
    /**
     * @private
     * @param {?} field
     * @param {?} fieldToFind
     * @return {?}
     */
    isSearchedField(field, fieldToFind) {
        /** @type {?} */
        const formattedFieldName = this.removeLabel(field, fieldToFind);
        return field.id ? field.id.toUpperCase() === formattedFieldName.toUpperCase() : false;
    }
    /**
     * @private
     * @param {?} field
     * @param {?} fieldToFind
     * @return {?}
     */
    removeLabel(field, fieldToFind) {
        /** @type {?} */
        let formattedFieldName = fieldToFind || '';
        if (field.fieldType === 'RestFieldRepresentation' && fieldToFind.indexOf('_LABEL') > 0) {
            formattedFieldName = fieldToFind.substring(0, fieldToFind.length - 6);
        }
        return formattedFieldName;
    }
    /**
     * @param {?} form
     * @param {?} name
     * @param {?} processVarList
     * @return {?}
     */
    getVariableValue(form, name, processVarList) {
        return this.getFormVariableValue(form, name) ||
            this.getProcessVariableValue(name, processVarList);
    }
    /**
     * @private
     * @param {?} form
     * @param {?} name
     * @return {?}
     */
    getFormVariableValue(form, name) {
        if (form.json.variables) {
            /** @type {?} */
            const formVariable = form.json.variables.find((/**
             * @param {?} formVar
             * @return {?}
             */
            (formVar) => formVar.name === name));
            return formVariable ? formVariable.value : formVariable;
        }
    }
    /**
     * @private
     * @param {?} name
     * @param {?} processVarList
     * @return {?}
     */
    getProcessVariableValue(name, processVarList) {
        if (this.processVarList) {
            /** @type {?} */
            const processVariable = this.processVarList.find((/**
             * @param {?} variable
             * @return {?}
             */
            (variable) => variable.id === name));
            return processVariable ? processVariable.value : processVariable;
        }
    }
    /**
     * @param {?} logicOp
     * @param {?} previousValue
     * @param {?} newValue
     * @return {?}
     */
    evaluateLogicalOperation(logicOp, previousValue, newValue) {
        switch (logicOp) {
            case 'and':
                return previousValue && newValue;
            case 'or':
                return previousValue || newValue;
            case 'and-not':
                return previousValue && !newValue;
            case 'or-not':
                return previousValue || !newValue;
            default:
                this.logService.error('NO valid operation! wrong op request : ' + logicOp);
                break;
        }
    }
    /**
     * @param {?} leftValue
     * @param {?} rightValue
     * @param {?} operator
     * @return {?}
     */
    evaluateCondition(leftValue, rightValue, operator) {
        switch (operator) {
            case '==':
                return leftValue + '' === rightValue + '';
            case '<':
                return leftValue < rightValue;
            case '!=':
                return leftValue + '' !== rightValue + '';
            case '>':
                return leftValue > rightValue;
            case '>=':
                return leftValue >= rightValue;
            case '<=':
                return leftValue <= rightValue;
            case 'empty':
                return leftValue ? leftValue === '' : true;
            case '!empty':
                return leftValue ? leftValue !== '' : false;
            default:
                this.logService.error('NO valid operation!');
                break;
        }
        return;
    }
    /**
     * @return {?}
     */
    cleanProcessVariable() {
        this.processVarList = [];
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getTaskProcessVariable(taskId) {
        return from(this.apiService.getInstance().activiti.taskFormsApi.getTaskFormVariables(taskId))
            .pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            /** @type {?} */
            const jsonRes = this.toJson(res);
            this.processVarList = (/** @type {?} */ (jsonRes));
            return jsonRes;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJson(res) {
        return res || {};
    }
    /**
     * @private
     * @param {?} err
     * @return {?}
     */
    handleError(err) {
        this.logService.error('Error while performing a call');
        return throwError('Error while performing a call - Server error');
    }
}
WidgetVisibilityService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
WidgetVisibilityService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ WidgetVisibilityService.ngInjectableDef = defineInjectable({ factory: function WidgetVisibilityService_Factory() { return new WidgetVisibilityService(inject(AlfrescoApiService), inject(LogService)); }, token: WidgetVisibilityService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidateDynamicTableRowEvent extends FormFieldEvent {
    /**
     * @param {?} form
     * @param {?} field
     * @param {?} row
     * @param {?} summary
     */
    constructor(form, field, row, summary) {
        super(form, field);
        this.row = row;
        this.summary = summary;
        this.isValid = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateCellValidator {
    constructor() {
        this.supportedTypes = [
            'Date'
        ];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isSupported(column) {
        return column && column.editable && this.supportedTypes.indexOf(column.type) > -1;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?=} summary
     * @return {?}
     */
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            /** @type {?} */
            const value = row.value[column.id];
            /** @type {?} */
            const dateValue = moment(value, 'D-M-YYYY');
            if (!dateValue.isValid()) {
                if (summary) {
                    summary.isValid = false;
                    summary.message = `Invalid '${column.name}' format.`;
                }
                return false;
            }
        }
        return true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicRowValidationSummary extends ErrorMessageModel {
    /**
     * @param {?=} json
     */
    constructor(json) {
        super(json);
        this.isValid = json.isValid;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class NumberCellValidator {
    constructor() {
        this.supportedTypes = [
            'Number',
            'Amount'
        ];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isSupported(column) {
        return column && column.required && this.supportedTypes.indexOf(column.type) > -1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isNumber(value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        return !isNaN(+value);
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?=} summary
     * @return {?}
     */
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            /** @type {?} */
            const value = row.value[column.id];
            if (value === null ||
                value === undefined ||
                value === '' ||
                this.isNumber(value)) {
                return true;
            }
            if (summary) {
                summary.isValid = false;
                summary.message = `Field '${column.name}' must be a number.`;
            }
            return false;
        }
        return true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
class RequiredCellValidator {
    constructor() {
        this.supportedTypes = [
            'String',
            'Number',
            'Amount',
            'Date',
            'Dropdown'
        ];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isSupported(column) {
        return column && column.required && this.supportedTypes.indexOf(column.type) > -1;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?=} summary
     * @return {?}
     */
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            /** @type {?} */
            const value = row.value[column.id];
            if (column.required) {
                if (value === null || value === undefined || value === '') {
                    if (summary) {
                        summary.isValid = false;
                        summary.message = `Field '${column.name}' is required.`;
                    }
                    return false;
                }
            }
        }
        return true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicTableModel extends FormWidgetModel {
    /**
     * @param {?} field
     * @param {?} formService
     */
    constructor(field, formService) {
        super(field.form, field.json);
        this.formService = formService;
        this.columns = [];
        this.visibleColumns = [];
        this.rows = [];
        this._validators = [];
        this.field = field;
        if (field.json) {
            /** @type {?} */
            const columns = this.getColumns(field);
            if (columns) {
                this.columns = columns;
                this.visibleColumns = this.columns.filter((/**
                 * @param {?} col
                 * @return {?}
                 */
                (col) => col.visible));
            }
            if (field.json.value) {
                this.rows = field.json.value.map((/**
                 * @param {?} obj
                 * @return {?}
                 */
                (obj) => (/** @type {?} */ ({ selected: false, value: obj }))));
            }
        }
        this._validators = [
            new RequiredCellValidator(),
            new DateCellValidator(),
            new NumberCellValidator()
        ];
    }
    /**
     * @return {?}
     */
    get selectedRow() {
        return this._selectedRow;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedRow(value) {
        if (this._selectedRow && this._selectedRow === value) {
            this._selectedRow.selected = false;
            this._selectedRow = null;
            return;
        }
        this.rows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        (row) => row.selected = false));
        this._selectedRow = value;
        if (value) {
            this._selectedRow.selected = true;
        }
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    getColumns(field) {
        if (field && field.json) {
            /** @type {?} */
            let definitions = field.json.columnDefinitions;
            if (!definitions && field.json.params && field.json.params.field) {
                definitions = field.json.params.field.columnDefinitions;
            }
            if (definitions) {
                return definitions.map((/**
                 * @param {?} obj
                 * @return {?}
                 */
                (obj) => (/** @type {?} */ (obj))));
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    flushValue() {
        if (this.field) {
            this.field.value = this.rows.map((/**
             * @param {?} r
             * @return {?}
             */
            (r) => r.value));
            this.field.updateForm();
        }
    }
    /**
     * @param {?} row
     * @param {?} offset
     * @return {?}
     */
    moveRow(row, offset) {
        /** @type {?} */
        const oldIndex = this.rows.indexOf(row);
        if (oldIndex > -1) {
            /** @type {?} */
            let newIndex = (oldIndex + offset);
            if (newIndex < 0) {
                newIndex = 0;
            }
            else if (newIndex >= this.rows.length) {
                newIndex = this.rows.length;
            }
            /** @type {?} */
            const arr = this.rows.slice();
            arr.splice(oldIndex, 1);
            arr.splice(newIndex, 0, row);
            this.rows = arr;
            this.flushValue();
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    deleteRow(row) {
        if (row) {
            if (this.selectedRow === row) {
                this.selectedRow = null;
            }
            /** @type {?} */
            const idx = this.rows.indexOf(row);
            if (idx > -1) {
                this.rows.splice(idx, 1);
                this.flushValue();
            }
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    addRow(row) {
        if (row) {
            this.rows.push(row);
            // this.selectedRow = row;
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    validateRow(row) {
        /** @type {?} */
        const summary = new DynamicRowValidationSummary({
            isValid: true,
            message: null
        });
        /** @type {?} */
        const event = new ValidateDynamicTableRowEvent(this.form, this.field, row, summary);
        this.formService.validateDynamicTableRow.next(event);
        if (event.defaultPrevented || !summary.isValid) {
            return summary;
        }
        if (row) {
            for (const col of this.columns) {
                for (const validator of this._validators) {
                    if (!validator.validate(row, col, summary)) {
                        return summary;
                    }
                }
            }
        }
        return summary;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    getCellValue(row, column) {
        /** @type {?} */
        const rowValue = row.value[column.id];
        if (column.type === 'Dropdown') {
            if (rowValue) {
                return rowValue.name;
            }
        }
        if (column.type === 'Boolean') {
            return rowValue ? true : false;
        }
        if (column.type === 'Date') {
            if (rowValue) {
                return moment(rowValue.split('T')[0], 'YYYY-MM-DD').format('DD-MM-YYYY');
            }
        }
        return rowValue || '';
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getDisplayText(column) {
        /** @type {?} */
        let columnName = column.name;
        if (column.type === 'Amount') {
            /** @type {?} */
            const currency = column.amountCurrency || '$';
            columnName = `${column.name} (${currency})`;
        }
        return columnName;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicTableWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} elementRef
     * @param {?} visibilityService
     * @param {?} logService
     * @param {?} cd
     */
    constructor(formService, elementRef, visibilityService, logService, cd) {
        super(formService);
        this.formService = formService;
        this.elementRef = elementRef;
        this.visibilityService = visibilityService;
        this.logService = logService;
        this.cd = cd;
        this.ERROR_MODEL_NOT_FOUND = 'Table model not found';
        this.editMode = false;
        this.editRow = null;
        this.selectArrayCode = [32, 0, 13];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            this.content = new DynamicTableModel(this.field, this.formService);
            this.visibilityService.refreshVisibility(this.field.form);
        }
    }
    /**
     * @return {?}
     */
    forceFocusOnAddButton() {
        if (this.content) {
            this.cd.detectChanges();
            /** @type {?} */
            const buttonAddRow = (/** @type {?} */ (this.elementRef.nativeElement.querySelector('#' + this.content.id + '-add-row')));
            if (this.isDynamicTableReady(buttonAddRow)) {
                buttonAddRow.focus();
            }
        }
    }
    /**
     * @private
     * @param {?} buttonAddRow
     * @return {?}
     */
    isDynamicTableReady(buttonAddRow) {
        return this.field && !this.editMode && buttonAddRow;
    }
    /**
     * @return {?}
     */
    isValid() {
        /** @type {?} */
        let valid = true;
        if (this.content && this.content.field) {
            valid = this.content.field.isValid;
        }
        return valid;
    }
    /**
     * @param {?} row
     * @return {?}
     */
    onRowClicked(row) {
        if (this.content) {
            this.content.selectedRow = row;
        }
    }
    /**
     * @param {?} $event
     * @param {?} row
     * @return {?}
     */
    onKeyPressed($event, row) {
        if (this.content && this.isEnterOrSpacePressed($event.keyCode)) {
            this.content.selectedRow = row;
        }
    }
    /**
     * @private
     * @param {?} keyCode
     * @return {?}
     */
    isEnterOrSpacePressed(keyCode) {
        return this.selectArrayCode.indexOf(keyCode) !== -1;
    }
    /**
     * @return {?}
     */
    hasSelection() {
        return !!(this.content && this.content.selectedRow);
    }
    /**
     * @return {?}
     */
    moveSelectionUp() {
        if (this.content && !this.readOnly) {
            this.content.moveRow(this.content.selectedRow, -1);
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    moveSelectionDown() {
        if (this.content && !this.readOnly) {
            this.content.moveRow(this.content.selectedRow, 1);
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    deleteSelection() {
        if (this.content && !this.readOnly) {
            this.content.deleteRow(this.content.selectedRow);
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    addNewRow() {
        if (this.content && !this.readOnly) {
            this.editRow = (/** @type {?} */ ({
                isNew: true,
                selected: false,
                value: {}
            }));
            this.editMode = true;
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    editSelection() {
        if (this.content && !this.readOnly) {
            this.editRow = this.copyRow(this.content.selectedRow);
            this.editMode = true;
            return true;
        }
        return false;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    getCellValue(row, column) {
        if (this.content) {
            /** @type {?} */
            const cellValue = this.content.getCellValue(row, column);
            if (column.type === 'Amount') {
                return (column.amountCurrency || '$') + ' ' + (cellValue || 0);
            }
            return cellValue;
        }
        return null;
    }
    /**
     * @return {?}
     */
    onSaveChanges() {
        if (this.content) {
            if (this.editRow.isNew) {
                /** @type {?} */
                const row = this.copyRow(this.editRow);
                this.content.selectedRow = null;
                this.content.addRow(row);
                this.editRow.isNew = false;
            }
            else {
                this.content.selectedRow.value = this.copyObject(this.editRow.value);
            }
            this.content.flushValue();
        }
        else {
            this.logService.error(this.ERROR_MODEL_NOT_FOUND);
        }
        this.editMode = false;
        this.forceFocusOnAddButton();
    }
    /**
     * @return {?}
     */
    onCancelChanges() {
        this.editMode = false;
        this.editRow = null;
        this.forceFocusOnAddButton();
    }
    /**
     * @param {?} row
     * @return {?}
     */
    copyRow(row) {
        return (/** @type {?} */ ({
            value: this.copyObject(row.value)
        }));
    }
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    copyObject(obj) {
        /** @type {?} */
        let result = obj;
        if (typeof obj === 'object' && obj !== null && obj !== undefined) {
            result = Object.assign({}, obj);
            Object.keys(obj).forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                if (typeof obj[key] === 'object') {
                    result[key] = this.copyObject(obj[key]);
                }
            }));
        }
        return result;
    }
}
DynamicTableWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'dynamic-table-widget',
                template: "<div class=\"adf-dynamic-table-scrolling {{field.className}}\"\n    [class.adf-invalid]=\"!isValid()\">\n    <div class=\"adf-label\">{{content.name}}<span *ngIf=\"isRequired()\">*</span></div>\n\n    <div *ngIf=\"!editMode\">\n        <div class=\"adf-table-container\">\n            <table class=\"adf-full-width adf-dynamic-table\" id=\"dynamic-table-{{content.id}}\">\n                <thead>\n                    <tr>\n                        <th *ngFor=\"let column of content.visibleColumns\">\n                            {{column.name}}\n                        </th>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr *ngFor=\"let row of content.rows; let idx = index\" tabindex=\"0\" id=\"{{content.id}}-row-{{idx}}\"\n                        [class.adf-dynamic-table-widget__row-selected]=\"row.selected\" (keyup)=\"onKeyPressed($event, row)\">\n                        <td *ngFor=\"let column of content.visibleColumns\"\n                            (click)=\"onRowClicked(row)\">\n                            <span *ngIf=\"column.type !== 'Boolean' else checkbox\">\n                                {{ getCellValue(row, column) }}\n                            </span>\n                            <ng-template #checkbox>\n                                <mat-checkbox disabled [checked]=\"getCellValue(row, column)\">\n                                </mat-checkbox>\n                            </ng-template>\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n        </div>\n\n        <div *ngIf=\"!readOnly\">\n            <button mat-button\n                    [disabled]=\"!hasSelection()\"\n                    (click)=\"moveSelectionUp()\">\n                <mat-icon>arrow_upward</mat-icon>\n            </button>\n            <button mat-button\n                    [disabled]=\"!hasSelection()\"\n                    (click)=\"moveSelectionDown()\">\n                <mat-icon>arrow_downward</mat-icon>\n            </button>\n            <button mat-button\n                    [disabled]=\"field.readOnly\"\n                    id=\"{{content.id}}-add-row\"\n                    (click)=\"addNewRow()\">\n                <mat-icon>add_circle_outline</mat-icon>\n            </button>\n            <button mat-button\n                    [disabled]=\"!hasSelection()\"\n                    (click)=\"deleteSelection()\">\n                <mat-icon>remove_circle_outline</mat-icon>\n            </button>\n            <button mat-button\n                    [disabled]=\"!hasSelection()\"\n                    (click)=\"editSelection()\">\n                <mat-icon>edit</mat-icon>\n            </button>\n        </div>\n     </div>\n\n     <row-editor *ngIf=\"editMode\"\n        [table]=\"content\"\n        [row]=\"editRow\"\n        (save)=\"onSaveChanges()\"\n        (cancel)=\"onCancelChanges()\">\n     </row-editor>\n    <error-widget [error]=\"field.validationSummary\" ></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
DynamicTableWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: ElementRef },
    { type: WidgetVisibilityService },
    { type: LogService },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BooleanEditorComponent {
    /**
     * @param {?} row
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    onValueChanged(row, column, event) {
        /** @type {?} */
        const value = ((/** @type {?} */ (event))).checked;
        row.value[column.id] = value;
    }
}
BooleanEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-boolean-editor',
                template: " <label [attr.for]=\"column.id\">\n    <mat-checkbox\n        color=\"primary\"\n        [id]=\"column.id\"\n        [checked]=\"table.getCellValue(row, column)\"\n        [required]=\"column.required\"\n        [disabled]=\"!column.editable\"\n        (change)=\"onValueChanged(row, column, $event)\">\n    <span class=\"adf-checkbox-label\">{{column.name}}</span>\n    </mat-checkbox>\n</label>\n",
                styles: [".adf-checkbox-label{position:relative;cursor:pointer;font-size:16px;line-height:24px;margin:0}"]
            }] }
];
BooleanEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$2 = MOMENT_DATE_FORMATS;
class DateEditorComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.DATE_FORMAT = 'DD-MM-YYYY';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            this.dateAdapter.setLocale(locale);
        }));
        /** @type {?} */
        const momentDateAdapter = (/** @type {?} */ (this.dateAdapter));
        momentDateAdapter.overrideDisplayFormat = this.DATE_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), 'YYYY-MM-DD');
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            /** @type {?} */
            const momentDate = moment(newDateValue.value, this.DATE_FORMAT, true);
            if (!momentDate.isValid()) {
                this.row.value[this.column.id] = '';
            }
            else {
                this.row.value[this.column.id] = `${momentDate.format('YYYY-MM-DD')}T00:00:00.000Z`;
                this.table.flushValue();
            }
        }
    }
}
DateEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-editor',
                template: "<div>\n    <mat-form-field class=\"adf-date-editor\">\n        <label [attr.for]=\"column.id\">{{column.name}} (d-M-yyyy)</label>\n        <input matInput\n            id=\"dateInput\"\n            type=\"text\"\n            [matDatepicker]=\"datePicker\"\n            [value]=\"value\"\n            [id]=\"column.id\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (focusout)=\"onDateChanged($event.srcElement.value)\"\n            (dateChange)=\"onDateChanged($event)\">\n        <mat-datepicker-toggle  *ngIf=\"column.editable\" matSuffix [for]=\"datePicker\" class=\"adf-date-editor-button\" ></mat-datepicker-toggle>\n    </mat-form-field>\n    <mat-datepicker #datePicker [touchUi]=\"true\"></mat-datepicker>\n</div>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$2 }
                ],
                styles: [".adf-date-editor{width:100%}.adf-date-editor-button{position:relative;top:25px}"]
            }] }
];
/** @nocollapse */
DateEditorComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
DateEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$3 = MOMENT_DATE_FORMATS, ɵ1$1 = MAT_MOMENT_DATETIME_FORMATS;
class DateTimeEditorComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.DATE_FORMAT = 'D-M-YYYY hh:mm A';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            this.dateAdapter.setLocale(locale);
        }));
        /** @type {?} */
        const momentDateAdapter = (/** @type {?} */ (this.dateAdapter));
        momentDateAdapter.overrideDisplayFormat = this.DATE_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), this.DATE_FORMAT);
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            /** @type {?} */
            const newValue = moment(newDateValue.value, this.DATE_FORMAT);
            this.row.value[this.column.id] = newDateValue.value.format(this.DATE_FORMAT);
            this.value = newValue;
            this.table.flushValue();
        }
        else if (newDateValue) {
            /** @type {?} */
            const newValue = moment(newDateValue, this.DATE_FORMAT);
            this.value = newValue;
            this.row.value[this.column.id] = newDateValue;
            this.table.flushValue();
        }
        else {
            this.row.value[this.column.id] = '';
        }
    }
}
DateTimeEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datetime-editor',
                template: "<div>\n    <mat-form-field class=\"adf-date-editor\">\n        <label [attr.for]=\"column.id\">{{column.name}} {{DATE_FORMAT}}</label>\n        <input matInput\n            [matDatetimepicker]=\"datetimePicker\"\n            [(ngModel)]=\"value\"\n            [id]=\"column.id\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (focusout)=\"onDateChanged($event.srcElement.value)\"\n            (dateChange)=\"onDateChanged($event)\">\n            <mat-datetimepicker-toggle matSuffix [for]=\"datetimePicker\"\n                            *ngIf=\"column.editable\"\n                            class=\"adf-date-editor-button\"></mat-datetimepicker-toggle>\n    </mat-form-field>\n    <mat-datetimepicker #datetimePicker\n                        type=\"datetime\"\n                        openOnFocus=\"true\"\n                        timeInterval=\"5\"></mat-datetimepicker>\n</div>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$3 },
                    { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1$1 }
                ],
                styles: [".adf-date-editor{width:100%}.adf-date-editor-button{position:relative;top:25px}"]
            }] }
];
/** @nocollapse */
DateTimeEditorComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
DateTimeEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DropdownEditorComponent {
    /**
     * @param {?} formService
     * @param {?} logService
     */
    constructor(formService, logService) {
        this.formService = formService;
        this.logService = logService;
        this.value = null;
        this.options = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const field = this.table.field;
        if (field) {
            if (this.column.optionType === 'rest') {
                if (this.table.form && this.table.form.taskId) {
                    this.getValuesByTaskId(field);
                }
                else {
                    this.getValuesByProcessDefinitionId(field);
                }
            }
            else {
                this.options = this.column.options || [];
                this.value = this.table.getCellValue(this.row, this.column);
            }
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getValuesByTaskId(field) {
        this.formService
            .getRestFieldValuesColumn(field.form.taskId, field.id, this.column.id)
            .subscribe((/**
         * @param {?} dynamicTableColumnOption
         * @return {?}
         */
        (dynamicTableColumnOption) => {
            this.column.options = dynamicTableColumnOption || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getValuesByProcessDefinitionId(field) {
        this.formService
            .getRestFieldValuesColumnByProcessId(field.form.processDefinitionId, field.id, this.column.id)
            .subscribe((/**
         * @param {?} dynamicTableColumnOption
         * @return {?}
         */
        (dynamicTableColumnOption) => {
            this.column.options = dynamicTableColumnOption || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    onValueChanged(row, column, event) {
        /** @type {?} */
        let value = ((/** @type {?} */ (event))).value;
        value = column.options.find((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => opt.name === value));
        row.value[column.id] = value;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
    }
}
DropdownEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-editor',
                template: "<div class=\"dropdown-editor\">\n    <label [attr.for]=\"column.id\">{{column.name}}</label>\n    <mat-form-field>\n        <mat-select\n            floatPlaceholder=\"never\"\n            class=\"adf-dropdown-editor-select\"\n            [id]=\"column.id\"\n            [(ngModel)]=\"value\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (selectionChange)=\"onValueChanged(row, column, $event)\">\n            <mat-option></mat-option>\n            <mat-option *ngFor=\"let opt of options\" [value]=\"opt.name\" [id]=\"opt.id\">{{opt.name}}</mat-option>\n        </mat-select>\n    </mat-form-field>\n</div>\n",
                styles: [".adf-dropdown-editor-select{width:100%}"]
            }] }
];
/** @nocollapse */
DropdownEditorComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService }
];
DropdownEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RowEditorComponent {
    constructor() {
        this.save = new EventEmitter();
        this.cancel = new EventEmitter();
        this.validationSummary = new DynamicRowValidationSummary({ isValid: true, message: '' });
    }
    /**
     * @return {?}
     */
    onCancelChanges() {
        this.cancel.emit({
            table: this.table,
            row: this.row,
            column: this.column
        });
    }
    /**
     * @return {?}
     */
    onSaveChanges() {
        this.validate();
        if (this.isValid()) {
            this.save.emit({
                table: this.table,
                row: this.row,
                column: this.column
            });
        }
    }
    /**
     * @private
     * @return {?}
     */
    isValid() {
        return this.validationSummary && this.validationSummary.isValid;
    }
    /**
     * @private
     * @return {?}
     */
    validate() {
        this.validationSummary = this.table.validateRow(this.row);
    }
}
RowEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'row-editor',
                template: "<div class=\"row-editor mdl-shadow--2dp\"\n    [class.row-editor__invalid]=\"!validationSummary.isValid\">\n    <div class=\"mdl-grid\" *ngFor=\"let column of table.columns\">\n        <div class=\"mdl-cell mdl-cell--6-col\" [ngSwitch]=\"column.type\">\n            <div *ngSwitchCase=\"'Dropdown'\">\n                <adf-dropdown-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-dropdown-editor>\n                </div>\n                <div *ngSwitchCase=\"'Date'\">\n                    <adf-date-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-date-editor>\n                </div>\n                <div *ngSwitchCase=\"'Datetime'\">\n                    <adf-datetime-editor\n                        [table]=\"table\"\n                        [row]=\"row\"\n                        [column]=\"column\">\n                    </adf-datetime-editor>\n                </div>\n                <div *ngSwitchCase=\"'Boolean'\">\n                <adf-boolean-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-boolean-editor>\n                </div>\n                <div *ngSwitchDefault>\n                <adf-text-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-text-editor>\n            </div>\n        </div>\n    </div>\n    <error-widget [error]=\"validationSummary\"></error-widget>\n    <div>\n        <button mat-button (click)=\"onCancelChanges()\">Cancel</button>\n        <button mat-button (click)=\"onSaveChanges()\">Save</button>\n    </div>\n</div>\n",
                styles: [".row-editor{padding:8px}.row-editor__validation-summary{visibility:hidden}.row-editor__invalid .row-editor__validation-summary{color:#d50000;visibility:visible;padding:8px 16px}"]
            }] }
];
/** @nocollapse */
RowEditorComponent.ctorParameters = () => [];
RowEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }],
    save: [{ type: Output }],
    cancel: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextEditorComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.displayName = this.table.getDisplayText(this.column);
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    onValueChanged(row, column, event) {
        /** @type {?} */
        const value = ((/** @type {?} */ (event.target))).value;
        row.value[column.id] = value;
    }
}
TextEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-text-editor',
                template: "<div class=\"adf-text-editor\">\n    <mat-form-field>\n    <label [attr.for]=\"column.id\">{{displayName}}</label>\n    <input matInput\n        type=\"text\"\n        [value]=\"table.getCellValue(row, column)\"\n        (keyup)=\"onValueChanged(row, column, $event)\"\n        [required]=\"column.required\"\n        [disabled]=\"!column.editable\"\n        [id]=\"column.id\">\n    </mat-form-field>\n</div>\n",
                styles: [".adf-text-editor{width:100%}"]
            }] }
];
TextEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ErrorWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.translateParameters = null;
        this._subscriptAnimationState = '';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['required']) {
            this.required = changes.required.currentValue;
            this._subscriptAnimationState = 'enter';
        }
        if (changes['error'] && changes['error'].currentValue) {
            if (changes.error.currentValue.isActive()) {
                this.error = changes.error.currentValue;
                this.translateParameters = this.error.getAttributesAsJsonObj();
                this._subscriptAnimationState = 'enter';
            }
        }
    }
}
ErrorWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'error-widget',
                template: "<div class=\"adf-error-text-container\">\n    <div *ngIf=\"error?.isActive()\" [@transitionMessages]=\"_subscriptAnimationState\">\n        <div class=\"adf-error-text\">{{error.message | translate:translateParameters}}</div>\n        <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n    </div>\n    <div *ngIf=\"required\" [@transitionMessages]=\"_subscriptAnimationState\">\n            <div class=\"adf-error-text\">{{required}}</div>\n    </div>\n</div>\n",
                animations: [
                    trigger('transitionMessages', [
                        state('enter', style({ opacity: 1, transform: 'translateY(0%)' })),
                        transition('void => enter', [
                            style({ opacity: 0, transform: 'translateY(-100%)' }),
                            animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                        ])
                    ])
                ],
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-error-text{width:85%}"]
            }] }
];
/** @nocollapse */
ErrorWidgetComponent.ctorParameters = () => [
    { type: FormService }
];
ErrorWidgetComponent.propDecorators = {
    error: [{ type: Input }],
    required: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FunctionalGroupWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} elementRef
     */
    constructor(formService, elementRef) {
        super(formService);
        this.formService = formService;
        this.elementRef = elementRef;
        this.groups = [];
        this.minTermLength = 1;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            /** @type {?} */
            const group$$1 = this.field.value;
            if (group$$1) {
                this.value = group$$1.name;
            }
            /** @type {?} */
            const params = this.field.params;
            if (params && params['restrictWithGroup']) {
                /** @type {?} */
                const restrictWithGroup = (/** @type {?} */ (params['restrictWithGroup']));
                this.groupId = restrictWithGroup.id;
            }
            // Load auto-completion for previously saved value
            if (this.value) {
                this.formService
                    .getWorkflowGroups(this.value, this.groupId)
                    .subscribe((/**
                 * @param {?} groupModel
                 * @return {?}
                 */
                (groupModel) => this.groups = groupModel || []));
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp(event) {
        if (this.value && this.value.length >= this.minTermLength && this.oldValue !== this.value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                this.oldValue = this.value;
                this.formService.getWorkflowGroups(this.value, this.groupId)
                    .subscribe((/**
                 * @param {?} group
                 * @return {?}
                 */
                (group$$1) => {
                    this.groups = group$$1 || [];
                }));
            }
        }
    }
    /**
     * @return {?}
     */
    flushValue() {
        /** @type {?} */
        const option = this.groups.find((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.name.toLocaleLowerCase() === this.value.toLocaleLowerCase()));
        if (option) {
            this.field.value = option;
            this.value = option.name;
        }
        else {
            this.field.value = null;
            this.value = null;
        }
        this.field.updateForm();
    }
    /**
     * @param {?} item
     * @param {?} event
     * @return {?}
     */
    onItemClick(item, event) {
        if (item) {
            this.field.value = item;
            this.value = item.name;
        }
        if (event) {
            event.preventDefault();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onItemSelect(item) {
        if (item) {
            this.field.value = item;
            this.value = item.name;
        }
    }
}
FunctionalGroupWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'functional-group-widget',
                template: "<div class=\"adf-group-widget {{field.className}}\"\n     [class.is-dirty]=\"value\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\" id=\"functional-group-div\">\n    <mat-form-field>\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               class=\"adf-input\"\n               type=\"text\"\n               [id]=\"field.id\"\n               [(ngModel)]=\"value\"\n               (keyup)=\"onKeyUp($event)\"\n               [disabled]=\"field.readOnly\"\n               placeholder=\"{{field.placeholder}}\"\n               [matAutocomplete]=\"auto\">\n        <mat-autocomplete #auto=\"matAutocomplete\" (optionSelected)=\"onItemSelect($event.option.value)\">\n            <mat-option *ngFor=\"let item of groups\"\n                       [id]=\"field.id +'-'+item.id\"\n                       (click)=\"onItemClick(item, $event)\"  [value]=\"item\">\n                <span>{{item.name}}</span>\n            </mat-option>\n        </mat-autocomplete>\n\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-group-widget{width:100%}"]
            }] }
];
/** @nocollapse */
FunctionalGroupWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HyperlinkWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.linkUrl = WidgetComponent.DEFAULT_HYPERLINK_URL;
        this.linkText = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            this.linkUrl = this.getHyperlinkUrl(this.field);
            this.linkText = this.getHyperlinkText(this.field);
        }
    }
}
HyperlinkWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'hyperlink-widget',
                template: "<div class=\"adf-hyperlink-widget {{field.className}}\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n    <div>\n        <a [href]=\"linkUrl\" target=\"_blank\" rel=\"nofollow\">{{linkText}}</a>\n    </div>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
HyperlinkWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MultilineTextWidgetComponentComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
MultilineTextWidgetComponentComponent.decorators = [
    { type: Component, args: [{
                selector: 'multiline-text-widget',
                template: "<div class=\"adf-multiline-text-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <mat-form-field floatPlaceholder=\"never\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n        <textarea matInput class=\"adf-input\"\n                  matTextareaAutosize\n                  type=\"text\"\n                  rows=\"3\"\n                  [id]=\"field.id\"\n                  [required]=\"isRequired()\"\n                  [(ngModel)]=\"field.value\"\n                  (ngModelChange)=\"onFieldChanged(field)\"\n                  [disabled]=\"field.readOnly || readOnly\"\n                  placeholder=\"{{field.placeholder}}\">\n        </textarea>\n    </mat-form-field>\n    <div *ngIf=\"field.maxLength > 0\" class=\"adf-multiline-word-counter\">\n        <span>{{field?.value?.length || 0}}/{{field.maxLength}}</span>\n    </div>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget class=\"adf-multiline-required-message\" *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-multiline-text-widget{width:100%}.adf-multiline-word-counter{float:right;margin-top:-20px!important;min-height:24px;min-width:1px;font-size:12px;line-height:14px;overflow:hidden;transition:.3s cubic-bezier(.55,0,.55,.2);opacity:1;padding-top:5px;text-align:right;padding-right:2px;padding-left:0}.adf-multiline-required-message{display:flex}"]
            }] }
];
/** @nocollapse */
MultilineTextWidgetComponentComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NumberWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
NumberWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'number-widget',
                template: "<div class=\"adf-textfield adf-number-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <mat-form-field>\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               class=\"adf-input\"\n               type=\"text\"\n               pattern=\"-?[0-9]*(\\.[0-9]+)?\"\n               [id]=\"field.id\"\n               [required]=\"isRequired()\"\n               [value]=\"field.value\"\n               [(ngModel)]=\"field.value\"\n               (ngModelChange)=\"onFieldChanged(field)\"\n               [disabled]=\"field.readOnly\"\n               placeholder=\"{{field.placeholder}}\">\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\" ></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-number-widget{width:100%}"]
            }] }
];
/** @nocollapse */
NumberWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeopleProcessService {
    /**
     * @param {?} alfrescoJsApi
     * @param {?} logService
     */
    constructor(alfrescoJsApi, logService) {
        this.alfrescoJsApi = alfrescoJsApi;
        this.logService = logService;
    }
    /**
     * Gets information about users across all tasks.
     * @param {?=} taskId ID of the task
     * @param {?=} searchWord Filter text to search for
     * @return {?} Array of user information objects
     */
    getWorkflowUsers(taskId, searchWord) {
        /** @type {?} */
        const option = { excludeTaskId: taskId, filter: searchWord };
        return from(this.getWorkflowUserApi(option))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => (/** @type {?} */ (response.data)) || [])), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the profile picture URL for the specified user.
     * @param {?} user The target user
     * @return {?} Profile picture URL
     */
    getUserImage(user) {
        return this.getUserProfileImageApi(user.id);
    }
    /**
     * Sets a user to be involved with a task.
     * @param {?} taskId ID of the target task
     * @param {?} idToInvolve ID of the user to involve
     * @return {?} Empty response when the update completes
     */
    involveUserWithTask(taskId, idToInvolve) {
        /** @type {?} */
        const node = { userId: idToInvolve };
        return from(this.involveUserToTaskApi(taskId, node))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Removes a user who is currently involved with a task.
     * @param {?} taskId ID of the target task
     * @param {?} idToRemove ID of the user to remove
     * @return {?} Empty response when the update completes
     */
    removeInvolvedUser(taskId, idToRemove) {
        /** @type {?} */
        const node = { userId: idToRemove };
        return from(this.removeInvolvedUserFromTaskApi(taskId, node))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    getWorkflowUserApi(options) {
        return this.alfrescoJsApi.getInstance().activiti.usersWorkflowApi.getUsers(options);
    }
    /**
     * @private
     * @param {?} taskId
     * @param {?} node
     * @return {?}
     */
    involveUserToTaskApi(taskId, node) {
        return this.alfrescoJsApi.getInstance().activiti.taskActionsApi.involveUser(taskId, node);
    }
    /**
     * @private
     * @param {?} taskId
     * @param {?} node
     * @return {?}
     */
    removeInvolvedUserFromTaskApi(taskId, node) {
        return this.alfrescoJsApi.getInstance().activiti.taskActionsApi.removeInvolvedUser(taskId, node);
    }
    /**
     * @private
     * @param {?} userId
     * @return {?}
     */
    getUserProfileImageApi(userId) {
        return this.alfrescoJsApi.getInstance().activiti.userApi.getUserProfilePictureUrl(userId);
    }
    /**
     * Throw the error
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
PeopleProcessService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PeopleProcessService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ PeopleProcessService.ngInjectableDef = defineInjectable({ factory: function PeopleProcessService_Factory() { return new PeopleProcessService(inject(AlfrescoApiService), inject(LogService)); }, token: PeopleProcessService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeopleWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} peopleProcessService
     */
    constructor(formService, peopleProcessService) {
        super(formService);
        this.formService = formService;
        this.peopleProcessService = peopleProcessService;
        this.searchTerm = new FormControl();
        this.errorMsg = '';
        this.searchTerms$ = this.searchTerm.valueChanges;
        this.users$ = this.searchTerms$.pipe(tap((/**
         * @return {?}
         */
        () => {
            this.errorMsg = '';
        })), distinctUntilChanged(), switchMap((/**
         * @param {?} searchTerm
         * @return {?}
         */
        (searchTerm) => {
            /** @type {?} */
            const value = searchTerm.email ? this.getDisplayName(searchTerm) : searchTerm;
            return this.formService.getWorkflowUsers(value, this.groupId)
                .pipe(catchError((/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.errorMsg = err.message;
                return of();
            })));
        })), map((/**
         * @param {?} list
         * @return {?}
         */
        (list) => {
            /** @type {?} */
            const value = this.searchTerm.value.email ? this.getDisplayName(this.searchTerm.value) : this.searchTerm.value;
            this.checkUserAndValidateForm(list, value);
            return list;
        })));
        this.peopleSelected = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            if (this.field.value) {
                this.searchTerm.setValue(this.field.value);
            }
            if (this.field.readOnly) {
                this.searchTerm.disable();
            }
            /** @type {?} */
            const params = this.field.params;
            if (params && params.restrictWithGroup) {
                /** @type {?} */
                const restrictWithGroup = (/** @type {?} */ (params.restrictWithGroup));
                this.groupId = restrictWithGroup.id;
            }
        }
    }
    /**
     * @param {?} list
     * @param {?} value
     * @return {?}
     */
    checkUserAndValidateForm(list, value) {
        /** @type {?} */
        const isValidUser = this.isValidUser(list, value);
        if (isValidUser || value === '') {
            this.field.validationSummary.message = '';
            this.field.validate();
            this.field.form.validateForm();
        }
        else {
            this.field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
            this.field.markAsInvalid();
            this.field.form.markAsInvalid();
        }
    }
    /**
     * @param {?} users
     * @param {?} name
     * @return {?}
     */
    isValidUser(users, name) {
        if (users) {
            return users.find((/**
             * @param {?} user
             * @return {?}
             */
            (user) => {
                /** @type {?} */
                const selectedUser = this.getDisplayName(user).toLocaleLowerCase() === name.toLocaleLowerCase();
                if (selectedUser) {
                    this.peopleSelected.emit(user && user.id || undefined);
                }
                return selectedUser;
            }));
        }
    }
    /**
     * @param {?} model
     * @return {?}
     */
    getDisplayName(model) {
        if (model) {
            /** @type {?} */
            const displayName = `${model.firstName || ''} ${model.lastName || ''}`;
            return displayName.trim();
        }
        return '';
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onItemSelect(item) {
        if (item) {
            this.field.value = item;
        }
    }
}
PeopleWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'people-widget',
                template: "<div class=\"adf-people-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\"\n     [class.adf-readonly]=\"field.readOnly\"\n     id=\"people-widget-content\">\n    <mat-form-field>\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n        <input #inputValue\n               matInput\n               class=\"adf-input\"\n               data-automation-id=\"adf-people-search-input\"\n               type=\"text\"\n               [id]=\"field.id\"\n               [formControl]=\"searchTerm\"\n               placeholder=\"{{field.placeholder}}\"\n               [matAutocomplete]=\"auto\">\n        <mat-autocomplete class=\"adf-people-widget-list\"\n                          #auto=\"matAutocomplete\"\n                          (optionSelected)=\"onItemSelect($event.option.value)\"\n                          [displayWith]=\"getDisplayName\">\n            <mat-option *ngFor=\"let user of users$ | async; let i = index\" [value]=\"user\">\n                <div class=\"adf-people-widget-row\" id=\"adf-people-widget-user-{{i}}\">\n                    <div [outerHTML]=\"user | usernameInitials:'adf-people-widget-pic'\"></div>\n                    <div *ngIf=\"user.pictureId\" class=\"adf-people-widget-image-row\">\n                        <img id=\"adf-people-widget-pic-{{i}}\" class=\"adf-people-widget-image\"\n                             [alt]=\"getDisplayName(user)\" [src]=\"peopleProcessService.getUserImage(user)\"/>\n                    </div>\n                    <span class=\"adf-people-label-name\">{{getDisplayName(user)}}</span>\n                </div>\n            </mat-option>\n        </mat-autocomplete>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
PeopleWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: PeopleProcessService }
];
PeopleWidgetComponent.propDecorators = {
    input: [{ type: ViewChild, args: ['inputValue',] }],
    peopleSelected: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioButtonsWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} logService
     */
    constructor(formService, logService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field && this.field.restUrl) {
            if (this.field.form.taskId) {
                this.getOptionsByTaskId();
            }
            else {
                this.getOptionsByProcessDefinitionId();
            }
        }
    }
    /**
     * @return {?}
     */
    getOptionsByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((/**
         * @param {?} formFieldOption
         * @return {?}
         */
        (formFieldOption) => {
            this.field.options = formFieldOption || [];
            this.field.updateForm();
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
    }
    /**
     * @return {?}
     */
    getOptionsByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((/**
         * @param {?} formFieldOption
         * @return {?}
         */
        (formFieldOption) => {
            this.field.options = formFieldOption || [];
            this.field.updateForm();
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
    }
    /**
     * @param {?} optionSelected
     * @return {?}
     */
    onOptionClick(optionSelected) {
        this.field.value = optionSelected;
        this.fieldChanged.emit(this.field);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
    }
}
RadioButtonsWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'radio-buttons-widget',
                template: "<div class=\"adf-radio-buttons-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\" [id]=\"field.id\">\n    <div class=\"adf-radio-button-container\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n        <mat-radio-group class=\"adf-radio-group\" [(ngModel)]=\"field.value\">\n            <mat-radio-button\n                [id]=\"field.id + '-' + opt.id\"\n                [name]=\"field.id\"\n                [value]=\"opt.id\"\n                [disabled]=\"field.readOnly\"\n                [checked]=\"field.value === opt.id\"\n                (change)=\"onOptionClick(opt.id)\"\n                color=\"primary\"\n                class=\"adf-radio-button\" *ngFor=\"let opt of field.options\" >\n                {{opt.name}}\n            </mat-radio-button>\n        </mat-radio-group>\n    </div>\n    <error-widget [error]=\"field.validationSummary\" ></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n\n\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-radio-button-container{margin-bottom:15px}.adf-radio-group{display:inline-flex;flex-direction:column}.adf-radio-button{margin:5px}"]
            }] }
];
/** @nocollapse */
RadioButtonsWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => InputMaskDirective)),
    multi: true
};
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class InputMaskDirective {
    /**
     * @param {?} el
     * @param {?} render
     */
    constructor(el, render) {
        this.el = el;
        this.render = render;
        this.translationMask = {
            '0': { pattern: /\d/ },
            '9': { pattern: /\d/, optional: true },
            '#': { pattern: /\d/, recursive: true },
            'A': { pattern: /[a-zA-Z0-9]/ },
            'S': { pattern: /[a-zA-Z]/ }
        };
        this.byPassKeys = [9, 16, 17, 18, 36, 37, 38, 39, 40, 91];
        this.invalidCharacters = [];
        this._onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        this._onTouched = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTextInput(event) {
        if (this.inputMask && this.inputMask.mask) {
            this.maskValue(this.el.nativeElement.value, this.el.nativeElement.selectionStart, this.inputMask.mask, this.inputMask.isReversed, event.keyCode);
        }
        else {
            this._onChange(this.el.nativeElement.value);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['inputMask'] && changes['inputMask'].currentValue['mask']) {
            this.inputMask = changes['inputMask'].currentValue;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.el.nativeElement.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @private
     * @param {?} actualValue
     * @param {?} startCaret
     * @param {?} maskToApply
     * @param {?} isMaskReversed
     * @param {?} keyCode
     * @return {?}
     */
    maskValue(actualValue, startCaret, maskToApply, isMaskReversed, keyCode) {
        if (this.byPassKeys.indexOf(keyCode) === -1) {
            /** @type {?} */
            const value = this.getMasked(false, actualValue, maskToApply, isMaskReversed);
            /** @type {?} */
            const calculatedCaret = this.calculateCaretPosition(startCaret, actualValue, keyCode);
            this.render.setAttribute(this.el.nativeElement, 'value', value);
            this.el.nativeElement.value = value;
            this.setValue(value);
            this._onChange(value);
            this.setCaretPosition(calculatedCaret);
        }
    }
    /**
     * @private
     * @param {?} caretPosition
     * @return {?}
     */
    setCaretPosition(caretPosition) {
        this.el.nativeElement.moveStart = caretPosition;
        this.el.nativeElement.moveEnd = caretPosition;
    }
    /**
     * @param {?} caretPosition
     * @param {?} newValue
     * @param {?} keyCode
     * @return {?}
     */
    calculateCaretPosition(caretPosition, newValue, keyCode) {
        /** @type {?} */
        const newValueLength = newValue.length;
        /** @type {?} */
        const oldValue = this.getValue() || '';
        /** @type {?} */
        const oldValueLength = oldValue.length;
        if (keyCode === 8 && oldValue !== newValue) {
            caretPosition = caretPosition - (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
        }
        else if (oldValue !== newValue) {
            if (caretPosition >= oldValueLength) {
                caretPosition = newValueLength;
            }
            else {
                caretPosition = caretPosition + (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
            }
        }
        return caretPosition;
    }
    /**
     * @param {?} skipMaskChars
     * @param {?} val
     * @param {?} mask
     * @param {?=} isReversed
     * @return {?}
     */
    getMasked(skipMaskChars, val, mask, isReversed = false) {
        /** @type {?} */
        const buf = [];
        /** @type {?} */
        const value = val;
        /** @type {?} */
        let maskIndex = 0;
        /** @type {?} */
        const maskLen = mask.length;
        /** @type {?} */
        let valueIndex = 0;
        /** @type {?} */
        const valueLength = value.length;
        /** @type {?} */
        let offset = 1;
        /** @type {?} */
        let addMethod = 'push';
        /** @type {?} */
        let resetPos = -1;
        /** @type {?} */
        let lastMaskChar;
        /** @type {?} */
        let lastUntranslatedMaskChar;
        /** @type {?} */
        let check;
        if (isReversed) {
            addMethod = 'unshift';
            offset = -1;
            lastMaskChar = 0;
            maskIndex = maskLen - 1;
            valueIndex = valueLength - 1;
        }
        else {
            lastMaskChar = maskLen - 1;
        }
        check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        while (check) {
            /** @type {?} */
            const maskDigit = mask.charAt(maskIndex);
            /** @type {?} */
            const valDigit = value.charAt(valueIndex);
            /** @type {?} */
            const translation = this.translationMask[maskDigit];
            if (translation) {
                if (valDigit.match(translation.pattern)) {
                    buf[addMethod](valDigit);
                    if (translation.recursive) {
                        if (resetPos === -1) {
                            resetPos = maskIndex;
                        }
                        else if (maskIndex === lastMaskChar) {
                            maskIndex = resetPos - offset;
                        }
                        if (lastMaskChar === resetPos) {
                            maskIndex -= offset;
                        }
                    }
                    maskIndex += offset;
                }
                else if (valDigit === lastUntranslatedMaskChar) {
                    lastUntranslatedMaskChar = undefined;
                }
                else if (translation.optional) {
                    maskIndex += offset;
                    valueIndex -= offset;
                }
                else {
                    this.invalidCharacters.push({
                        index: valueIndex,
                        digit: valDigit,
                        translated: translation.pattern
                    });
                }
                valueIndex += offset;
            }
            else {
                if (!skipMaskChars) {
                    buf[addMethod](maskDigit);
                }
                if (valDigit === maskDigit) {
                    valueIndex += offset;
                }
                else {
                    lastUntranslatedMaskChar = maskDigit;
                }
                maskIndex += offset;
            }
            check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        }
        /** @type {?} */
        const lastMaskCharDigit = mask.charAt(lastMaskChar);
        if (maskLen === valueLength + 1 && !this.translationMask[lastMaskCharDigit]) {
            buf.push(lastMaskCharDigit);
        }
        return buf.join('');
    }
    /**
     * @private
     * @param {?} isReversed
     * @param {?} maskIndex
     * @param {?} maskLen
     * @param {?} valueIndex
     * @param {?} valueLength
     * @return {?}
     */
    isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength) {
        /** @type {?} */
        let check = false;
        if (isReversed) {
            check = (maskIndex > -1) && (valueIndex > -1);
        }
        else {
            check = (maskIndex < maskLen) && (valueIndex < valueLength);
        }
        return check;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setValue(value) {
        this.value = value;
    }
    /**
     * @private
     * @return {?}
     */
    getValue() {
        return this.value;
    }
}
InputMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-text-mask], [textMask]',
                providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR]
            },] }
];
/** @nocollapse */
InputMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
InputMaskDirective.propDecorators = {
    inputMask: [{ type: Input, args: ['textMask',] }],
    onTextInput: [{ type: HostListener, args: ['input', ['$event'],] }, { type: HostListener, args: ['keyup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field.params) {
            this.mask = this.field.params['inputMask'];
            this.placeholder = this.field.params['inputMask'] && this.field.params['inputMaskPlaceholder'] ? this.field.params['inputMaskPlaceholder'] : this.field.placeholder;
            this.isMaskReversed = this.field.params['inputMaskReversed'] ? this.field.params['inputMaskReversed'] : false;
        }
    }
}
TextWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'text-widget',
                template: "<div class=\"adf-textfield adf-text-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <mat-form-field>\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               class=\"adf-input\"\n               type=\"text\"\n               [id]=\"field.id\"\n               [required]=\"isRequired()\"\n               [value]=\"field.value\"\n               [(ngModel)]=\"field.value\"\n               (ngModelChange)=\"onFieldChanged(field)\"\n               [disabled]=\"field.readOnly || readOnly\"\n               [textMask]=\"{mask: mask, isReversed: isMaskReversed}\"\n               [placeholder]=\"placeholder\">\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-text-widget{width:100%}"]
            }] }
];
/** @nocollapse */
TextWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TypeaheadWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} logService
     */
    constructor(formService, logService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
        this.minTermLength = 1;
        this.options = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field.form.taskId && this.field.restUrl) {
            this.getValuesByTaskId();
        }
        else if (this.field.form.processDefinitionId && this.field.restUrl) {
            this.getValuesByProcessDefinitionId();
        }
        if (this.isReadOnlyType()) {
            this.value = this.field.value;
        }
    }
    /**
     * @return {?}
     */
    getValuesByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((/**
         * @param {?} formFieldOption
         * @return {?}
         */
        (formFieldOption) => {
            /** @type {?} */
            const options = formFieldOption || [];
            this.field.options = options;
            /** @type {?} */
            const fieldValue = this.field.value;
            if (fieldValue) {
                /** @type {?} */
                const toSelect = options.find((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => item.id === fieldValue || item.name.toLocaleLowerCase() === fieldValue.toLocaleLowerCase()));
                if (toSelect) {
                    this.value = toSelect.name;
                }
            }
            this.onFieldChanged(this.field);
            this.field.updateForm();
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
    }
    /**
     * @return {?}
     */
    getValuesByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((/**
         * @param {?} formFieldOption
         * @return {?}
         */
        (formFieldOption) => {
            /** @type {?} */
            const options = formFieldOption || [];
            this.field.options = options;
            /** @type {?} */
            const fieldValue = this.field.value;
            if (fieldValue) {
                /** @type {?} */
                const toSelect = options.find((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => item.id === fieldValue));
                if (toSelect) {
                    this.value = toSelect.name;
                }
            }
            this.onFieldChanged(this.field);
            this.field.updateForm();
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
    }
    /**
     * @return {?}
     */
    getOptions() {
        /** @type {?} */
        const val = this.value.trim().toLocaleLowerCase();
        return this.field.options.filter((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            /** @type {?} */
            const name = item.name.toLocaleLowerCase();
            return name.indexOf(val) > -1;
        }));
    }
    /**
     * @param {?} optionName
     * @return {?}
     */
    isValidOptionName(optionName) {
        /** @type {?} */
        const option = this.field.options.find((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.name && item.name.toLocaleLowerCase() === optionName.toLocaleLowerCase()));
        return option ? true : false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp(event) {
        if (this.value && this.value.trim().length >= this.minTermLength && this.oldValue !== this.value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                if (this.value.length >= this.minTermLength) {
                    this.options = this.getOptions();
                    this.oldValue = this.value;
                    if (this.isValidOptionName(this.value)) {
                        this.field.value = this.options[0].id;
                    }
                }
            }
        }
        if (this.isValueDefined() && this.value.trim().length === 0) {
            this.oldValue = this.value;
            this.options = [];
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onItemSelect(item) {
        if (item) {
            this.field.value = item.id;
            this.value = item.name;
            this.onFieldChanged(this.field);
        }
    }
    /**
     * @return {?}
     */
    validate() {
        this.field.value = this.value;
    }
    /**
     * @return {?}
     */
    isValueDefined() {
        return this.value !== null && this.value !== undefined;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
    }
    /**
     * @return {?}
     */
    isReadOnlyType() {
        return this.field.type === 'readonly' ? true : false;
    }
}
TypeaheadWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'typeahead-widget',
                template: "<div class=\"adf-typeahead-widget-container\">\n    <div class=\"adf-typeahead-widget {{field.className}}\"\n        [class.is-dirty]=\"value\"\n        [class.adf-invalid]=\"!field.isValid\"\n        [class.adf-readonly]=\"field.readOnly\"\n        id=\"typehead-div\">\n        <mat-form-field>\n            <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}</label>\n            <input matInput class=\"adf-input\"\n                   type=\"text\"\n                   [id]=\"field.id\"\n                   [(ngModel)]=\"value\"\n                   (ngModelChange)=\"validate()\"\n                   (keyup)=\"onKeyUp($event)\"\n                   [disabled]=\"field.readOnly\"\n                   placeholder=\"{{field.placeholder}}\"\n                   [matAutocomplete]=\"auto\">\n            <mat-autocomplete #auto=\"matAutocomplete\" (optionSelected)=\"onItemSelect($event.option.value)\">\n                <mat-option *ngFor=\"let item of options\" [value]=\"item\">\n                    <span [id]=\"field.name+'_option_'+item.id\">{{item.name}}</span>\n                </mat-option>\n            </mat-autocomplete>\n        </mat-form-field>\n\n        <error-widget [error]=\"field.validationSummary\"></error-widget>\n        <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n    </div>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-typeahead-widget-container{position:relative;display:block}.adf-typeahead-widget{width:100%}"]
            }] }
];
/** @nocollapse */
TypeaheadWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessContentService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * @private
     * @return {?}
     */
    get contentApi() {
        return this.apiService.getInstance().activiti.contentApi;
    }
    /**
     * Create temporary related content from an uploaded file.
     * @param {?} file File to use for content
     * @return {?} The created content data
     */
    createTemporaryRawRelatedContent(file) {
        return from(this.contentApi.createTemporaryRawRelatedContent(file))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the metadata for a related content item.
     * @param {?} contentId ID of the content item
     * @return {?} Metadata for the content
     */
    getFileContent(contentId) {
        return from(this.contentApi.getContent(contentId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets raw binary content data for a related content file.
     * @param {?} contentId ID of the related content
     * @return {?} Binary data of the related content
     */
    getFileRawContent(contentId) {
        return from(this.contentApi.getRawContent(contentId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the preview for a related content file.
     * @param {?} contentId ID of the related content
     * @return {?} Binary data of the content preview
     */
    getContentPreview(contentId) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.contentApi.getContentPreview(contentId).then((/**
             * @param {?} result
             * @return {?}
             */
            (result) => {
                observer.next(result);
                observer.complete();
            }), (/**
             * @return {?}
             */
            () => {
                this.contentApi.getRawContent(contentId).then((/**
                 * @param {?} data
                 * @return {?}
                 */
                (data) => {
                    observer.next(data);
                    observer.complete();
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => {
                    observer.error(err);
                    observer.complete();
                }));
            }));
        }));
    }
    /**
     * Gets a URL for direct access to a related content file.
     * @param {?} contentId ID of the related content
     * @return {?} URL to access the content
     */
    getFileRawContentUrl(contentId) {
        return this.contentApi.getRawContentUrl(contentId);
    }
    /**
     * Gets the thumbnail for a related content file.
     * @param {?} contentId ID of the related content
     * @return {?} Binary data of the thumbnail image
     */
    getContentThumbnail(contentId) {
        return from(this.contentApi.getContentThumbnail(contentId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets related content items for a task instance.
     * @param {?} taskId ID of the target task
     * @param {?=} opts Options supported by JS-API
     * @return {?} Metadata for the content
     */
    getTaskRelatedContent(taskId, opts) {
        return from(this.contentApi.getRelatedContentForTask(taskId, opts))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets related content items for a process instance.
     * @param {?} processId ID of the target process
     * @param {?=} opts Options supported by JS-API
     * @return {?} Metadata for the content
     */
    getProcessRelatedContent(processId, opts) {
        return from(this.contentApi.getRelatedContentForProcessInstance(processId, opts))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Deletes related content.
     * @param {?} contentId Identifier of the content to delete
     * @return {?} Null response that notifies when the deletion is complete
     */
    deleteRelatedContent(contentId) {
        return from(this.contentApi.deleteContent(contentId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Associates an uploaded file with a process instance.
     * @param {?} processInstanceId ID of the target process instance
     * @param {?} content File to associate
     * @param {?=} opts Options supported by JS-API
     * @return {?} Details of created content
     */
    createProcessRelatedContent(processInstanceId, content, opts) {
        return from(this.contentApi.createRelatedContentOnProcessInstance(processInstanceId, content, opts))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Associates an uploaded file with a task instance.
     * @param {?} taskId ID of the target task
     * @param {?} file File to associate
     * @param {?=} opts Options supported by JS-API
     * @return {?} Details of created content
     */
    createTaskRelatedContent(taskId, file, opts) {
        return from(this.contentApi.createRelatedContentOnTask(taskId, file, opts))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Creates a JSON representation of data.
     * @param {?} res Object representing data
     * @return {?} JSON object
     */
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    /**
     * Creates a JSON array representation of data.
     * @param {?} res Object representing data
     * @return {?} JSON array object
     */
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    /**
     * Reports an error message.
     * @param {?} error Data object with optional `message` and `status` fields for the error
     * @return {?} Callback when an error occurs
     */
    handleError(error) {
        /** @type {?} */
        let errMsg = ProcessContentService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : ProcessContentService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return throwError(errMsg);
    }
}
ProcessContentService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
ProcessContentService.GENERIC_ERROR_MESSAGE = 'Server error';
ProcessContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ProcessContentService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ ProcessContentService.ngInjectableDef = defineInjectable({ factory: function ProcessContentService_Factory() { return new ProcessContentService(inject(AlfrescoApiService), inject(LogService)); }, token: ProcessContentService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UploadWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} logService
     * @param {?} thumbnailService
     * @param {?} processContentService
     */
    constructor(formService, logService, thumbnailService, processContentService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
        this.processContentService = processContentService;
        this.multipleOption = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field &&
            this.field.value &&
            this.field.value.length > 0) {
            this.hasFile = true;
        }
        this.getMultipleFileParam();
    }
    /**
     * @param {?} file
     * @return {?}
     */
    removeFile(file) {
        if (this.field) {
            this.removeElementFromList(file);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFileChanged(event) {
        /** @type {?} */
        const files = event.target.files;
        /** @type {?} */
        let filesSaved = [];
        if (this.field.json.value) {
            filesSaved = [...this.field.json.value];
        }
        if (files && files.length > 0) {
            from(files)
                .pipe(mergeMap((/**
             * @param {?} file
             * @return {?}
             */
            (file) => this.uploadRawContent(file))))
                .subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => filesSaved.push(res)), (/**
             * @return {?}
             */
            () => this.logService.error('Error uploading file. See console output for more details.')), (/**
             * @return {?}
             */
            () => {
                this.field.value = filesSaved;
                this.field.json.value = filesSaved;
                this.hasFile = true;
            }));
        }
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    uploadRawContent(file) {
        return this.processContentService.createTemporaryRawRelatedContent(file)
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            this.logService.info(response);
            response.contentBlob = file;
            return response;
        })));
    }
    /**
     * @return {?}
     */
    getMultipleFileParam() {
        if (this.field &&
            this.field.params &&
            this.field.params.multiple) {
            this.multipleOption = this.field.params.multiple ? 'multiple' : '';
        }
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    removeElementFromList(file) {
        /** @type {?} */
        const index = this.field.value.indexOf(file);
        if (index !== -1) {
            this.field.value.splice(index, 1);
            this.field.json.value = this.field.value;
            this.field.updateForm();
        }
        this.hasFile = this.field.value.length > 0;
        this.resetFormValueWithNoFiles();
    }
    /**
     * @private
     * @return {?}
     */
    resetFormValueWithNoFiles() {
        if (this.field.value.length === 0) {
            this.field.value = [];
            this.field.json.value = [];
        }
    }
    /**
     * @param {?} mimeType
     * @return {?}
     */
    getIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    /**
     * @param {?} contentLinkModel
     * @return {?}
     */
    fileClicked(contentLinkModel) {
        /** @type {?} */
        const file = new ContentLinkModel(contentLinkModel);
        /** @type {?} */
        let fetch = this.processContentService.getContentPreview(file.id);
        if (file.isTypeImage() || file.isTypePdf()) {
            fetch = this.processContentService.getFileRawContent(file.id);
        }
        fetch.subscribe((/**
         * @param {?} blob
         * @return {?}
         */
        (blob) => {
            file.contentBlob = blob;
            this.formService.formContentClicked.next(file);
        }), (/**
         * @return {?}
         */
        () => {
            this.logService.error('Unable to send event for file ' + file.name);
        }));
    }
}
UploadWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'upload-widget',
                template: "<div class=\"adf-upload-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\"\n     [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n    <div class=\"adf-upload-widget-container\">\n        <div>\n            <mat-list *ngIf=\"hasFile\">\n                <mat-list-item class=\"adf-upload-files-row\" *ngFor=\"let file of field.value\">\n                    <img mat-list-icon class=\"adf-upload-widget__icon\"\n                         [id]=\"'file-'+file.id+'-icon'\"\n                         [src]=\"getIcon(file.mimeType)\"\n                         [alt]=\"mimeTypeIcon\"\n                         (click)=\"fileClicked(file)\"\n                         (keyup.enter)=\"fileClicked(file)\"\n                         role=\"button\"\n                         tabindex=\"0\"/>\n                    <span matLine id=\"{{'file-'+file.id}}\" (click)=\"fileClicked(file)\" (keyup.enter)=\"fileClicked(file)\"\n                          role=\"button\" tabindex=\"0\" class=\"adf-file\">{{file.name}}</span>\n                    <button *ngIf=\"!field.readOnly\" mat-icon-button [id]=\"'file-'+file.id+'-remove'\"\n                            (click)=\"removeFile(file);\" (keyup.enter)=\"removeFile(file);\">\n                        <mat-icon class=\"mat-24\">highlight_off</mat-icon>\n                    </button>\n                </mat-list-item>\n            </mat-list>\n        </div>\n\n        <div class=\"button-row\" *ngIf=\"(!hasFile || multipleOption) && !field.readOnly\">\n            <a mat-raised-button color=\"primary\">\n                {{ 'FORM.FIELD.UPLOAD' | translate }}<mat-icon>file_upload</mat-icon>\n                <input #uploadFiles\n                       [multiple]=\"multipleOption\"\n                       type=\"file\"\n                       [id]=\"field.id\"\n                       (change)=\"onFileChanged($event)\"/>\n            </a>\n        </div>\n    </div>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-upload-widget-container{margin-bottom:15px}.adf-upload-widget-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}.adf-upload-widget{width:100%;word-break:break-all;padding:.4375em 0;border-top:.84375em solid transparent}.adf-upload-widget__icon{padding:6px;float:left;cursor:pointer}.adf-upload-widget__reset{margin-top:-2px}.adf-upload-files-row .mat-line{margin-bottom:0}"]
            }] }
];
/** @nocollapse */
UploadWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService },
    { type: ThumbnailService },
    { type: ProcessContentService }
];
UploadWidgetComponent.propDecorators = {
    fileInput: [{ type: ViewChild, args: ['uploadFiles',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$4 = MOMENT_DATE_FORMATS, ɵ1$2 = MAT_MOMENT_DATETIME_FORMATS;
class DateTimeWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(formService, dateAdapter, userPreferencesService) {
        super(formService);
        this.formService = formService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            this.dateAdapter.setLocale(locale);
        }));
        /** @type {?} */
        const momentDateAdapter = (/** @type {?} */ (this.dateAdapter));
        momentDateAdapter.overrideDisplayFormat = this.field.dateDisplayFormat;
        if (this.field) {
            if (this.field.minValue) {
                this.minDate = moment(this.field.minValue, 'YYYY-MM-DDTHH:mm:ssZ');
            }
            if (this.field.maxValue) {
                this.maxDate = moment(this.field.maxValue, 'YYYY-MM-DDTHH:mm:ssZ');
            }
        }
        this.displayDate = moment(this.field.value, this.field.dateDisplayFormat);
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            this.field.value = newDateValue.value.format(this.field.dateDisplayFormat);
        }
        else if (newDateValue) {
            this.field.value = newDateValue;
        }
        else {
            this.field.value = null;
        }
        this.onFieldChanged(this.field);
    }
}
DateTimeWidgetComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$4 },
                    { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1$2 }
                ],
                selector: 'date-time-widget',
                template: "<div class=\"{{field.className}}\"\n     id=\"data-time-widget\" [class.adf-invalid]=\"!field.isValid\">\n    <mat-form-field class=\"adf-date-time-widget\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}} ({{field.dateDisplayFormat}})<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               [matDatetimepicker]=\"datetimePicker\"\n               [id]=\"field.id\"\n               [(ngModel)]=\"displayDate\"\n               [required]=\"isRequired()\"\n               [disabled]=\"field.readOnly\"\n               [min]=\"minDate\"\n               [max]=\"maxDate\"\n               (focusout)=\"onDateChanged($event.srcElement.value)\"\n               (dateChange)=\"onDateChanged($event)\"\n               placeholder=\"{{field.placeholder}}\">\n        <mat-datetimepicker-toggle matSuffix [for]=\"datetimePicker\" [disabled]=\"field.readOnly\"></mat-datetimepicker-toggle>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n    <mat-datetimepicker #datetimePicker type=\"datetime\" openOnFocus=\"true\" timeInterval=\"5\"></mat-datetimepicker>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-date-time-widget .mat-form-field-suffix{text-align:right;position:absolute;margin-top:30px;width:100%}@media screen and (-ms-high-contrast:active),screen and (-ms-high-contrast:none){.adf-date-widget .mat-form-field-suffix{position:relative;width:auto}}"]
            }] }
];
/** @nocollapse */
DateTimeWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: DateAdapter },
    { type: UserPreferencesService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const WIDGET_DIRECTIVES = [
    UnknownWidgetComponent,
    TabsWidgetComponent,
    ContainerWidgetComponent,
    TextWidgetComponent,
    NumberWidgetComponent,
    CheckboxWidgetComponent,
    MultilineTextWidgetComponentComponent,
    DropdownWidgetComponent,
    HyperlinkWidgetComponent,
    RadioButtonsWidgetComponent,
    DisplayTextWidgetComponentComponent,
    UploadWidgetComponent,
    TypeaheadWidgetComponent,
    FunctionalGroupWidgetComponent,
    PeopleWidgetComponent,
    DateWidgetComponent,
    AmountWidgetComponent,
    DynamicTableWidgetComponent,
    DateEditorComponent,
    DropdownEditorComponent,
    BooleanEditorComponent,
    TextEditorComponent,
    RowEditorComponent,
    ErrorWidgetComponent,
    DocumentWidgetComponent,
    DateTimeWidgetComponent,
    DateTimeEditorComponent
];
/** @type {?} */
const MASK_DIRECTIVE = [
    InputMaskDirective
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FormBaseComponent {
    constructor() {
        /**
         * Toggle rendering of the form title.
         */
        this.showTitle = true;
        /**
         * Toggle rendering of the `Complete` outcome button.
         */
        this.showCompleteButton = true;
        /**
         * If true then the `Complete` outcome button is shown but it will be disabled.
         */
        this.disableCompleteButton = false;
        /**
         * If true then the `Start Process` outcome button is shown but it will be disabled.
         */
        this.disableStartProcessButton = false;
        /**
         * Toggle rendering of the `Save` outcome button.
         */
        this.showSaveButton = true;
        /**
         * Toggle readonly state of the form. Forces all form widgets to render as readonly if enabled.
         */
        this.readOnly = false;
        /**
         * Toggle rendering of the `Refresh` button.
         */
        this.showRefreshButton = true;
        /**
         * Toggle rendering of the validation icon next to the form title.
         */
        this.showValidationIcon = true;
        /**
         * Contains a list of form field validator instances.
         */
        this.fieldValidators = [];
        /**
         * Emitted when the supplied form values have a validation error.
         */
        this.formError = new EventEmitter();
        /**
         * Emitted when any outcome is executed. Default behaviour can be prevented
         * via `event.preventDefault()`.
         */
        this.executeOutcome = new EventEmitter();
        /**
         * Emitted when any error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    getParsedFormDefinition() {
        return this;
    }
    /**
     * @return {?}
     */
    hasForm() {
        return this.form ? true : false;
    }
    /**
     * @return {?}
     */
    isTitleEnabled() {
        /** @type {?} */
        let titleEnabled = false;
        if (this.showTitle && this.form) {
            titleEnabled = true;
        }
        return titleEnabled;
    }
    /**
     * @param {?} outcomeName
     * @return {?}
     */
    getColorForOutcome(outcomeName) {
        return outcomeName === FormBaseComponent.COMPLETE_OUTCOME_NAME ? FormBaseComponent.COMPLETE_BUTTON_COLOR : '';
    }
    /**
     * @param {?} outcome
     * @return {?}
     */
    isOutcomeButtonEnabled(outcome) {
        if (this.form.readOnly) {
            return false;
        }
        if (outcome) {
            // Make 'Save' button always available
            if (outcome.name === FormOutcomeModel.SAVE_ACTION) {
                return true;
            }
            if (outcome.name === FormOutcomeModel.COMPLETE_ACTION) {
                return this.disableCompleteButton ? false : this.form.isValid;
            }
            if (outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
                return this.disableStartProcessButton ? false : this.form.isValid;
            }
            return this.form.isValid;
        }
        return false;
    }
    /**
     * @param {?} outcome
     * @param {?} isFormReadOnly
     * @return {?}
     */
    isOutcomeButtonVisible(outcome, isFormReadOnly) {
        if (outcome && outcome.name) {
            if (outcome.name === FormOutcomeModel.COMPLETE_ACTION) {
                return this.showCompleteButton;
            }
            if (isFormReadOnly) {
                return outcome.isSelected;
            }
            if (outcome.name === FormOutcomeModel.SAVE_ACTION) {
                return this.showSaveButton;
            }
            if (outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
                return false;
            }
            return true;
        }
        return false;
    }
    /**
     * Invoked when user clicks outcome button.
     * @param {?} outcome Form outcome model
     * @return {?}
     */
    onOutcomeClicked(outcome) {
        if (!this.readOnly && outcome && this.form) {
            if (!this.onExecuteOutcome(outcome)) {
                return false;
            }
            if (outcome.isSystem) {
                if (outcome.id === FormBaseComponent.SAVE_OUTCOME_ID) {
                    this.saveTaskForm();
                    return true;
                }
                if (outcome.id === FormBaseComponent.COMPLETE_OUTCOME_ID) {
                    this.completeTaskForm();
                    return true;
                }
                if (outcome.id === FormBaseComponent.START_PROCESS_OUTCOME_ID) {
                    this.completeTaskForm();
                    return true;
                }
                if (outcome.id === FormBaseComponent.CUSTOM_OUTCOME_ID) {
                    this.onTaskSaved(this.form);
                    this.storeFormAsMetadata();
                    return true;
                }
            }
            else {
                // Note: Activiti is using NAME field rather than ID for outcomes
                if (outcome.name) {
                    this.onTaskSaved(this.form);
                    this.completeTaskForm(outcome.name);
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * @param {?} err
     * @return {?}
     */
    handleError(err) {
        this.error.emit(err);
    }
}
FormBaseComponent.SAVE_OUTCOME_ID = '$save';
FormBaseComponent.COMPLETE_OUTCOME_ID = '$complete';
FormBaseComponent.START_PROCESS_OUTCOME_ID = '$startProcess';
FormBaseComponent.CUSTOM_OUTCOME_ID = '$custom';
FormBaseComponent.COMPLETE_BUTTON_COLOR = 'primary';
FormBaseComponent.COMPLETE_OUTCOME_NAME = 'COMPLETE';
FormBaseComponent.propDecorators = {
    path: [{ type: Input }],
    nameNode: [{ type: Input }],
    showTitle: [{ type: Input }],
    showCompleteButton: [{ type: Input }],
    disableCompleteButton: [{ type: Input }],
    disableStartProcessButton: [{ type: Input }],
    showSaveButton: [{ type: Input }],
    readOnly: [{ type: Input }],
    showRefreshButton: [{ type: Input }],
    showValidationIcon: [{ type: Input }],
    fieldValidators: [{ type: Input }],
    formError: [{ type: Output }],
    executeOutcome: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormListComponent {
    /**
     * @param {?} formService
     */
    constructor(formService) {
        this.formService = formService;
        /**
         * The array that contains the information to show inside the list.
         */
        this.forms = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.getForms();
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.forms && this.forms.length === 0;
    }
    /**
     * @return {?}
     */
    getForms() {
        this.formService.getForms().subscribe((/**
         * @param {?} forms
         * @return {?}
         */
        (forms) => {
            this.forms.push(...forms);
        }));
    }
}
FormListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-list',
                template: "<adf-datatable *ngIf=\"!isEmpty()\"\n    [rows]=\"forms\">\n    <data-columns>\n        <data-column key=\"name\" type=\"text\" title=\"Name\" class=\"adf-ellipsis-cell\" [sortable]=\"true\"></data-column>\n        <data-column key=\"lastUpdatedByFullName\" type=\"text\" title=\"User\" class=\"adf-ellipsis-cell\" [sortable]=\"true\"></data-column>\n        <data-column key=\"lastUpdated\" type=\"date\" format=\"shortDate\" title=\"Date\"></data-column>\n    </data-columns>\n</adf-datatable>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
FormListComponent.ctorParameters = () => [
    { type: FormService }
];
FormListComponent.propDecorators = {
    forms: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentWidgetComponent {
    /**
     * @param {?} formService
     * @param {?} logService
     * @param {?} contentService
     * @param {?} processContentService
     */
    constructor(formService, logService, contentService, processContentService) {
        this.formService = formService;
        this.logService = logService;
        this.contentService = contentService;
        this.processContentService = processContentService;
        /**
         * Toggles showing document content.
         */
        this.showDocumentContent = true;
        /**
         * Emitted when the content is clicked.
         */
        this.contentClick = new EventEmitter();
        /**
         * Emitted when the thumbnail has loaded.
         */
        this.thumbnailLoaded = new EventEmitter();
        /**
         * Emitted when the content has loaded.
         */
        this.contentLoaded = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const contentId = changes['id'];
        if (contentId && contentId.currentValue) {
            this.loadContent(contentId.currentValue);
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    loadContent(id) {
        this.processContentService
            .getFileContent(id)
            .subscribe((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            this.content = new ContentLinkModel(response);
            this.contentLoaded.emit(this.content);
            this.loadThumbnailUrl(this.content);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
        }));
    }
    /**
     * @param {?} content
     * @return {?}
     */
    loadThumbnailUrl(content) {
        if (this.content.isThumbnailSupported()) {
            /** @type {?} */
            let observable;
            if (this.content.isTypeImage()) {
                observable = this.processContentService.getFileRawContent(content.id);
            }
            else {
                observable = this.processContentService.getContentThumbnail(content.id);
            }
            if (observable) {
                observable.subscribe((/**
                 * @param {?} response
                 * @return {?}
                 */
                (response) => {
                    this.content.thumbnailUrl = this.contentService.createTrustedUrl(response);
                    this.thumbnailLoaded.emit(this.content.thumbnailUrl);
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                (error) => {
                    this.error.emit(error);
                }));
            }
        }
    }
    /**
     * @param {?} content
     * @return {?}
     */
    openViewer(content) {
        /** @type {?} */
        let fetch = this.processContentService.getContentPreview(content.id);
        if (content.isTypeImage() || content.isTypePdf()) {
            fetch = this.processContentService.getFileRawContent(content.id);
        }
        fetch.subscribe((/**
         * @param {?} blob
         * @return {?}
         */
        (blob) => {
            content.contentBlob = blob;
            this.contentClick.emit(content);
            this.logService.info('Content clicked' + content.id);
            this.formService.formContentClicked.next(content);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
        }));
    }
    /**
     * Invoke content download.
     * @param {?} content
     * @return {?}
     */
    download(content) {
        this.processContentService.getFileRawContent(content.id).subscribe((/**
         * @param {?} blob
         * @return {?}
         */
        (blob) => this.contentService.downloadBlob(blob, content.name)), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
        }));
    }
}
ContentWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content',
                template: "<mat-card class=\"adf-content-container\" *ngIf=\"content\">\n    <mat-card-content *ngIf=\"showDocumentContent\">\n        <div *ngIf=\"content.isThumbnailSupported()\" >\n            <img id=\"thumbnailPreview\" class=\"adf-img-upload-widget\" [src]=\"content.thumbnailUrl\" alt=\"{{content.name}}\">\n        </div>\n        <div *ngIf=\"!content.isThumbnailSupported()\">\n            <mat-icon>image</mat-icon>\n            <div id=\"unsupported-thumbnail\" class=\"adf-content-widget-preview-text\">{{ 'FORM.PREVIEW.IMAGE_NOT_AVAILABLE' | translate }}\n            </div>\n        </div>\n        <div class=\"mdl-card__supporting-text upload-widget__content-text\">{{content.name}}</div>\n    </mat-card-content>\n\n    <mat-card-actions>\n        <button mat-icon-button id=\"view\" (click)=\"openViewer(content)\">\n            <mat-icon class=\"mat-24\">zoom_in</mat-icon>\n        </button>\n        <button mat-icon-button id=\"download\" (click)=\"download(content)\">\n            <mat-icon class=\"mat-24\">file_download</mat-icon>\n        </button>\n    </mat-card-actions>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-img-upload-widget{width:100%;height:100%;border:1px solid rgba(117,117,117,.57);box-shadow:1px 1px 2px #ddd;background-color:#fff}.adf-content-widget-preview-text{word-wrap:break-word;word-break:break-all;text-align:center}"]
            }] }
];
/** @nocollapse */
ContentWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService },
    { type: ContentService },
    { type: ProcessContentService }
];
ContentWidgetComponent.propDecorators = {
    id: [{ type: Input }],
    showDocumentContent: [{ type: Input }],
    contentClick: [{ type: Output }],
    thumbnailLoaded: [{ type: Output }],
    contentLoaded: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormRendererComponent {
    constructor() {
        /**
         * Toggle debug options.
         */
        this.showDebugButton = false;
    }
}
FormRendererComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-renderer',
                template: "<div class=\"{{formDefinition.className}}\" [ngClass]=\"{'adf-readonly-form': formDefinition.readOnly }\">\n    <div *ngIf=\"formDefinition.hasTabs()\">\n        <tabs-widget [tabs]=\"formDefinition.tabs\"></tabs-widget>\n    </div>\n\n    <div *ngIf=\"!formDefinition.hasTabs() && formDefinition.hasFields()\">\n        <div *ngFor=\"let field of formDefinition.fields\">\n            <adf-form-field [field]=\"field.field\"></adf-form-field>\n        </div>\n    </div>\n</div>\n<!--\nFor debugging and data visualisation purposes,\nwill be removed during future revisions\n-->\n<div *ngIf=\"showDebugButton\" class=\"adf-form-debug-container\">\n    <mat-slide-toggle [(ngModel)]=\"debugMode\">Debug mode</mat-slide-toggle>\n    <div *ngIf=\"debugMode\">\n        <h4>Values</h4>\n        <pre>{{formDefinition.values | json}}</pre>\n\n        <h4>Form</h4>\n        <pre>{{formDefinition.json | json}}</pre>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
FormRendererComponent.propDecorators = {
    showDebugButton: [{ type: Input }],
    formDefinition: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActivitiContentService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Returns a list of child nodes below the specified folder
     *
     * @param {?} accountId
     * @param {?} folderId
     * @return {?}
     */
    getAlfrescoNodes(accountId, folderId) {
        /** @type {?} */
        const apiService = this.apiService.getInstance();
        /** @type {?} */
        const accountShortId = accountId.replace('alfresco-', '');
        return from(apiService.activiti.alfrescoApi.getContentInFolder(accountShortId, folderId))
            .pipe(map(this.toJsonArray), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Returns a list of all the repositories configured
     *
     * @param {?} tenantId
     * @param {?} includeAccount
     * @return {?}
     */
    getAlfrescoRepositories(tenantId, includeAccount) {
        /** @type {?} */
        const apiService = this.apiService.getInstance();
        /** @type {?} */
        const opts = {
            tenantId: tenantId,
            includeAccounts: includeAccount
        };
        return from(apiService.activiti.alfrescoApi.getRepositories(opts))
            .pipe(map(this.toJsonArray), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Returns a list of child nodes below the specified folder
     *
     * @param {?} accountId
     * @param {?} node
     * @param {?} siteId
     * @return {?}
     */
    linkAlfrescoNode(accountId, node, siteId) {
        /** @type {?} */
        const apiService = this.apiService.getInstance();
        return from(apiService.activiti.contentApi.createTemporaryRelatedContent({
            link: true,
            name: node.title,
            simpleType: node.simpleType,
            source: accountId,
            sourceId: node.id + '@' + siteId
        }))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @param {?} node
     * @param {?} siteId
     * @param {?} accountId
     * @return {?}
     */
    applyAlfrescoNode(node, siteId, accountId) {
        /** @type {?} */
        const apiService = this.apiService.getInstance();
        /** @type {?} */
        const currentSideId = siteId ? siteId : this.getSiteNameFromNodePath(node);
        /** @type {?} */
        const params = {
            source: accountId,
            mimeType: node.content.mimeType,
            sourceId: node.id + ';' + node.properties['cm:versionLabel'] + '@' + currentSideId,
            name: node.name,
            link: false
        };
        return from(apiService.activiti.contentApi.createTemporaryRelatedContent(params))
            .pipe(map(this.toJson), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getSiteNameFromNodePath(node) {
        /** @type {?} */
        let siteName = '';
        if (node.path) {
            /** @type {?} */
            const foundNode = node.path
                .elements.find((/**
             * @param {?} pathNode
             * @return {?}
             */
            (pathNode) => pathNode.nodeType === 'st:site' &&
                pathNode.name !== 'Sites'));
            siteName = foundNode ? foundNode.name : '';
        }
        return siteName.toLocaleLowerCase();
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    /**
     * @param {?} res
     * @return {?}
     */
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        /** @type {?} */
        let errMsg = ActivitiContentService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : ActivitiContentService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return throwError(errMsg);
    }
}
ActivitiContentService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
ActivitiContentService.GENERIC_ERROR_MESSAGE = 'Server error';
ActivitiContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ActivitiContentService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ ActivitiContentService.ngInjectableDef = defineInjectable({ factory: function ActivitiContentService_Factory() { return new ActivitiContentService(inject(AlfrescoApiService), inject(LogService)); }, token: ActivitiContentService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormRenderingService extends DynamicComponentMapper {
    constructor() {
        super();
        this.defaultValue = UnknownWidgetComponent;
        this.types = {
            'text': DynamicComponentResolver.fromType(TextWidgetComponent),
            'string': DynamicComponentResolver.fromType(TextWidgetComponent),
            'integer': DynamicComponentResolver.fromType(NumberWidgetComponent),
            'multi-line-text': DynamicComponentResolver.fromType(MultilineTextWidgetComponentComponent),
            'boolean': DynamicComponentResolver.fromType(CheckboxWidgetComponent),
            'dropdown': DynamicComponentResolver.fromType(DropdownWidgetComponent),
            'date': DynamicComponentResolver.fromType(DateWidgetComponent),
            'amount': DynamicComponentResolver.fromType(AmountWidgetComponent),
            'radio-buttons': DynamicComponentResolver.fromType(RadioButtonsWidgetComponent),
            'hyperlink': DynamicComponentResolver.fromType(HyperlinkWidgetComponent),
            'readonly-text': DynamicComponentResolver.fromType(DisplayTextWidgetComponentComponent),
            'typeahead': DynamicComponentResolver.fromType(TypeaheadWidgetComponent),
            'people': DynamicComponentResolver.fromType(PeopleWidgetComponent),
            'functional-group': DynamicComponentResolver.fromType(FunctionalGroupWidgetComponent),
            'dynamic-table': DynamicComponentResolver.fromType(DynamicTableWidgetComponent),
            'container': DynamicComponentResolver.fromType(ContainerWidgetComponent),
            'group': DynamicComponentResolver.fromType(ContainerWidgetComponent),
            'document': DynamicComponentResolver.fromType(DocumentWidgetComponent),
            'upload': DynamicComponentResolver.fromType(UploadWidgetComponent),
            'datetime': DynamicComponentResolver.fromType(DateTimeWidgetComponent)
        };
    }
}
FormRenderingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FormRenderingService.ctorParameters = () => [];
/** @nocollapse */ FormRenderingService.ngInjectableDef = defineInjectable({ factory: function FormRenderingService_Factory() { return new FormRenderingService(); }, token: FormRenderingService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeMetadata {
    /**
     * @param {?} metadata
     * @param {?} nodeType
     */
    constructor(metadata, nodeType) {
        this.metadata = metadata;
        this.nodeType = nodeType;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodeService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * Get the metadata and the nodeType for a nodeId cleaned by the prefix.
     * @param {?} nodeId ID of the target node
     * @return {?} Node metadata
     */
    getNodeMetadata(nodeId) {
        return from(this.apiService.getInstance().nodes.getNode(nodeId))
            .pipe(map(this.cleanMetadataFromSemicolon));
    }
    /**
     * Create a new Node from form metadata.
     * @param {?} nodeType Node type
     * @param {?} nameSpace Namespace for properties
     * @param {?} data Property data to store in the node under namespace
     * @param {?} path Path to the node
     * @param {?=} name Node name
     * @return {?} The created node
     */
    createNodeMetadata(nodeType, nameSpace, data, path, name) {
        /** @type {?} */
        const properties = {};
        for (const key in data) {
            if (data[key]) {
                properties[nameSpace + ':' + key] = data[key];
            }
        }
        return this.createNode(name || this.generateUuid(), nodeType, properties, path);
    }
    /**
     * Create a new Node from form metadata
     * @param {?} name Node name
     * @param {?} nodeType Node type
     * @param {?} properties Node body properties
     * @param {?} path Path to the node
     * @return {?} The created node
     */
    createNode(name, nodeType, properties, path) {
        /** @type {?} */
        const body = {
            name: name,
            nodeType: nodeType,
            properties: properties,
            relativePath: path
        };
        /** @type {?} */
        const apiService = this.apiService.getInstance();
        return from(apiService.nodes.addNode('-root-', body, {}));
    }
    /**
     * @private
     * @return {?}
     */
    generateUuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (/**
         * @param {?} c
         * @return {?}
         */
        function (c) {
            /** @type {?} */
            const r = Math.random() * 16 | 0;
            /** @type {?} */
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        }));
    }
    /**
     * @private
     * @param {?} nodeEntry
     * @return {?}
     */
    cleanMetadataFromSemicolon(nodeEntry) {
        /** @type {?} */
        const metadata = {};
        if (nodeEntry && nodeEntry.entry.properties) {
            for (const key in nodeEntry.entry.properties) {
                if (key) {
                    if (key.indexOf(':') !== -1) {
                        metadata[key.split(':')[1]] = nodeEntry.entry.properties[key];
                    }
                    else {
                        metadata[key] = nodeEntry.entry.properties[key];
                    }
                }
            }
        }
        return new NodeMetadata(metadata, nodeEntry.entry.nodeType);
    }
}
NodeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NodeService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ NodeService.ngInjectableDef = defineInjectable({ factory: function NodeService_Factory() { return new NodeService(inject(AlfrescoApiService)); }, token: NodeService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormErrorEvent extends FormEvent {
    /**
     * @param {?} form
     * @param {?} error
     */
    constructor(form, error) {
        super(form);
        this.error = error;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class StartFormCustomButtonDirective {
}
StartFormCustomButtonDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-form-custom-button], [form-custom-button]' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormFieldComponent {
    /**
     * @param {?} formRenderingService
     * @param {?} componentFactoryResolver
     * @param {?} visibilityService
     * @param {?} compiler
     */
    constructor(formRenderingService, componentFactoryResolver, visibilityService, compiler) {
        this.formRenderingService = formRenderingService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.visibilityService = visibilityService;
        this.compiler = compiler;
        /**
         * Contains all the necessary data needed to determine what UI Widget
         * to use when rendering the field in the form. You would typically not
         * create this data manually but instead create the form in APS and export
         * it to get to all the `FormFieldModel` definitions.
         */
        this.field = null;
        this.focus = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const w = window;
        if (w.adf === undefined) {
            w.adf = {};
        }
        /** @type {?} */
        const originalField = this.getField();
        if (originalField) {
            /** @type {?} */
            const customTemplate = this.field.form.customFieldTemplates[originalField.type];
            if (customTemplate && this.hasController(originalField.type)) {
                /** @type {?} */
                const factory = this.getComponentFactorySync(originalField.type, customTemplate);
                this.componentRef = this.container.createComponent(factory);
                /** @type {?} */
                const instance = this.componentRef.instance;
                if (instance) {
                    instance.field = originalField;
                }
            }
            else {
                /** @type {?} */
                const componentType = this.formRenderingService.resolveComponentType(originalField);
                if (componentType) {
                    /** @type {?} */
                    const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
                    this.componentRef = this.container.createComponent(factory);
                    /** @type {?} */
                    const instance = (/** @type {?} */ (this.componentRef.instance));
                    instance.field = this.field;
                    instance.fieldChanged.subscribe((/**
                     * @param {?} field
                     * @return {?}
                     */
                    (field) => {
                        if (field && this.field.form) {
                            this.visibilityService.refreshVisibility(field.form);
                            field.form.onFormFieldChanged(field);
                        }
                    }));
                }
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    getField() {
        if (this.field && this.field.params) {
            /** @type {?} */
            const wrappedField = this.field.params.field;
            if (wrappedField && wrappedField.type) {
                return wrappedField;
            }
        }
        return this.field;
    }
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    hasController(type) {
        return (adf && adf.components && adf.components[type]);
    }
    /**
     * @private
     * @param {?} type
     * @param {?} template
     * @return {?}
     */
    getComponentFactorySync(type, template) {
        /** @type {?} */
        const componentInfo = adf.components[type];
        if (componentInfo.factory) {
            return componentInfo.factory;
        }
        /** @type {?} */
        const metadata = {
            selector: `runtime-component-${type}`,
            template: template
        };
        /** @type {?} */
        const factory = this.createComponentFactorySync(this.compiler, metadata, componentInfo.class);
        componentInfo.factory = factory;
        return factory;
    }
    /**
     * @private
     * @param {?} compiler
     * @param {?} metadata
     * @param {?} componentClass
     * @return {?}
     */
    createComponentFactorySync(compiler, metadata, componentClass) {
        /** @type {?} */
        const cmpClass = componentClass || class RuntimeComponent {
        };
        /** @type {?} */
        const decoratedCmp = Component(metadata)(cmpClass);
        class RuntimeComponentModule {
        }
        RuntimeComponentModule.decorators = [
            { type: NgModule, args: [{ imports: [], declarations: [decoratedCmp] },] },
        ];
        /** @type {?} */
        const module = compiler.compileModuleAndAllComponentsSync(RuntimeComponentModule);
        return module.componentFactories.find((/**
         * @param {?} x
         * @return {?}
         */
        (x) => x.componentType === decoratedCmp));
    }
    /**
     * @return {?}
     */
    focusToggle() {
        this.focus = !this.focus;
    }
}
FormFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-field',
                template: `
        <div [id]="'field-'+field?.id+'-container'"
            [hidden]="!field?.isVisible"
            [class.adf-focus]="focus"
            (focusin)="focusToggle()"
            (focusout)="focusToggle()">
            <div #container></div>
        </div>
    `,
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
FormFieldComponent.ctorParameters = () => [
    { type: FormRenderingService },
    { type: ComponentFactoryResolver },
    { type: WidgetVisibilityService },
    { type: Compiler }
];
FormFieldComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],
    field: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormBaseModule {
}
FormBaseModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    DataTableModule,
                    HttpClientModule,
                    MaterialModule,
                    TranslateModule.forChild(),
                    FormsModule,
                    ReactiveFormsModule,
                    DataColumnModule,
                    PipeModule,
                    MatDatetimepickerModule,
                    MatNativeDatetimeModule
                ],
                declarations: [
                    ContentWidgetComponent,
                    FormFieldComponent,
                    FormListComponent,
                    FormRendererComponent,
                    StartFormCustomButtonDirective,
                    ...WIDGET_DIRECTIVES,
                    ...MASK_DIRECTIVE,
                    WidgetComponent
                ],
                entryComponents: [
                    ...WIDGET_DIRECTIVES
                ],
                exports: [
                    ContentWidgetComponent,
                    FormFieldComponent,
                    FormListComponent,
                    FormRendererComponent,
                    StartFormCustomButtonDirective,
                    ...WIDGET_DIRECTIVES
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidenavLayoutContentDirective {
}
SidenavLayoutContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-sidenav-layout-content'
            },] }
];
SidenavLayoutContentDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidenavLayoutHeaderDirective {
}
SidenavLayoutHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-sidenav-layout-header'
            },] }
];
SidenavLayoutHeaderDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidenavLayoutNavigationDirective {
}
SidenavLayoutNavigationDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-sidenav-layout-navigation'
            },] }
];
SidenavLayoutNavigationDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidenavLayoutComponent {
    /**
     * @param {?} mediaMatcher
     */
    constructor(mediaMatcher) {
        this.mediaMatcher = mediaMatcher;
        /**
         * The direction of the layout. 'ltr' or 'rtl'
         */
        this.direction = 'ltr';
        /**
         * The side that the drawer is attached to. Possible values are 'start' and 'end'.
         */
        this.position = 'start';
        /**
         * Toggles showing/hiding the navigation region.
         */
        this.hideSidenav = false;
        /**
         * Should the navigation region be expanded initially?
         */
        this.expandedSidenav = true;
        /**
         * Emitted when the menu toggle and the collapsed/expanded state of the sideNav changes.
         */
        this.expanded = new EventEmitter();
        this.templateContext = {
            toggleMenu: (/**
             * @return {?}
             */
            () => { }),
            isMenuMinimized: (/**
             * @return {?}
             */
            () => this.isMenuMinimized)
        };
        this.onMediaQueryChange = this.onMediaQueryChange.bind(this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const initialMenuState = !this.expandedSidenav;
        this.menuOpenStateSubject = new BehaviorSubject(initialMenuState);
        this.menuOpenState$ = this.menuOpenStateSubject.asObservable();
        /** @type {?} */
        const stepOver = this.stepOver || SidenavLayoutComponent.STEP_OVER;
        this.isMenuMinimized = initialMenuState;
        this.mediaQueryList = this.mediaMatcher.matchMedia(`(max-width: ${stepOver}px)`);
        this.mediaQueryList.addListener(this.onMediaQueryChange);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.templateContext.toggleMenu = this.toggleMenu.bind(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.mediaQueryList.removeListener(this.onMediaQueryChange);
    }
    /**
     * @return {?}
     */
    toggleMenu() {
        if (!this.mediaQueryList.matches) {
            this.isMenuMinimized = !this.isMenuMinimized;
        }
        else {
            this.isMenuMinimized = false;
        }
        this.container.toggleMenu();
        this.expanded.emit(!this.isMenuMinimized);
    }
    /**
     * @return {?}
     */
    get isMenuMinimized() {
        return this._isMenuMinimized;
    }
    /**
     * @param {?} menuState
     * @return {?}
     */
    set isMenuMinimized(menuState) {
        this._isMenuMinimized = menuState;
        this.menuOpenStateSubject.next(!menuState);
    }
    /**
     * @return {?}
     */
    get isHeaderInside() {
        return this.mediaQueryList.matches;
    }
    /**
     * @return {?}
     */
    get headerTemplate() {
        return this.headerDirective && this.headerDirective.template || this.emptyTemplate;
    }
    /**
     * @return {?}
     */
    get navigationTemplate() {
        return this.navigationDirective && this.navigationDirective.template || this.emptyTemplate;
    }
    /**
     * @return {?}
     */
    get contentTemplate() {
        return this.contentDirective && this.contentDirective.template || this.emptyTemplate;
    }
    /**
     * @return {?}
     */
    onMediaQueryChange() {
        this.isMenuMinimized = false;
        this.expanded.emit(!this.isMenuMinimized);
    }
}
SidenavLayoutComponent.STEP_OVER = 600;
SidenavLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sidenav-layout',
                template: "<div [dir]=\"direction\" class=\"adf-sidenav-layout-full-space\">\n    <ng-container *ngIf=\"!isHeaderInside\">\n        <ng-container class=\"adf-sidenav-layout-outer-header\"\n                      *ngTemplateOutlet=\"headerTemplate; context:templateContext\"></ng-container>\n    </ng-container>\n\n    <adf-layout-container #container\n                          [position]=\"position\"\n                          [sidenavMin]=\"sidenavMin\"\n                          [sidenavMax]=\"sidenavMax\"\n                          [mediaQueryList]=\"mediaQueryList\"\n                          [hideSidenav]=\"hideSidenav\"\n                          [expandedSidenav]=\"expandedSidenav\"\n                          data-automation-id=\"adf-layout-container\"\n                          class=\"adf-layout__content\">\n\n        <ng-container app-layout-navigation\n                      *ngTemplateOutlet=\"navigationTemplate; context:templateContext\"></ng-container>\n\n        <ng-container app-layout-content>\n            <ng-container *ngIf=\"isHeaderInside\">\n                <ng-container *ngTemplateOutlet=\"headerTemplate; context:templateContext\"></ng-container>\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"contentTemplate; context:templateContext\"></ng-container>\n        </ng-container>\n    </adf-layout-container>\n\n    <ng-template #emptyTemplate></ng-template>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-sidenav-layout' },
                styles: [""]
            }] }
];
/** @nocollapse */
SidenavLayoutComponent.ctorParameters = () => [
    { type: MediaMatcher }
];
SidenavLayoutComponent.propDecorators = {
    direction: [{ type: Input }],
    position: [{ type: Input }],
    sidenavMin: [{ type: Input }],
    sidenavMax: [{ type: Input }],
    stepOver: [{ type: Input }],
    hideSidenav: [{ type: Input }],
    expandedSidenav: [{ type: Input }],
    expanded: [{ type: Output }],
    headerDirective: [{ type: ContentChild, args: [SidenavLayoutHeaderDirective,] }],
    navigationDirective: [{ type: ContentChild, args: [SidenavLayoutNavigationDirective,] }],
    contentDirective: [{ type: ContentChild, args: [SidenavLayoutContentDirective,] }],
    container: [{ type: ViewChild, args: ['container',] }],
    emptyTemplate: [{ type: ViewChild, args: ['emptyTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const sidenavAnimation = trigger('sidenavAnimation', [
    state('expanded', style({ width: '{{ width }}px' }), { params: { width: 0 } }),
    state('compact', style({ width: '{{ width }}px' }), { params: { width: 0 } }),
    transition('compact <=> expanded', animate('0.4s cubic-bezier(0.25, 0.8, 0.25, 1)'))
]);
/** @type {?} */
const contentAnimationLeft = trigger('contentAnimationLeft', [
    state('expanded', style({ 'margin-left': '{{ margin }}px' }), { params: { margin: 0 } }),
    state('compact', style({ 'margin-left': '{{ margin }}px' }), { params: { margin: 0 } }),
    transition('expanded <=> compact', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))
]);
/** @type {?} */
const contentAnimationRight = trigger('contentAnimationRight', [
    state('expanded', style({ 'margin-right': '{{ margin }}px' }), { params: { margin: 0 } }),
    state('compact', style({ 'margin-right': '{{ margin }}px' }), { params: { margin: 0 } }),
    transition('expanded <=> compact', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayoutContainerComponent {
    constructor() {
        this.hideSidenav = false;
        this.expandedSidenav = true;
        /**
         * The side that the drawer is attached to 'start' | 'end' page
         */
        this.position = 'start';
        this.SIDENAV_STATES = { MOBILE: {}, EXPANDED: {}, COMPACT: {} };
        this.CONTENT_STATES = { MOBILE: {}, EXPANDED: {}, COMPACT: {} };
        this.onMediaQueryChange = this.onMediaQueryChange.bind(this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.SIDENAV_STATES.MOBILE = { value: 'expanded', params: { width: this.sidenavMax } };
        this.SIDENAV_STATES.EXPANDED = { value: 'expanded', params: { width: this.sidenavMax } };
        this.SIDENAV_STATES.COMPACT = { value: 'compact', params: { width: this.sidenavMin } };
        this.CONTENT_STATES.MOBILE = { value: 'expanded', params: { margin: 0 } };
        this.CONTENT_STATES.EXPANDED = { value: 'expanded', params: { margin: this.sidenavMin } };
        this.CONTENT_STATES.COMPACT = { value: 'compact', params: { margin: this.sidenavMax } };
        this.mediaQueryList.addListener(this.onMediaQueryChange);
        if (this.isMobileScreenSize) {
            this.sidenavAnimationState = this.SIDENAV_STATES.MOBILE;
            this.contentAnimationState = this.CONTENT_STATES.MOBILE;
        }
        else if (this.expandedSidenav) {
            this.sidenavAnimationState = this.SIDENAV_STATES.EXPANDED;
            this.contentAnimationState = this.CONTENT_STATES.COMPACT;
        }
        else {
            this.sidenavAnimationState = this.SIDENAV_STATES.COMPACT;
            this.contentAnimationState = this.CONTENT_STATES.EXPANDED;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.mediaQueryList.removeListener(this.onMediaQueryChange);
    }
    /**
     * @return {?}
     */
    toggleMenu() {
        if (this.isMobileScreenSize) {
            this.sidenav.toggle();
        }
        else {
            this.sidenavAnimationState = this.toggledSidenavAnimation;
            this.contentAnimationState = this.toggledContentAnimation;
        }
    }
    /**
     * @private
     * @return {?}
     */
    get toggledSidenavAnimation() {
        return this.sidenavAnimationState === this.SIDENAV_STATES.EXPANDED
            ? this.SIDENAV_STATES.COMPACT
            : this.SIDENAV_STATES.EXPANDED;
    }
    /**
     * @private
     * @return {?}
     */
    get toggledContentAnimation() {
        if (this.isMobileScreenSize) {
            return this.CONTENT_STATES.MOBILE;
        }
        if (this.sidenavAnimationState === this.SIDENAV_STATES.EXPANDED) {
            return this.CONTENT_STATES.COMPACT;
        }
        else {
            return this.CONTENT_STATES.EXPANDED;
        }
    }
    /**
     * @return {?}
     */
    get isMobileScreenSize() {
        return this.mediaQueryList.matches;
    }
    /**
     * @private
     * @return {?}
     */
    onMediaQueryChange() {
        this.sidenavAnimationState = this.SIDENAV_STATES.EXPANDED;
        this.contentAnimationState = this.toggledContentAnimation;
    }
    /**
     * @return {?}
     */
    getContentAnimationStateLeft() {
        if (this.position === 'start') {
            return this.contentAnimationState;
        }
        else {
            return { value: 'compact', params: { width: this.sidenavMin } };
        }
    }
    /**
     * @return {?}
     */
    getContentAnimationStateRight() {
        if (this.position === 'end') {
            return this.contentAnimationState;
        }
        else {
            return { value: 'compact', params: { width: this.sidenavMin } };
        }
    }
}
LayoutContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-layout-container',
                template: "<mat-sidenav-container>\n    <mat-sidenav\n        [position]=\"position\"\n        [disableClose]=\"!isMobileScreenSize\"\n        [ngClass]=\"{ 'adf-sidenav--hidden': hideSidenav }\"\n        [@sidenavAnimation]=\"sidenavAnimationState\"\n        [opened]=\"!isMobileScreenSize\"\n        [mode]=\"isMobileScreenSize ? 'over' : 'side'\">\n        <ng-content sidenav select=\"[app-layout-navigation]\"></ng-content>\n    </mat-sidenav>\n\n    <div>\n        <div class=\"adf-rtl-container-alignment adf-container-full-width\" [@contentAnimationLeft]=\"getContentAnimationStateLeft()\" [@contentAnimationRight]=\"getContentAnimationStateRight()\">\n            <ng-content select=\"[app-layout-content]\"></ng-content>\n        </div>\n    </div>\n</mat-sidenav-container>\n",
                encapsulation: ViewEncapsulation.None,
                animations: [sidenavAnimation, contentAnimationLeft, contentAnimationRight],
                styles: [""]
            }] }
];
/** @nocollapse */
LayoutContainerComponent.ctorParameters = () => [];
LayoutContainerComponent.propDecorators = {
    sidenavMin: [{ type: Input }],
    sidenavMax: [{ type: Input }],
    mediaQueryList: [{ type: Input }],
    hideSidenav: [{ type: Input }],
    expandedSidenav: [{ type: Input }],
    position: [{ type: Input }],
    sidenav: [{ type: ViewChild, args: [MatSidenav,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidebarActionMenuComponent {
    constructor() {
        /**
         * Width in pixels for sidebar action menu options.
         */
        this.width = 272;
    }
    /**
     * @return {?}
     */
    isExpanded() {
        return this.expanded;
    }
}
SidebarActionMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sidebar-action-menu',
                template: "<div class=\"adf-sidebar-action-menu\">\n    <button *ngIf=\"isExpanded()\" mat-raised-button class=\"adf-sidebar-action-menu-button\" data-automation-id=\"create-button\" [matMenuTriggerFor]=\"adfSidebarMenu\">\n        <span *ngIf=\"title\" class=\"adf-sidebar-action-menu-text\">{{ title }}</span>\n        <ng-content select=\"[adf-sidebar-menu-title-icon], [sidebar-menu-title-icon]\"></ng-content>\n    </button>\n\n    <div *ngIf=\"!isExpanded()\" class=\"adf-sidebar-action-menu-icon\" [matMenuTriggerFor]=\"adfSidebarMenu\">\n        <ng-content select=\"[adf-sidebar-menu-expand-icon], [sidebar-menu-expand-icon]\"></ng-content>\n    </div>\n\n    <mat-menu #adfSidebarMenu=\"matMenu\" class=\"adf-sidebar-action-menu-panel\" [overlapTrigger]=\"false\" yPosition=\"below\">\n        <div class=\"adf-sidebar-action-menu-options\" [style.width.px]=\"width\">\n            <ng-content select=\"[adf-sidebar-menu-options], [sidebar-menu-options]\"></ng-content>\n        </div>\n    </mat-menu>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-sidebar-action-menu' },
                styles: [""]
            }] }
];
SidebarActionMenuComponent.propDecorators = {
    title: [{ type: Input }],
    expanded: [{ type: Input }],
    width: [{ type: Input }]
};
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class SidebarMenuDirective {
}
SidebarMenuDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-sidebar-menu-options], [sidebar-menu-options]' },] }
];
class SidebarMenuTitleIconDirective {
}
SidebarMenuTitleIconDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-sidebar-menu-title-icon], [sidebar-menu-title-icon]' },] }
];
class SidebarMenuExpandIconDirective {
}
SidebarMenuExpandIconDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-sidebar-menu-expand-icon], [sidebar-menu-expand-icon]' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HeaderLayoutComponent {
    constructor() {
        /**
         * The router link for the application logo, when clicked.
         */
        this.redirectUrl = '/';
        /**
         * Toggles whether the sidenav button will be displayed in the header
         * or not.
         */
        this.showSidenavToggle = true;
        /**
         * Emitted when the sidenav button is clicked.
         */
        this.clicked = new EventEmitter();
        /**
         * The side of the page that the drawer is attached to (can be 'start' or 'end')
         */
        this.position = 'start';
    }
    /**
     * @return {?}
     */
    toggleMenu() {
        this.clicked.emit(true);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.logo) {
            this.logo = './assets/images/logo.png';
        }
    }
}
HeaderLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-layout-header',
                template: "<mat-toolbar\n    [color]=\"color\"\n    [style.background-color]=\"color\"\n    role=\"heading\"\n    aria-level=\"1\">\n    <button\n        *ngIf=\"showSidenavToggle && position === 'start'\"\n        id=\"adf-sidebar-toggle-start\"\n        data-automation-id=\"adf-menu-icon\"\n        class=\"mat-icon-button adf-menu-icon\"\n        mat-icon-button\n        (click)=\"toggleMenu()\"\n        aria-label=\"Toggle Menu\">\n        <mat-icon\n            class=\"mat-icon material-icon\"\n            role=\"img\"\n            aria-hidden=\"true\">menu</mat-icon>\n    </button>\n\n    <a [routerLink]=\"redirectUrl\" title=\"{{ tooltip }}\">\n        <img\n            src=\"{{ logo }}\"\n            class=\"adf-app-logo\"\n            alt=\"{{ 'CORE.HEADER.LOGO_ARIA' | translate }}\"\n        />\n    </a>\n\n    <span\n        [routerLink]=\"redirectUrl\"\n        fxFlex=\"1 1 auto\"\n        fxShow\n        fxHide.lt-sm=\"true\"\n        class=\"adf-app-title\"\n        >{{ title }}</span>\n    <ng-content></ng-content>\n\n    <button\n        *ngIf=\"showSidenavToggle && position === 'end'\"\n        id=\"adf-sidebar-toggle-end\"\n        data-automation-id=\"adf-menu-icon\"\n        class=\"mat-icon-button adf-menu-icon\"\n        mat-icon-button\n        (click)=\"toggleMenu()\"\n        aria-label=\"Toggle Menu\">\n        <mat-icon\n            class=\"mat-icon material-icon\"\n            role=\"img\"\n            aria-hidden=\"true\">menu</mat-icon>\n    </button>\n</mat-toolbar>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-layout-header' }
            }] }
];
HeaderLayoutComponent.propDecorators = {
    title: [{ type: Input }],
    logo: [{ type: Input }],
    redirectUrl: [{ type: Input }],
    tooltip: [{ type: Input }],
    color: [{ type: Input }],
    showSidenavToggle: [{ type: Input }],
    clicked: [{ type: Output }],
    position: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayoutModule {
}
LayoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    RouterModule,
                    TranslateModule.forChild()
                ],
                exports: [
                    SidenavLayoutHeaderDirective,
                    SidenavLayoutContentDirective,
                    SidenavLayoutNavigationDirective,
                    SidenavLayoutComponent,
                    LayoutContainerComponent,
                    SidebarActionMenuComponent,
                    SidebarMenuDirective,
                    SidebarMenuExpandIconDirective,
                    SidebarMenuTitleIconDirective,
                    HeaderLayoutComponent
                ],
                declarations: [
                    SidenavLayoutHeaderDirective,
                    SidenavLayoutContentDirective,
                    SidenavLayoutNavigationDirective,
                    SidenavLayoutComponent,
                    LayoutContainerComponent,
                    SidebarActionMenuComponent,
                    SidebarMenuDirective,
                    SidebarMenuExpandIconDirective,
                    SidebarMenuTitleIconDirective,
                    HeaderLayoutComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommentListComponent {
    /**
     * @param {?} peopleProcessService
     * @param {?} ecmUserService
     * @param {?} userPreferenceService
     */
    constructor(peopleProcessService, ecmUserService, userPreferenceService) {
        this.peopleProcessService = peopleProcessService;
        this.ecmUserService = ecmUserService;
        this.userPreferenceService = userPreferenceService;
        /**
         * Emitted when the user clicks on one of the comment rows.
         */
        this.clickRow = new EventEmitter();
        userPreferenceService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            this.currentLocale = locale;
        }));
    }
    /**
     * @param {?} comment
     * @return {?}
     */
    selectComment(comment) {
        if (this.selectedComment) {
            this.selectedComment.isSelected = false;
        }
        comment.isSelected = true;
        this.selectedComment = comment;
        this.clickRow.emit(this.selectedComment);
    }
    /**
     * @param {?} user
     * @return {?}
     */
    getUserShortName(user) {
        /** @type {?} */
        let shortName = '';
        if (user) {
            if (user.firstName) {
                shortName = user.firstName[0].toUpperCase();
            }
            if (user.lastName) {
                shortName += user.lastName[0].toUpperCase();
            }
        }
        return shortName;
    }
    /**
     * @param {?} user
     * @return {?}
     */
    isPictureDefined(user) {
        return user.pictureId || user.avatarId;
    }
    /**
     * @param {?} user
     * @return {?}
     */
    getUserImage(user) {
        if (this.isAContentUsers(user)) {
            return this.ecmUserService.getUserProfileImage(user.avatarId);
        }
        else {
            return this.peopleProcessService.getUserImage(user);
        }
    }
    /**
     * @private
     * @param {?} user
     * @return {?}
     */
    isAContentUsers(user) {
        return user.avatarId;
    }
}
CommentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-comment-list',
                template: " <mat-list class=\"adf-comment-list\">\n    <mat-list-item *ngFor=\"let comment of comments\"\n                  (click)=\"selectComment(comment)\"\n                  class=\"adf-comment-list-item\"\n                  [class.adf-is-selected]=\"comment.isSelected\"\n                  id=\"adf-comment-{{comment?.id}}\">\n        <div id=\"comment-user-icon\" class=\"adf-comment-img-container\">\n            <div\n                *ngIf=\"!isPictureDefined(comment.createdBy)\"\n                class=\"adf-comment-user-icon\">\n                {{getUserShortName(comment.createdBy)}}\n            </div>\n            <div>\n                <img [alt]=\"comment.createdBy\" *ngIf=\"isPictureDefined(comment.createdBy)\"\n                      class=\"adf-people-img\"\n                     [src]=\"getUserImage(comment.createdBy)\" />\n            </div>\n        </div>\n        <div class=\"adf-comment-contents\">\n            <div matLine id=\"comment-user\" class=\"adf-comment-user-name\">\n                {{comment.createdBy?.firstName}} {{comment.createdBy?.lastName}}\n            </div>\n            <div matLine id=\"comment-message\" class=\"adf-comment-message\" [innerHTML]=\"comment.message\"></div>\n            <div matLine id=\"comment-time\" class=\"adf-comment-message-time\">\n                {{ comment.created | adfTimeAgo: currentLocale }}\n            </div>\n        </div>\n    </mat-list-item>\n</mat-list>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
CommentListComponent.ctorParameters = () => [
    { type: PeopleProcessService },
    { type: EcmUserService },
    { type: UserPreferencesService }
];
CommentListComponent.propDecorators = {
    comments: [{ type: Input }],
    clickRow: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id;
            this.message = obj.message;
            this.created = obj.created;
            this.createdBy = obj.createdBy;
            this.isSelected = obj.isSelected ? obj.isSelected : false;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This object represent the process service user.*
 */
class UserProcessModel {
    /**
     * @param {?=} input
     */
    constructor(input) {
        if (input) {
            this.id = input.id;
            this.email = input.email || null;
            this.firstName = input.firstName || null;
            this.lastName = input.lastName || null;
            this.pictureId = input.pictureId || null;
            this.externalId = input.externalId || null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommentProcessService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Adds a comment to a task.
     * @param {?} taskId ID of the target task
     * @param {?} message Text for the comment
     * @return {?} Details about the comment
     */
    addTaskComment(taskId, message) {
        return from(this.apiService.getInstance().activiti.taskApi.addTaskComment({ message: message }, taskId))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return new CommentModel({
                id: response.id,
                message: response.message,
                created: response.created,
                createdBy: response.createdBy
            });
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets all comments that have been added to a task.
     * @param {?} taskId ID of the target task
     * @return {?} Details for each comment
     */
    getTaskComments(taskId) {
        return from(this.apiService.getInstance().activiti.taskApi.getTaskComments(taskId))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const comments = [];
            response.data.forEach((/**
             * @param {?} comment
             * @return {?}
             */
            (comment) => {
                /** @type {?} */
                const user = new UserProcessModel(comment.createdBy);
                comments.push(new CommentModel({
                    id: comment.id,
                    message: comment.message,
                    created: comment.created,
                    createdBy: user
                }));
            }));
            return comments;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets all comments that have been added to a process instance.
     * @param {?} processInstanceId ID of the target process instance
     * @return {?} Details for each comment
     */
    getProcessInstanceComments(processInstanceId) {
        return from(this.apiService.getInstance().activiti.commentsApi.getProcessInstanceComments(processInstanceId))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const comments = [];
            response.data.forEach((/**
             * @param {?} comment
             * @return {?}
             */
            (comment) => {
                /** @type {?} */
                const user = new UserProcessModel(comment.createdBy);
                comments.push(new CommentModel({
                    id: comment.id,
                    message: comment.message,
                    created: comment.created,
                    createdBy: user
                }));
            }));
            return comments;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Adds a comment to a process instance.
     * @param {?} processInstanceId ID of the target process instance
     * @param {?} message Text for the comment
     * @return {?} Details of the comment added
     */
    addProcessInstanceComment(processInstanceId, message) {
        return from(this.apiService.getInstance().activiti.commentsApi.addProcessInstanceComment({ message: message }, processInstanceId)).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return new CommentModel({
                id: response.id,
                message: response.message,
                created: response.created,
                createdBy: response.createdBy
            });
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
CommentProcessService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CommentProcessService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ CommentProcessService.ngInjectableDef = defineInjectable({ factory: function CommentProcessService_Factory() { return new CommentProcessService(inject(AlfrescoApiService), inject(LogService)); }, token: CommentProcessService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommentContentService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Adds a comment to a node.
     * @param {?} nodeId ID of the target node
     * @param {?} message Text for the comment
     * @return {?} Details of the comment added
     */
    addNodeComment(nodeId, message) {
        return from(this.apiService.getInstance().core.commentsApi.addComment(nodeId, { content: message }))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return new CommentModel({
                id: response.entry.id,
                message: response.entry.content,
                created: response.entry.createdAt,
                createdBy: response.entry.createdBy
            });
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets all comments that have been added to a node.
     * @param {?} nodeId ID of the target node
     * @return {?} Details for each comment
     */
    getNodeComments(nodeId) {
        return from(this.apiService.getInstance().core.commentsApi.getComments(nodeId))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const comments = [];
            response.list.entries.forEach((/**
             * @param {?} comment
             * @return {?}
             */
            (comment) => {
                comments.push(new CommentModel({
                    id: comment.entry.id,
                    message: comment.entry.content,
                    created: comment.entry.createdAt,
                    createdBy: comment.entry.createdBy
                }));
            }));
            return comments;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
CommentContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CommentContentService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ CommentContentService.ngInjectableDef = defineInjectable({ factory: function CommentContentService_Factory() { return new CommentContentService(inject(AlfrescoApiService), inject(LogService)); }, token: CommentContentService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommentsComponent {
    /**
     * @param {?} commentProcessService
     * @param {?} commentContentService
     */
    constructor(commentProcessService, commentContentService) {
        this.commentProcessService = commentProcessService;
        this.commentContentService = commentContentService;
        /**
         * Are the comments read only?
         */
        this.readOnly = false;
        /**
         * Emitted when an error occurs while displaying/adding a comment.
         */
        this.error = new EventEmitter();
        this.comments = [];
        this.beingAdded = false;
        this.comment$ = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => this.commentObserver = observer))
            .pipe(share());
        this.comment$.subscribe((/**
         * @param {?} comment
         * @return {?}
         */
        (comment) => {
            this.comments.push(comment);
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.taskId = null;
        this.nodeId = null;
        this.taskId = changes['taskId'] ? changes['taskId'].currentValue : null;
        this.nodeId = changes['nodeId'] ? changes['nodeId'].currentValue : null;
        if (this.taskId || this.nodeId) {
            this.getComments();
        }
        else {
            this.resetComments();
        }
    }
    /**
     * @private
     * @return {?}
     */
    getComments() {
        this.resetComments();
        if (this.isATask()) {
            this.commentProcessService.getTaskComments(this.taskId).subscribe((/**
             * @param {?} comments
             * @return {?}
             */
            (comments) => {
                if (comments && comments instanceof Array) {
                    comments = comments.sort((/**
                     * @param {?} comment1
                     * @param {?} comment2
                     * @return {?}
                     */
                    (comment1, comment2) => {
                        /** @type {?} */
                        const date1 = new Date(comment1.created);
                        /** @type {?} */
                        const date2 = new Date(comment2.created);
                        return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                    }));
                    comments.forEach((/**
                     * @param {?} currentComment
                     * @return {?}
                     */
                    (currentComment) => {
                        this.commentObserver.next(currentComment);
                    }));
                }
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
        if (this.isANode()) {
            this.commentContentService.getNodeComments(this.nodeId).subscribe((/**
             * @param {?} comments
             * @return {?}
             */
            (comments) => {
                if (comments && comments instanceof Array) {
                    comments = comments.sort((/**
                     * @param {?} comment1
                     * @param {?} comment2
                     * @return {?}
                     */
                    (comment1, comment2) => {
                        /** @type {?} */
                        const date1 = new Date(comment1.created);
                        /** @type {?} */
                        const date2 = new Date(comment2.created);
                        return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                    }));
                    comments.forEach((/**
                     * @param {?} comment
                     * @return {?}
                     */
                    (comment) => {
                        this.commentObserver.next(comment);
                    }));
                }
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetComments() {
        this.comments = [];
    }
    /**
     * @return {?}
     */
    add() {
        if (this.message && this.message.trim() && !this.beingAdded) {
            /** @type {?} */
            const comment = this.sanitize(this.message);
            this.beingAdded = true;
            if (this.isATask()) {
                this.commentProcessService.addTaskComment(this.taskId, comment)
                    .subscribe((/**
                 * @param {?} res
                 * @return {?}
                 */
                (res) => {
                    this.comments.unshift(res);
                    this.message = '';
                    this.beingAdded = false;
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => {
                    this.error.emit(err);
                    this.beingAdded = false;
                }));
            }
            if (this.isANode()) {
                this.commentContentService.addNodeComment(this.nodeId, comment)
                    .subscribe((/**
                 * @param {?} res
                 * @return {?}
                 */
                (res) => {
                    this.comments.unshift(res);
                    this.message = '';
                    this.beingAdded = false;
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => {
                    this.error.emit(err);
                    this.beingAdded = false;
                }));
            }
        }
    }
    /**
     * @return {?}
     */
    clear() {
        this.message = '';
    }
    /**
     * @return {?}
     */
    isReadOnly() {
        return this.readOnly;
    }
    /**
     * @return {?}
     */
    isATask() {
        return this.taskId ? true : false;
    }
    /**
     * @return {?}
     */
    isANode() {
        return this.nodeId ? true : false;
    }
    /**
     * @private
     * @param {?} input
     * @return {?}
     */
    sanitize(input) {
        return input.replace(/<[^>]+>/g, '')
            .replace(/^\s+|\s+$|\s+(?=\s)/g, '')
            .replace(/\r?\n/g, '<br/>');
    }
}
CommentsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-comments',
                template: "<div class=\"adf-comments-container\">\n    <div id=\"comment-header\" class=\"adf-comments-header\">\n        {{'COMMENTS.HEADER' | translate: { count: comments?.length} }}\n    </div>\n    <div class=\"adf-comments-input-container\" *ngIf=\"!isReadOnly()\">\n            <mat-form-field class=\"adf-full-width\">\n                <textarea (keyup.escape)=\"clear()\" matInput id=\"comment-input\" placeholder=\"{{'COMMENTS.ADD' | translate}}\" [(ngModel)]=\"message\"></textarea>\n            </mat-form-field>\n\n            <div class=\"adf-comments-input-actions\">\n                <button mat-button\n                    class=\"adf-comments-input-add\"\n                    data-automation-id=\"comments-input-add\"\n                    color=\"primary\"\n                    (click)=\"add()\"\n                    [disabled]=\"!message\">\n                    {{ 'COMMENTS.ADD' | translate }}\n                </button>\n            </div>\n    </div>\n\n    <div *ngIf=\"comments.length > 0\">\n        <adf-comment-list [comments]=\"comments\">\n        </adf-comment-list>\n    </div>\n</div>",
                styles: [""]
            }] }
];
/** @nocollapse */
CommentsComponent.ctorParameters = () => [
    { type: CommentProcessService },
    { type: CommentContentService }
];
CommentsComponent.propDecorators = {
    taskId: [{ type: Input }],
    nodeId: [{ type: Input }],
    readOnly: [{ type: Input }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommentsModule {
}
CommentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    PipeModule,
                    DataColumnModule,
                    DataTableModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule.forChild()
                ],
                declarations: [
                    CommentListComponent,
                    CommentsComponent
                ],
                exports: [
                    CommentListComponent,
                    CommentsComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ButtonsMenuComponent {
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.buttons.length > 0) {
            this.isMenuEmpty = false;
        }
        else {
            this.isMenuEmpty = true;
        }
    }
    /**
     * @return {?}
     */
    isMobile() {
        return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
}
ButtonsMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-buttons-action-menu',
                template: "<div id=\"adf-buttons-menu\" class=\"adf-buttons-menu\" *ngIf=\"!isMenuEmpty\">\n    <div *ngIf=\"isMobile()\">\n        <button mat-icon-button [matMenuTriggerFor]=\"editReportMenu\">\n            <mat-icon>more_vert</mat-icon>\n        </button>\n        <mat-menu #editReportMenu=\"matMenu\" class=\"adf-buttons-menu-mobile\">\n            <ng-content *ngTemplateOutlet=\"desktop\">\n            </ng-content>\n        </mat-menu>\n    </div>\n\n    <div *ngIf=\"!isMobile()\" class=\"adf-buttons-menu-desktop\">\n        <ng-content *ngTemplateOutlet=\"desktop\">\n        </ng-content>\n    </div>\n</div>\n\n<ng-template #desktop>\n    <ng-content></ng-content>\n</ng-template>",
                styles: [""]
            }] }
];
ButtonsMenuComponent.propDecorators = {
    buttons: [{ type: ContentChildren, args: [MatMenuItem,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ButtonsMenuModule {
}
ButtonsMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild(),
                    FlexLayoutModule
                ],
                declarations: [
                    ButtonsMenuComponent
                ],
                exports: [
                    ButtonsMenuComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SortingPickerComponent {
    constructor() {
        /**
         * Available sorting options
         */
        this.options = [];
        /**
         * Current sorting direction
         */
        this.ascending = true;
        /**
         * Raised each time sorting key gets changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Raised each time direction gets changed.
         */
        this.sortingChange = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onOptionChanged(event) {
        this.selected = event.value;
        this.valueChange.emit(this.selected);
    }
    /**
     * @return {?}
     */
    toggleSortDirection() {
        this.ascending = !this.ascending;
        this.sortingChange.emit(this.ascending);
    }
}
SortingPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sorting-picker',
                template: "<mat-form-field>\n    <mat-select [(value)]=\"selected\" (selectionChange)=\"onOptionChanged($event)\">\n        <mat-option *ngFor=\"let option of options\" [value]=\"option.key\">\n            {{ option.label | translate }}\n        </mat-option>\n    </mat-select>\n</mat-form-field>\n\n<button *ngIf=\"selected\" mat-icon-button (click)=\"toggleSortDirection()\">\n    <mat-icon *ngIf=\"ascending\">arrow_upward</mat-icon>\n    <mat-icon *ngIf=\"!ascending\">arrow_downward</mat-icon>\n</button>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-sorting-picker' }
            }] }
];
SortingPickerComponent.propDecorators = {
    options: [{ type: Input }],
    selected: [{ type: Input }],
    ascending: [{ type: Input }],
    valueChange: [{ type: Output }],
    sortingChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SortingPickerModule {
}
SortingPickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild()
                ],
                declarations: [
                    SortingPickerComponent
                ],
                exports: [
                    SortingPickerComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ErrorContentComponent {
    /**
     * @param {?} route
     * @param {?} router
     * @param {?} translateService
     */
    constructor(route, router, translateService) {
        this.route = route;
        this.router = router;
        this.translateService = translateService;
        /**
         * Target URL for the secondary button.
         */
        this.secondaryButtonUrl = 'report-issue';
        /**
         * Target URL for the return button.
         */
        this.returnButtonUrl = '/';
        /**
         * Error code associated with this error.
         */
        this.errorCode = ErrorContentComponent.UNKNOWN_ERROR;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.route) {
            this.route.params.forEach((/**
             * @param {?} params
             * @return {?}
             */
            (params) => {
                if (params['id']) {
                    this.errorCode = this.checkErrorExists(params['id']) ? params['id'] : ErrorContentComponent.UNKNOWN_ERROR;
                }
            }));
        }
    }
    /**
     * @param {?} errorCode
     * @return {?}
     */
    checkErrorExists(errorCode) {
        /** @type {?} */
        const errorMessage = this.translateService.instant('ERROR_CONTENT.' + errorCode);
        return errorMessage !== ('ERROR_CONTENT.' + errorCode);
    }
    /**
     * @return {?}
     */
    getTranslations() {
        this.hasSecondButton = this.translateService.instant('ERROR_CONTENT.' + this.errorCode + '.SECONDARY_BUTTON.TEXT') ? true : false;
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.getTranslations();
    }
    /**
     * @return {?}
     */
    onSecondButton() {
        this.router.navigate(['/' + this.secondaryButtonUrl]);
    }
    /**
     * @return {?}
     */
    onReturnButton() {
        this.router.navigate(['/' + this.returnButtonUrl]);
    }
}
ErrorContentComponent.UNKNOWN_ERROR = 'UNKNOWN';
ErrorContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-error-content',
                template: "<div class=\"adf-error-content\">\n    <p class=\"adf-error-content-code\">\n        {{ errorCode }}\n    </p>\n    <div class=\"adf-error-content-shadow\"></div>\n    <p class=\"adf-error-content-title\">\n        {{ 'ERROR_CONTENT.' + errorCode + '.TITLE' | translate }}\n    </p>\n    <p class=\"adf-error-content-description\">\n        {{ 'ERROR_CONTENT.' + errorCode + '.DESCRIPTION' | translate }}\n    </p>\n    <div class=\"adf-error-content-buttons\">\n        <a a id=\"adf-secondary-button\" mat-raised-button color=\"primary\"\n            *ngIf=\"hasSecondButton\" (click)=\"onSecondButton()\"\n            class=\"adf-error-content-description-link\">\n            {{ 'ERROR_CONTENT.' + errorCode + '.SECONDARY_BUTTON.TEXT' | translate | uppercase }}\n        </a>\n        <a id=\"adf-return-button\" mat-raised-button color=\"primary\" (click)=\"onReturnButton()\">\n            {{ 'ERROR_CONTENT.' + this.errorCode + '.RETURN_BUTTON.TEXT' | translate | uppercase }}\n        </a>\n    </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-error-content' },
                styles: [""]
            }] }
];
/** @nocollapse */
ErrorContentComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: Router },
    { type: TranslationService }
];
ErrorContentComponent.propDecorators = {
    secondaryButtonUrl: [{ type: Input }],
    returnButtonUrl: [{ type: Input }],
    errorCode: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EmptyContentComponent {
    constructor() {
        /**
         * Material Icon to use.
         */
        this.icon = 'cake';
        /**
         * String or Resource Key for the title.
         */
        this.title = '';
        /**
         * String or Resource Key for the subtitle.
         */
        this.subtitle = '';
    }
}
EmptyContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-empty-content',
                template: "<div class=\"adf-empty-content\">\n    <mat-icon class=\"adf-empty-content__icon\">{{ icon }}</mat-icon>\n    <div class=\"adf-empty-content__title\">{{ title | translate }}</div>\n    <div class=\"adf-empty-content__subtitle\">{{ subtitle | translate }}</div>\n    <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-empty-content' },
                styles: [""]
            }] }
];
EmptyContentComponent.propDecorators = {
    icon: [{ type: Input }],
    title: [{ type: Input }],
    subtitle: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TemplateModule {
}
TemplateModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild()
                ],
                declarations: [
                    ErrorContentComponent,
                    EmptyContentComponent
                ],
                exports: [
                    ErrorContentComponent,
                    EmptyContentComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AuthGuardBase {
    /**
     * @param {?} authenticationService
     * @param {?} router
     * @param {?} appConfigService
     */
    constructor(authenticationService, router, appConfigService) {
        this.authenticationService = authenticationService;
        this.router = router;
        this.appConfigService = appConfigService;
    }
    /**
     * @protected
     * @return {?}
     */
    get withCredentials() {
        return this.appConfigService.get('auth.withCredentials', false);
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivate(route, state$$1) {
        return this.checkLogin(route, state$$1.url);
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivateChild(route, state$$1) {
        return this.canActivate(route, state$$1);
    }
    /**
     * @protected
     * @param {?} provider
     * @param {?} url
     * @return {?}
     */
    redirectToUrl(provider, url) {
        this.authenticationService.setRedirect({ provider, url });
        /** @type {?} */
        const pathToLogin = this.getLoginRoute();
        /** @type {?} */
        const urlToRedirect = `/${pathToLogin}?redirectUrl=${url}`;
        this.router.navigateByUrl(urlToRedirect);
    }
    /**
     * @protected
     * @return {?}
     */
    getLoginRoute() {
        return (this.appConfigService &&
            this.appConfigService.get(AppConfigValues.LOGIN_ROUTE, 'login'));
    }
    /**
     * @protected
     * @return {?}
     */
    isOAuthWithoutSilentLogin() {
        /** @type {?} */
        const oauth = this.appConfigService.get(AppConfigValues.OAUTHCONFIG, null);
        return (this.authenticationService.isOauth() && oauth.silentLogin === false);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthGuard extends AuthGuardBase {
    /**
     * @param {?} authenticationService
     * @param {?} router
     * @param {?} appConfigService
     */
    constructor(authenticationService, router, appConfigService) {
        super(authenticationService, router, appConfigService);
    }
    /**
     * @param {?} activeRoute
     * @param {?} redirectUrl
     * @return {?}
     */
    checkLogin(activeRoute, redirectUrl) {
        if (this.authenticationService.isLoggedIn() || this.withCredentials) {
            return true;
        }
        if (!this.authenticationService.isOauth() || this.isOAuthWithoutSilentLogin()) {
            this.redirectToUrl('ALL', redirectUrl);
        }
        return false;
    }
}
AuthGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AuthGuard.ctorParameters = () => [
    { type: AuthenticationService },
    { type: Router },
    { type: AppConfigService }
];
/** @nocollapse */ AuthGuard.ngInjectableDef = defineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(inject(AuthenticationService), inject(Router), inject(AppConfigService)); }, token: AuthGuard, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthGuardEcm extends AuthGuardBase {
    /**
     * @param {?} authenticationService
     * @param {?} router
     * @param {?} appConfigService
     */
    constructor(authenticationService, router, appConfigService) {
        super(authenticationService, router, appConfigService);
    }
    /**
     * @param {?} activeRoute
     * @param {?} redirectUrl
     * @return {?}
     */
    checkLogin(activeRoute, redirectUrl) {
        if (this.authenticationService.isEcmLoggedIn() || this.withCredentials) {
            return true;
        }
        if (!this.authenticationService.isOauth() || this.isOAuthWithoutSilentLogin()) {
            this.redirectToUrl('ECM', redirectUrl);
        }
        return false;
    }
}
AuthGuardEcm.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AuthGuardEcm.ctorParameters = () => [
    { type: AuthenticationService },
    { type: Router },
    { type: AppConfigService }
];
/** @nocollapse */ AuthGuardEcm.ngInjectableDef = defineInjectable({ factory: function AuthGuardEcm_Factory() { return new AuthGuardEcm(inject(AuthenticationService), inject(Router), inject(AppConfigService)); }, token: AuthGuardEcm, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthGuardBpm extends AuthGuardBase {
    /**
     * @param {?} authenticationService
     * @param {?} router
     * @param {?} appConfigService
     */
    constructor(authenticationService, router, appConfigService) {
        super(authenticationService, router, appConfigService);
    }
    /**
     * @param {?} activeRoute
     * @param {?} redirectUrl
     * @return {?}
     */
    checkLogin(activeRoute, redirectUrl) {
        if (this.authenticationService.isBpmLoggedIn() || this.withCredentials) {
            return true;
        }
        if (!this.authenticationService.isOauth() || this.isOAuthWithoutSilentLogin()) {
            this.redirectToUrl('BPM', redirectUrl);
        }
        return false;
    }
}
AuthGuardBpm.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AuthGuardBpm.ctorParameters = () => [
    { type: AuthenticationService },
    { type: Router },
    { type: AppConfigService }
];
/** @nocollapse */ AuthGuardBpm.ngInjectableDef = defineInjectable({ factory: function AuthGuardBpm_Factory() { return new AuthGuardBpm(inject(AuthenticationService), inject(Router), inject(AppConfigService)); }, token: AuthGuardBpm, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthGuardSsoRoleService {
    /**
     * @param {?} storageService
     * @param {?} jwtHelperService
     * @param {?} router
     */
    constructor(storageService, jwtHelperService, router) {
        this.storageService = storageService;
        this.jwtHelperService = jwtHelperService;
        this.router = router;
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivate(route, state$$1) {
        /** @type {?} */
        let hasRole = false;
        /** @type {?} */
        let hasRealmRole = false;
        /** @type {?} */
        let hasClientRole = true;
        if (route.data) {
            if (route.data['roles']) {
                /** @type {?} */
                const rolesToCheck = route.data['roles'];
                hasRealmRole = this.hasRealmRoles(rolesToCheck);
            }
            if (route.data['clientRoles']) {
                /** @type {?} */
                const clientRoleName = route.params[route.data['clientRoles']];
                /** @type {?} */
                const rolesToCheck = route.data['roles'];
                hasClientRole = this.hasRealmRolesForClientRole(clientRoleName, rolesToCheck);
            }
        }
        hasRole = hasRealmRole && hasClientRole;
        if (!hasRole && route.data && route.data['redirectUrl']) {
            this.router.navigate(['/' + route.data['redirectUrl']]);
        }
        return hasRole;
    }
    /**
     * @return {?}
     */
    getRealmRoles() {
        /** @type {?} */
        const access = this.getValueFromToken('realm_access');
        /** @type {?} */
        const roles = access ? access['roles'] : [];
        return roles;
    }
    /**
     * @param {?} client
     * @return {?}
     */
    getClientRoles(client) {
        /** @type {?} */
        const clientRole = this.getValueFromToken('resource_access')[client];
        /** @type {?} */
        const roles = clientRole ? clientRole['roles'] : [];
        return roles;
    }
    /**
     * @return {?}
     */
    getAccessToken() {
        return this.storageService.getItem('access_token');
    }
    /**
     * @param {?} role
     * @return {?}
     */
    hasRealmRole(role) {
        /** @type {?} */
        let hasRole = false;
        if (this.getAccessToken()) {
            /** @type {?} */
            const realmRoles = this.getRealmRoles();
            hasRole = realmRoles.some((/**
             * @param {?} currentRole
             * @return {?}
             */
            (currentRole) => {
                return currentRole === role;
            }));
        }
        return hasRole;
    }
    /**
     * @param {?} rolesToCheck
     * @return {?}
     */
    hasRealmRoles(rolesToCheck) {
        return rolesToCheck.some((/**
         * @param {?} currentRole
         * @return {?}
         */
        (currentRole) => {
            return this.hasRealmRole(currentRole);
        }));
    }
    /**
     * @param {?} clientRole
     * @param {?} rolesToCheck
     * @return {?}
     */
    hasRealmRolesForClientRole(clientRole, rolesToCheck) {
        return rolesToCheck.some((/**
         * @param {?} currentRole
         * @return {?}
         */
        (currentRole) => {
            return this.hasClientRole(clientRole, currentRole);
        }));
    }
    /**
     * @param {?} clientRole
     * @param {?} role
     * @return {?}
     */
    hasClientRole(clientRole, role) {
        /** @type {?} */
        let hasRole = false;
        if (this.getAccessToken()) {
            /** @type {?} */
            const clientRoles = this.getClientRoles(clientRole);
            hasRole = clientRoles.some((/**
             * @param {?} currentRole
             * @return {?}
             */
            (currentRole) => {
                return currentRole === role;
            }));
        }
        return hasRole;
    }
    /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    getValueFromToken(key) {
        /** @type {?} */
        let value;
        /** @type {?} */
        const accessToken = this.getAccessToken();
        if (accessToken) {
            /** @type {?} */
            const tokenPayload = this.jwtHelperService.decodeToken(accessToken);
            value = tokenPayload[key];
        }
        return (/** @type {?} */ (value));
    }
}
AuthGuardSsoRoleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AuthGuardSsoRoleService.ctorParameters = () => [
    { type: StorageService },
    { type: JwtHelperService },
    { type: Router }
];
/** @nocollapse */ AuthGuardSsoRoleService.ngInjectableDef = defineInjectable({ factory: function AuthGuardSsoRoleService_Factory() { return new AuthGuardSsoRoleService(inject(StorageService), inject(JwtHelperService), inject(Router)); }, token: AuthGuardSsoRoleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppsProcessService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Gets a list of deployed apps for this user.
     * @return {?} The list of deployed apps
     */
    getDeployedApplications() {
        return from(this.apiService.getInstance().activiti.appsApi.getAppDefinitions())
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => (/** @type {?} */ (response.data)))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a list of deployed apps for this user, where the app name is `name`.
     * @param {?} name Name of the app
     * @return {?} The list of deployed apps
     */
    getDeployedApplicationsByName(name) {
        return from(this.apiService.getInstance().activiti.appsApi.getAppDefinitions())
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => (/** @type {?} */ (response.data.find((/**
         * @param {?} app
         * @return {?}
         */
        (app) => app.name === name)))))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the details for a specific app ID number.
     * @param {?} appId ID of the target app
     * @return {?} Details of the app
     */
    getApplicationDetailsById(appId) {
        return from(this.apiService.getInstance().activiti.appsApi.getAppDefinitions())
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => response.data.find((/**
         * @param {?} app
         * @return {?}
         */
        (app) => app.id === appId)))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
AppsProcessService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AppsProcessService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ AppsProcessService.ngInjectableDef = defineInjectable({ factory: function AppsProcessService_Factory() { return new AppsProcessService(inject(AlfrescoApiService), inject(LogService)); }, token: AppsProcessService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PageTitleService {
    /**
     * @param {?} titleService
     * @param {?} appConfig
     * @param {?} translationService
     */
    constructor(titleService, appConfig, translationService) {
        this.titleService = titleService;
        this.appConfig = appConfig;
        this.translationService = translationService;
        this.originalTitle = '';
        this.translatedTitle = '';
        translationService.translate.onLangChange.subscribe((/**
         * @return {?}
         */
        () => this.onLanguageChanged()));
        translationService.translate.onTranslationChange.subscribe((/**
         * @return {?}
         */
        () => this.onLanguageChanged()));
    }
    /**
     * Sets the page title.
     * @param {?=} value The new title
     * @return {?}
     */
    setTitle(value = '') {
        this.originalTitle = value;
        this.translatedTitle = this.translationService.instant(value);
        this.updateTitle();
    }
    /**
     * @private
     * @return {?}
     */
    onLanguageChanged() {
        this.translatedTitle = this.translationService.instant(this.originalTitle);
        this.updateTitle();
    }
    /**
     * @private
     * @return {?}
     */
    updateTitle() {
        /** @type {?} */
        const name = this.appConfig.get('application.name') || 'Alfresco ADF Application';
        /** @type {?} */
        const title = this.translatedTitle ? `${this.translatedTitle} - ${name}` : `${name}`;
        this.titleService.setTitle(title);
    }
}
PageTitleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PageTitleService.ctorParameters = () => [
    { type: Title },
    { type: AppConfigService },
    { type: TranslationService }
];
/** @nocollapse */ PageTitleService.ngInjectableDef = defineInjectable({ factory: function PageTitleService_Factory() { return new PageTitleService(inject(Title), inject(AppConfigService), inject(TranslationService)); }, token: PageTitleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RenditionsService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * Gets the first available rendition found for a node.
     * @param {?} nodeId ID of the target node
     * @return {?} Information object for the rendition
     */
    getAvailableRenditionForNode(nodeId) {
        return from(this.apiService.renditionsApi.getRenditions(nodeId)).pipe(map((/**
         * @param {?} availableRenditions
         * @return {?}
         */
        (availableRenditions) => {
            /** @type {?} */
            const renditionsAvailable = availableRenditions.list.entries.filter((/**
             * @param {?} rendition
             * @return {?}
             */
            (rendition) => (rendition.entry.id === 'pdf' || rendition.entry.id === 'imgpreview')));
            /** @type {?} */
            const existingRendition = renditionsAvailable.find((/**
             * @param {?} rend
             * @return {?}
             */
            (rend) => rend.entry.status === 'CREATED'));
            return existingRendition ? existingRendition : renditionsAvailable[0];
        })));
    }
    /**
     * Generates a rendition for a node using the first available encoding.
     * @param {?} nodeId ID of the target node
     * @return {?} Null response to indicate completion
     */
    generateRenditionForNode(nodeId) {
        return this.getAvailableRenditionForNode(nodeId).pipe(map((/**
         * @param {?} rendition
         * @return {?}
         */
        (rendition) => {
            if (rendition.entry.status !== 'CREATED') {
                return from(this.apiService.renditionsApi.createRendition(nodeId, { id: rendition.entry.id }));
            }
            else {
                return empty();
            }
        })));
    }
    /**
     * Checks if the specified rendition is available for a node.
     * @param {?} nodeId ID of the target node
     * @param {?} encoding Name of the rendition encoding
     * @return {?} True if the rendition is available, false otherwise
     */
    isRenditionAvailable(nodeId, encoding) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.getRendition(nodeId, encoding).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                /** @type {?} */
                let isAvailable = true;
                if (res.entry.status.toString() === 'NOT_CREATED') {
                    isAvailable = false;
                }
                observer.next(isAvailable);
                observer.complete();
            }), (/**
             * @return {?}
             */
            () => {
                observer.next(false);
                observer.complete();
            }));
        }));
    }
    /**
     * Checks if the node can be converted using the specified rendition.
     * @param {?} nodeId ID of the target node
     * @param {?} encoding Name of the rendition encoding
     * @return {?} True if the node can be converted, false otherwise
     */
    isConversionPossible(nodeId, encoding) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.getRendition(nodeId, encoding).subscribe((/**
             * @return {?}
             */
            () => {
                observer.next(true);
                observer.complete();
            }), (/**
             * @return {?}
             */
            () => {
                observer.next(false);
                observer.complete();
            }));
        }));
    }
    /**
     * Gets a URL linking to the specified rendition of a node.
     * @param {?} nodeId ID of the target node
     * @param {?} encoding Name of the rendition encoding
     * @return {?} URL string
     */
    getRenditionUrl(nodeId, encoding) {
        return this.apiService.contentApi.getRenditionUrl(nodeId, encoding);
    }
    /**
     * Gets information about a rendition of a node.
     * @param {?} nodeId ID of the target node
     * @param {?} encoding Name of the rendition encoding
     * @return {?} Information object about the rendition
     */
    getRendition(nodeId, encoding) {
        return from(this.apiService.renditionsApi.getRendition(nodeId, encoding));
    }
    /**
     * Gets a list of all renditions for a node.
     * @param {?} nodeId ID of the target node
     * @return {?} Paged list of rendition details
     */
    getRenditionsListByNodeId(nodeId) {
        return from(this.apiService.renditionsApi.getRenditions(nodeId));
    }
    /**
     * Creates a rendition for a node.
     * @param {?} nodeId ID of the target node
     * @param {?} encoding Name of the rendition encoding
     * @return {?} Null response to indicate completion
     */
    createRendition(nodeId, encoding) {
        return from(this.apiService.renditionsApi.createRendition(nodeId, { id: encoding }));
    }
    /**
     * Repeatedly attempts to create a rendition, through to success or failure.
     * @param {?} nodeId ID of the target node
     * @param {?} encoding Name of the rendition encoding
     * @param {?=} pollingInterval Time interval (in milliseconds) between checks for completion
     * @param {?=} retries Number of attempts to make before declaring failure
     * @return {?} True if the rendition was created, false otherwise
     */
    convert(nodeId, encoding, pollingInterval = 1000, retries = 5) {
        return this.createRendition(nodeId, encoding)
            .pipe(concatMap((/**
         * @return {?}
         */
        () => this.pollRendition(nodeId, encoding, pollingInterval, retries))));
    }
    /**
     * @private
     * @param {?} nodeId
     * @param {?} encoding
     * @param {?=} intervalSize
     * @param {?=} retries
     * @return {?}
     */
    pollRendition(nodeId, encoding, intervalSize = 1000, retries = 5) {
        /** @type {?} */
        let attempts = 0;
        return interval(intervalSize)
            .pipe(switchMap((/**
         * @return {?}
         */
        () => this.getRendition(nodeId, encoding))), takeWhile((/**
         * @param {?} renditionEntry
         * @return {?}
         */
        (renditionEntry) => {
            attempts += 1;
            if (attempts > retries) {
                return false;
            }
            return (renditionEntry.entry.status.toString() !== 'CREATED');
        })));
    }
}
RenditionsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
RenditionsService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ RenditionsService.ngInjectableDef = defineInjectable({ factory: function RenditionsService_Factory() { return new RenditionsService(inject(AlfrescoApiService)); }, token: RenditionsService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ComponentTranslationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.name = obj && obj.name;
        this.path = obj && obj.path;
        this.json = obj && obj.json || [];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TranslateLoaderService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.prefix = 'i18n';
        this.suffix = '.json';
        this.providers = [];
        this.queue = [];
        this.defaultLang = 'en';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setDefaultLang(value) {
        this.defaultLang = value || 'en';
    }
    /**
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    registerProvider(name, path) {
        /** @type {?} */
        const registered = this.providers.find((/**
         * @param {?} provider
         * @return {?}
         */
        (provider) => provider.name === name));
        if (registered) {
            registered.path = path;
        }
        else {
            this.providers.push(new ComponentTranslationModel({ name: name, path: path }));
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    providerRegistered(name) {
        return this.providers.find((/**
         * @param {?} x
         * @return {?}
         */
        (x) => x.name === name)) ? true : false;
    }
    /**
     * @param {?} lang
     * @param {?} component
     * @param {?=} fallbackUrl
     * @return {?}
     */
    fetchLanguageFile(lang, component, fallbackUrl) {
        /** @type {?} */
        const translationUrl = fallbackUrl || `${component.path}/${this.prefix}/${lang}${this.suffix}?v=${Date.now()}`;
        return this.http.get(translationUrl).pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            component.json[lang] = res;
        })), retry(3), catchError((/**
         * @return {?}
         */
        () => {
            if (!fallbackUrl && lang.includes('-')) {
                const [langId] = lang.split('-');
                if (langId && langId !== this.defaultLang) {
                    /** @type {?} */
                    const url = `${component.path}/${this.prefix}/${langId}${this.suffix}?v=${Date.now()}`;
                    return this.fetchLanguageFile(lang, component, url);
                }
            }
            return throwError(`Failed to load ${translationUrl}`);
        })));
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    getComponentToFetch(lang) {
        /** @type {?} */
        const observableBatch = [];
        if (!this.queue[lang]) {
            this.queue[lang] = [];
        }
        this.providers.forEach((/**
         * @param {?} component
         * @return {?}
         */
        (component) => {
            if (!this.isComponentInQueue(lang, component.name)) {
                this.queue[lang].push(component.name);
                observableBatch.push(this.fetchLanguageFile(lang, component));
            }
        }));
        return observableBatch;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    init(lang) {
        if (this.queue[lang] === undefined) {
            this.queue[lang] = [];
        }
    }
    /**
     * @param {?} lang
     * @param {?} name
     * @return {?}
     */
    isComponentInQueue(lang, name) {
        return (this.queue[lang] || []).find((/**
         * @param {?} x
         * @return {?}
         */
        (x) => x === name)) ? true : false;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    getFullTranslationJSON(lang) {
        /** @type {?} */
        let result = {};
        this.providers
            .slice(0)
            .sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => {
            if (a.name === 'app') {
                return 1;
            }
            if (b.name === 'app') {
                return -1;
            }
            return a.name.localeCompare(b.name);
        }))
            .forEach((/**
         * @param {?} model
         * @return {?}
         */
        (model) => {
            if (model.json && model.json[lang]) {
                result = ObjectUtils.merge(result, model.json[lang]);
            }
        }));
        return result;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    getTranslation(lang) {
        /** @type {?} */
        let hasFailures = false;
        /** @type {?} */
        const batch = [
            ...this.getComponentToFetch(lang).map((/**
             * @param {?} observable
             * @return {?}
             */
            (observable) => {
                return observable.pipe(catchError((/**
                 * @param {?} error
                 * @return {?}
                 */
                (error) => {
                    console.warn(error);
                    hasFailures = true;
                    return of(error);
                })));
            }))
        ];
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            if (batch.length > 0) {
                forkJoin(batch).subscribe((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const fullTranslation = this.getFullTranslationJSON(lang);
                    if (fullTranslation) {
                        observer.next(fullTranslation);
                    }
                    if (hasFailures) {
                        observer.error('Failed to load some resources');
                    }
                    else {
                        observer.complete();
                    }
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => {
                    observer.error('Failed to load some resources');
                }));
            }
            else {
                /** @type {?} */
                const fullTranslation = this.getFullTranslationJSON(lang);
                if (fullTranslation) {
                    observer.next(fullTranslation);
                    observer.complete();
                }
            }
        }));
    }
}
TranslateLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TranslateLoaderService.ctorParameters = () => [
    { type: HttpClient }
];
/** @nocollapse */ TranslateLoaderService.ngInjectableDef = defineInjectable({ factory: function TranslateLoaderService_Factory() { return new TranslateLoaderService(inject(HttpClient)); }, token: TranslateLoaderService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UploadService {
    /**
     * @param {?} apiService
     * @param {?} appConfigService
     */
    constructor(apiService, appConfigService) {
        this.apiService = apiService;
        this.appConfigService = appConfigService;
        this.cache = {};
        this.totalComplete = 0;
        this.totalAborted = 0;
        this.totalError = 0;
        this.excludedFileList = [];
        this.matchingOptions = null;
        this.activeTask = null;
        this.queue = [];
        this.queueChanged = new Subject();
        this.fileUpload = new Subject();
        this.fileUploadStarting = new Subject();
        this.fileUploadCancelled = new Subject();
        this.fileUploadProgress = new Subject();
        this.fileUploadAborted = new Subject();
        this.fileUploadError = new Subject();
        this.fileUploadComplete = new Subject();
        this.fileUploadDeleted = new Subject();
        this.fileDeleted = new Subject();
    }
    /**
     * Checks whether the service is uploading a file.
     * @return {?} True if a file is uploading, false otherwise
     */
    isUploading() {
        return this.activeTask ? true : false;
    }
    /**
     * Gets the file Queue
     * @return {?} Array of files that form the queue
     */
    getQueue() {
        return this.queue;
    }
    /**
     * Adds files to the uploading queue to be uploaded
     * @param {...?} files One or more separate parameters or an array of files to queue
     * @return {?} Array of files that were not blocked from upload by the ignore list
     */
    addToQueue(...files) {
        /** @type {?} */
        const allowedFiles = files.filter((/**
         * @param {?} currentFile
         * @return {?}
         */
        (currentFile) => this.filterElement(currentFile)));
        this.queue = this.queue.concat(allowedFiles);
        this.queueChanged.next(this.queue);
        return allowedFiles;
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    filterElement(file) {
        /** @type {?} */
        let isAllowed = true;
        this.excludedFileList = (/** @type {?} */ (this.appConfigService.get('files.excluded')));
        if (this.excludedFileList) {
            this.matchingOptions = this.appConfigService.get('files.match-options');
            isAllowed = this.excludedFileList.filter((/**
             * @param {?} pattern
             * @return {?}
             */
            (pattern) => {
                /** @type {?} */
                const minimatch = new Minimatch(pattern, this.matchingOptions);
                return minimatch.match(file.name);
            })).length === 0;
        }
        return isAllowed;
    }
    /**
     * Finds all the files in the queue that are not yet uploaded and uploads them into the directory folder.
     * @param {?=} emitter Emitter to invoke on file status change
     * @return {?}
     */
    uploadFilesInTheQueue(emitter) {
        if (!this.activeTask) {
            /** @type {?} */
            const file = this.queue.find((/**
             * @param {?} currentFile
             * @return {?}
             */
            (currentFile) => currentFile.status === FileUploadStatus.Pending));
            if (file) {
                this.onUploadStarting(file);
                /** @type {?} */
                const promise = this.beginUpload(file, emitter);
                this.activeTask = promise;
                this.cache[file.id] = promise;
                /** @type {?} */
                const next = (/**
                 * @return {?}
                 */
                () => {
                    this.activeTask = null;
                    setTimeout((/**
                     * @return {?}
                     */
                    () => this.uploadFilesInTheQueue(emitter)), 100);
                });
                promise.next = next;
                promise.then((/**
                 * @return {?}
                 */
                () => next()), (/**
                 * @return {?}
                 */
                () => next()));
            }
        }
    }
    /**
     * Cancels uploading of files.
     * @param {...?} files One or more separate parameters or an array of files specifying uploads to cancel
     * @return {?}
     */
    cancelUpload(...files) {
        files.forEach((/**
         * @param {?} file
         * @return {?}
         */
        (file) => {
            /** @type {?} */
            const promise = this.cache[file.id];
            if (promise) {
                promise.abort();
                delete this.cache[file.id];
            }
            else {
                /** @type {?} */
                const performAction = this.getAction(file);
                performAction();
            }
        }));
    }
    /**
     * Clears the upload queue
     * @return {?}
     */
    clearQueue() {
        this.queue = [];
        this.totalComplete = 0;
        this.totalAborted = 0;
        this.totalError = 0;
    }
    /**
     * Gets an upload promise for a file.
     * @param {?} file The target file
     * @return {?} Promise that is resolved if the upload is successful or error otherwise
     */
    getUploadPromise(file) {
        /** @type {?} */
        const opts = {
            renditions: 'doclib',
            include: ['allowableOperations']
        };
        if (file.options.newVersion === true) {
            opts.overwrite = true;
            opts.majorVersion = file.options.majorVersion;
            opts.comment = file.options.comment;
            opts.name = file.name;
        }
        else {
            opts.autoRename = true;
        }
        if (file.options.nodeType) {
            opts.nodeType = file.options.nodeType;
        }
        if (file.id) {
            return this.apiService.getInstance().node.updateNodeContent(file.id, file.file, opts);
        }
        else {
            return this.apiService.getInstance().upload.uploadFile(file.file, file.options.path, file.options.parentId, file.options, opts);
        }
    }
    /**
     * @private
     * @param {?} file
     * @param {?} emitter
     * @return {?}
     */
    beginUpload(file, emitter) {
        /** @type {?} */
        const promise = this.getUploadPromise(file);
        promise.on('progress', (/**
         * @param {?} progress
         * @return {?}
         */
        (progress) => {
            this.onUploadProgress(file, progress);
        }))
            .on('abort', (/**
         * @return {?}
         */
        () => {
            this.onUploadAborted(file);
            if (emitter) {
                emitter.emit({ value: 'File aborted' });
            }
        }))
            .on('error', (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.onUploadError(file, err);
            if (emitter) {
                emitter.emit({ value: 'Error file uploaded' });
            }
        }))
            .on('success', (/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            this.onUploadComplete(file, data);
            if (emitter) {
                emitter.emit({ value: data });
            }
        }))
            .catch((/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
        }));
        return promise;
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    onUploadStarting(file) {
        if (file) {
            file.status = FileUploadStatus.Starting;
            /** @type {?} */
            const event = new FileUploadEvent(file, FileUploadStatus.Starting);
            this.fileUpload.next(event);
            this.fileUploadStarting.next(event);
        }
    }
    /**
     * @private
     * @param {?} file
     * @param {?} progress
     * @return {?}
     */
    onUploadProgress(file, progress) {
        if (file) {
            file.progress = progress;
            file.status = FileUploadStatus.Progress;
            /** @type {?} */
            const event = new FileUploadEvent(file, FileUploadStatus.Progress);
            this.fileUpload.next(event);
            this.fileUploadProgress.next(event);
        }
    }
    /**
     * @private
     * @param {?} file
     * @param {?} error
     * @return {?}
     */
    onUploadError(file, error) {
        if (file) {
            file.errorCode = (error || {}).status;
            file.status = FileUploadStatus.Error;
            this.totalError++;
            /** @type {?} */
            const promise = this.cache[file.id];
            if (promise) {
                delete this.cache[file.id];
            }
            /** @type {?} */
            const event = new FileUploadErrorEvent(file, error, this.totalError);
            this.fileUpload.next(event);
            this.fileUploadError.next(event);
        }
    }
    /**
     * @private
     * @param {?} file
     * @param {?} data
     * @return {?}
     */
    onUploadComplete(file, data) {
        if (file) {
            file.status = FileUploadStatus.Complete;
            file.data = data;
            this.totalComplete++;
            /** @type {?} */
            const promise = this.cache[file.id];
            if (promise) {
                delete this.cache[file.id];
            }
            /** @type {?} */
            const event = new FileUploadCompleteEvent(file, this.totalComplete, data, this.totalAborted);
            this.fileUpload.next(event);
            this.fileUploadComplete.next(event);
        }
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    onUploadAborted(file) {
        if (file) {
            file.status = FileUploadStatus.Aborted;
            this.totalAborted++;
            /** @type {?} */
            const promise = this.cache[file.id];
            if (promise) {
                delete this.cache[file.id];
            }
            /** @type {?} */
            const event = new FileUploadEvent(file, FileUploadStatus.Aborted);
            this.fileUpload.next(event);
            this.fileUploadAborted.next(event);
            promise.next();
        }
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    onUploadCancelled(file) {
        if (file) {
            file.status = FileUploadStatus.Cancelled;
            /** @type {?} */
            const event = new FileUploadEvent(file, FileUploadStatus.Cancelled);
            this.fileUpload.next(event);
            this.fileUploadCancelled.next(event);
        }
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    onUploadDeleted(file) {
        if (file) {
            file.status = FileUploadStatus.Deleted;
            this.totalComplete--;
            /** @type {?} */
            const event = new FileUploadDeleteEvent(file, this.totalComplete);
            this.fileUpload.next(event);
            this.fileUploadDeleted.next(event);
        }
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    getAction(file) {
        /** @type {?} */
        const actions = {
            [FileUploadStatus.Pending]: (/**
             * @return {?}
             */
            () => this.onUploadCancelled(file)),
            [FileUploadStatus.Deleted]: (/**
             * @return {?}
             */
            () => this.onUploadDeleted(file)),
            [FileUploadStatus.Error]: (/**
             * @return {?}
             */
            () => this.onUploadError(file, null))
        };
        return actions[file.status];
    }
}
UploadService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UploadService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService }
];
/** @nocollapse */ UploadService.ngInjectableDef = defineInjectable({ factory: function UploadService_Factory() { return new UploadService(inject(AlfrescoApiService), inject(AppConfigService)); }, token: UploadService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DeletedNodesApiService {
    /**
     * @param {?} apiService
     * @param {?} preferences
     */
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    /**
     * @private
     * @return {?}
     */
    get nodesApi() {
        return this.apiService.getInstance().core.nodesApi;
    }
    /**
     * Gets a list of nodes in the trash.
     * @param {?=} options Options for JS-API call
     * @return {?} List of nodes in the trash
     */
    getDeletedNodes(options) {
        /** @type {?} */
        const defaultOptions = {
            include: ['path', 'properties'],
            maxItems: this.preferences.paginationSize,
            skipCount: 0
        };
        /** @type {?} */
        const queryOptions = Object.assign(defaultOptions, options);
        /** @type {?} */
        const promise = this.nodesApi.getDeletedNodes(queryOptions);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => of(err))));
    }
}
DeletedNodesApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DeletedNodesApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];
/** @nocollapse */ DeletedNodesApiService.ngInjectableDef = defineInjectable({ factory: function DeletedNodesApiService_Factory() { return new DeletedNodesApiService(inject(AlfrescoApiService), inject(UserPreferencesService)); }, token: DeletedNodesApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FavoritesApiService {
    /**
     * @param {?} apiService
     * @param {?} preferences
     */
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    static remapEntry({ entry }) {
        entry.properties = {
            'cm:title': entry.title,
            'cm:description': entry.description
        };
        return { entry };
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    remapFavoritesData(data = {}) {
        /** @type {?} */
        const list = (data.list || {});
        /** @type {?} */
        const pagination = (list.pagination || {});
        /** @type {?} */
        const entries = this
            .remapFavoriteEntries(list.entries || []);
        return (/** @type {?} */ ({
            list: { entries, pagination }
        }));
    }
    /**
     * @param {?} entries
     * @return {?}
     */
    remapFavoriteEntries(entries) {
        return entries
            .map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ entry: { target } }) => ({
            entry: target.file || target.folder
        })))
            .filter((/**
         * @param {?} __0
         * @return {?}
         */
        ({ entry }) => (!!entry)))
            .map(FavoritesApiService.remapEntry);
    }
    /**
     * @private
     * @return {?}
     */
    get favoritesApi() {
        return this.apiService.getInstance().core.favoritesApi;
    }
    /**
     * Gets the favorites for a user.
     * @param {?} personId ID of the user
     * @param {?=} options Options supported by JS-API
     * @return {?} List of favorites
     */
    getFavorites(personId, options) {
        /** @type {?} */
        const defaultOptions = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: ['properties', 'allowableOperations']
        };
        /** @type {?} */
        const queryOptions = Object.assign(defaultOptions, options);
        /** @type {?} */
        const promise = this.favoritesApi
            .getFavorites(personId, queryOptions)
            .then(this.remapFavoritesData);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => of(err))));
    }
}
FavoritesApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FavoritesApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];
/** @nocollapse */ FavoritesApiService.ngInjectableDef = defineInjectable({ factory: function FavoritesApiService_Factory() { return new FavoritesApiService(inject(AlfrescoApiService), inject(UserPreferencesService)); }, token: FavoritesApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodesApiService {
    /**
     * @param {?} api
     * @param {?} preferences
     */
    constructor(api, preferences) {
        this.api = api;
        this.preferences = preferences;
    }
    /**
     * @private
     * @return {?}
     */
    get nodesApi() {
        return this.api.getInstance().core.nodesApi;
    }
    /**
     * @private
     * @param {?} entity
     * @return {?}
     */
    getEntryFromEntity(entity) {
        return entity.entry;
    }
    /**
     * Gets the stored information about a node.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Node information
     */
    getNode(nodeId, options = {}) {
        /** @type {?} */
        const defaults = {
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        /** @type {?} */
        const queryOptions = Object.assign(defaults, options);
        /** @type {?} */
        const promise = this.nodesApi
            .getNode(nodeId, queryOptions)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => throwError(err))));
    }
    /**
     * Gets the items contained in a folder node.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} List of child items from the folder
     */
    getNodeChildren(nodeId, options = {}) {
        /** @type {?} */
        const defaults = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        /** @type {?} */
        const queryOptions = Object.assign(defaults, options);
        /** @type {?} */
        const promise = this.nodesApi
            .getNodeChildren(nodeId, queryOptions);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => throwError(err))));
    }
    /**
     * Creates a new document node inside a folder.
     * @param {?} parentNodeId ID of the parent folder node
     * @param {?} nodeBody Data for the new node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Details of the new node
     */
    createNode(parentNodeId, nodeBody, options = {}) {
        /** @type {?} */
        const promise = this.nodesApi
            .addNode(parentNodeId, nodeBody, options)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => throwError(err))));
    }
    /**
     * Creates a new folder node inside a parent folder.
     * @param {?} parentNodeId ID of the parent folder node
     * @param {?} nodeBody Data for the new folder
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Details of the new folder
     */
    createFolder(parentNodeId, nodeBody, options = {}) {
        /** @type {?} */
        const body = Object.assign({ nodeType: 'cm:folder' }, nodeBody);
        return this.createNode(parentNodeId, body, options);
    }
    /**
     * Updates the information about a node.
     * @param {?} nodeId ID of the target node
     * @param {?} nodeBody New data for the node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Updated node information
     */
    updateNode(nodeId, nodeBody, options = {}) {
        /** @type {?} */
        const defaults = {
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        /** @type {?} */
        const queryOptions = Object.assign(defaults, options);
        /** @type {?} */
        const promise = this.nodesApi
            .updateNode(nodeId, nodeBody, queryOptions)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => throwError(err))));
    }
    /**
     * Moves a node to the trashcan.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Empty result that notifies when the deletion is complete
     */
    deleteNode(nodeId, options = {}) {
        /** @type {?} */
        const promise = this.nodesApi.deleteNode(nodeId, options);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => throwError(err))));
    }
    /**
     * Restores a node previously moved to the trashcan.
     * @param {?} nodeId ID of the node to restore
     * @return {?} Details of the restored node
     */
    restoreNode(nodeId) {
        /** @type {?} */
        const promise = this.nodesApi
            .restoreNode(nodeId)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => throwError(err))));
    }
}
NodesApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NodesApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];
/** @nocollapse */ NodesApiService.ngInjectableDef = defineInjectable({ factory: function NodesApiService_Factory() { return new NodesApiService(inject(AlfrescoApiService), inject(UserPreferencesService)); }, token: NodesApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeopleContentService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * @private
     * @return {?}
     */
    get peopleApi() {
        return this.apiService.getInstance().core.peopleApi;
    }
    /**
     * Gets information about a user identified by their username.
     * @param {?} personId ID of the target user
     * @return {?} User information
     */
    getPerson(personId) {
        /** @type {?} */
        const promise = this.peopleApi.getPerson(personId);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => of(err))));
    }
    /**
     * Gets information about the user who is currently logged in.
     * @return {?} User information
     */
    getCurrentPerson() {
        return this.getPerson('-me-');
    }
}
PeopleContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PeopleContentService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ PeopleContentService.ngInjectableDef = defineInjectable({ factory: function PeopleContentService_Factory() { return new PeopleContentService(inject(AlfrescoApiService)); }, token: PeopleContentService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchConfigurationService {
    constructor() {
    }
    /**
     * Generates a QueryBody object with custom search parameters.
     * @param {?} searchTerm Term text to search for
     * @param {?} maxResults Maximum number of search results to show in a page
     * @param {?} skipCount The offset of the start of the page within the results list
     * @return {?} Query body defined by the parameters
     */
    generateQueryBody(searchTerm, maxResults, skipCount) {
        /** @type {?} */
        const defaultQueryBody = {
            query: {
                query: searchTerm ? `'${searchTerm}*' OR name:'${searchTerm}*'` : searchTerm
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: maxResults,
                skipCount: skipCount
            },
            filterQueries: [
                { query: "TYPE:'cm:folder' OR TYPE:'cm:content'" },
                { query: 'NOT cm:creator:System' }
            ]
        };
        return defaultQueryBody;
    }
}
SearchConfigurationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SearchConfigurationService.ctorParameters = () => [];
/** @nocollapse */ SearchConfigurationService.ngInjectableDef = defineInjectable({ factory: function SearchConfigurationService_Factory() { return new SearchConfigurationService(); }, token: SearchConfigurationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchService {
    /**
     * @param {?} apiService
     * @param {?} searchConfigurationService
     */
    constructor(apiService, searchConfigurationService) {
        this.apiService = apiService;
        this.searchConfigurationService = searchConfigurationService;
        this.dataLoaded = new Subject();
    }
    /**
     * Gets a list of nodes that match the given search criteria.
     * @param {?} term Term to search for
     * @param {?=} options Options for delivery of the search results
     * @return {?} List of nodes resulting from the search
     */
    getNodeQueryResults(term, options) {
        /** @type {?} */
        const promise = this.apiService.getInstance().core.queriesApi.findNodes(term, options);
        promise.then((/**
         * @param {?} nodePaging
         * @return {?}
         */
        (nodePaging) => {
            this.dataLoaded.next(nodePaging);
        }));
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Performs a search.
     * @param {?} searchTerm Term to search for
     * @param {?} maxResults Maximum number of items in the list of results
     * @param {?} skipCount Number of higher-ranked items to skip over in the list
     * @return {?} List of search results
     */
    search(searchTerm, maxResults, skipCount) {
        /** @type {?} */
        const searchQuery = Object.assign(this.searchConfigurationService.generateQueryBody(searchTerm, maxResults, skipCount));
        /** @type {?} */
        const promise = this.apiService.getInstance().search.searchApi.search(searchQuery);
        promise.then((/**
         * @param {?} nodePaging
         * @return {?}
         */
        (nodePaging) => {
            this.dataLoaded.next(nodePaging);
        }));
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Performs a search with its parameters supplied by a QueryBody object.
     * @param {?} queryBody Object containing the search parameters
     * @return {?} List of search results
     */
    searchByQueryBody(queryBody) {
        /** @type {?} */
        const promise = this.apiService.getInstance().search.searchApi.search(queryBody);
        promise.then((/**
         * @param {?} nodePaging
         * @return {?}
         */
        (nodePaging) => {
            this.dataLoaded.next(nodePaging);
        }));
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return throwError(error || 'Server error');
    }
}
SearchService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SearchService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: SearchConfigurationService }
];
/** @nocollapse */ SearchService.ngInjectableDef = defineInjectable({ factory: function SearchService_Factory() { return new SearchService(inject(AlfrescoApiService), inject(SearchConfigurationService)); }, token: SearchService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SharedLinksApiService {
    /**
     * @param {?} apiService
     * @param {?} preferences
     */
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    /**
     * @private
     * @return {?}
     */
    get sharedLinksApi() {
        return this.apiService.getInstance().core.sharedlinksApi;
    }
    /**
     * Gets shared links available to the current user.
     * @param {?=} options Options supported by JS-API
     * @return {?} List of shared links
     */
    getSharedLinks(options = {}) {
        /** @type {?} */
        const defaultOptions = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['properties', 'allowableOperations']
        };
        /** @type {?} */
        const queryOptions = Object.assign({}, defaultOptions, options);
        /** @type {?} */
        const promise = this.sharedLinksApi.findSharedLinks(queryOptions);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => of(err))));
    }
    /**
     * Creates a shared link available to the current user.
     * @param {?} nodeId ID of the node to link to
     * @param {?=} options Options supported by JS-API
     * @return {?} The shared link just created
     */
    createSharedLinks(nodeId, options = {}) {
        /** @type {?} */
        const promise = this.sharedLinksApi.addSharedLink({ nodeId: nodeId });
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => of(err))));
    }
    /**
     * Deletes a shared link.
     * @param {?} sharedId ID of the link to delete
     * @return {?} Null response notifying when the operation is complete
     */
    deleteSharedLink(sharedId) {
        /** @type {?} */
        const promise = this.sharedLinksApi.deleteSharedLink(sharedId);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => of(err))));
    }
}
SharedLinksApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SharedLinksApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];
/** @nocollapse */ SharedLinksApiService.ngInjectableDef = defineInjectable({ factory: function SharedLinksApiService_Factory() { return new SharedLinksApiService(inject(AlfrescoApiService), inject(UserPreferencesService)); }, token: SharedLinksApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SitesService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * Gets a list of all sites in the repository.
     * @param {?=} opts Options supported by JS-API
     * @return {?} List of sites
     */
    getSites(opts = {}) {
        /** @type {?} */
        const defaultOptions = {
            skipCount: 0,
            include: ['properties']
        };
        /** @type {?} */
        const queryOptions = Object.assign({}, defaultOptions, opts);
        return from(this.apiService.getInstance().core.sitesApi.getSites(queryOptions))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the details for a site.
     * @param {?} siteId ID of the target site
     * @param {?=} opts Options supported by JS-API
     * @return {?} Information about the site
     */
    getSite(siteId, opts) {
        return from(this.apiService.getInstance().core.sitesApi.getSite(siteId, opts))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Deletes a site.
     * @param {?} siteId Site to delete
     * @param {?=} permanentFlag True: deletion is permanent; False: site is moved to the trash
     * @return {?} Null response notifying when the operation is complete
     */
    deleteSite(siteId, permanentFlag = true) {
        /** @type {?} */
        const options = {};
        options.permanent = permanentFlag;
        return from(this.apiService.getInstance().core.sitesApi.deleteSite(siteId, options))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a site's content.
     * @param {?} siteId ID of the target site
     * @return {?} Site content
     */
    getSiteContent(siteId) {
        return this.getSite(siteId, { relations: ['containers'] });
    }
    /**
     * Gets a list of all a site's members.
     * @param {?} siteId ID of the target site
     * @return {?} Site members
     */
    getSiteMembers(siteId) {
        return this.getSite(siteId, { relations: ['members'] });
    }
    /**
     * Gets the username of the user currently logged into ACS.
     * @return {?} Username string
     */
    getEcmCurrentLoggedUserName() {
        return this.apiService.getInstance().getEcmUsername();
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.error(error);
        return throwError(error || 'Server error');
    }
}
SitesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SitesService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ SitesService.ngInjectableDef = defineInjectable({ factory: function SitesService_Factory() { return new SitesService(inject(AlfrescoApiService)); }, token: SitesService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoginDialogService {
    /**
     * @param {?} dialog
     */
    constructor(dialog) {
        this.dialog = dialog;
    }
    /**
     * Opens a dialog to choose a file to upload.
     * @param {?} actionName Name of the action to show in the title
     * @param {?} title Title for the dialog
     * @return {?} Information about the chosen file(s)
     */
    openLogin(actionName, title) {
        /** @type {?} */
        const logged = new Subject();
        logged.subscribe({
            complete: this.close.bind(this)
        });
        /** @type {?} */
        const data = {
            title,
            actionName,
            logged
        };
        this.openLoginDialog(data, 'adf-login-dialog', '630px');
        return logged;
    }
    /**
     * @private
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    openLoginDialog(data, currentPanelClass, chosenWidth) {
        this.dialog.open(LoginDialogComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
    }
    /**
     * Closes the currently open dialog.
     * @return {?}
     */
    close() {
        this.dialog.closeAll();
    }
}
LoginDialogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
LoginDialogService.ctorParameters = () => [
    { type: MatDialog }
];
/** @nocollapse */ LoginDialogService.ngInjectableDef = defineInjectable({ factory: function LoginDialogService_Factory() { return new LoginDialogService(inject(MatDialog$1)); }, token: LoginDialogService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable:adf-file-name */
class ExternalAlfrescoApiService {
    /**
     * @return {?}
     */
    getInstance() {
        return this.alfrescoApi;
    }
    /**
     * @return {?}
     */
    get contentApi() {
        return this.getInstance().content;
    }
    /**
     * @return {?}
     */
    get nodesApi() {
        return this.getInstance().nodes;
    }
    /**
     * @param {?} ecmHost
     * @param {?} contextRoot
     * @return {?}
     */
    init(ecmHost, contextRoot) {
        /** @type {?} */
        const domainPrefix = this.createPrefixFromHost(ecmHost);
        /** @type {?} */
        const config = {
            provider: 'ECM',
            hostEcm: ecmHost,
            authType: 'BASIC',
            contextRoot: contextRoot,
            domainPrefix
        };
        this.initAlfrescoApi(config);
    }
    /**
     * @protected
     * @param {?} config
     * @return {?}
     */
    initAlfrescoApi(config) {
        if (this.alfrescoApi) {
            this.alfrescoApi.configureJsApi(config);
        }
        else {
            this.alfrescoApi = new AlfrescoApiCompatibility(config);
        }
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    createPrefixFromHost(url) {
        /** @type {?} */
        const match = url.match(/:\/\/(www[0-9]?\.)?(.[^/:]+)/i);
        /** @type {?} */
        let result = null;
        if (match != null && match.length > 2 && typeof match[2] === 'string' && match[2].length > 0) {
            result = match[2];
        }
        return result;
    }
}
ExternalAlfrescoApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ExternalAlfrescoApiService.ngInjectableDef = defineInjectable({ factory: function ExternalAlfrescoApiService_Factory() { return new ExternalAlfrescoApiService(); }, token: ExternalAlfrescoApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LockService {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isLocked(node) {
        /** @type {?} */
        let isLocked = false;
        if (this.hasLockConfigured(node)) {
            if (this.isReadOnlyLock(node)) {
                isLocked = true;
                if (this.isLockExpired(node)) {
                    isLocked = false;
                }
            }
            else if (this.isLockOwnerAllowed(node)) {
                isLocked = this.alfrescoApiService.getInstance().getEcmUsername() !== node.properties['cm:lockOwner'].id;
                if (this.isLockExpired(node)) {
                    isLocked = false;
                }
            }
        }
        return isLocked;
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    hasLockConfigured(node) {
        return node.isFile && node.isLocked && node.properties['cm:lockType'];
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    isReadOnlyLock(node) {
        return node.properties['cm:lockType'] === 'READ_ONLY_LOCK' && node.properties['cm:lockLifetime'] === 'PERSISTENT';
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    isLockOwnerAllowed(node) {
        return node.properties['cm:lockType'] === 'WRITE_LOCK' && node.properties['cm:lockLifetime'] === 'PERSISTENT';
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getLockExpiryTime(node) {
        if (node.properties['cm:expiryDate']) {
            return moment(node.properties['cm:expiryDate'], 'yyyy-MM-ddThh:mm:ssZ');
        }
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    isLockExpired(node) {
        /** @type {?} */
        const expiryLockTime = this.getLockExpiryTime(node);
        return moment().isAfter(expiryLockTime);
    }
}
LockService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
LockService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ LockService.ngInjectableDef = defineInjectable({ factory: function LockService_Factory() { return new LockService(inject(AlfrescoApiService)); }, token: LockService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CoreAutomationService {
    /**
     * @param {?} appConfigService
     * @param {?} alfrescoApiService
     * @param {?} storageService
     */
    constructor(appConfigService, alfrescoApiService, storageService) {
        this.appConfigService = appConfigService;
        this.alfrescoApiService = alfrescoApiService;
        this.storageService = storageService;
    }
    /**
     * @return {?}
     */
    setup() {
        /** @type {?} */
        const adfProxy = window['adf'] || {};
        adfProxy.setConfigField = (/**
         * @param {?} field
         * @param {?} value
         * @return {?}
         */
        (field, value) => {
            this.appConfigService.config[field] = JSON.parse(value);
        });
        adfProxy.setStorageItem = (/**
         * @param {?} key
         * @param {?} data
         * @return {?}
         */
        (key, data) => {
            this.storageService.setItem(key, data);
        });
        adfProxy.clearStorage = (/**
         * @return {?}
         */
        () => {
            this.storageService.clear();
        });
        adfProxy.apiReset = (/**
         * @return {?}
         */
        () => {
            this.alfrescoApiService.reset();
        });
        window['adf'] = adfProxy;
    }
}
CoreAutomationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CoreAutomationService.ctorParameters = () => [
    { type: AppConfigService },
    { type: AlfrescoApiService },
    { type: StorageService }
];
/** @nocollapse */ CoreAutomationService.ngInjectableDef = defineInjectable({ factory: function CoreAutomationService_Factory() { return new CoreAutomationService(inject(AppConfigService), inject(AlfrescoApiService), inject(StorageService)); }, token: CoreAutomationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DialogModule {
}
DialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild(),
                    PipeModule
                ],
                declarations: [
                    DownloadZipDialogComponent
                ],
                exports: [
                    DownloadZipDialogComponent
                ],
                entryComponents: [
                    DownloadZipDialogComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IconComponent {
    constructor() {
        this._value = '';
        this._isCustom = false;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Icon value, which can be either a ligature name or a custom icon in the format `[namespace]:[name]`.
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value || 'settings';
        this._isCustom = this._value.includes(':');
    }
    /**
     * @return {?}
     */
    get isCustom() {
        return this._isCustom;
    }
}
IconComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-icon',
                template: "<ng-container *ngIf=\"isCustom; else: default\">\n  <mat-icon [color]=\"color\" [svgIcon]=\"value\"></mat-icon>\n</ng-container>\n\n<ng-template #default>\n  <mat-icon [color]=\"color\">{{ value }}</mat-icon>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-icon' },
                styles: [".adf-icon{display:inline-flex;vertical-align:middle}"]
            }] }
];
IconComponent.propDecorators = {
    color: [{ type: Input }],
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IconModule {
}
IconModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MatIconModule
                ],
                declarations: [
                    IconComponent
                ],
                exports: [
                    IconComponent
                ],
                providers: [
                    ThumbnailService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EcmCompanyModel {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This object represent the user redirection guard.*
 */
class RedirectionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.provider = obj.provider;
            this.url = obj.url || null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RequestPaginationModel {
    /**
     * @param {?=} input
     */
    constructor(input) {
        this.merge = false;
        if (input) {
            Object.assign(this, input);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:adf-file-name  */
class AlfrescoApiMock {
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    login(username, password) {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => {
            resolve('TICKET_4479f4d3bb155195879bfbb8d5206f433488a1b1');
        }));
    }
    /**
     * @return {?}
     */
    logout() {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => {
            resolve('logout');
        }));
    }
    /**
     * @return {?}
     */
    changeConfig() {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppConfigServiceMock extends AppConfigService {
    /**
     * @param {?} http
     */
    constructor(http) {
        super(http);
        this.config = {
            application: {
                name: 'Alfresco ADF Application'
            },
            ecmHost: 'http://{hostname}{:port}/ecm',
            bpmHost: 'http://{hostname}{:port}/bpm',
            logLevel: 'silent'
        };
    }
    /**
     * @return {?}
     */
    load() {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => {
            this.onLoadSubject.next(this.config);
            resolve(this.config);
        }));
    }
}
AppConfigServiceMock.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AppConfigServiceMock.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let fakeApps = {
    size: 2, total: 2, start: 0,
    data: [
        {
            id: 1, defaultAppId: null, name: 'Sales-Fakes-App', description: 'desc-fake1', modelId: 22,
            theme: 'theme-1-fake', icon: 'glyphicon-asterisk', 'deploymentId': '111', 'tenantId': null
        },
        {
            id: 2, defaultAppId: null, name: 'health-care-Fake', description: 'desc-fake2', modelId: 33,
            theme: 'theme-2-fake', icon: 'glyphicon-asterisk', 'deploymentId': '444', 'tenantId': null
        }
    ]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: should be extending AuthenticationService
class AuthenticationMock /*extends AuthenticationService*/ {
    constructor() {
        this.redirectUrl = null;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    setRedirectUrl(url) {
        this.redirectUrl = url;
    }
    /**
     * @return {?}
     */
    getRedirectUrl() {
        return this.redirectUrl ? this.redirectUrl.url : null;
    }
    // TODO: real auth service returns Observable<string>
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    login(username, password) {
        if (username === 'fake-username' && password === 'fake-password') {
            return of({ type: 'type', ticket: 'ticket' });
        }
        if (username === 'fake-username-CORS-error' && password === 'fake-password') {
            return throwError({
                error: {
                    crossDomain: true,
                    message: 'ERROR: the network is offline, Origin is not allowed by Access-Control-Allow-Origin'
                }
            });
        }
        if (username === 'fake-username-CSRF-error' && password === 'fake-password') {
            return throwError({ message: 'ERROR: Invalid CSRF-token', status: 403 });
        }
        if (username === 'fake-username-ECM-access-error' && password === 'fake-password') {
            return throwError({ message: 'ERROR: 00170728 Access Denied.  The system is currently in read-only mode', status: 403 });
        }
        return throwError('Fake server error');
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let fakeBpmUserNoImage = {
    apps: [],
    capabilities: 'fake-capability',
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: undefined,
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};
/** @type {?} */
let fakeBpmUser = {
    apps: [],
    capabilities: null,
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-bpm-first-name',
    lastName: 'fake-bpm-last-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: 12,
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};
/** @type {?} */
let fakeBpmEditedUser = {
    apps: [],
    capabilities: 'fake-capability',
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: 'src/assets/images/bpmImg.gif',
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let fakeUser1 = { id: 1, email: 'fake-email@dom.com', firstName: 'firstName', lastName: 'lastName' };
/** @type {?} */
let fakeUser2 = { id: 1001, email: 'some-one@somegroup.com', firstName: 'some', lastName: 'one' };
/** @type {?} */
let fakeTasksComment = {
    size: 2, total: 2, start: 0,
    data: [
        {
            id: 1, message: 'fake-message-1', created: '', createdBy: fakeUser1
        },
        {
            id: 2, message: 'fake-message-2', created: '', createdBy: fakeUser1
        }
    ]
};
/** @type {?} */
let fakeProcessComment = new CommentModel({ id: 1, message: 'Test', created: new Date('2016-11-10T03:37:30.010+0000'), createdBy: new UserProcessModel({
        id: 13,
        firstName: 'Wilbur',
        lastName: 'Adams',
        email: 'wilbur@app.com'
    }) });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CookieServiceMock extends CookieService {
    /**
     * @override
     * @return {?}
     */
    isEnabled() {
        return true;
    }
    /**
     * @override
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        return this[key] && this[key].data || null;
    }
    /**
     * @override
     * @param {?} key
     * @param {?} data
     * @param {?} expiration
     * @param {?} path
     * @return {?}
     */
    setItem(key, data, expiration, path) {
        this[key] = { data, expiration, path };
    }
    /**
     * @override
     * @return {?}
     */
    clear() {
        Object.keys(this).forEach((/**
         * @param {?} key
         * @return {?}
         */
        (key) => {
            if (this.hasOwnProperty(key) && typeof (this[key]) !== 'function') {
                this[key] = undefined;
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let fakeEcmCompany = {
    organization: 'company-fake-name',
    address1: 'fake-address-1',
    address2: 'fake-address-2',
    address3: 'fake-address-3',
    postcode: 'fAk1',
    telephone: '00000000',
    fax: '11111111',
    email: 'fakeCompany@fake.com'
};
/** @type {?} */
let fakeEcmUser = {
    id: 'fake-id',
    firstName: 'fake-ecm-first-name',
    lastName: 'fake-ecm-last-name',
    description: 'i am a fake user for test',
    avatarId: 'fake-avatar-id',
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: 'job-ecm-test',
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};
/** @type {?} */
let fakeEcmUserNoImage = {
    id: 'fake-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    description: 'i am a fake user for test',
    avatarId: null,
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: null,
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};
/** @type {?} */
let fakeEcmEditedUser = {
    id: 'fake-id',
    firstName: null,
    lastName: 'fake-last-name',
    description: 'i am a fake user for test',
    avatarId: 'fake-avatar-id',
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: 'test job',
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EventMock {
    /**
     * @param {?} key
     * @return {?}
     */
    static keyDown(key) {
        /** @type {?} */
        const event = document.createEvent('Event');
        event.keyCode = key;
        event.initEvent('keydown');
        document.dispatchEvent(event);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    static keyUp(key) {
        /** @type {?} */
        const event = document.createEvent('Event');
        event.keyCode = key;
        event.initEvent('keyup');
        document.dispatchEvent(event);
    }
    /**
     * @return {?}
     */
    static resizeMobileView() {
        // todo: no longer compiles with TS 2.0.2 as innerWidth/innerHeight are readonly fields
        /*
        window.innerWidth = 320;
        window.innerHeight = 568;
        */
        window.dispatchEvent(new Event('resize'));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let fakeRendition = {
    entry: {
        id: 'pdf',
        content: {
            mimeType: 'application/pdf',
            mimeTypeName: 'Adobe PDF Document'
        },
        status: 'NOT_CREATED'
    }
};
/** @type {?} */
let fakeRenditionCreated = {
    entry: {
        id: 'pdf',
        content: {
            mimeType: 'application/pdf',
            mimeTypeName: 'Adobe PDF Document'
        },
        status: 'CREATED'
    }
};
/** @type {?} */
let fakeRenditionsList = {
    list: {
        pagination: {
            count: 6,
            hasMoreItems: false,
            totalItems: 6,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: {
                    id: 'avatar',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'avatar32',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'doclib',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'imgpreview',
                    content: {
                        mimeType: 'image/jpeg',
                        mimeTypeName: 'JPEG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'medium',
                    content: {
                        mimeType: 'image/jpeg',
                        mimeTypeName: 'JPEG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'pdf',
                    content: {
                        mimeType: 'application/pdf',
                        mimeTypeName: 'Adobe PDF Document'
                    },
                    status: 'NOT_CREATED'
                }
            }
        ]
    }
};
/** @type {?} */
let fakeRenditionsListWithACreated = {
    list: {
        pagination: {
            count: 6,
            hasMoreItems: false,
            totalItems: 6,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: {
                    id: 'avatar',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'avatar32',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'doclib',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'imgpreview',
                    content: {
                        mimeType: 'image/jpeg',
                        mimeTypeName: 'JPEG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'medium',
                    content: {
                        mimeType: 'image/jpeg',
                        mimeTypeName: 'JPEG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'pdf',
                    content: {
                        mimeType: 'application/pdf',
                        mimeTypeName: 'Adobe PDF Document'
                    },
                    status: 'CREATED'
                }
            }
        ]
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let fakeSearch = {
    list: {
        pagination: {
            count: 1,
            hasMoreItems: false,
            totalItems: 1,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: {
                    id: '123',
                    name: 'MyDoc',
                    content: {
                        mimetype: 'text/plain'
                    },
                    createdByUser: {
                        displayName: 'John Doe'
                    },
                    modifiedByUser: {
                        displayName: 'John Doe'
                    }
                }
            }
        ]
    }
};
/** @type {?} */
let mockError = {
    error: {
        errorKey: 'Search failed',
        statusCode: 400,
        briefSummary: '08220082 search failed',
        stackTrace: 'For security reasons the stack trace is no longer displayed, but the property is kept for previous versions.',
        descriptionURL: 'https://api-explorer.alfresco.com'
    }
};
/** @type {?} */
let searchMockApi = {
    core: {
        queriesApi: {
            findNodes: (/**
             * @param {?} term
             * @param {?} opts
             * @return {?}
             */
            (term, opts) => Promise.resolve(fakeSearch))
        }
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TranslationMock {
    constructor() {
        this.defaultLang = 'en';
        this.translate = {
            onLangChange: new EventEmitter()
        };
    }
    /**
     * @return {?}
     */
    addTranslationFolder() { }
    /**
     * @return {?}
     */
    onTranslationChanged() { }
    /**
     * @return {?}
     */
    use() { }
    /**
     * @return {?}
     */
    loadTranslation() { }
    /**
     * @param {?} key
     * @param {?=} interpolateParams
     * @return {?}
     */
    get(key, interpolateParams) {
        return of(key);
    }
    /**
     * @param {?} key
     * @param {?=} interpolateParams
     * @return {?}
     */
    instant(key, interpolateParams) {
        return key;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable:adf-file-name */
class AlfrescoApiServiceMock extends AlfrescoApiService {
    /**
     * @param {?} appConfig
     */
    constructor(appConfig) {
        super(appConfig);
        this.appConfig = appConfig;
        if (!this.alfrescoApi) {
            this.initAlfrescoApi();
        }
    }
}
AlfrescoApiServiceMock.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AlfrescoApiServiceMock.ctorParameters = () => [
    { type: AppConfigService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let fakeForm = {
    id: 1001,
    name: 'ISSUE_FORM',
    processDefinitionId: 'ISSUE_APP:1:2504',
    processDefinitionName: 'ISSUE_APP',
    processDefinitionKey: 'ISSUE_APP',
    taskId: '7506',
    taskDefinitionKey: 'sid-F67A2996-1684-4774-855A-4591490081FD',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1498212398417',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'label',
                        name: 'Label',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'test1'
                            },
                            {
                                id: 'option_2',
                                name: 'test2'
                            },
                            {
                                id: 'option_3',
                                name: 'test3'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'radio',
                        name: 'radio',
                        type: 'radio-buttons',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: [
                            {
                                id: 'option_1',
                                name: 'Option 1'
                            },
                            {
                                id: 'option_2',
                                name: 'Option 2'
                            },
                            {
                                id: 'option_3',
                                name: 'Option 3'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 2,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: '1498212413062',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'date',
                        name: 'date',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let formDefinitionTwoTextFields = {
    id: 20,
    name: 'formTextDefinition',
    processDefinitionId: 'textDefinition:1:153',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '159',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507044399260',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'firstname',
                        name: 'firstName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'lastname',
                        name: 'lastName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
/** @type {?} */
let formDefinitionDropdownField = {
    id: 21,
    name: 'dropdownDefinition',
    processDefinitionId: 'textDefinition:2:163',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '169',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507046026940',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'united kingdom'
                            },
                            {
                                id: 'option_2',
                                name: 'italy'
                            },
                            {
                                id: 'option_3',
                                name: 'france'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
/** @type {?} */
let formDefinitionRequiredField = {
    id: 21,
    name: 'dropdownDefinition',
    processDefinitionId: 'textDefinition:2:163',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '169',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507046026940',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'united kingdom'
                            },
                            {
                                id: 'option_2',
                                name: 'italy'
                            },
                            {
                                id: 'option_3',
                                name: 'france'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let formReadonlyTwoTextFields = {
    id: 22,
    name: 'formTextDefinition',
    processDefinitionId: 'textDefinition:3:182',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '188',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507044399260',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'firstname',
                        name: 'firstName',
                        type: 'readonly',
                        value: 'fakeFirstName',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2,
                            field: {
                                id: 'firstname',
                                name: 'firstName',
                                type: 'text',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                dateDisplayFormat: null,
                                layout: null,
                                sizeX: 0,
                                sizeY: 0,
                                row: 0,
                                col: 0,
                                visibilityCondition: null
                            }
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'lastname',
                        name: 'lastName',
                        type: 'readonly',
                        value: 'fakeLastName',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1,
                            field: {
                                id: 'lastname',
                                name: 'lastName',
                                type: 'text',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                dateDisplayFormat: null,
                                layout: null,
                                sizeX: 0,
                                sizeY: 0,
                                row: 0,
                                col: 0,
                                visibilityCondition: null
                            }
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let formDefVisibilitiFieldDependsOnNextOne = {
    id: 19,
    processDefinitionId: 'visibility:1:148',
    processDefinitionName: 'visibility',
    processDefinitionKey: 'visibility',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1506960847579',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'france'
                            },
                            {
                                id: 'option_2',
                                name: 'uk'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: {
                            leftFormFieldId: 'name',
                            leftRestResponseId: null,
                            operator: '==',
                            rightValue: 'italy',
                            rightType: null,
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: '',
                            nextCondition: null
                        },
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'name',
                        name: 'name',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
/** @type {?} */
let formDefVisibilitiFieldDependsOnPreviousOne = {
    id: 19,
    processDefinitionId: 'visibility:1:148',
    processDefinitionName: 'visibility',
    processDefinitionKey: 'visibility',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1506960847579',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'name',
                        name: 'name',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'france'
                            },
                            {
                                id: 'option_2',
                                name: 'uk'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: {
                            leftFormFieldId: 'name',
                            leftRestResponseId: null,
                            operator: '==',
                            rightValue: 'italy',
                            rightType: null,
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: '',
                            nextCondition: null
                        },
                        endpoint: null,
                        requestHeaders: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let startFormDateWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'date',
                        name: 'date',
                        type: 'date',
                        value: null
                    }]
            }
        }
    ]
};
/** @type {?} */
let startFormNumberWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'number',
                        name: 'number widget',
                        type: 'integer',
                        value: null
                    }]
            }
        }
    ]
};
/** @type {?} */
let startFormAmountWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'amount',
                        name: 'amount widget',
                        type: 'amount',
                        value: null
                    }]
            }
        }
    ]
};
/** @type {?} */
let startFormRadioButtonWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'RestFieldRepresentation',
                        id: 'radio-but',
                        name: 'radio-buttons',
                        type: 'radio-buttons',
                        value: null
                    }]
            }
        }
    ]
};
/** @type {?} */
let startFormTextDefinitionMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'mocktext',
                        name: 'mockText',
                        type: 'text',
                        value: null
                    }]
            }
        }
    ]
};
/** @type {?} */
let startFormDropdownDefinitionMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'RestFieldRepresentation',
                        id: 'mockTypeDropDown',
                        name: 'mock DropDown',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'opt1',
                                name: 'Option-1'
                            },
                            {
                                id: 'opt2',
                                name: 'Option-2'
                            },
                            {
                                id: 'opt3',
                                name: 'Option-3'
                            },
                            {
                                id: 'opt2',
                                name: 'Option-3'
                            }
                        ]
                    }]
            }
        }
    ]
};
/** @type {?} */
let startMockForm = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    processDefinitionName: 'ClaimReviewProcess',
    processDefinitionKey: 'ClaimReviewProcess',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'clientname',
                        name: 'ClientName',
                        type: 'text',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'policyno',
                        name: 'PolicyNo',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterPolicyName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953270269,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billAmount',
                        name: 'BillAmount',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterBillAmount',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billdate',
                        name: 'BillDate',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: 'billdate',
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953280930,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'claimtype',
                        name: 'ClaimType',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'cashless',
                                name: 'Cashless'
                            },
                            {
                                id: 'reimbursement',
                                name: 'Reimbursement'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'hospitalName',
                        name: 'HospitalName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterHospitalName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [
        {
            id: 'approve',
            name: 'Approve'
        },
        {
            id: 'complete',
            name: 'Complete'
        },
        {
            id: 'start_process',
            name: 'Start Process'
        }
    ],
    javascriptEvents: [],
    className: '',
    style: '',
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D - M - YYYY'
};
/** @type {?} */
let startMockFormWithTab = {
    id: 4,
    taskName: 'Mock Title',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    processDefinitionName: 'ClaimReviewProcess',
    processDefinitionKey: 'ClaimReviewProcess',
    tabs: [
        {
            id: 'form1',
            name: 'Tab 1'
        },
        {
            id: 'form2',
            name: 'Tab 2'
        }
    ],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'clientname',
                        name: 'ClientName',
                        type: 'text',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'policyno',
                        name: 'PolicyNo',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterPolicyName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953270269,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billAmount',
                        name: 'BillAmount',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterBillAmount',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billdate',
                        name: 'BillDate',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: 'billdate',
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953280930,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'claimtype',
                        name: 'ClaimType',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'cashless',
                                name: 'Cashless'
                            },
                            {
                                id: 'reimbursement',
                                name: 'Reimbursement'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'hospitalName',
                        name: 'HospitalName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterHospitalName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [
        {
            id: 'approve',
            name: 'Approve'
        },
        {
            id: 'complete',
            name: 'Complete'
        }
    ],
    javascriptEvents: [],
    className: '',
    style: '',
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D - M - YYYY'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let formModelTabs = {
    id: 16,
    name: 'start event',
    description: '',
    version: 2,
    lastUpdatedBy: 4,
    lastUpdatedByFullName: 'User Test',
    lastUpdated: '2017-10-04T13:00:03.030+0000',
    stencilSetId: null,
    referenceId: null,
    formDefinition: {
        tabs: [],
        fields: [
            {
                fieldType: 'ContainerRepresentation',
                id: '1507037668653',
                name: 'Label',
                type: 'container',
                value: null,
                required: false,
                readOnly: false,
                overrideId: false,
                colspan: 1,
                placeholder: null,
                minLength: 0,
                maxLength: 0,
                minValue: null,
                maxValue: null,
                regexPattern: null,
                optionType: null,
                hasEmptyValue: null,
                options: null,
                restUrl: null,
                restResponsePath: null,
                restIdProperty: null,
                restLabelProperty: null,
                tab: null,
                className: null,
                dateDisplayFormat: null,
                layout: null,
                sizeX: 2,
                sizeY: 1,
                row: -1,
                col: -1,
                visibilityCondition: null,
                numberOfColumns: 2,
                fields: {
                    '1': [
                        {
                            fieldType: 'AmountFieldRepresentation',
                            id: 'label',
                            name: 'Label',
                            type: 'amount',
                            value: null,
                            required: false,
                            readOnly: false,
                            overrideId: false,
                            colspan: 1,
                            placeholder: null,
                            minLength: 0,
                            maxLength: 0,
                            minValue: null,
                            maxValue: null,
                            regexPattern: null,
                            optionType: null,
                            hasEmptyValue: null,
                            options: null,
                            restUrl: null,
                            restResponsePath: null,
                            restIdProperty: null,
                            restLabelProperty: null,
                            tab: null,
                            className: null,
                            params: {
                                existingColspan: 1,
                                maxColspan: 2
                            },
                            dateDisplayFormat: null,
                            layout: {
                                row: -1,
                                column: -1,
                                colspan: 1
                            },
                            sizeX: 1,
                            sizeY: 1,
                            row: -1,
                            col: -1,
                            visibilityCondition: null,
                            enableFractions: false,
                            currency: null
                        }
                    ],
                    '2': [
                        {
                            fieldType: 'FormFieldRepresentation',
                            id: 'label1',
                            name: 'Label1',
                            type: 'date',
                            value: null,
                            required: false,
                            readOnly: false,
                            overrideId: false,
                            colspan: 1,
                            placeholder: null,
                            minLength: 0,
                            maxLength: 0,
                            minValue: null,
                            maxValue: null,
                            regexPattern: null,
                            optionType: null,
                            hasEmptyValue: null,
                            options: null,
                            restUrl: null,
                            restResponsePath: null,
                            restIdProperty: null,
                            restLabelProperty: null,
                            tab: null,
                            className: null,
                            params: {
                                existingColspan: 1,
                                maxColspan: 1
                            },
                            dateDisplayFormat: null,
                            layout: {
                                row: -1,
                                column: -1,
                                colspan: 1
                            },
                            sizeX: 1,
                            sizeY: 1,
                            row: -1,
                            col: -1,
                            visibilityCondition: null
                        }
                    ]
                }
            },
            {
                fieldType: 'ContainerRepresentation',
                id: '1507037670167',
                name: 'Label',
                type: 'container',
                value: null,
                required: false,
                readOnly: false,
                overrideId: false,
                colspan: 1,
                placeholder: null,
                minLength: 0,
                maxLength: 0,
                minValue: null,
                maxValue: null,
                regexPattern: null,
                optionType: null,
                hasEmptyValue: null,
                options: null,
                restUrl: null,
                restResponsePath: null,
                restIdProperty: null,
                restLabelProperty: null,
                tab: null,
                className: null,
                dateDisplayFormat: null,
                layout: null,
                sizeX: 2,
                sizeY: 1,
                row: -1,
                col: -1,
                visibilityCondition: null,
                numberOfColumns: 2,
                fields: {
                    '1': [
                        {
                            fieldType: 'FormFieldRepresentation',
                            id: 'label2',
                            name: 'Label2',
                            type: 'boolean',
                            value: null,
                            required: false,
                            readOnly: false,
                            overrideId: false,
                            colspan: 1,
                            placeholder: null,
                            minLength: 0,
                            maxLength: 0,
                            minValue: null,
                            maxValue: null,
                            regexPattern: null,
                            optionType: null,
                            hasEmptyValue: null,
                            options: null,
                            restUrl: null,
                            restResponsePath: null,
                            restIdProperty: null,
                            restLabelProperty: null,
                            tab: null,
                            className: null,
                            params: {
                                existingColspan: 1,
                                maxColspan: 2
                            },
                            dateDisplayFormat: null,
                            layout: {
                                row: -1,
                                column: -1,
                                colspan: 1
                            },
                            sizeX: 1,
                            sizeY: 1,
                            row: -1,
                            col: -1,
                            visibilityCondition: null
                        }
                    ],
                    '2': []
                }
            }
        ],
        outcomes: [],
        javascriptEvents: [],
        className: '',
        style: '',
        customFieldTemplates: {},
        metadata: {},
        variables: [],
        customFieldsValueInfo: {},
        gridsterForm: false
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let formTest = new FormModel({});
/** @type {?} */
let fakeTaskProcessVariableModels = [
    { id: 'TEST_VAR_1', type: 'string', value: 'test_value_1' },
    { id: 'TEST_VAR_2', type: 'string', value: 'test_value_2' },
    { id: 'TEST_VAR_3', type: 'string', value: 'test_value_3' }
];
/** @type {?} */
let formValues = {
    'test_1': 'value_1',
    'test_2': 'value_2',
    'test_3': 'value_1',
    'test_4': 'dropdown_id',
    'test_5': 'dropdown_label',
    'dropdown': { 'id': 'dropdown_id', 'name': 'dropdown_label' }
};
/** @type {?} */
let fakeFormJson = {
    id: '9999',
    name: 'FORM_VISIBILITY',
    processDefinitionId: 'PROCESS_TEST:9:9999',
    processDefinitionName: 'PROCESS_TEST',
    processDefinitionKey: 'PROCESS_TEST',
    taskId: '999',
    taskName: 'TEST',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '000000000000000000',
            name: 'Label',
            type: 'container',
            value: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'FIELD_TEST',
                        name: 'FIELD_TEST',
                        type: 'text',
                        value: 'RIGHT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    },
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'FIELD_WITH_CONDITION',
                        name: 'FIELD_WITH_CONDITION',
                        type: 'text',
                        value: 'field_with_condition_value',
                        visibilityCondition: null,
                        isVisible: true
                    },
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'LEFT_FORM_FIELD_ID',
                        name: 'LEFT_FORM_FIELD_NAME',
                        type: 'text',
                        value: 'LEFT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'RIGHT_FORM_FIELD_ID',
                        name: 'RIGHT_FORM_FIELD_NAME',
                        type: 'text',
                        value: 'RIGHT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    }
                ]
            }
        }
    ]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let mockToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ' +
    'zdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiZmFtaWx5X25hbWUiOiJEb2UiLCJnaXZ' +
    'lbl9uYW1lIjoiSm9obiIsImFkbWluIjp0cnVlLCJlbWFpbCI6ImpvaG5Eb2VAZ21haWwuY29tIiwicHJ' +
    'lZmVycmVkX3VzZXJuYW1lIjoiam9obkRvZTEiLCJqdGkiOiI2MmQ3YjA4NS1hNTJjLTRjZmEtYjA2Zi1' +
    'hODFhN2IwNjRjZDIiLCJpYXQiOjE1NDM0MTA0NzcsImV4cCI6MTU0MzQxNTIxM30.pSP86kmX3keuU5E3ndaOUq2TzKdJRsuMnBdFz3Y-UEU';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const resetTestingModule = TestBed.resetTestingModule;
/** @type {?} */
const preventAngularFromResetting = (/**
 * @return {?}
 */
() => (TestBed.resetTestingModule = (/**
 * @return {?}
 */
() => TestBed)));
/** @type {?} */
const allowAngularToReset = (/**
 * @return {?}
 */
() => (TestBed.resetTestingModule = resetTestingModule));
/** @type {?} */
const setupTestBed = (/**
 * @param {?} moduleDef
 * @return {?}
 */
(moduleDef) => {
    beforeAll((/**
     * @param {?} done
     * @return {?}
     */
    (done) => ((/**
     * @return {?}
     */
    () => __awaiter(this, void 0, void 0, function* () {
        localStorage.clear();
        sessionStorage.clear();
        resetTestingModule();
        preventAngularFromResetting();
        TestBed.configureTestingModule(moduleDef);
        yield TestBed.compileComponents();
        // prevent Angular from resetting testing module
        TestBed.resetTestingModule = (/**
         * @return {?}
         */
        () => TestBed);
    })))()
        .then(done)
        .catch(done.fail)));
    afterAll((/**
     * @return {?}
     */
    () => allowAngularToReset()));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {?} alfrescoApiService
 * @return {?}
 */
function startupServiceFactory(alfrescoApiService) {
    return (/**
     * @return {?}
     */
    () => alfrescoApiService.load());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CoreModule {
    /**
     * @param {?} translation
     */
    constructor(translation) {
        translation.addTranslationFolder('adf-core', 'assets/adf-core');
    }
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: CoreModule,
            providers: [
                TranslateStore,
                TranslateService,
                { provide: TranslateLoader, useClass: TranslateLoaderService },
                {
                    provide: APP_INITIALIZER,
                    useFactory: startupServiceFactory,
                    deps: [
                        AlfrescoApiService
                    ],
                    multi: true
                }
            ]
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: CoreModule
        };
    }
}
CoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    TranslateModule,
                    ExtensionsModule.forChild(),
                    AboutModule,
                    ViewerModule,
                    LayoutModule,
                    PipeModule,
                    CommonModule,
                    DirectiveModule,
                    DialogModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HostSettingsModule,
                    UserInfoModule,
                    MaterialModule,
                    AppConfigModule,
                    PaginationModule,
                    ToolbarModule,
                    ContextMenuModule,
                    CardViewModule,
                    FormBaseModule,
                    CommentsModule,
                    LoginModule,
                    LanguageMenuModule,
                    InfoDrawerModule,
                    DataColumnModule,
                    DataTableModule,
                    ButtonsMenuModule,
                    TemplateModule,
                    IconModule,
                    SortingPickerModule
                ],
                exports: [
                    AboutModule,
                    ViewerModule,
                    LayoutModule,
                    PipeModule,
                    CommonModule,
                    DirectiveModule,
                    DialogModule,
                    ClipboardModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HostSettingsModule,
                    UserInfoModule,
                    MaterialModule,
                    AppConfigModule,
                    PaginationModule,
                    ToolbarModule,
                    ContextMenuModule,
                    CardViewModule,
                    FormBaseModule,
                    CommentsModule,
                    LoginModule,
                    LanguageMenuModule,
                    InfoDrawerModule,
                    DataColumnModule,
                    DataTableModule,
                    TranslateModule,
                    ButtonsMenuModule,
                    TemplateModule,
                    SortingPickerModule,
                    IconModule
                ]
            },] }
];
/** @nocollapse */
CoreModule.ctorParameters = () => [
    { type: TranslationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AboutComponent, AboutModule, ViewUtilService, ViewerComponent, ImgViewerComponent, MediaPlayerComponent, PdfViewerComponent, PdfThumbListComponent, PdfThumbComponent, TxtViewerComponent, UnknownFormatComponent, ViewerMoreActionsComponent, ViewerOpenWithComponent, ViewerSidebarComponent, ViewerToolbarComponent, ViewerToolbarActionsComponent, ViewerExtensionDirective, ViewerModule, UserInfoComponent, BpmUserService, EcmUserService, IdentityUserService, BpmUserModel, EcmUserModel, IdentityUserModel, IdentityRoleModel, UserInfoModule, ToolbarDividerComponent, ToolbarTitleComponent, ToolbarComponent, ToolbarModule, HostSettingsComponent, HostSettingsModule, PaginationComponent, InfinitePaginationComponent, PaginationModule, LoginHeaderDirective, LoginFooterDirective, LoginComponent, LoginDialogComponent, LoginDialogPanelComponent, LoginErrorEvent, LoginSubmitEvent, LoginSuccessEvent, LoginModule, LanguageMenuComponent, LanguageMenuModule, InfoDrawerLayoutComponent, InfoDrawerTitleDirective, InfoDrawerButtonsDirective, InfoDrawerContentDirective, InfoDrawerTabComponent, InfoDrawerComponent, declarations, InfoDrawerModule, DataColumnListComponent, DataColumnComponent, DataColumnModule, DataRowEvent, DataSorting, ObjectDataRow, ObjectDataTableAdapter, ObjectDataColumn, DataCellEventModel, DataCellEvent, DataRowActionModel, DataRowActionEvent, DropZoneDirective, DataTableCellComponent, DisplayMode, DataTableComponent, DateCellComponent, EmptyListComponent, EmptyListHeaderDirective, EmptyListBodyDirective, EmptyListFooterDirective, FileSizeCellComponent, LocationCellComponent, DataTableSchema, LoadingContentTemplateDirective, NoContentTemplateDirective, NoPermissionTemplateDirective, CustomEmptyContentTemplateDirective, CustomLoadingContentTemplateDirective, CustomNoPermissionTemplateDirective, DataTableModule, ContextMenuHolderComponent, ContextMenuDirective, ContextMenuService, ContextMenuOverlayService, ContextMenuModule, CardViewComponent, CardViewBoolItemComponent, CardViewDateItemComponent, CardViewMapItemComponent, CardViewTextItemComponent, CardViewSelectItemComponent, CardViewKeyValuePairsItemComponent, CardViewItemIntValidator, CardViewItemFloatValidator, CardViewBaseItemModel, CardViewBoolItemModel, CardViewDateItemModel, CardViewDatetimeItemModel, CardViewFloatItemModel, CardViewIntItemModel, CardViewMapItemModel, CardViewTextItemModel, CardViewKeyValuePairsItemModel, CardViewSelectItemModel, CardItemTypeService, transformKeyToObject, CardViewUpdateService, CardViewContentProxyDirective, CardViewModule, AppConfigValues, Status, AppConfigService, DebugAppConfigService, AppConfigPipe, AppConfigModule, FormBaseComponent, FormListComponent, ContentWidgetComponent, FormRendererComponent, WIDGET_DIRECTIVES, MASK_DIRECTIVE, baseHost, WidgetComponent, FormFieldTypes, FormWidgetModel, FormFieldModel, FormModel, ContainerModel, ContainerColumnModel, TabModel, FormOutcomeModel, FormOutcomeEvent, RequiredFieldValidator, NumberFieldValidator, DateFieldValidator, MinDateFieldValidator, MaxDateFieldValidator, MinDateTimeFieldValidator, MaxDateTimeFieldValidator, MinLengthFieldValidator, MaxLengthFieldValidator, MinValueFieldValidator, MaxValueFieldValidator, RegExFieldValidator, FixedValueFieldValidator, FORM_FIELD_VALIDATORS, ContentLinkModel, ErrorMessageModel, TabsWidgetComponent, ContainerWidgetComponent, UnknownWidgetComponent, TextWidgetComponent, NumberWidgetComponent, CheckboxWidgetComponent, MultilineTextWidgetComponentComponent, DropdownWidgetComponent, HyperlinkWidgetComponent, RadioButtonsWidgetComponent, DisplayTextWidgetComponentComponent, UploadWidgetComponent, TypeaheadWidgetComponent, FunctionalGroupWidgetComponent, PeopleWidgetComponent, DateWidgetComponent, AmountWidgetComponent, DynamicTableWidgetComponent, ErrorWidgetComponent, DocumentWidgetComponent, DateTimeWidgetComponent, DynamicTableModel, RowEditorComponent, DateEditorComponent, DropdownEditorComponent, BooleanEditorComponent, TextEditorComponent, DateTimeEditorComponent, CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR, InputMaskDirective, ActivitiContentService, EcmModelService, FormRenderingService, FormService, NodeService, ProcessContentService, WidgetVisibilityService, FormEvent, FormErrorEvent, FormFieldEvent, ValidateFormFieldEvent, ValidateFormEvent, ValidateDynamicTableRowEvent, FormBaseModule, SidenavLayoutComponent, LayoutModule, LayoutModule as SidenavLayoutModule, CommentListComponent, CommentsComponent, CommentsModule, ButtonsMenuComponent, ButtonsMenuModule, SortingPickerComponent, SortingPickerModule, ErrorContentComponent, EmptyContentComponent, TemplateModule, FileSizePipe, MimeTypeIconPipe, NodeNameTooltipPipe, HighlightPipe, TimeAgoPipe, InitialUsernamePipe, FullNamePipe, MultiValuePipe, PipeModule, AuthGuardBase, AuthenticationService, AlfrescoApiService, ContentService, AuthGuard, AuthGuardEcm, AuthGuardBpm, AuthGuardSsoRoleService, AppsProcessService, PageTitleService, StorageService, CookieService, RenditionsService, NotificationService, LogService, TRANSLATION_PROVIDER, TranslationService, TranslateLoaderService, ThumbnailService, UploadService, DynamicComponentResolver, DynamicComponentMapper, UserPreferenceValues, UserPreferencesService, HighlightTransformService, DeletedNodesApiService, FavoritesApiService, NodesApiService, PeopleContentService, PeopleProcessService, SearchService, SharedLinksApiService, SitesService, DiscoveryApiService, CommentProcessService, SearchConfigurationService, CommentContentService, LoginDialogService, ExternalAlfrescoApiService, JwtHelperService, DownloadZipService, LockService, CoreAutomationService, PreviousRouteService, HighlightDirective, LogoutDirective, NodeDeleteDirective, NodeFavoriteDirective, CheckAllowableOperationDirective, RestoreMessageModel, NodeRestoreDirective, NodeDownloadDirective, UploadDirective, DirectiveModule, ClipboardDirective, ClipboardComponent, ClipboardService, ClipboardModule, DownloadZipDialogComponent, DialogModule, IconComponent, IconModule, ObjectUtils, FileUtils, MOMENT_DATE_FORMATS, MomentDateAdapter, EXTENDIBLE_COMPONENT, FileUploadOptions, FileUploadStatus, FileModel, AllowableOperationsEnum, PermissionsEnum, BpmProductVersionModel, VersionModel, LicenseModel, VersionStatusModel, VersionModuleModel, EcmProductVersionModel, UserProcessModel, CommentModel, EcmCompanyModel, RedirectionModel, PaginationModel, RequestPaginationModel, BaseEvent, BaseUIEvent, FileUploadEvent, FileUploadCompleteEvent, FileUploadDeleteEvent, FileUploadErrorEvent, AlfrescoApiMock, AppConfigServiceMock, fakeApps, AuthenticationMock, fakeBpmUserNoImage, fakeBpmUser, fakeBpmEditedUser, fakeUser1, fakeUser2, fakeTasksComment, fakeProcessComment, CookieServiceMock, fakeEcmCompany, fakeEcmUser, fakeEcmUserNoImage, fakeEcmEditedUser, EventMock, fakeRendition, fakeRenditionCreated, fakeRenditionsList, fakeRenditionsListWithACreated, fakeSearch, mockError, searchMockApi, TranslationMock, AlfrescoApiServiceMock, fakeForm, formDefinitionTwoTextFields, formDefinitionDropdownField, formDefinitionRequiredField, formReadonlyTwoTextFields, formDefVisibilitiFieldDependsOnNextOne, formDefVisibilitiFieldDependsOnPreviousOne, startFormDateWidgetMock, startFormNumberWidgetMock, startFormAmountWidgetMock, startFormRadioButtonWidgetMock, startFormTextDefinitionMock, startFormDropdownDefinitionMock, startMockForm, startMockFormWithTab, formModelTabs, formTest, fakeTaskProcessVariableModels, formValues, fakeFormJson, mockToken, setupTestBed, CoreModule, CardViewItemDispatcherComponent as ɵa, contextMenuAnimation as ɵe, ContextMenuListComponent as ɵd, ContextMenuOverlayRef as ɵf, CONTEXT_MENU_DATA as ɵg, JsonCellComponent as ɵj, FormBaseModel as ɵm, StartFormCustomButtonDirective as ɵp, FormFieldComponent as ɵo, DynamicRowValidationSummary as ɵn, HeaderLayoutComponent as ɵbb, LayoutContainerComponent as ɵt, SidebarActionMenuComponent as ɵx, SidebarMenuDirective as ɵy, SidebarMenuExpandIconDirective as ɵba, SidebarMenuTitleIconDirective as ɵz, SidenavLayoutContentDirective as ɵs, SidenavLayoutHeaderDirective as ɵq, SidenavLayoutNavigationDirective as ɵr, contentAnimationLeft as ɵv, contentAnimationRight as ɵw, sidenavAnimation as ɵu, MaterialModule as ɵc, modules as ɵb, FileTypePipe as ɵi, FormatSpacePipe as ɵh, getType as ɵbc, startupServiceFactory as ɵbd, PdfPasswordDialogComponent as ɵl, RenderingQueueServices as ɵk };

//# sourceMappingURL=adf-core.js.map