/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { from, throwError } from 'rxjs';
import { AlfrescoApiService } from './alfresco-api.service';
import { UserPreferencesService } from './user-preferences.service';
import { catchError } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./alfresco-api.service";
import * as i2 from "./user-preferences.service";
var NodesApiService = /** @class */ (function () {
    function NodesApiService(api, preferences) {
        this.api = api;
        this.preferences = preferences;
    }
    Object.defineProperty(NodesApiService.prototype, "nodesApi", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.api.getInstance().core.nodesApi;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} entity
     * @return {?}
     */
    NodesApiService.prototype.getEntryFromEntity = /**
     * @private
     * @param {?} entity
     * @return {?}
     */
    function (entity) {
        return entity.entry;
    };
    /**
     * Gets the stored information about a node.
     * @param nodeId ID of the target node
     * @param options Optional parameters supported by JS-API
     * @returns Node information
     */
    /**
     * Gets the stored information about a node.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Node information
     */
    NodesApiService.prototype.getNode = /**
     * Gets the stored information about a node.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Node information
     */
    function (nodeId, options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var defaults = {
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        /** @type {?} */
        var queryOptions = Object.assign(defaults, options);
        /** @type {?} */
        var promise = this.nodesApi
            .getNode(nodeId, queryOptions)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return throwError(err); })));
    };
    /**
     * Gets the items contained in a folder node.
     * @param nodeId ID of the target node
     * @param options Optional parameters supported by JS-API
     * @returns List of child items from the folder
     */
    /**
     * Gets the items contained in a folder node.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} List of child items from the folder
     */
    NodesApiService.prototype.getNodeChildren = /**
     * Gets the items contained in a folder node.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} List of child items from the folder
     */
    function (nodeId, options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var defaults = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        /** @type {?} */
        var queryOptions = Object.assign(defaults, options);
        /** @type {?} */
        var promise = this.nodesApi
            .getNodeChildren(nodeId, queryOptions);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return throwError(err); })));
    };
    /**
     * Creates a new document node inside a folder.
     * @param parentNodeId ID of the parent folder node
     * @param nodeBody Data for the new node
     * @param options Optional parameters supported by JS-API
     * @returns Details of the new node
     */
    /**
     * Creates a new document node inside a folder.
     * @param {?} parentNodeId ID of the parent folder node
     * @param {?} nodeBody Data for the new node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Details of the new node
     */
    NodesApiService.prototype.createNode = /**
     * Creates a new document node inside a folder.
     * @param {?} parentNodeId ID of the parent folder node
     * @param {?} nodeBody Data for the new node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Details of the new node
     */
    function (parentNodeId, nodeBody, options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var promise = this.nodesApi
            .addNode(parentNodeId, nodeBody, options)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return throwError(err); })));
    };
    /**
     * Creates a new folder node inside a parent folder.
     * @param parentNodeId ID of the parent folder node
     * @param nodeBody Data for the new folder
     * @param options Optional parameters supported by JS-API
     * @returns Details of the new folder
     */
    /**
     * Creates a new folder node inside a parent folder.
     * @param {?} parentNodeId ID of the parent folder node
     * @param {?} nodeBody Data for the new folder
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Details of the new folder
     */
    NodesApiService.prototype.createFolder = /**
     * Creates a new folder node inside a parent folder.
     * @param {?} parentNodeId ID of the parent folder node
     * @param {?} nodeBody Data for the new folder
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Details of the new folder
     */
    function (parentNodeId, nodeBody, options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var body = Object.assign({ nodeType: 'cm:folder' }, nodeBody);
        return this.createNode(parentNodeId, body, options);
    };
    /**
     * Updates the information about a node.
     * @param nodeId ID of the target node
     * @param nodeBody New data for the node
     * @param options Optional parameters supported by JS-API
     * @returns Updated node information
     */
    /**
     * Updates the information about a node.
     * @param {?} nodeId ID of the target node
     * @param {?} nodeBody New data for the node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Updated node information
     */
    NodesApiService.prototype.updateNode = /**
     * Updates the information about a node.
     * @param {?} nodeId ID of the target node
     * @param {?} nodeBody New data for the node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Updated node information
     */
    function (nodeId, nodeBody, options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var defaults = {
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        /** @type {?} */
        var queryOptions = Object.assign(defaults, options);
        /** @type {?} */
        var promise = this.nodesApi
            .updateNode(nodeId, nodeBody, queryOptions)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return throwError(err); })));
    };
    /**
     * Moves a node to the trashcan.
     * @param nodeId ID of the target node
     * @param options Optional parameters supported by JS-API
     * @returns Empty result that notifies when the deletion is complete
     */
    /**
     * Moves a node to the trashcan.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Empty result that notifies when the deletion is complete
     */
    NodesApiService.prototype.deleteNode = /**
     * Moves a node to the trashcan.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JS-API
     * @return {?} Empty result that notifies when the deletion is complete
     */
    function (nodeId, options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var promise = this.nodesApi.deleteNode(nodeId, options);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return throwError(err); })));
    };
    /**
     * Restores a node previously moved to the trashcan.
     * @param nodeId ID of the node to restore
     * @returns Details of the restored node
     */
    /**
     * Restores a node previously moved to the trashcan.
     * @param {?} nodeId ID of the node to restore
     * @return {?} Details of the restored node
     */
    NodesApiService.prototype.restoreNode = /**
     * Restores a node previously moved to the trashcan.
     * @param {?} nodeId ID of the node to restore
     * @return {?} Details of the restored node
     */
    function (nodeId) {
        /** @type {?} */
        var promise = this.nodesApi
            .restoreNode(nodeId)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return throwError(err); })));
    };
    NodesApiService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NodesApiService.ctorParameters = function () { return [
        { type: AlfrescoApiService },
        { type: UserPreferencesService }
    ]; };
    /** @nocollapse */ NodesApiService.ngInjectableDef = i0.defineInjectable({ factory: function NodesApiService_Factory() { return new NodesApiService(i0.inject(i1.AlfrescoApiService), i0.inject(i2.UserPreferencesService)); }, token: NodesApiService, providedIn: "root" });
    return NodesApiService;
}());
export { NodesApiService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NodesApiService.prototype.api;
    /**
     * @type {?}
     * @private
     */
    NodesApiService.prototype.preferences;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZXMtYXBpLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9ub2Rlcy1hcGkuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBYyxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3BELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUU1QztJQUtJLHlCQUNZLEdBQXVCLEVBQ3ZCLFdBQW1DO1FBRG5DLFFBQUcsR0FBSCxHQUFHLENBQW9CO1FBQ3ZCLGdCQUFXLEdBQVgsV0FBVyxDQUF3QjtJQUFHLENBQUM7SUFFbkQsc0JBQVkscUNBQVE7Ozs7O1FBQXBCO1lBQ0ksT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDaEQsQ0FBQzs7O09BQUE7Ozs7OztJQUVPLDRDQUFrQjs7Ozs7SUFBMUIsVUFBMkIsTUFBaUI7UUFDeEMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7T0FLRzs7Ozs7OztJQUNILGlDQUFPOzs7Ozs7SUFBUCxVQUFRLE1BQWMsRUFBRSxPQUFpQjtRQUFqQix3QkFBQSxFQUFBLFlBQWlCOztZQUMvQixRQUFRLEdBQUc7WUFDYixPQUFPLEVBQUUsQ0FBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLHFCQUFxQixFQUFFLGFBQWEsQ0FBRTtTQUMxRTs7WUFDSyxZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFR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QUFHLENBQUMsRUFBZixDQUFlLEVBQUMsQ0FDdkMsQ0FBQztJQUNOLENBQUM7SUFFRDs7Ozs7T0FLRzs7Ozs7OztJQUNILG9DQUFVOzs7Ozs7SUFBVixVQUFXLE1BQWMsRUFBRSxPQUFpQjtRQUFqQix3QkFBQSxFQUFBLFlBQWlCOztZQUNsQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQztRQUV6RCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ3JCLFVBQVU7Ozs7UUFBQyxVQUFDLEdBQUcsSUFBSyxPQUFBLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBZixDQUFlLEVBQUMsQ0FDdkMsQ0FBQztJQUNOLENBQUM7SUFFRDs7OztPQUlHOzs7Ozs7SUFDSCxxQ0FBVzs7Ozs7SUFBWCxVQUFZLE1BQWM7O1lBQ2hCLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUTthQUN4QixXQUFXLENBQUMsTUFBTSxDQUFDO2FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUM7UUFFbEMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNyQixVQUFVOzs7O1FBQUMsVUFBQyxHQUFHLElBQUssT0FBQSxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQWYsQ0FBZSxFQUFDLENBQ3ZDLENBQUM7SUFDTixDQUFDOztnQkF4SUosVUFBVSxTQUFDO29CQUNSLFVBQVUsRUFBRSxNQUFNO2lCQUNyQjs7OztnQkFOUSxrQkFBa0I7Z0JBQ2xCLHNCQUFzQjs7OzBCQXJCL0I7Q0FpS0MsQUF6SUQsSUF5SUM7U0F0SVksZUFBZTs7Ozs7O0lBR3BCLDhCQUErQjs7Ozs7SUFDL0Isc0NBQTJDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTm9kZUVudHJ5LCBNaW5pbWFsTm9kZSwgTm9kZVBhZ2luZyB9IGZyb20gJ0BhbGZyZXNjby9qcy1hcGknO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnLi9hbGZyZXNjby1hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlIH0gZnJvbSAnLi91c2VyLXByZWZlcmVuY2VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBOb2Rlc0FwaVNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgYXBpOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgcHJlZmVyZW5jZXM6IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UpIHt9XG5cbiAgICBwcml2YXRlIGdldCBub2Rlc0FwaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmdldEluc3RhbmNlKCkuY29yZS5ub2Rlc0FwaTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEVudHJ5RnJvbUVudGl0eShlbnRpdHk6IE5vZGVFbnRyeSkge1xuICAgICAgICByZXR1cm4gZW50aXR5LmVudHJ5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0b3JlZCBpbmZvcm1hdGlvbiBhYm91dCBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHN1cHBvcnRlZCBieSBKUy1BUElcbiAgICAgKiBAcmV0dXJucyBOb2RlIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgZ2V0Tm9kZShub2RlSWQ6IHN0cmluZywgb3B0aW9uczogYW55ID0ge30pOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlPiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgaW5jbHVkZTogWyAncGF0aCcsICdwcm9wZXJ0aWVzJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnLCAncGVybWlzc2lvbnMnIF1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcXVlcnlPcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm5vZGVzQXBpXG4gICAgICAgICAgICAuZ2V0Tm9kZShub2RlSWQsIHF1ZXJ5T3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKHRoaXMuZ2V0RW50cnlGcm9tRW50aXR5KTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB0aHJvd0Vycm9yKGVycikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaXRlbXMgY29udGFpbmVkIGluIGEgZm9sZGVyIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHN1cHBvcnRlZCBieSBKUy1BUElcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGNoaWxkIGl0ZW1zIGZyb20gdGhlIGZvbGRlclxuICAgICAqL1xuICAgIGdldE5vZGVDaGlsZHJlbihub2RlSWQ6IHN0cmluZywgb3B0aW9uczogYW55ID0ge30pOiBPYnNlcnZhYmxlPE5vZGVQYWdpbmc+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBtYXhJdGVtczogdGhpcy5wcmVmZXJlbmNlcy5wYWdpbmF0aW9uU2l6ZSxcbiAgICAgICAgICAgIHNraXBDb3VudDogMCxcbiAgICAgICAgICAgIGluY2x1ZGU6IFsgJ3BhdGgnLCAncHJvcGVydGllcycsICdhbGxvd2FibGVPcGVyYXRpb25zJywgJ3Blcm1pc3Npb25zJyBdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHF1ZXJ5T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5ub2Rlc0FwaVxuICAgICAgICAgICAgLmdldE5vZGVDaGlsZHJlbihub2RlSWQsIHF1ZXJ5T3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIGZyb20ocHJvbWlzZSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4gdGhyb3dFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgbm9kZSBpbnNpZGUgYSBmb2xkZXIuXG4gICAgICogQHBhcmFtIHBhcmVudE5vZGVJZCBJRCBvZiB0aGUgcGFyZW50IGZvbGRlciBub2RlXG4gICAgICogQHBhcmFtIG5vZGVCb2R5IERhdGEgZm9yIHRoZSBuZXcgbm9kZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3VwcG9ydGVkIGJ5IEpTLUFQSVxuICAgICAqIEByZXR1cm5zIERldGFpbHMgb2YgdGhlIG5ldyBub2RlXG4gICAgICovXG4gICAgY3JlYXRlTm9kZShwYXJlbnROb2RlSWQ6IHN0cmluZywgbm9kZUJvZHk6IGFueSwgb3B0aW9uczogYW55ID0ge30pOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlPiB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm5vZGVzQXBpXG4gICAgICAgICAgICAuYWRkTm9kZShwYXJlbnROb2RlSWQsIG5vZGVCb2R5LCBvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5nZXRFbnRyeUZyb21FbnRpdHkpO1xuXG4gICAgICAgIHJldHVybiBmcm9tKHByb21pc2UpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKChlcnIpID0+IHRocm93RXJyb3IoZXJyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGZvbGRlciBub2RlIGluc2lkZSBhIHBhcmVudCBmb2xkZXIuXG4gICAgICogQHBhcmFtIHBhcmVudE5vZGVJZCBJRCBvZiB0aGUgcGFyZW50IGZvbGRlciBub2RlXG4gICAgICogQHBhcmFtIG5vZGVCb2R5IERhdGEgZm9yIHRoZSBuZXcgZm9sZGVyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycyBzdXBwb3J0ZWQgYnkgSlMtQVBJXG4gICAgICogQHJldHVybnMgRGV0YWlscyBvZiB0aGUgbmV3IGZvbGRlclxuICAgICAqL1xuICAgIGNyZWF0ZUZvbGRlcihwYXJlbnROb2RlSWQ6IHN0cmluZywgbm9kZUJvZHk6IGFueSwgb3B0aW9uczogYW55ID0ge30pOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlPiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKHsgbm9kZVR5cGU6ICdjbTpmb2xkZXInIH0sIG5vZGVCb2R5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTm9kZShwYXJlbnROb2RlSWQsIGJvZHksIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGluZm9ybWF0aW9uIGFib3V0IGEgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEBwYXJhbSBub2RlQm9keSBOZXcgZGF0YSBmb3IgdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHN1cHBvcnRlZCBieSBKUy1BUElcbiAgICAgKiBAcmV0dXJucyBVcGRhdGVkIG5vZGUgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICB1cGRhdGVOb2RlKG5vZGVJZDogc3RyaW5nLCBub2RlQm9keTogYW55LCBvcHRpb25zOiBhbnkgPSB7fSk6IE9ic2VydmFibGU8TWluaW1hbE5vZGU+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBpbmNsdWRlOiBbICdwYXRoJywgJ3Byb3BlcnRpZXMnLCAnYWxsb3dhYmxlT3BlcmF0aW9ucycsICdwZXJtaXNzaW9ucycgXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5ub2Rlc0FwaVxuICAgICAgICAgICAgLnVwZGF0ZU5vZGUobm9kZUlkLCBub2RlQm9keSwgcXVlcnlPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5nZXRFbnRyeUZyb21FbnRpdHkpO1xuXG4gICAgICAgIHJldHVybiBmcm9tKHByb21pc2UpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKChlcnIpID0+IHRocm93RXJyb3IoZXJyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIG5vZGUgdG8gdGhlIHRyYXNoY2FuLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycyBzdXBwb3J0ZWQgYnkgSlMtQVBJXG4gICAgICogQHJldHVybnMgRW1wdHkgcmVzdWx0IHRoYXQgbm90aWZpZXMgd2hlbiB0aGUgZGVsZXRpb24gaXMgY29tcGxldGVcbiAgICAgKi9cbiAgICBkZWxldGVOb2RlKG5vZGVJZDogc3RyaW5nLCBvcHRpb25zOiBhbnkgPSB7fSk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm5vZGVzQXBpLmRlbGV0ZU5vZGUobm9kZUlkLCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB0aHJvd0Vycm9yKGVycikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgYSBub2RlIHByZXZpb3VzbHkgbW92ZWQgdG8gdGhlIHRyYXNoY2FuLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIG5vZGUgdG8gcmVzdG9yZVxuICAgICAqIEByZXR1cm5zIERldGFpbHMgb2YgdGhlIHJlc3RvcmVkIG5vZGVcbiAgICAgKi9cbiAgICByZXN0b3JlTm9kZShub2RlSWQ6IHN0cmluZyk6IE9ic2VydmFibGU8TWluaW1hbE5vZGU+IHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubm9kZXNBcGlcbiAgICAgICAgICAgIC5yZXN0b3JlTm9kZShub2RlSWQpXG4gICAgICAgICAgICAudGhlbih0aGlzLmdldEVudHJ5RnJvbUVudGl0eSk7XG5cbiAgICAgICAgcmV0dXJuIGZyb20ocHJvbWlzZSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4gdGhyb3dFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==