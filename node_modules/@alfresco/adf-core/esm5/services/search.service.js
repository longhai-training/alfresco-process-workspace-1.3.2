/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { Subject, from, throwError } from 'rxjs';
import { AlfrescoApiService } from './alfresco-api.service';
import { SearchConfigurationService } from './search-configuration.service';
import { catchError } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./alfresco-api.service";
import * as i2 from "./search-configuration.service";
var SearchService = /** @class */ (function () {
    function SearchService(apiService, searchConfigurationService) {
        this.apiService = apiService;
        this.searchConfigurationService = searchConfigurationService;
        this.dataLoaded = new Subject();
    }
    /**
     * Gets a list of nodes that match the given search criteria.
     * @param term Term to search for
     * @param options Options for delivery of the search results
     * @returns List of nodes resulting from the search
     */
    /**
     * Gets a list of nodes that match the given search criteria.
     * @param {?} term Term to search for
     * @param {?=} options Options for delivery of the search results
     * @return {?} List of nodes resulting from the search
     */
    SearchService.prototype.getNodeQueryResults = /**
     * Gets a list of nodes that match the given search criteria.
     * @param {?} term Term to search for
     * @param {?=} options Options for delivery of the search results
     * @return {?} List of nodes resulting from the search
     */
    function (term, options) {
        var _this = this;
        /** @type {?} */
        var promise = this.apiService.getInstance().core.queriesApi.findNodes(term, options);
        promise.then((/**
         * @param {?} nodePaging
         * @return {?}
         */
        function (nodePaging) {
            _this.dataLoaded.next(nodePaging);
        }));
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Performs a search.
     * @param searchTerm Term to search for
     * @param maxResults Maximum number of items in the list of results
     * @param skipCount Number of higher-ranked items to skip over in the list
     * @returns List of search results
     */
    /**
     * Performs a search.
     * @param {?} searchTerm Term to search for
     * @param {?} maxResults Maximum number of items in the list of results
     * @param {?} skipCount Number of higher-ranked items to skip over in the list
     * @return {?} List of search results
     */
    SearchService.prototype.search = /**
     * Performs a search.
     * @param {?} searchTerm Term to search for
     * @param {?} maxResults Maximum number of items in the list of results
     * @param {?} skipCount Number of higher-ranked items to skip over in the list
     * @return {?} List of search results
     */
    function (searchTerm, maxResults, skipCount) {
        var _this = this;
        /** @type {?} */
        var searchQuery = Object.assign(this.searchConfigurationService.generateQueryBody(searchTerm, maxResults, skipCount));
        /** @type {?} */
        var promise = this.apiService.getInstance().search.searchApi.search(searchQuery);
        promise.then((/**
         * @param {?} nodePaging
         * @return {?}
         */
        function (nodePaging) {
            _this.dataLoaded.next(nodePaging);
        }));
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Performs a search with its parameters supplied by a QueryBody object.
     * @param queryBody Object containing the search parameters
     * @returns List of search results
     */
    /**
     * Performs a search with its parameters supplied by a QueryBody object.
     * @param {?} queryBody Object containing the search parameters
     * @return {?} List of search results
     */
    SearchService.prototype.searchByQueryBody = /**
     * Performs a search with its parameters supplied by a QueryBody object.
     * @param {?} queryBody Object containing the search parameters
     * @return {?} List of search results
     */
    function (queryBody) {
        var _this = this;
        /** @type {?} */
        var promise = this.apiService.getInstance().search.searchApi.search(queryBody);
        promise.then((/**
         * @param {?} nodePaging
         * @return {?}
         */
        function (nodePaging) {
            _this.dataLoaded.next(nodePaging);
        }));
        return from(promise).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    SearchService.prototype.handleError = /**
     * @private
     * @param {?} error
     * @return {?}
     */
    function (error) {
        return throwError(error || 'Server error');
    };
    SearchService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    SearchService.ctorParameters = function () { return [
        { type: AlfrescoApiService },
        { type: SearchConfigurationService }
    ]; };
    /** @nocollapse */ SearchService.ngInjectableDef = i0.defineInjectable({ factory: function SearchService_Factory() { return new SearchService(i0.inject(i1.AlfrescoApiService), i0.inject(i2.SearchConfigurationService)); }, token: SearchService, providedIn: "root" });
    return SearchService;
}());
export { SearchService };
if (false) {
    /** @type {?} */
    SearchService.prototype.dataLoaded;
    /**
     * @type {?}
     * @private
     */
    SearchService.prototype.apiService;
    /**
     * @type {?}
     * @private
     */
    SearchService.prototype.searchConfigurationService;
}
/**
 * @record
 */
export function SearchOptions() { }
if (false) {
    /**
     * The number of entities that exist in the collection before those included in this list.
     * @type {?|undefined}
     */
    SearchOptions.prototype.skipCount;
    /**
     * The maximum number of items to return in the list.
     * @type {?|undefined}
     */
    SearchOptions.prototype.maxItems;
    /**
     * The id of the node to start the search from. Supports the aliases -my-, -root- and -shared-.
     * @type {?|undefined}
     */
    SearchOptions.prototype.rootNodeId;
    /**
     * Restrict the returned results to only those of the given node type and its sub-types.
     * @type {?|undefined}
     */
    SearchOptions.prototype.nodeType;
    /**
     * Return additional information about the node. The available optional fields are:
     * `allowableOperations`, `aspectNames`, `isLink`, `isLocked`, `path` and `properties`.
     * @type {?|undefined}
     */
    SearchOptions.prototype.include;
    /**
     * String to control the order of the entities returned in a list. You can use this
     * parameter to sort the list by one or more fields. Each field has a default sort order,
     * which is normally ascending order (but see the JS-API docs to check if any fields used
     * in a method have a descending default search order). To sort the entities in a specific
     * order, you can use the "ASC" and "DESC" keywords for any field.
     * @type {?|undefined}
     */
    SearchOptions.prototype.orderBy;
    /**
     * List of field names. You can use this parameter to restrict the fields returned within
     * a response if, for example, you want to save on overall bandwidth. The list applies to a
     * returned individual entity or entries within a collection. If the API method also supports
     * the `include` parameter, then the fields specified in the include parameter are returned in
     * addition to those specified in the fields parameter.
     * @type {?|undefined}
     */
    SearchOptions.prototype.fields;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9zZWFyY2guc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBYyxPQUFPLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM3RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM1RSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7QUFFNUM7SUFPSSx1QkFBb0IsVUFBOEIsRUFDOUIsMEJBQXNEO1FBRHRELGVBQVUsR0FBVixVQUFVLENBQW9CO1FBQzlCLCtCQUEwQixHQUExQiwwQkFBMEIsQ0FBNEI7UUFIMUUsZUFBVSxHQUF3QixJQUFJLE9BQU8sRUFBRSxDQUFDO0lBSWhELENBQUM7SUFFRDs7Ozs7T0FLRzs7Ozs7OztJQUNILDJDQUFtQjs7Ozs7O0lBQW5CLFVBQW9CLElBQVksRUFBRSxPQUF1QjtRQUF6RCxpQkFVQzs7WUFUUyxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDO1FBRXRGLE9BQU8sQ0FBQyxJQUFJOzs7O1FBQUMsVUFBQyxVQUFzQjtZQUNoQyxLQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNyQyxDQUFDLEVBQUMsQ0FBQztRQUVILE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDckIsVUFBVTs7OztRQUFDLFVBQUMsR0FBRyxJQUFLLE9BQUEsS0FBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBckIsQ0FBcUIsRUFBQyxDQUM3QyxDQUFDO0lBQ04sQ0FBQztJQUVEOzs7Ozs7T0FNRzs7Ozs7Ozs7SUFDSCw4QkFBTTs7Ozs7OztJQUFOLFVBQU8sVUFBa0IsRUFBRSxVQUFrQixFQUFFLFNBQWlCO1FBQWhFLGlCQVdDOztZQVZTLFdBQVcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDOztZQUNqSCxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFFbEYsT0FBTyxDQUFDLElBQUk7Ozs7UUFBQyxVQUFDLFVBQXNCO1lBQ2hDLEtBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3JDLENBQUMsRUFBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNyQixVQUFVOzs7O1FBQUMsVUFBQyxHQUFHLElBQUssT0FBQSxLQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFyQixDQUFxQixFQUFDLENBQzdDLENBQUM7SUFDTixDQUFDO0lBRUQ7Ozs7T0FJRzs7Ozs7O0lBQ0gseUNBQWlCOzs7OztJQUFqQixVQUFrQixTQUFvQjtRQUF0QyxpQkFVQzs7WUFUUyxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7UUFFaEYsT0FBTyxDQUFDLElBQUk7Ozs7UUFBQyxVQUFDLFVBQXNCO1lBQ2hDLEtBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3JDLENBQUMsRUFBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNyQixVQUFVOzs7O1FBQUMsVUFBQyxHQUFRLElBQUssT0FBQSxLQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFyQixDQUFxQixFQUFDLENBQ2xELENBQUM7SUFDTixDQUFDOzs7Ozs7SUFFTyxtQ0FBVzs7Ozs7SUFBbkIsVUFBb0IsS0FBVTtRQUMxQixPQUFPLFVBQVUsQ0FBQyxLQUFLLElBQUksY0FBYyxDQUFDLENBQUM7SUFDL0MsQ0FBQzs7Z0JBcEVKLFVBQVUsU0FBQztvQkFDUixVQUFVLEVBQUUsTUFBTTtpQkFDckI7Ozs7Z0JBTlEsa0JBQWtCO2dCQUNsQiwwQkFBMEI7Ozt3QkFyQm5DO0NBNkZDLEFBckVELElBcUVDO1NBbEVZLGFBQWE7OztJQUV0QixtQ0FBZ0Q7Ozs7O0lBRXBDLG1DQUFzQzs7Ozs7SUFDdEMsbURBQThEOzs7OztBQStEOUUsbUNBb0NDOzs7Ozs7SUFsQ0csa0NBQW1COzs7OztJQUduQixpQ0FBa0I7Ozs7O0lBR2xCLG1DQUFvQjs7Ozs7SUFHcEIsaUNBQWtCOzs7Ozs7SUFNbEIsZ0NBQW1COzs7Ozs7Ozs7SUFTbkIsZ0NBQWlCOzs7Ozs7Ozs7SUFTakIsK0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTm9kZVBhZ2luZywgUXVlcnlCb2R5IH0gZnJvbSAnQGFsZnJlc2NvL2pzLWFwaSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBmcm9tLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UgfSBmcm9tICcuL2FsZnJlc2NvLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaENvbmZpZ3VyYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9zZWFyY2gtY29uZmlndXJhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoU2VydmljZSB7XG5cbiAgICBkYXRhTG9hZGVkOiBTdWJqZWN0PE5vZGVQYWdpbmc+ID0gbmV3IFN1YmplY3QoKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYXBpU2VydmljZTogQWxmcmVzY29BcGlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgc2VhcmNoQ29uZmlndXJhdGlvblNlcnZpY2U6IFNlYXJjaENvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gc2VhcmNoIGNyaXRlcmlhLlxuICAgICAqIEBwYXJhbSB0ZXJtIFRlcm0gdG8gc2VhcmNoIGZvclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIGRlbGl2ZXJ5IG9mIHRoZSBzZWFyY2ggcmVzdWx0c1xuICAgICAqIEByZXR1cm5zIExpc3Qgb2Ygbm9kZXMgcmVzdWx0aW5nIGZyb20gdGhlIHNlYXJjaFxuICAgICAqL1xuICAgIGdldE5vZGVRdWVyeVJlc3VsdHModGVybTogc3RyaW5nLCBvcHRpb25zPzogU2VhcmNoT3B0aW9ucyk6IE9ic2VydmFibGU8Tm9kZVBhZ2luZz4ge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS5xdWVyaWVzQXBpLmZpbmROb2Rlcyh0ZXJtLCBvcHRpb25zKTtcblxuICAgICAgICBwcm9taXNlLnRoZW4oKG5vZGVQYWdpbmc6IE5vZGVQYWdpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxvYWRlZC5uZXh0KG5vZGVQYWdpbmcpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBzZWFyY2guXG4gICAgICogQHBhcmFtIHNlYXJjaFRlcm0gVGVybSB0byBzZWFyY2ggZm9yXG4gICAgICogQHBhcmFtIG1heFJlc3VsdHMgTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3Qgb2YgcmVzdWx0c1xuICAgICAqIEBwYXJhbSBza2lwQ291bnQgTnVtYmVyIG9mIGhpZ2hlci1yYW5rZWQgaXRlbXMgdG8gc2tpcCBvdmVyIGluIHRoZSBsaXN0XG4gICAgICogQHJldHVybnMgTGlzdCBvZiBzZWFyY2ggcmVzdWx0c1xuICAgICAqL1xuICAgIHNlYXJjaChzZWFyY2hUZXJtOiBzdHJpbmcsIG1heFJlc3VsdHM6IG51bWJlciwgc2tpcENvdW50OiBudW1iZXIpOiBPYnNlcnZhYmxlPE5vZGVQYWdpbmc+IHtcbiAgICAgICAgY29uc3Qgc2VhcmNoUXVlcnkgPSBPYmplY3QuYXNzaWduKHRoaXMuc2VhcmNoQ29uZmlndXJhdGlvblNlcnZpY2UuZ2VuZXJhdGVRdWVyeUJvZHkoc2VhcmNoVGVybSwgbWF4UmVzdWx0cywgc2tpcENvdW50KSk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5zZWFyY2guc2VhcmNoQXBpLnNlYXJjaChzZWFyY2hRdWVyeSk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKChub2RlUGFnaW5nOiBOb2RlUGFnaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMb2FkZWQubmV4dChub2RlUGFnaW5nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZyb20ocHJvbWlzZSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgc2VhcmNoIHdpdGggaXRzIHBhcmFtZXRlcnMgc3VwcGxpZWQgYnkgYSBRdWVyeUJvZHkgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBxdWVyeUJvZHkgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNlYXJjaCBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBzZWFyY2ggcmVzdWx0c1xuICAgICAqL1xuICAgIHNlYXJjaEJ5UXVlcnlCb2R5KHF1ZXJ5Qm9keTogUXVlcnlCb2R5KTogT2JzZXJ2YWJsZTxOb2RlUGFnaW5nPiB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5zZWFyY2guc2VhcmNoQXBpLnNlYXJjaChxdWVyeUJvZHkpO1xuXG4gICAgICAgIHByb21pc2UudGhlbigobm9kZVBhZ2luZzogTm9kZVBhZ2luZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRhTG9hZGVkLm5leHQobm9kZVBhZ2luZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmcm9tKHByb21pc2UpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKChlcnI6IGFueSkgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlRXJyb3IoZXJyb3I6IGFueSk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yIHx8ICdTZXJ2ZXIgZXJyb3InKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyB7XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZW50aXRpZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiBiZWZvcmUgdGhvc2UgaW5jbHVkZWQgaW4gdGhpcyBsaXN0LiAqL1xuICAgIHNraXBDb3VudD86IG51bWJlcjtcblxuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gcmV0dXJuIGluIHRoZSBsaXN0LiAqL1xuICAgIG1heEl0ZW1zPzogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBpZCBvZiB0aGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoIGZyb20uIFN1cHBvcnRzIHRoZSBhbGlhc2VzIC1teS0sIC1yb290LSBhbmQgLXNoYXJlZC0uICovXG4gICAgcm9vdE5vZGVJZD86IHN0cmluZztcblxuICAgIC8qKiBSZXN0cmljdCB0aGUgcmV0dXJuZWQgcmVzdWx0cyB0byBvbmx5IHRob3NlIG9mIHRoZSBnaXZlbiBub2RlIHR5cGUgYW5kIGl0cyBzdWItdHlwZXMuICovXG4gICAgbm9kZVR5cGU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbm9kZS4gVGhlIGF2YWlsYWJsZSBvcHRpb25hbCBmaWVsZHMgYXJlOlxuICAgICAqIGBhbGxvd2FibGVPcGVyYXRpb25zYCwgYGFzcGVjdE5hbWVzYCwgYGlzTGlua2AsIGBpc0xvY2tlZGAsIGBwYXRoYCBhbmQgYHByb3BlcnRpZXNgLlxuICAgICAqL1xuICAgIGluY2x1ZGU/OiBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyB0byBjb250cm9sIHRoZSBvcmRlciBvZiB0aGUgZW50aXRpZXMgcmV0dXJuZWQgaW4gYSBsaXN0LiBZb3UgY2FuIHVzZSB0aGlzXG4gICAgICogcGFyYW1ldGVyIHRvIHNvcnQgdGhlIGxpc3QgYnkgb25lIG9yIG1vcmUgZmllbGRzLiBFYWNoIGZpZWxkIGhhcyBhIGRlZmF1bHQgc29ydCBvcmRlcixcbiAgICAgKiB3aGljaCBpcyBub3JtYWxseSBhc2NlbmRpbmcgb3JkZXIgKGJ1dCBzZWUgdGhlIEpTLUFQSSBkb2NzIHRvIGNoZWNrIGlmIGFueSBmaWVsZHMgdXNlZFxuICAgICAqIGluIGEgbWV0aG9kIGhhdmUgYSBkZXNjZW5kaW5nIGRlZmF1bHQgc2VhcmNoIG9yZGVyKS4gVG8gc29ydCB0aGUgZW50aXRpZXMgaW4gYSBzcGVjaWZpY1xuICAgICAqIG9yZGVyLCB5b3UgY2FuIHVzZSB0aGUgXCJBU0NcIiBhbmQgXCJERVNDXCIga2V5d29yZHMgZm9yIGFueSBmaWVsZC5cbiAgICAgKi9cbiAgICBvcmRlckJ5Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBmaWVsZCBuYW1lcy4gWW91IGNhbiB1c2UgdGhpcyBwYXJhbWV0ZXIgdG8gcmVzdHJpY3QgdGhlIGZpZWxkcyByZXR1cm5lZCB3aXRoaW5cbiAgICAgKiBhIHJlc3BvbnNlIGlmLCBmb3IgZXhhbXBsZSwgeW91IHdhbnQgdG8gc2F2ZSBvbiBvdmVyYWxsIGJhbmR3aWR0aC4gVGhlIGxpc3QgYXBwbGllcyB0byBhXG4gICAgICogcmV0dXJuZWQgaW5kaXZpZHVhbCBlbnRpdHkgb3IgZW50cmllcyB3aXRoaW4gYSBjb2xsZWN0aW9uLiBJZiB0aGUgQVBJIG1ldGhvZCBhbHNvIHN1cHBvcnRzXG4gICAgICogdGhlIGBpbmNsdWRlYCBwYXJhbWV0ZXIsIHRoZW4gdGhlIGZpZWxkcyBzcGVjaWZpZWQgaW4gdGhlIGluY2x1ZGUgcGFyYW1ldGVyIGFyZSByZXR1cm5lZCBpblxuICAgICAqIGFkZGl0aW9uIHRvIHRob3NlIHNwZWNpZmllZCBpbiB0aGUgZmllbGRzIHBhcmFtZXRlci5cbiAgICAgKi9cbiAgICBmaWVsZHM/OiBzdHJpbmdbXTtcbn1cbiJdfQ==