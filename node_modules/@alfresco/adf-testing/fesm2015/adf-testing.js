import { AlfrescoApiCompatibility, AlfrescoApiConfig } from '@alfresco/js-api';
import { AlfrescoApiService, AppConfigValues, AppConfigService } from '@alfresco/adf-core';
import { __awaiter } from 'tslib';
import { browser, protractor, element, by, Key } from 'protractor';
import { NgModule, Injectable, defineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StringUtil {
    /**
     * @param {?=} length
     * @return {?}
     */
    static generatePasswordString(length = 8) {
        /** @type {?} */
        let text = '';
        /** @type {?} */
        const possibleUpperCase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        /** @type {?} */
        const possibleLowerCase = 'abcdefghijklmnopqrstuvwxyz';
        /** @type {?} */
        const lowerCaseLimit = Math.floor(length / 2);
        for (let i = 0; i < lowerCaseLimit; i++) {
            text += possibleLowerCase.charAt(Math.floor(Math.random() * possibleLowerCase.length));
        }
        for (let i = 0; i < length - lowerCaseLimit; i++) {
            text += possibleUpperCase.charAt(Math.floor(Math.random() * possibleUpperCase.length));
        }
        return text;
    }
    /**
     * Generates a random string.
     *
     * \@method generateRandomString
     * @param {?=} length If this parameter is not provided the length is set to 8 by default.
     * @return {?}
     */
    static generateRandomString(length = 8) {
        /** @type {?} */
        let text = '';
        /** @type {?} */
        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < length; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }
    /**
     * Generates a random email address following the format: abcdef\@activiti.test.com
     *
     * \@method generateRandomEmail
     * @param {?} domain
     * @param {?=} length
     * @return {?}
     */
    static generateRandomEmail(domain, length = 5) {
        /** @type {?} */
        let email = '';
        /** @type {?} */
        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < length; i++) {
            email += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        email += domain;
        return email.toLowerCase();
    }
    /**
     * Generates a random string - digits only.
     *
     * \@method generateRandomString
     * @param {?=} length {int} If this parameter is not provided the length is set to 8 by default.
     * @return {?}
     */
    static generateRandomStringDigits(length = 8) {
        /** @type {?} */
        let text = '';
        /** @type {?} */
        const possible = '0123456789';
        for (let i = 0; i < length; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }
    /**
     * Generates a random string - non-latin characters only.
     *
     * \@method generateRandomString
     * @param {?=} length {int} If this parameter is not provided the length is set to 3 by default.
     * @return {?}
     */
    static generateRandomStringNonLatin(length = 3) {
        /** @type {?} */
        let text = '';
        /** @type {?} */
        const possible = '密码你好𠮷';
        for (let i = 0; i < length; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserModel {
    /**
     * @param {?=} details
     */
    constructor(details) {
        this.firstName = StringUtil.generateRandomString();
        this.lastName = StringUtil.generateRandomString() + 'LastName';
        this.password = StringUtil.generateRandomString();
        this.email = StringUtil.generateRandomEmail('@alfresco.com');
        this.username = StringUtil.generateRandomString().toLowerCase();
        Object.assign(this, details);
    }
    /**
     * @return {?}
     */
    get id() {
        return this.email;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IdentityService {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
    }
    /**
     * @param {?=} user
     * @return {?}
     */
    createIdentityUser(user = new UserModel()) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.createUser(user);
            /** @type {?} */
            const userIdentity = yield this.getUserInfoByUsername(user.username);
            yield this.resetPassword(userIdentity.id, user.password);
            user.idIdentityService = userIdentity.id;
            return user;
        });
    }
    /**
     * @param {?} user
     * @return {?}
     */
    createIdentityUserAndSyncECMBPM(user) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.api.config.provider === 'ECM' || this.api.config.provider === 'ALL') {
                /** @type {?} */
                const createUser = (/** @type {?} */ ({
                    firstName: user.firstName,
                    lastName: user.lastName,
                    password: user.password,
                    email: user.email,
                    id: user.email
                }));
                yield this.api.apiService.core.peopleApi.addPerson(createUser);
            }
            if (this.api.config.provider === 'BPM' || this.api.config.provider === 'ALL') {
                yield this.api.apiService.activiti.adminUsersApi.createNewUser({
                    email: user.email,
                    firstName: user.firstName,
                    lastName: user.lastName,
                    password: user.password,
                    type: 'enterprise',
                    tenantId: 1,
                    company: null
                });
            }
            yield this.createIdentityUser(user);
        });
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    deleteIdentityUser(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteUser(userId);
        });
    }
    /**
     * @param {?} user
     * @return {?}
     */
    createUser(user) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/users';
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {
                'username': user.username,
                'firstName': user.firstName,
                'lastName': user.lastName,
                'enabled': true,
                'email': user.email
            };
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    deleteUser(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/users/${userId}`;
            /** @type {?} */
            const method = 'DELETE';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} username
     * @return {?}
     */
    getUserInfoByUsername(username) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/users`;
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            const queryParams = { 'username': username };
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data[0];
        });
    }
    /**
     * @param {?} id
     * @param {?} password
     * @return {?}
     */
    resetPassword(id, password) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/users/${id}/reset-password`;
            /** @type {?} */
            const method = 'PUT';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = { 'type': 'password', 'value': password, 'temporary': false };
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} userId
     * @param {?} roleId
     * @param {?} roleName
     * @return {?}
     */
    assignRole(userId, roleId, roleName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/users/${userId}/role-mappings/realm`;
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = [{ 'id': roleId, 'name': roleName }];
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} userId
     * @param {?} clientId
     * @param {?} roleId
     * @param {?} roleName
     * @return {?}
     */
    deleteClientRole(userId, clientId, roleId, roleName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/users/${userId}/role-mappings/clients/${clientId}`;
            /** @type {?} */
            const method = 'DELETE';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = [{
                    'id': roleId,
                    'name': roleName,
                    'composite': false,
                    'clientRole': true,
                    'containerId': clientId
                }];
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data;
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GroupIdentityService {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
    }
    /**
     * @param {?=} groupName
     * @return {?}
     */
    createIdentityGroup(groupName = StringUtil.generateRandomString(5)) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.createGroup(groupName);
            /** @type {?} */
            const group = yield this.getGroupInfoByGroupName(groupName);
            return group;
        });
    }
    /**
     * @param {?} groupId
     * @return {?}
     */
    deleteIdentityGroup(groupId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteGroup(groupId);
        });
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    createGroup(groupName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/groups';
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {
                'name': groupName + 'TestGroup'
            };
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} groupId
     * @return {?}
     */
    deleteGroup(groupId) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/groups/${groupId}`;
            /** @type {?} */
            const method = 'DELETE';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    getGroupInfoByGroupName(groupName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/groups`;
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            const queryParams = { 'search': groupName };
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data[0];
        });
    }
    /**
     * @param {?} groupId
     * @param {?} roleId
     * @param {?} roleName
     * @return {?}
     */
    assignRole(groupId, roleId, roleName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/groups/${groupId}/role-mappings/realm`;
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = [{ 'id': roleId, 'name': roleName }];
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * Add client roles.
     * @param {?} groupId ID of the target group
     * @param {?} clientId ID of the client
     * @param {?} roleId ID of the clientRole
     * @param {?} roleName of the clientRole
     * @return {?}
     */
    addClientRole(groupId, clientId, roleId, roleName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/groups/${groupId}/role-mappings/clients/${clientId}`;
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = [{
                    'id': roleId,
                    'name': roleName,
                    'composite': false,
                    'clientRole': true,
                    'containerId': clientId
                }];
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * Gets the client ID using the app name.
     * @param {?} applicationName Name of the app
     * @return {?} client ID string
     */
    getClientIdByApplicationName(applicationName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/clients`;
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            const queryParams = { clientId: applicationName };
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            return data[0].id;
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RolesService {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
    }
    /**
     * @param {?} roleName
     * @return {?}
     */
    getRoleIdByRoleName(roleName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/roles`;
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            let roleId;
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            for (const key in data) {
                if (data[key].name === roleName) {
                    roleId = data[key].id;
                }
            }
            return roleId;
        });
    }
    /**
     * @param {?} groupId
     * @param {?} clientId
     * @param {?} clientRoleName
     * @return {?}
     */
    getClientRoleIdByRoleName(groupId, clientId, clientRoleName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = `/groups/${groupId}/role-mappings/clients/${clientId}/available`;
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            let clientRoleId;
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performIdentityOperation(path, method, queryParams, postBody);
            for (const key in data) {
                if (data[key].name === clientRoleName) {
                    clientRoleId = data[key].id;
                }
            }
            return clientRoleId;
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TasksService {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
    }
    /**
     * @param {?} taskName
     * @param {?} appName
     * @param {?=} options
     * @return {?}
     */
    createStandaloneTask(taskName, appName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/tasks';
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = Object.assign({ 'name': taskName, 'payloadType': 'CreateTaskPayload' }, options);
            /** @type {?} */
            const data = yield this.api.performBpmOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} taskId
     * @param {?} appName
     * @return {?}
     */
    completeTask(taskId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/tasks/' + taskId + '/complete';
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = { 'payloadType': 'CompleteTaskPayload' };
            /** @type {?} */
            const data = yield this.api.performBpmOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} taskId
     * @param {?} appName
     * @return {?}
     */
    claimTask(taskId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/tasks/' + taskId + '/claim';
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performBpmOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} taskId
     * @param {?} appName
     * @return {?}
     */
    deleteTask(taskId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/tasks/' + taskId;
            /** @type {?} */
            const method = 'DELETE';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performBpmOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} taskName
     * @param {?} appName
     * @return {?}
     */
    createAndCompleteTask(taskName, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const task = yield this.createStandaloneTask(taskName, appName);
            yield this.claimTask(task.entry.id, appName);
            yield this.completeTask(task.entry.id, appName);
            return task;
        });
    }
    /**
     * @param {?} taskId
     * @param {?} appName
     * @return {?}
     */
    getTask(taskId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/query/v1/tasks/' + taskId;
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performBpmOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} taskName
     * @param {?} appName
     * @return {?}
     */
    getTaskId(taskName, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/query/v1/tasks';
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            const queryParams = { name: taskName };
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performBpmOperation(path, method, queryParams, postBody);
            return data.list.entries[0].entry.id;
        });
    }
    /**
     * @param {?} parentTaskId
     * @param {?} appName
     * @param {?} name
     * @return {?}
     */
    createStandaloneSubtask(parentTaskId, appName, name) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/tasks';
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = { 'name': name, 'parentTaskId': parentTaskId, 'payloadType': 'CreateTaskPayload' };
            /** @type {?} */
            const data = yield this.api.performBpmOperation(path, method, queryParams, postBody);
            return data;
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class QueryService {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
    }
    /**
     * @param {?} processInstanceId
     * @param {?} appName
     * @return {?}
     */
    getProcessInstanceTasks(processInstanceId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/query/v1/process-instances/' + processInstanceId + '/tasks';
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            /** @type {?} */
            const data = yield this.api.performBpmOperation(path, method, queryParams, postBody);
            return data;
        });
    }
    /**
     * @param {?} processInstanceId
     * @param {?} appName
     * @return {?}
     */
    getProcessInstanceSubProcesses(processInstanceId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/query/v1/process-instances/' + processInstanceId + '/subprocesses';
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const data = yield this.api.performBpmOperation(path, method, queryParams, {});
            return data;
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ApiService {
    /**
     * @param {?} clientId
     * @param {?} host
     * @param {?} hostSso
     * @param {?} provider
     */
    constructor(clientId, host, hostSso, provider) {
        this.config = {
            provider: provider,
            hostBpm: host,
            hostEcm: host,
            authType: 'OAUTH',
            oauth2: {
                host: hostSso,
                clientId: clientId,
                scope: 'openid',
                secret: '',
                implicitFlow: false,
                silentLogin: false,
                redirectUri: '/',
                redirectUriLogout: '/logout'
            }
        };
        this.apiService = new AlfrescoApiCompatibility(this.config);
    }
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    login(username, password) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.apiService.login(username, password);
        });
    }
    /**
     * @param {?} path
     * @param {?} method
     * @param {?} queryParams
     * @param {?} postBody
     * @return {?}
     */
    performBpmOperation(path, method, queryParams, postBody) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const uri = this.config.hostBpm + path;
            /** @type {?} */
            const pathParams = {};
            /** @type {?} */
            const formParams = {};
            /** @type {?} */
            const contentTypes = ['application/json'];
            /** @type {?} */
            const accepts = ['application/json'];
            /** @type {?} */
            const headerParams = {
                'Authorization': 'bearer ' + this.apiService.oauth2Auth.token
            };
            return this.apiService.processClient.callCustomApi(uri, method, pathParams, queryParams, headerParams, formParams, postBody, contentTypes, accepts, Object)
                .catch((/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                throw (error);
            }));
        });
    }
    /**
     * @param {?} path
     * @param {?} method
     * @param {?} queryParams
     * @param {?} postBody
     * @return {?}
     */
    performIdentityOperation(path, method, queryParams, postBody) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const uri = this.config.oauth2.host.replace('/realms', '/admin/realms') + path;
            /** @type {?} */
            const pathParams = {};
            /** @type {?} */
            const formParams = {};
            /** @type {?} */
            const contentTypes = ['application/json'];
            /** @type {?} */
            const accepts = ['application/json'];
            /** @type {?} */
            const headerParams = {
                'Authorization': 'bearer ' + this.apiService.oauth2Auth.token
            };
            return this.apiService.processClient.callCustomApi(uri, method, pathParams, queryParams, headerParams, formParams, postBody, contentTypes, accepts, Object)
                .catch((/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                throw (error);
            }));
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const until = protractor.ExpectedConditions;
/** @type {?} */
const DEFAULT_TIMEOUT = global['TestConfig'] ? global['TestConfig'].main.timeout : 40000;
class BrowserVisibility {
    /*
         * Wait for element is visible
         */
    /**
     * @param {?} elementToCheck
     * @param {?=} waitTimeout
     * @return {?}
     */
    static waitUntilElementIsVisible(elementToCheck, waitTimeout = DEFAULT_TIMEOUT) {
        /** @type {?} */
        let isDisplayed = false;
        return browser.wait((/**
         * @return {?}
         */
        () => {
            browser.waitForAngularEnabled();
            elementToCheck.isDisplayed().then((/**
             * @return {?}
             */
            () => {
                isDisplayed = true;
            }), (/**
             * @return {?}
             */
            () => {
                isDisplayed = false;
            }));
            return isDisplayed;
        }), waitTimeout, 'Element is not visible ' + elementToCheck.locator());
    }
    /*
         * Wait for element to be clickable
         */
    /**
     * @param {?} elementToCheck
     * @param {?=} waitTimeout
     * @return {?}
     */
    static waitUntilElementIsClickable(elementToCheck, waitTimeout = DEFAULT_TIMEOUT) {
        /** @type {?} */
        let isDisplayed = false;
        return browser.wait((/**
         * @return {?}
         */
        () => {
            browser.waitForAngularEnabled();
            elementToCheck.isDisplayed().then((/**
             * @return {?}
             */
            () => {
                isDisplayed = true;
            }), (/**
             * @return {?}
             */
            () => {
                isDisplayed = false;
            }));
            return isDisplayed;
        }), waitTimeout, 'Element is not visible ' + elementToCheck.locator());
    }
    /*
       * Wait for element to not be visible
       */
    /**
     * @param {?} elementToCheck
     * @param {?=} waitTimeout
     * @return {?}
     */
    static waitUntilElementIsStale(elementToCheck, waitTimeout = DEFAULT_TIMEOUT) {
        return browser.wait(until.stalenessOf(elementToCheck), waitTimeout, 'Element is not in stale ' + elementToCheck.locator());
    }
    /*
         * Wait for element to not be visible
         */
    /**
     * @param {?} elementToCheck
     * @param {?=} waitTimeout
     * @return {?}
     */
    static waitUntilElementIsNotVisible(elementToCheck, waitTimeout = DEFAULT_TIMEOUT) {
        /** @type {?} */
        let isPresent = false;
        return browser.wait((/**
         * @return {?}
         */
        () => {
            browser.waitForAngularEnabled();
            elementToCheck.isPresent().then((/**
             * @param {?} present
             * @return {?}
             */
            (present) => {
                isPresent = !present;
            }));
            return isPresent;
        }), waitTimeout, 'Element is Visible and it should not' + elementToCheck.locator());
    }
    /*
         * Wait for element to have value
         */
    /**
     * @param {?} elementToCheck
     * @param {?} elementValue
     * @param {?=} waitTimeout
     * @return {?}
     */
    static waitUntilElementHasValue(elementToCheck, elementValue, waitTimeout = DEFAULT_TIMEOUT) {
        browser.waitForAngularEnabled();
        browser.wait(until.textToBePresentInElementValue(elementToCheck, elementValue), waitTimeout, 'Element doesn\'t have a value ' + elementToCheck.locator());
    }
    /**
     * @param {?} elementToCheck
     * @param {?=} waitTimeout
     * @return {?}
     */
    static waitUntilElementIsOnPage(elementToCheck, waitTimeout = DEFAULT_TIMEOUT) {
        return browser.wait(browser.wait(until.visibilityOf(elementToCheck)), waitTimeout);
    }
    /*
         * Wait for element to not be visible
         */
    /**
     * @param {?} elementToCheck
     * @param {?=} waitTimeout
     * @return {?}
     */
    static waitUntilElementIsNotOnPage(elementToCheck, waitTimeout = DEFAULT_TIMEOUT) {
        return browser.wait(until.not(until.visibilityOf(elementToCheck)), waitTimeout, 'Element is not in the page ' + elementToCheck.locator());
    }
    /**
     * @param {?} elementToCheck
     * @param {?=} waitTimeout
     * @return {?}
     */
    static waitUntilElementIsPresent(elementToCheck, waitTimeout = DEFAULT_TIMEOUT) {
        browser.waitForAngularEnabled();
        return browser.wait(until.presenceOf(elementToCheck), waitTimeout, 'Element is not present ' + elementToCheck.locator());
    }
    /**
     * @param {?} elementToCheck
     * @param {?=} waitTimeout
     * @return {?}
     */
    static waitUntilElementIsNotPresent(elementToCheck, waitTimeout = DEFAULT_TIMEOUT) {
        return browser.wait(until.not(until.presenceOf(elementToCheck)), waitTimeout, 'Element is not in the page ' + elementToCheck.locator());
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HeaderPage {
    constructor() {
        this.checkBox = element(by.cssContainingText('.mat-checkbox-label', 'Show menu button'));
        this.headerColor = element(by.css('option[value="primary"]'));
        this.titleInput = element(by.css('input[name="title"]'));
        this.iconInput = element(by.css('input[placeholder="URL path"]'));
        this.hexColorInput = element(by.css('input[placeholder="hex color code"]'));
        this.logoHyperlinkInput = element(by.css('input[placeholder="Redirect URL"]'));
        this.logoTooltipInput = element(by.css('input[placeholder="Tooltip text"]'));
        this.positionStart = element.all(by.css('mat-radio-button[value="start"]')).first();
        this.positionEnd = element.all(by.css('mat-radio-button[value="end"]')).first();
        this.sideBarPositionRight = element(by.css('mat-sidenav.mat-drawer.mat-sidenav.mat-drawer-end'));
        this.sideBarPositionLeft = element(by.css('mat-sidenav.mat-drawer.mat-sidenav'));
    }
    /**
     * @return {?}
     */
    checkShowMenuCheckBoxIsDisplayed() {
        return BrowserVisibility.waitUntilElementIsVisible(this.checkBox);
    }
    /**
     * @return {?}
     */
    checkChooseHeaderColourIsDisplayed() {
        return BrowserVisibility.waitUntilElementIsVisible(this.headerColor);
    }
    /**
     * @return {?}
     */
    checkChangeTitleIsDisplayed() {
        return BrowserVisibility.waitUntilElementIsVisible(this.titleInput);
    }
    /**
     * @return {?}
     */
    checkChangeUrlPathIsDisplayed() {
        return BrowserVisibility.waitUntilElementIsVisible(this.iconInput);
    }
    /**
     * @return {?}
     */
    clickShowMenuButton() {
        /** @type {?} */
        const checkBox = element.all(by.css('mat-checkbox'));
        BrowserVisibility.waitUntilElementIsVisible(checkBox);
        return checkBox.get(0).click();
    }
    /**
     * @param {?} color
     * @return {?}
     */
    changeHeaderColor(color) {
        /** @type {?} */
        const headerColor = element(by.css('option[value="' + color + '"]'));
        return headerColor.click();
    }
    /**
     * @param {?} name
     * @return {?}
     */
    checkAppTitle(name) {
        /** @type {?} */
        const title = element(by.cssContainingText('.adf-app-title', name));
        return BrowserVisibility.waitUntilElementIsVisible(title);
    }
    /**
     * @param {?} title
     * @return {?}
     */
    addTitle(title) {
        BrowserVisibility.waitUntilElementIsVisible(this.titleInput);
        this.titleInput.click();
        this.titleInput.sendKeys(title);
        this.titleInput.sendKeys(protractor.Key.ENTER);
    }
    /**
     * @param {?} url
     * @return {?}
     */
    checkIconIsDisplayed(url) {
        /** @type {?} */
        const icon = element(by.css('img[src="' + url + '"]'));
        BrowserVisibility.waitUntilElementIsVisible(icon);
    }
    /**
     * @param {?} url
     * @return {?}
     */
    addIcon(url) {
        BrowserVisibility.waitUntilElementIsVisible(this.iconInput);
        this.iconInput.click();
        this.iconInput.sendKeys(url);
        this.iconInput.sendKeys(protractor.Key.ENTER);
    }
    /**
     * @return {?}
     */
    checkHexColorInputIsDisplayed() {
        return BrowserVisibility.waitUntilElementIsVisible(this.hexColorInput);
    }
    /**
     * @return {?}
     */
    checkLogoHyperlinkInputIsDisplayed() {
        return BrowserVisibility.waitUntilElementIsVisible(this.logoHyperlinkInput);
    }
    /**
     * @return {?}
     */
    checkLogoTooltipInputIsDisplayed() {
        return BrowserVisibility.waitUntilElementIsVisible(this.logoTooltipInput);
    }
    /**
     * @param {?} hexCode
     * @return {?}
     */
    addHexCodeColor(hexCode) {
        BrowserVisibility.waitUntilElementIsVisible(this.hexColorInput);
        this.hexColorInput.click();
        this.hexColorInput.sendKeys(hexCode);
        return this.hexColorInput.sendKeys(protractor.Key.ENTER);
    }
    /**
     * @param {?} hyperlink
     * @return {?}
     */
    addLogoHyperlink(hyperlink) {
        BrowserVisibility.waitUntilElementIsVisible(this.logoHyperlinkInput);
        BrowserVisibility.waitUntilElementIsClickable(this.logoHyperlinkInput);
        this.logoHyperlinkInput.click();
        this.logoHyperlinkInput.sendKeys(hyperlink);
        return this.logoHyperlinkInput.sendKeys(protractor.Key.ENTER);
    }
    /**
     * @param {?} tooltip
     * @return {?}
     */
    addLogoTooltip(tooltip) {
        BrowserVisibility.waitUntilElementIsVisible(this.logoTooltipInput);
        this.logoTooltipInput.click();
        this.logoTooltipInput.sendKeys(tooltip);
        return this.logoTooltipInput.sendKeys(protractor.Key.ENTER);
    }
    /**
     * @return {?}
     */
    sideBarPositionStart() {
        BrowserVisibility.waitUntilElementIsVisible(this.positionStart);
        return this.positionStart.click();
    }
    /**
     * @return {?}
     */
    sideBarPositionEnd() {
        BrowserVisibility.waitUntilElementIsVisible(this.positionEnd);
        return this.positionEnd.click();
    }
    /**
     * @return {?}
     */
    checkSidebarPositionStart() {
        return BrowserVisibility.waitUntilElementIsVisible(this.sideBarPositionLeft);
    }
    /**
     * @return {?}
     */
    checkSidebarPositionEnd() {
        return BrowserVisibility.waitUntilElementIsVisible(this.sideBarPositionRight);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabsPage {
    /**
     * @param {?} tabTitle
     * @return {?}
     */
    clickTabByTitle(tabTitle) {
        /** @type {?} */
        const tab = element(by.cssContainingText("div[id*='mat-tab-label']", tabTitle));
        BrowserVisibility.waitUntilElementIsVisible(tab);
        tab.click();
    }
    /**
     * @param {?} tabTitle
     * @return {?}
     */
    checkTabIsSelectedByTitle(tabTitle) {
        /** @type {?} */
        const tab = element(by.cssContainingText("div[id*='mat-tab-label']", tabTitle));
        tab.getAttribute('aria-selected').then((/**
         * @param {?} result
         * @return {?}
         */
        (result) => {
            expect(result).toBe('true');
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserInfoPage {
    constructor() {
        this.dialog = element.all(by.css('mat-card[class*="adf-userinfo-card"]')).first();
        this.userImage = element(by.css('div[id="user-initial-image"]'));
        this.userInfoEcmHeaderTitle = element(by.css('div[id="ecm-username"]'));
        this.userInfoEcmTitle = element(by.css('mat-card-content span[id="ecm-full-name"]'));
        this.ecmEmail = element(by.css('span[id="ecm-email"]'));
        this.ecmJobTitle = element(by.css('span[id="ecm-job-title"]'));
        this.userInfoProcessHeaderTitle = element(by.css('div[id="bpm-username"]'));
        this.userInfoProcessTitle = element(by.css('mat-card-content span[id="bpm-full-name"]'));
        this.processEmail = element(by.css('span[id="bpm-email"]'));
        this.processTenant = element(by.css('span[class="detail-profile"]'));
        this.apsImage = element(by.css('img[id="bpm-user-detail-image"]'));
        this.acsImage = element(by.css('img[id="ecm-user-detail-image"]'));
        this.initialImage = element.all(by.css('div[id="user-initials-image"]')).first();
        this.userInfoSsoHeaderTitle = this.dialog.element(by.css('div[id="identity-username"]'));
        this.userInfoSsoTitle = element(by.css('.adf-userinfo__detail-title'));
        this.ssoEmail = element(by.id('identity-email'));
        this.userProfileButton = element(by.css('button[data-automation-id="adf-user-profile"]'));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    dialogIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).dialog);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    dialogIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotOnPage((/** @type {?} */ (this)).dialog);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    clickUserProfile() {
        BrowserVisibility.waitUntilElementIsVisible(this.userProfileButton);
        this.userProfileButton.click();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickOnContentServicesTab() {
        /** @type {?} */
        const tabsPage = new TabsPage();
        tabsPage.clickTabByTitle('Content Services');
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkProcessServicesTabIsSelected() {
        /** @type {?} */
        const tabsPage = new TabsPage;
        tabsPage.checkTabIsSelectedByTitle('Process Services');
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickOnProcessServicesTab() {
        /** @type {?} */
        const tabsPage = new TabsPage;
        tabsPage.clickTabByTitle('Process Services');
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    userImageIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).userImage);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getContentHeaderTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.dialog);
        BrowserVisibility.waitUntilElementIsVisible(this.userInfoEcmHeaderTitle);
        return this.userInfoEcmHeaderTitle.getText();
    }
    /**
     * @return {?}
     */
    getContentTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.userInfoEcmTitle);
        return this.userInfoEcmTitle.getText();
    }
    /**
     * @return {?}
     */
    getContentEmail() {
        BrowserVisibility.waitUntilElementIsVisible(this.ecmEmail);
        return this.ecmEmail.getText();
    }
    /**
     * @return {?}
     */
    getContentJobTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.ecmJobTitle);
        return this.ecmJobTitle.getText();
    }
    /**
     * @return {?}
     */
    getProcessHeaderTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.userInfoProcessHeaderTitle);
        return this.userInfoProcessHeaderTitle.getText();
    }
    /**
     * @return {?}
     */
    getProcessTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.userInfoProcessTitle);
        return this.userInfoProcessTitle.getText();
    }
    /**
     * @return {?}
     */
    getProcessEmail() {
        BrowserVisibility.waitUntilElementIsVisible(this.processEmail);
        return this.processEmail.getText();
    }
    /**
     * @return {?}
     */
    getProcessTenant() {
        BrowserVisibility.waitUntilElementIsVisible(this.processTenant);
        return this.processTenant.getText();
    }
    /**
     * @return {?}
     */
    getSsoHeaderTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.userInfoSsoHeaderTitle);
        return this.userInfoSsoHeaderTitle.getText();
    }
    /**
     * @return {?}
     */
    getSsoTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.userInfoSsoTitle);
        return this.userInfoSsoTitle.getText();
    }
    /**
     * @return {?}
     */
    getSsoEmail() {
        BrowserVisibility.waitUntilElementIsVisible(this.ssoEmail);
        return this.ssoEmail.getText();
    }
    /**
     * @return {?}
     */
    closeUserProfile() {
        BrowserVisibility.waitUntilElementIsVisible(this.dialog);
        browser.actions().sendKeys(protractor.Key.ESCAPE).perform();
    }
    /**
     * @return {?}
     */
    checkACSProfileImage() {
        BrowserVisibility.waitUntilElementIsVisible(this.acsImage);
    }
    /**
     * @return {?}
     */
    checkAPSProfileImage() {
        BrowserVisibility.waitUntilElementIsVisible(this.apsImage);
    }
    /**
     * @return {?}
     */
    checkInitialImage() {
        BrowserVisibility.waitUntilElementIsVisible(this.initialImage);
    }
    /**
     * @return {?}
     */
    initialImageNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotOnPage(this.initialImage);
    }
    /**
     * @return {?}
     */
    ACSProfileImageNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotOnPage(this.acsImage);
    }
    /**
     * @return {?}
     */
    APSProfileImageNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotOnPage(this.apsImage);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormControllersPage {
    /**
     * @param {?} toggle
     * @return {?}
     */
    enableToggle(toggle) {
        BrowserVisibility.waitUntilElementIsVisible(toggle);
        toggle.getAttribute('class').then((/**
         * @param {?} check
         * @return {?}
         */
        (check) => {
            if (check.indexOf('mat-checked') < 0) {
                BrowserVisibility.waitUntilElementIsClickable(toggle.all(by.css('div')).first());
                toggle.all(by.css('div')).first().click();
            }
        }));
    }
    /**
     * @param {?} toggle
     * @return {?}
     */
    disableToggle(toggle) {
        BrowserVisibility.waitUntilElementIsVisible(toggle);
        toggle.getAttribute('class').then((/**
         * @param {?} check
         * @return {?}
         */
        (check) => {
            if (check.indexOf('mat-checked') >= 0) {
                BrowserVisibility.waitUntilElementIsClickable(toggle.all(by.css('div')).first());
                toggle.all(by.css('div')).first().click();
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LocalStorageUtil {
    /**
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    static setConfigField(field, value) {
        return __awaiter(this, void 0, void 0, function* () {
            yield browser.executeScript('window.adf.setConfigField(`' + field + '`, `' + value + '`);');
        });
    }
    /**
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    static setStorageItem(field, value) {
        return __awaiter(this, void 0, void 0, function* () {
            yield browser.executeScript('window.adf.setStorageItem(`' + field + '`, `' + value + '`);');
        });
    }
    /**
     * @return {?}
     */
    static clearStorage() {
        return __awaiter(this, void 0, void 0, function* () {
            yield browser.executeScript('window.adf.clearStorage();');
        });
    }
    /**
     * @return {?}
     */
    static apiReset() {
        return __awaiter(this, void 0, void 0, function* () {
            yield browser.executeScript(`window.adf.apiReset();`);
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoginPage {
    constructor() {
        this.loginURL = browser.baseUrl + '/login';
        this.formControllersPage = new FormControllersPage();
        this.txtUsername = element(by.css('input[id="username"]'));
        this.txtPassword = element(by.css('input[id="password"]'));
        this.logoImg = element(by.css('img[id="adf-login-img-logo"]'));
        this.successRouteTxt = element(by.css('input[data-automation-id="adf-success-route"]'));
        this.logoTxt = element(by.css('input[data-automation-id="adf-url-logo"]'));
        this.usernameTooltip = element(by.css('span[data-automation-id="username-error"]'));
        this.passwordTooltip = element(by.css('span[data-automation-id="password-required"]'));
        this.loginTooltip = element(by.css('span[class="adf-login-error-message"]'));
        this.usernameInactive = element(by.css('input[id="username"][aria-invalid="false"]'));
        this.passwordInactive = element(by.css('input[id="password"][aria-invalid="false"]'));
        this.adfLogo = element(by.css('img[class="adf-img-logo ng-star-inserted"]'));
        this.usernameHighlighted = element(by.css('input[id="username"][aria-invalid="true"]'));
        this.passwordHighlighted = element(by.css('input[id="password"][aria-invalid="true"]'));
        this.signInButton = element(by.id('login-button'));
        this.showPasswordElement = element(by.css('mat-icon[data-automation-id="show_password"]'));
        this.hidePasswordElement = element(by.css('mat-icon[data-automation-id="hide_password"]'));
        this.rememberMe = element(by.css('mat-checkbox[id="adf-login-remember"]'));
        this.needHelp = element(by.css('div[id="adf-login-action-left"]'));
        this.register = element(by.css('div[id="adf-login-action-right"]'));
        this.footerSwitch = element(by.id('switch4'));
        this.rememberMeSwitch = element(by.id('adf-toggle-show-rememberme'));
        this.successRouteSwitch = element(by.id('adf-toggle-show-successRoute'));
        this.logoSwitch = element(by.id('adf-toggle-logo'));
        this.header = element(by.id('adf-header'));
        this.settingsIcon = element(by.cssContainingText('a[data-automation-id="settings"] mat-icon', 'settings'));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    goToLoginPage() {
        browser.waitForAngularEnabled(true);
        browser.driver.get((/** @type {?} */ (this)).loginURL);
        (/** @type {?} */ (this)).waitForElements();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    waitForElements() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).txtUsername);
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).txtPassword);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} username
     * @return {?}
     */
    enterUsername(username) {
        BrowserVisibility.waitUntilElementIsVisible(this.txtUsername);
        this.txtUsername.sendKeys('');
        this.txtUsername.clear();
        return this.txtUsername.sendKeys(username);
    }
    /**
     * @param {?} password
     * @return {?}
     */
    enterPassword(password) {
        BrowserVisibility.waitUntilElementIsVisible(this.txtPassword);
        this.txtPassword.clear();
        return this.txtPassword.sendKeys(password);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clearUsername() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).txtUsername);
        (/** @type {?} */ (this)).txtUsername.click();
        (/** @type {?} */ (this)).txtUsername.getAttribute('value').then((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            for (let i = value.length; i >= 0; i--) {
                (/** @type {?} */ (this)).txtUsername.sendKeys(protractor.Key.BACK_SPACE);
            }
        }));
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    clearPassword() {
        BrowserVisibility.waitUntilElementIsVisible(this.txtPassword);
        this.txtPassword.getAttribute('value').then((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            for (let i = value.length; i >= 0; i--) {
                this.txtPassword.sendKeys(protractor.Key.BACK_SPACE);
            }
        }));
    }
    /**
     * @return {?}
     */
    getUsernameTooltip() {
        BrowserVisibility.waitUntilElementIsVisible(this.usernameTooltip);
        return this.usernameTooltip.getText();
    }
    /**
     * @return {?}
     */
    getPasswordTooltip() {
        BrowserVisibility.waitUntilElementIsVisible(this.passwordTooltip);
        return this.passwordTooltip.getText();
    }
    /**
     * @return {?}
     */
    getLoginError() {
        BrowserVisibility.waitUntilElementIsVisible(this.loginTooltip);
        return this.loginTooltip.getText();
    }
    /**
     * @return {?}
     */
    checkLoginImgURL() {
        BrowserVisibility.waitUntilElementIsVisible(this.logoImg);
        return this.logoImg.getAttribute('src');
    }
    /**
     * @return {?}
     */
    checkUsernameInactive() {
        BrowserVisibility.waitUntilElementIsVisible(this.usernameInactive);
    }
    /**
     * @return {?}
     */
    checkPasswordInactive() {
        BrowserVisibility.waitUntilElementIsVisible(this.passwordInactive);
    }
    /**
     * @return {?}
     */
    checkUsernameHighlighted() {
        this.adfLogo.click();
        BrowserVisibility.waitUntilElementIsVisible(this.usernameHighlighted);
    }
    /**
     * @return {?}
     */
    checkPasswordHighlighted() {
        this.adfLogo.click();
        BrowserVisibility.waitUntilElementIsVisible(this.passwordHighlighted);
    }
    /**
     * @return {?}
     */
    checkUsernameTooltipIsNotVisible() {
        BrowserVisibility.waitUntilElementIsNotVisible(this.usernameTooltip);
    }
    /**
     * @return {?}
     */
    checkPasswordTooltipIsNotVisible() {
        BrowserVisibility.waitUntilElementIsNotVisible(this.passwordTooltip);
    }
    /**
     * @return {?}
     */
    getSignInButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.signInButton);
        return this.signInButton.isEnabled();
    }
    /**
     * @param {?} userModel
     * @return {?}
     */
    loginToProcessServicesUsingUserModel(userModel) {
        return __awaiter(this, void 0, void 0, function* () {
            this.goToLoginPage();
            yield LocalStorageUtil.clearStorage();
            yield LocalStorageUtil.setStorageItem('providers', 'BPM');
            yield LocalStorageUtil.apiReset();
            this.login(userModel.email, userModel.password);
        });
    }
    /**
     * @param {?} userModel
     * @return {?}
     */
    loginToContentServicesUsingUserModel(userModel) {
        return __awaiter(this, void 0, void 0, function* () {
            this.goToLoginPage();
            yield LocalStorageUtil.clearStorage();
            yield LocalStorageUtil.setStorageItem('providers', 'ECM');
            yield LocalStorageUtil.apiReset();
            this.login(userModel.getId(), userModel.getPassword());
        });
    }
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    loginToContentServices(username, password) {
        return __awaiter(this, void 0, void 0, function* () {
            this.goToLoginPage();
            yield LocalStorageUtil.clearStorage();
            yield LocalStorageUtil.setStorageItem('providers', 'ECM');
            yield LocalStorageUtil.apiReset();
            this.waitForElements();
            this.login(username, password);
        });
    }
    /**
     * @return {?}
     */
    clickSignInButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.signInButton);
        this.signInButton.click();
    }
    /**
     * @return {?}
     */
    clickSettingsIcon() {
        BrowserVisibility.waitUntilElementIsVisible(this.settingsIcon);
        this.settingsIcon.click();
    }
    /**
     * @return {?}
     */
    showPassword() {
        BrowserVisibility.waitUntilElementIsVisible(this.showPasswordElement);
        this.showPasswordElement.click();
    }
    /**
     * @return {?}
     */
    hidePassword() {
        BrowserVisibility.waitUntilElementIsVisible(this.hidePasswordElement);
        this.hidePasswordElement.click();
    }
    /**
     * @return {?}
     */
    getShownPassword() {
        return this.txtPassword.getAttribute('value');
    }
    /**
     * @return {?}
     */
    checkPasswordIsHidden() {
        BrowserVisibility.waitUntilElementIsVisible(this.txtPassword);
    }
    /**
     * @return {?}
     */
    checkRememberIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible(this.rememberMe);
    }
    /**
     * @return {?}
     */
    checkRememberIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotVisible(this.rememberMe);
    }
    /**
     * @return {?}
     */
    checkNeedHelpIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible(this.needHelp);
    }
    /**
     * @return {?}
     */
    checkNeedHelpIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotVisible(this.needHelp);
    }
    /**
     * @return {?}
     */
    checkRegisterDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible(this.register);
    }
    /**
     * @return {?}
     */
    checkRegisterIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotVisible(this.register);
    }
    /**
     * @return {?}
     */
    enableFooter() {
        this.formControllersPage.enableToggle(this.footerSwitch);
    }
    /**
     * @return {?}
     */
    disableFooter() {
        this.formControllersPage.disableToggle(this.footerSwitch);
    }
    /**
     * @return {?}
     */
    disableRememberMe() {
        this.formControllersPage.disableToggle(this.rememberMeSwitch);
    }
    /**
     * @return {?}
     */
    enableSuccessRouteSwitch() {
        this.formControllersPage.enableToggle(this.successRouteSwitch);
    }
    /**
     * @return {?}
     */
    enableLogoSwitch() {
        this.formControllersPage.enableToggle(this.logoSwitch);
    }
    /**
     * @param {?} route
     * @return {?}
     */
    enterSuccessRoute(route) {
        BrowserVisibility.waitUntilElementIsVisible(this.successRouteTxt);
        this.successRouteTxt.sendKeys('');
        this.successRouteTxt.clear();
        return this.successRouteTxt.sendKeys(route);
    }
    /**
     * @param {?} logo
     * @return {?}
     */
    enterLogo(logo) {
        BrowserVisibility.waitUntilElementIsVisible(this.logoTxt);
        this.logoTxt.sendKeys('');
        this.logoTxt.clear();
        return this.logoTxt.sendKeys(logo);
    }
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    login(username, password) {
        this.waitForElements();
        this.enterUsername(username);
        this.enterPassword(password);
        this.clickSignInButton();
        return BrowserVisibility.waitUntilElementIsVisible(this.header);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SettingsPage {
    constructor() {
        this.settingsURL = browser.baseUrl + '/settings';
        this.providerDropdown = element(by.css('mat-select[id="adf-provider-selector"] div[class="mat-select-arrow-wrapper"]'));
        this.ecmAndBpm = {
            option: element(by.xpath('//SPAN[@class="mat-option-text"][contains(text(),"ALL")]')),
            text: 'ALL'
        };
        this.bpm = {
            option: element(by.xpath('//SPAN[@class="mat-option-text"][contains(text(),"BPM") and not (contains(text(),"and"))]')),
            text: 'BPM'
        };
        this.ecm = {
            option: element(by.xpath('//SPAN[@class="mat-option-text"][contains(text(),"ECM") and not (contains(text(),"and"))]')),
            text: 'ECM'
        };
        this.oauth = {
            option: element(by.xpath('//SPAN[@class="mat-option-text"][contains(text(),"OAUTH")]')),
            text: 'OAUTH'
        };
        this.selectedOption = element(by.css('span[class*="mat-select-value-text"]'));
        this.ecmText = element(by.css('input[data-automation-id*="ecmHost"]'));
        this.bpmText = element(by.css('input[data-automation-id*="bpmHost"]'));
        this.clientIdText = element(by.css('input[id="clientId"]'));
        this.authHostText = element(by.css('input[id="oauthHost"]'));
        this.logoutUrlText = element(by.css('input[id="logout-url"]'));
        this.basicAuthRadioButton = element(by.cssContainingText('mat-radio-button[id*="mat-radio"]', 'Basic Authentication'));
        this.identityHostText = element(by.css('input[id="identityHost"]'));
        this.ssoRadioButton = element(by.cssContainingText('[id*="mat-radio"]', 'SSO'));
        this.silentLoginToggleLabel = element(by.css('mat-slide-toggle[name="silentLogin"] label'));
        this.silentLoginToggleElement = element(by.css('mat-slide-toggle[name="silentLogin"]'));
        this.implicitFlowLabel = element(by.css('mat-slide-toggle[name="implicitFlow"] label'));
        this.implicitFlowElement = element(by.css('mat-slide-toggle[name="implicitFlow"]'));
        this.applyButton = element(by.css('button[data-automation-id*="host-button"]'));
        this.backButton = element(by.cssContainingText('button span[class="mat-button-wrapper"]', 'Back'));
        this.validationMessage = element(by.cssContainingText('mat-error', 'This field is required'));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    goToSettingsPage() {
        browser.waitForAngularEnabled(true);
        browser.driver.get((/** @type {?} */ (this)).settingsURL);
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).providerDropdown);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} option
     * @param {?} selected
     * @return {?}
     */
    setProvider(option, selected) {
        BrowserVisibility.waitUntilElementIsVisible(this.providerDropdown);
        this.providerDropdown.click();
        BrowserVisibility.waitUntilElementIsVisible(option);
        option.click();
        return expect(this.selectedOption.getText()).toEqual(selected);
    }
    /**
     * @return {?}
     */
    getSelectedOptionText() {
        return this.selectedOption.getText();
    }
    /**
     * @return {?}
     */
    getBpmHostUrl() {
        return this.bpmText.getAttribute('value');
    }
    /**
     * @return {?}
     */
    getEcmHostUrl() {
        return this.ecmText.getAttribute('value');
    }
    /**
     * @return {?}
     */
    getBpmOption() {
        return this.bpm.option;
    }
    /**
     * @return {?}
     */
    getEcmOption() {
        return this.ecm.option;
    }
    /**
     * @return {?}
     */
    getEcmAndBpmOption() {
        return this.ecmAndBpm.option;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    setProviderEcmBpm() {
        (/** @type {?} */ (this)).goToSettingsPage();
        (/** @type {?} */ (this)).setProvider((/** @type {?} */ (this)).ecmAndBpm.option, (/** @type {?} */ (this)).ecmAndBpm.text);
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).bpmText);
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).ecmText);
        (/** @type {?} */ (this)).clickApply();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    setProviderBpm() {
        (/** @type {?} */ (this)).goToSettingsPage();
        (/** @type {?} */ (this)).setProvider((/** @type {?} */ (this)).bpm.option, (/** @type {?} */ (this)).bpm.text);
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).bpmText);
        (/** @type {?} */ (this)).clickApply();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    setProviderEcm() {
        (/** @type {?} */ (this)).goToSettingsPage();
        (/** @type {?} */ (this)).setProvider((/** @type {?} */ (this)).ecm.option, (/** @type {?} */ (this)).ecm.text);
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).ecmText);
        expect((/** @type {?} */ (this)).bpmText.isPresent()).toBeFalsy();
        (/** @type {?} */ (this)).clickApply();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    setProviderOauth() {
        (/** @type {?} */ (this)).goToSettingsPage();
        (/** @type {?} */ (this)).setProvider((/** @type {?} */ (this)).oauth.option, (/** @type {?} */ (this)).oauth.text);
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).bpmText);
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).ecmText);
        expect((/** @type {?} */ (this)).authHostText.isPresent()).toBeTruthy();
        (/** @type {?} */ (this)).clickApply();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    clickBackButton() {
        return __awaiter(this, void 0, void 0, function* () {
            BrowserVisibility.waitUntilElementIsVisible(this.backButton);
            yield this.backButton.click();
        });
    }
    /**
     * @return {?}
     */
    clickSsoRadioButton() {
        return __awaiter(this, void 0, void 0, function* () {
            BrowserVisibility.waitUntilElementIsVisible(this.ssoRadioButton);
            yield this.ssoRadioButton.click();
        });
    }
    /**
     * @param {?} contentServiceURL
     * @param {?} authHost
     * @param {?} identityHost
     * @param {?=} silentLogin
     * @param {?=} implicitFlow
     * @param {?=} clientId
     * @param {?=} logoutUr
     * @return {?}
     */
    setProviderEcmSso(contentServiceURL, authHost, identityHost, silentLogin = true, implicitFlow = true, clientId, logoutUr = '/logout') {
        return __awaiter(this, void 0, void 0, function* () {
            this.goToSettingsPage();
            this.setProvider(this.ecm.option, this.ecm.text);
            BrowserVisibility.waitUntilElementIsNotOnPage(this.bpmText);
            BrowserVisibility.waitUntilElementIsVisible(this.ecmText);
            yield this.clickSsoRadioButton();
            yield this.setClientId(clientId);
            yield this.setContentServicesURL(contentServiceURL);
            yield this.setAuthHost(authHost);
            yield this.setIdentityHost(identityHost);
            yield this.setSilentLogin(silentLogin);
            yield this.setImplicitFlow(implicitFlow);
            yield this.setLogoutUrl(logoutUr);
            yield this.clickApply();
        });
    }
    /**
     * @param {?} processServiceURL
     * @param {?} authHost
     * @param {?} identityHost
     * @param {?=} silentLogin
     * @param {?=} implicitFlow
     * @return {?}
     */
    setProviderBpmSso(processServiceURL, authHost, identityHost, silentLogin = true, implicitFlow = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.goToSettingsPage();
            this.setProvider(this.bpm.option, this.bpm.text);
            BrowserVisibility.waitUntilElementIsVisible(this.bpmText);
            BrowserVisibility.waitUntilElementIsNotOnPage(this.ecmText);
            yield this.clickSsoRadioButton();
            yield this.setClientId();
            yield this.setProcessServicesURL(processServiceURL);
            yield this.setAuthHost(authHost);
            yield this.setIdentityHost(identityHost);
            yield this.setSilentLogin(silentLogin);
            yield this.setImplicitFlow(implicitFlow);
            yield this.clickApply();
        });
    }
    /**
     * @param {?} logoutUrl
     * @return {?}
     */
    setLogoutUrl(logoutUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            BrowserVisibility.waitUntilElementIsPresent(this.logoutUrlText);
            this.logoutUrlText.clear();
            this.logoutUrlText.sendKeys(logoutUrl);
        });
    }
    /**
     * @param {?} processServiceURL
     * @return {?}
     */
    setProcessServicesURL(processServiceURL) {
        return __awaiter(this, void 0, void 0, function* () {
            BrowserVisibility.waitUntilElementIsVisible(this.bpmText);
            this.bpmText.clear();
            this.bpmText.sendKeys(processServiceURL);
        });
    }
    /**
     * @param {?=} clientId
     * @return {?}
     */
    setClientId(clientId = browser.params.config.oauth2.clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            BrowserVisibility.waitUntilElementIsVisible(this.clientIdText);
            this.clientIdText.clear();
            this.clientIdText.sendKeys(clientId);
        });
    }
    /**
     * @param {?} contentServiceURL
     * @return {?}
     */
    setContentServicesURL(contentServiceURL) {
        return __awaiter(this, void 0, void 0, function* () {
            BrowserVisibility.waitUntilElementIsClickable(this.ecmText);
            this.ecmText.clear();
            this.ecmText.sendKeys(contentServiceURL);
        });
    }
    /**
     * @return {?}
     */
    clearContentServicesURL() {
        BrowserVisibility.waitUntilElementIsVisible(this.ecmText);
        this.ecmText.clear();
        this.ecmText.sendKeys('a');
        this.ecmText.sendKeys(protractor.Key.BACK_SPACE);
    }
    /**
     * @return {?}
     */
    clearProcessServicesURL() {
        BrowserVisibility.waitUntilElementIsVisible(this.bpmText);
        this.bpmText.clear();
        this.bpmText.sendKeys('a');
        this.bpmText.sendKeys(protractor.Key.BACK_SPACE);
    }
    /**
     * @param {?} authHostURL
     * @return {?}
     */
    setAuthHost(authHostURL) {
        return __awaiter(this, void 0, void 0, function* () {
            BrowserVisibility.waitUntilElementIsVisible(this.authHostText);
            yield this.authHostText.clear();
            yield this.authHostText.sendKeys(authHostURL);
        });
    }
    /**
     * @param {?} identityHost
     * @return {?}
     */
    setIdentityHost(identityHost) {
        return __awaiter(this, void 0, void 0, function* () {
            BrowserVisibility.waitUntilElementIsVisible(this.identityHostText);
            yield this.identityHostText.clear();
            yield this.identityHostText.sendKeys(identityHost);
        });
    }
    /**
     * @return {?}
     */
    clickApply() {
        return __awaiter(this, void 0, void 0, function* () {
            BrowserVisibility.waitUntilElementIsVisible(this.applyButton);
            yield this.applyButton.click();
        });
    }
    /**
     * @param {?} enableToggle
     * @return {?}
     */
    setSilentLogin(enableToggle) {
        return __awaiter(this, void 0, void 0, function* () {
            yield BrowserVisibility.waitUntilElementIsVisible(this.silentLoginToggleElement);
            /** @type {?} */
            const isChecked = (yield this.silentLoginToggleElement.getAttribute('class')).includes('mat-checked');
            if (isChecked && !enableToggle || !isChecked && enableToggle) {
                return this.silentLoginToggleLabel.click();
            }
            return Promise.resolve();
        });
    }
    /**
     * @param {?} enableToggle
     * @return {?}
     */
    setImplicitFlow(enableToggle) {
        return __awaiter(this, void 0, void 0, function* () {
            yield BrowserVisibility.waitUntilElementIsVisible(this.implicitFlowElement);
            /** @type {?} */
            const isChecked = (yield this.implicitFlowElement.getAttribute('class')).includes('mat-checked');
            if (isChecked && !enableToggle || !isChecked && enableToggle) {
                return this.implicitFlowLabel.click();
            }
            return Promise.resolve();
        });
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkApplyButtonIsDisabled() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).applyButton.getAttribute('disabled'));
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    checkProviderDropdownIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible(this.providerDropdown);
    }
    /**
     * @return {?}
     */
    checkValidationMessageIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible(this.validationMessage);
    }
    /**
     * @return {?}
     */
    checkProviderOptions() {
        BrowserVisibility.waitUntilElementIsVisible(this.providerDropdown);
        this.providerDropdown.click();
        BrowserVisibility.waitUntilElementIsVisible(this.ecmAndBpm.option);
        BrowserVisibility.waitUntilElementIsVisible(this.ecm.option);
        BrowserVisibility.waitUntilElementIsVisible(this.bpm.option);
    }
    /**
     * @return {?}
     */
    getBasicAuthRadioButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.basicAuthRadioButton);
        return this.basicAuthRadioButton;
    }
    /**
     * @return {?}
     */
    getSsoRadioButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.ssoRadioButton);
        return this.ssoRadioButton;
    }
    /**
     * @return {?}
     */
    getBackButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.backButton);
        return this.backButton;
    }
    /**
     * @return {?}
     */
    getApplyButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.applyButton);
        return this.applyButton;
    }
    /**
     * @return {?}
     */
    checkBasicAuthRadioIsSelected() {
        expect(this.getBasicAuthRadioButton().getAttribute('class')).toContain('mat-radio-checked');
    }
    /**
     * @return {?}
     */
    checkSsoRadioIsNotSelected() {
        expect(this.getSsoRadioButton().getAttribute('class')).not.toContain('mat-radio-checked');
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoginSSOPage {
    constructor() {
        this.ssoButton = element(by.css(`[data-automation-id="login-button-sso"]`));
        this.usernameField = element(by.id('username'));
        this.passwordField = element(by.id('password'));
        this.loginButton = element(by.css('input[class="submit"]'));
        this.header = element(by.id('adf-header'));
        this.loginError = element(by.css(`div[data-automation-id="login-error"]`));
    }
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    loginSSOIdentityService(username, password) {
        browser.ignoreSynchronization = true;
        BrowserVisibility.waitUntilElementIsVisible(this.usernameField);
        this.enterUsername(username);
        this.enterPassword(password);
        this.clickLoginButton();
        browser.actions().sendKeys(protractor.Key.ENTER).perform();
        return BrowserVisibility.waitUntilElementIsVisible(this.header);
    }
    /**
     * @return {?}
     */
    clickOnSSOButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.ssoButton);
        this.ssoButton.click();
    }
    /**
     * @param {?} username
     * @return {?}
     */
    enterUsername(username) {
        BrowserVisibility.waitUntilElementIsVisible(this.usernameField);
        this.usernameField.clear();
        this.usernameField.sendKeys(username);
    }
    /**
     * @param {?} password
     * @return {?}
     */
    enterPassword(password) {
        BrowserVisibility.waitUntilElementIsVisible(this.passwordField);
        this.passwordField.clear();
        this.passwordField.sendKeys(password);
    }
    /**
     * @return {?}
     */
    clickLoginButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.loginButton);
        return this.loginButton.click();
    }
    /**
     * @return {?}
     */
    checkLoginErrorIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible(this.loginError);
    }
    /**
     * @return {?}
     */
    getLoginErrorMessage() {
        BrowserVisibility.waitUntilElementIsVisible(this.loginError);
        return this.loginError.getText();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataTableComponentPage {
    /**
     * @param {?=} rootElement
     */
    constructor(rootElement = element.all(by.css('adf-datatable')).first()) {
        this.rows = by.css(`adf-datatable div[class*='adf-datatable-body'] div[class*='adf-datatable-row']`);
        this.rootElement = rootElement;
        this.list = this.rootElement.all(by.css(`div[class*='adf-datatable-body'] div[class*='adf-datatable-row']`));
        this.contents = this.rootElement.all(by.css('div[class="adf-datatable-body"] span'));
        this.tableBody = this.rootElement.all(by.css(`div[class='adf-datatable-body']`)).first();
        this.spinner = this.rootElement.element(by.css('mat-progress-spinner'));
        this.allColumns = this.rootElement.all(by.css('div[data-automation-id*="auto_id_entry."]'));
        this.selectedRowNumber = this.rootElement.element(by.css(`div[class*='is-selected'] div[data-automation-id*='text_']`));
        this.allSelectedRows = this.rootElement.all(by.css(`div[class*='is-selected']`));
        this.selectAll = this.rootElement.element(by.css(`div[class*='adf-datatable-header'] mat-checkbox`));
        this.copyColumnTooltip = this.rootElement.element(by.css(`adf-copy-content-tooltip span`));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkAllRowsButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).selectAll);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkAllRows() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).selectAll);
        BrowserVisibility.waitUntilElementIsClickable((/** @type {?} */ (this)).selectAll).then((/**
         * @return {?}
         */
        () => {
            (/** @type {?} */ (this)).selectAll.click();
            BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).selectAll.element(by.css('input[aria-checked="true"]')));
        }));
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    uncheckAllRows() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).selectAll);
        BrowserVisibility.waitUntilElementIsClickable((/** @type {?} */ (this)).selectAll).then((/**
         * @return {?}
         */
        () => {
            (/** @type {?} */ (this)).selectAll.click();
            BrowserVisibility.waitUntilElementIsNotOnPage((/** @type {?} */ (this)).selectAll.element(by.css('input[aria-checked="true"]')));
        }));
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    clickCheckbox(columnName, columnValue) {
        /** @type {?} */
        const checkbox = this.getRowCheckbox(columnName, columnValue);
        BrowserVisibility.waitUntilElementIsClickable(checkbox);
        checkbox.click();
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    checkRowIsNotChecked(columnName, columnValue) {
        BrowserVisibility.waitUntilElementIsNotOnPage(this.getRowCheckbox(columnName, columnValue).element(by.css('input[aria-checked="true"]')));
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    checkRowIsChecked(columnName, columnValue) {
        /** @type {?} */
        const rowCheckbox = this.getRowCheckbox(columnName, columnValue);
        BrowserVisibility.waitUntilElementIsVisible(rowCheckbox.element(by.css('input[aria-checked="true"]')));
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    getRowCheckbox(columnName, columnValue) {
        return this.getRow(columnName, columnValue)
            .element(by.css('mat-checkbox'));
    }
    /**
     * @return {?}
     */
    checkNoRowIsSelected() {
        BrowserVisibility.waitUntilElementIsNotOnPage(this.selectedRowNumber);
    }
    /**
     * @return {?}
     */
    getNumberOfSelectedRows() {
        return this.allSelectedRows.count();
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    selectRowWithKeyboard(columnName, columnValue) {
        /** @type {?} */
        const row = this.getRow(columnName, columnValue);
        browser.actions().sendKeys(protractor.Key.COMMAND).click(row).perform();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} columnName
     * @param {?} columnValue
     * @return {THIS}
     */
    selectRow(columnName, columnValue) {
        /** @type {?} */
        const row = (/** @type {?} */ (this)).getRow(columnName, columnValue);
        BrowserVisibility.waitUntilElementIsVisible(row);
        BrowserVisibility.waitUntilElementIsClickable(row);
        row.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} columnName
     * @param {?} columnValue
     * @return {THIS}
     */
    checkRowIsSelected(columnName, columnValue) {
        /** @type {?} */
        const selectedRow = (/** @type {?} */ (this)).getCellElementByValue(columnName, columnValue).element(by.xpath(`ancestor::div[contains(@class, 'is-selected')]`));
        BrowserVisibility.waitUntilElementIsVisible(selectedRow);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} columnName
     * @param {?} columnValue
     * @return {THIS}
     */
    checkRowIsNotSelected(columnName, columnValue) {
        /** @type {?} */
        const selectedRow = (/** @type {?} */ (this)).getCellElementByValue(columnName, columnValue).element(by.xpath(`ancestor::div[contains(@class, 'is-selected')]`));
        BrowserVisibility.waitUntilElementIsNotOnPage(selectedRow);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} identifyingColumn
     * @param {?} identifyingValue
     * @param {?} columnName
     * @return {?}
     */
    getColumnValueForRow(identifyingColumn, identifyingValue, columnName) {
        /** @type {?} */
        const row = this.getRow(identifyingColumn, identifyingValue);
        BrowserVisibility.waitUntilElementIsVisible(row);
        /** @type {?} */
        const rowColumn = row.element(by.css(`div[title="${columnName}"] span`));
        BrowserVisibility.waitUntilElementIsVisible(rowColumn);
        return rowColumn.getText();
    }
    /**
     * Check the list is sorted.
     *
     * @param {?} sortOrder
     * @param {?} locator
     * @return {?} 'true' if the list is sorted as expected and 'false' if it isn't
     */
    checkListIsSorted(sortOrder, locator) {
        /** @type {?} */
        const deferred = protractor.promise.defer();
        /** @type {?} */
        const column = element.all(by.css(`div[title='${locator}'] span`));
        BrowserVisibility.waitUntilElementIsVisible(column.first());
        /** @type {?} */
        const initialList = [];
        column.each((/**
         * @param {?} currentElement
         * @return {?}
         */
        function (currentElement) {
            currentElement.getText().then((/**
             * @param {?} text
             * @return {?}
             */
            function (text) {
                initialList.push(text);
            }));
        })).then((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            let sortedList = initialList;
            sortedList = sortedList.sort();
            if (sortOrder === false) {
                sortedList = sortedList.reverse();
            }
            deferred.fulfill(initialList.toString() === sortedList.toString());
        }));
        return deferred.promise;
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    rightClickOnRow(columnName, columnValue) {
        /** @type {?} */
        const row = this.getRow(columnName, columnValue);
        browser.actions().click(row, protractor.Button.RIGHT).perform();
        BrowserVisibility.waitUntilElementIsVisible(element(by.id('adf-context-menu-content')));
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    getTooltip(columnName, columnValue) {
        return this.getCellElementByValue(columnName, columnValue).getAttribute('title');
    }
    /**
     * @param {?} filename
     * @return {?}
     */
    getFileHyperlink(filename) {
        return element(by.cssContainingText('adf-name-column[class*="adf-datatable-link"] span', filename));
    }
    /**
     * @return {?}
     */
    numberOfRows() {
        return this.rootElement.all(this.rows).count();
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getAllRowsColumnValues(column) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const columnLocator = by.css("adf-datatable div[class*='adf-datatable-body'] div[class*='adf-datatable-row'] div[title='" + column + "'] span");
            BrowserVisibility.waitUntilElementIsVisible(element.all(columnLocator).first());
            /** @type {?} */
            const initialList = yield element.all(columnLocator).getText();
            return initialList.filter((/**
             * @param {?} el
             * @return {?}
             */
            (el) => el));
        });
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    getRowsWithSameColumnValues(columnName, columnValue) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const columnLocator = by.css(`div[title='${columnName}'] div[data-automation-id="text_${columnValue}"] span`);
            BrowserVisibility.waitUntilElementIsVisible(this.rootElement.all(columnLocator).first());
            return this.rootElement.all(columnLocator).getText();
        });
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} columnName
     * @param {?} columnValue
     * @return {THIS}
     */
    doubleClickRow(columnName, columnValue) {
        /** @type {?} */
        const row = (/** @type {?} */ (this)).getRow(columnName, columnValue);
        BrowserVisibility.waitUntilElementIsVisible(row);
        BrowserVisibility.waitUntilElementIsClickable(row);
        row.click();
        (/** @type {?} */ (this)).checkRowIsSelected(columnName, columnValue);
        browser.actions().sendKeys(protractor.Key.ENTER).perform();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    waitForTableBody() {
        BrowserVisibility.waitUntilElementIsVisible(this.tableBody);
    }
    /**
     * @param {?} detail
     * @return {?}
     */
    getFirstElementDetail(detail) {
        /** @type {?} */
        const firstNode = element.all(by.css(`adf-datatable div[title="${detail}"] span`)).first();
        return firstNode.getText();
    }
    /**
     * @param {?} detail
     * @return {?}
     */
    geCellElementDetail(detail) {
        return element.all(by.css(`adf-datatable div[title="${detail}"] span`));
    }
    /**
     * @param {?} sortOrder
     * @param {?} column
     * @return {?}
     */
    sortByColumn(sortOrder, column) {
        /** @type {?} */
        const locator = by.css(`div[data-automation-id="auto_id_${column}"]`);
        BrowserVisibility.waitUntilElementIsVisible(element(locator));
        return element(locator).getAttribute('class').then((/**
         * @param {?} result
         * @return {?}
         */
        function (result) {
            if (sortOrder === true) {
                if (!result.includes('sorted-asc')) {
                    if (result.includes('sorted-desc') || result.includes('sortable')) {
                        element(locator).click();
                    }
                }
            }
            else {
                if (result.includes('sorted-asc')) {
                    element(locator).click();
                }
                else if (result.includes('sortable')) {
                    element(locator).click();
                    element(locator).click();
                }
            }
            return Promise.resolve();
        }));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} columnName
     * @param {?} columnValue
     * @return {THIS}
     */
    checkContentIsDisplayed(columnName, columnValue) {
        /** @type {?} */
        const row = (/** @type {?} */ (this)).getCellElementByValue(columnName, columnValue);
        BrowserVisibility.waitUntilElementIsVisible(row);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} columnName
     * @param {?} columnValue
     * @return {THIS}
     */
    checkContentIsNotDisplayed(columnName, columnValue) {
        /** @type {?} */
        const row = (/** @type {?} */ (this)).getCellElementByValue(columnName, columnValue);
        BrowserVisibility.waitUntilElementIsNotOnPage(row);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    getRow(columnName, columnValue) {
        /** @type {?} */
        const row = this.rootElement.all(by.css(`div[title="${columnName}"] div[data-automation-id="text_${columnValue}"]`)).first()
            .element(by.xpath(`ancestor::div[contains(@class, 'adf-datatable-row')]`));
        BrowserVisibility.waitUntilElementIsVisible(row);
        return row;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    contentInPosition(position) {
        BrowserVisibility.waitUntilElementIsVisible(this.contents);
        return this.contents.get(position - 1).getText();
    }
    /**
     * @param {?} columnName
     * @param {?} columnValue
     * @return {?}
     */
    getCellElementByValue(columnName, columnValue) {
        return this.rootElement.all(by.css(`div[title="${columnName}"] div[data-automation-id="text_${columnValue}"] span`)).first();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkSpinnerIsDisplayed() {
        BrowserVisibility.waitUntilElementIsPresent((/** @type {?} */ (this)).spinner);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkSpinnerIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotOnPage((/** @type {?} */ (this)).spinner);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    tableIsLoaded() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).rootElement);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} column
     * @return {THIS}
     */
    checkColumnIsDisplayed(column) {
        BrowserVisibility.waitUntilElementIsVisible(element(by.css(`div[data-automation-id="auto_id_entry.${column}"]`)));
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getNumberOfColumns() {
        return this.allColumns.count();
    }
    /**
     * @return {?}
     */
    getNumberOfRows() {
        return this.list.count();
    }
    /**
     * @param {?} rowNumber
     * @param {?} columnName
     * @return {?}
     */
    getCellByRowNumberAndColumnName(rowNumber, columnName) {
        return this.list.get(rowNumber).element(by.css(`div[title="${columnName}"] span`));
    }
    /**
     * @param {?} rowColumn
     * @param {?} rowContent
     * @param {?} columnName
     * @return {?}
     */
    getCellByRowContentAndColumn(rowColumn, rowContent, columnName) {
        return this.getRow(rowColumn, rowContent).element(by.css(`div[title='${columnName}']`));
    }
    /**
     * @param {?} content
     * @return {?}
     */
    selectRowByContent(content) {
        /** @type {?} */
        const row = this.getCellByContent(content);
        return row.click();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} folderName
     * @return {THIS}
     */
    checkRowByContentIsSelected(folderName) {
        /** @type {?} */
        const selectedRow = (/** @type {?} */ (this)).getCellByContent(folderName).element(by.xpath(`ancestor::div[contains(@class, 'is-selected')]`));
        BrowserVisibility.waitUntilElementIsVisible(selectedRow);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} content
     * @return {?}
     */
    getCellByContent(content) {
        /** @type {?} */
        const cell = this.rootElement.element(by.cssContainingText(`div[class*='adf-datatable-row'] div[class*='adf-name-location-cell-name']`, content));
        BrowserVisibility.waitUntilElementIsVisible(cell);
        return cell;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    clickRowByContent(name) {
        /** @type {?} */
        const resultElement = this.rootElement.all(by.css(`div[data-automation-id='${name}']`)).first();
        BrowserVisibility.waitUntilElementIsVisible(resultElement);
        BrowserVisibility.waitUntilElementIsClickable(resultElement);
        resultElement.click();
    }
    /**
     * @return {?}
     */
    getCopyContentTooltip() {
        BrowserVisibility.waitUntilElementIsVisible(this.copyColumnTooltip);
        return this.copyColumnTooltip.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    copyContentTooltipIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotPresent((/** @type {?} */ (this)).copyColumnTooltip);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} columnName
     * @param {?} columnValue
     * @return {THIS}
     */
    mouseOverColumn(columnName, columnValue) {
        /** @type {?} */
        const column = (/** @type {?} */ (this)).getCellElementByValue(columnName, columnValue);
        (/** @type {?} */ (this)).mouseOverElement(column);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} elem
     * @return {THIS}
     */
    mouseOverElement(elem) {
        BrowserVisibility.waitUntilElementIsVisible(elem);
        browser.actions().mouseMove(elem).perform();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} columnName
     * @param {?} columnValue
     * @return {THIS}
     */
    clickColumn(columnName, columnValue) {
        /** @type {?} */
        const column = (/** @type {?} */ (this)).getCellElementByValue(columnName, columnValue);
        (/** @type {?} */ (this)).clickElement(column);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} elem
     * @return {THIS}
     */
    clickElement(elem) {
        BrowserVisibility.waitUntilElementIsVisible(elem);
        BrowserVisibility.waitUntilElementIsClickable(elem);
        elem.click();
        return (/** @type {?} */ (this));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationPage {
    constructor() {
        this.itemsPerPageDropdown = element(by.css('div[class*="adf-pagination__perpage-block"] button'));
        this.pageSelectorDropDown = element(by.css('div[class*="adf-pagination__page-selector"]'));
        this.pageSelectorArrow = element(by.css('button[data-automation-id="page-selector"]'));
        this.itemsPerPage = element(by.css('span[class="adf-pagination__max-items"]'));
        this.currentPage = element(by.css('span[class="adf-pagination__current-page"]'));
        this.totalPages = element(by.css('span[class="adf-pagination__total-pages"]'));
        this.paginationRange = element(by.css('span[class="adf-pagination__range"]'));
        this.nextPageButton = element(by.css('button[class*="adf-pagination__next-button"]'));
        this.nextButtonDisabled = element(by.css('button[class*="adf-pagination__next-button"][disabled]'));
        this.previousButtonDisabled = element(by.css('button[class*="adf-pagination__previous-button"][disabled]'));
        this.pageDropDown = element(by.css('div[class*="adf-pagination__actualinfo-block"] button'));
        this.pageDropDownOptions = by.css('div[class*="mat-menu-content"] button');
        this.paginationSection = element(by.css('adf-pagination'));
        this.paginationSectionEmpty = element(by.css('adf-pagination[class*="adf-pagination__empty"]'));
        this.totalFiles = element(by.css('span[class="adf-pagination__range"]'));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} numberOfItem
     * @return {THIS}
     */
    selectItemsPerPage(numberOfItem) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).itemsPerPageDropdown);
        BrowserVisibility.waitUntilElementIsClickable((/** @type {?} */ (this)).itemsPerPageDropdown);
        browser.actions().mouseMove((/** @type {?} */ (this)).itemsPerPageDropdown).perform();
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).itemsPerPageDropdown);
        BrowserVisibility.waitUntilElementIsClickable((/** @type {?} */ (this)).itemsPerPageDropdown);
        (/** @type {?} */ (this)).itemsPerPageDropdown.click();
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).pageSelectorDropDown);
        /** @type {?} */
        const itemsPerPage = element.all(by.cssContainingText('.mat-menu-item', numberOfItem)).first();
        BrowserVisibility.waitUntilElementIsClickable(itemsPerPage);
        BrowserVisibility.waitUntilElementIsVisible(itemsPerPage);
        itemsPerPage.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    checkPageSelectorIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotOnPage(this.pageSelectorArrow);
    }
    /**
     * @return {?}
     */
    checkPageSelectorIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible(this.pageSelectorArrow);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkPaginationIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsOnPage((/** @type {?} */ (this)).paginationSectionEmpty);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getCurrentItemsPerPage() {
        BrowserVisibility.waitUntilElementIsVisible(this.itemsPerPage);
        return this.itemsPerPage.getText();
    }
    /**
     * @return {?}
     */
    getCurrentPage() {
        BrowserVisibility.waitUntilElementIsVisible(this.paginationSection);
        BrowserVisibility.waitUntilElementIsVisible(this.currentPage);
        return this.currentPage.getText();
    }
    /**
     * @return {?}
     */
    getTotalPages() {
        BrowserVisibility.waitUntilElementIsVisible(this.totalPages);
        return this.totalPages.getText();
    }
    /**
     * @return {?}
     */
    getPaginationRange() {
        BrowserVisibility.waitUntilElementIsVisible(this.paginationRange);
        return this.paginationRange.getText();
    }
    /**
     * @return {?}
     */
    clickOnNextPage() {
        BrowserVisibility.waitUntilElementIsVisible(this.nextPageButton);
        BrowserVisibility.waitUntilElementIsClickable(this.nextPageButton);
        browser.actions().mouseMove(this.nextPageButton).perform();
        BrowserVisibility.waitUntilElementIsVisible(this.nextPageButton);
        BrowserVisibility.waitUntilElementIsClickable(this.nextPageButton);
        return this.nextPageButton.click();
    }
    /**
     * @return {?}
     */
    clickOnPageDropdown() {
        BrowserVisibility.waitUntilElementIsVisible(this.pageDropDown);
        BrowserVisibility.waitUntilElementIsClickable(this.pageDropDown);
        return this.pageDropDown.click();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} numberOfItemPerPage
     * @return {THIS}
     */
    clickOnPageDropdownOption(numberOfItemPerPage) {
        BrowserVisibility.waitUntilElementIsVisible(element.all((/** @type {?} */ (this)).pageDropDownOptions).first());
        /** @type {?} */
        const option = element(by.cssContainingText('div[class*="mat-menu-content"] button', numberOfItemPerPage));
        BrowserVisibility.waitUntilElementIsVisible(option);
        option.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getPageDropdownOptions() {
        /** @type {?} */
        const deferred = protractor.promise.defer();
        BrowserVisibility.waitUntilElementIsVisible(element.all(this.pageDropDownOptions).first());
        /** @type {?} */
        const initialList = [];
        element.all(this.pageDropDownOptions).each((/**
         * @param {?} currentOption
         * @return {?}
         */
        function (currentOption) {
            currentOption.getText().then((/**
             * @param {?} text
             * @return {?}
             */
            function (text) {
                if (text !== '') {
                    initialList.push(text);
                }
            }));
        })).then((/**
         * @return {?}
         */
        function () {
            deferred.fulfill(initialList);
        }));
        return deferred.promise;
    }
    /**
     * @return {?}
     */
    checkNextPageButtonIsDisabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.nextButtonDisabled);
    }
    /**
     * @return {?}
     */
    checkPreviousPageButtonIsDisabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.previousButtonDisabled);
    }
    /**
     * @return {?}
     */
    checkNextPageButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsNotOnPage(this.nextButtonDisabled);
    }
    /**
     * @return {?}
     */
    checkPreviousPageButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsNotOnPage(this.previousButtonDisabled);
    }
    /**
     * @return {?}
     */
    getTotalNumberOfFiles() {
        BrowserVisibility.waitUntilElementIsVisible(this.totalFiles);
        /** @type {?} */
        const numberOfFiles = this.totalFiles.getText().then((/**
         * @param {?} totalNumber
         * @return {?}
         */
        function (totalNumber) {
            /** @type {?} */
            const totalNumberOfFiles = totalNumber.split('of ')[1];
            return totalNumberOfFiles;
        }));
        return numberOfFiles;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ErrorPage {
    constructor() {
        this.errorPageCode = element(by.css('adf-error-content .adf-error-content-code'));
        this.errorPageTitle = element(by.css('adf-error-content .adf-error-content-title'));
        this.errorPageDescription = element(by.css('adf-error-content .adf-error-content-description'));
        this.backButton = element(by.id('adf-return-button'));
        this.secondButton = element(by.id('adf-secondary-button'));
    }
    /**
     * @return {?}
     */
    clickBackButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.backButton);
        this.backButton.click();
    }
    /**
     * @return {?}
     */
    clickSecondButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.secondButton);
        this.secondButton.click();
    }
    /**
     * @return {?}
     */
    checkErrorCode() {
        BrowserVisibility.waitUntilElementIsVisible(this.errorPageCode);
    }
    /**
     * @return {?}
     */
    getErrorCode() {
        BrowserVisibility.waitUntilElementIsVisible(this.errorPageCode);
        return this.errorPageCode.getText();
    }
    /**
     * @return {?}
     */
    getErrorTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.errorPageTitle);
        return this.errorPageTitle.getText();
    }
    /**
     * @return {?}
     */
    getErrorDescription() {
        BrowserVisibility.waitUntilElementIsVisible(this.errorPageDescription);
        return this.errorPageDescription.getText();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Tagged template to convert a sting to an `ElementFinder`.
 * \@example ```const item = byCss`.adf-breadcrumb-item-current`;``` / ```const item = byCss`${variable}`;```
 * @param {?} literals
 * @param {...?} placeholders
 * @return {?} Instance of `ElementFinder` type.
 */
function byCss(literals, ...placeholders) {
    /** @type {?} */
    const selector = literals[0] || placeholders[0];
    return browser.element(by.css(selector));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DocumentListPage {
    /**
     * @param {?=} rootElement
     */
    constructor(rootElement = element.all(by.css('adf-document-list')).first()) {
        this.actionMenu = element(by.css('div[role="menu"]'));
        this.optionButton = by.css('button[data-automation-id*="action_menu_"]');
        this.rootElement = rootElement;
        this.dataTable = new DataTableComponentPage(this.rootElement);
        this.tableBody = rootElement.all(by.css('div[class="adf-datatable-body"]')).first();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} content
     * @return {THIS}
     */
    checkLockedIcon(content) {
        /** @type {?} */
        const row = (/** @type {?} */ (this)).dataTable.getRow('Display name', content);
        /** @type {?} */
        const lockIcon = row.element(by.cssContainingText('div[title="Lock"] mat-icon', 'lock'));
        BrowserVisibility.waitUntilElementIsVisible(lockIcon);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} content
     * @return {THIS}
     */
    checkUnlockedIcon(content) {
        /** @type {?} */
        const row = (/** @type {?} */ (this)).dataTable.getRow('Display name', content);
        /** @type {?} */
        const lockIcon = row.element(by.cssContainingText('div[title="Lock"] mat-icon', 'lock_open'));
        BrowserVisibility.waitUntilElementIsVisible(lockIcon);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    waitForTableBody() {
        return BrowserVisibility.waitUntilElementIsVisible(this.tableBody);
    }
    /**
     * @param {?} nodeName
     * @return {?}
     */
    getTooltip(nodeName) {
        return this.dataTable.getTooltip('Display name', nodeName);
    }
    /**
     * @param {?} nodeName
     * @return {?}
     */
    selectRow(nodeName) {
        return this.dataTable.selectRow('Display name', nodeName);
    }
    /**
     * @param {?} nodeName
     * @return {?}
     */
    rightClickOnRow(nodeName) {
        return this.dataTable.rightClickOnRow('Display name', nodeName);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} content
     * @return {THIS}
     */
    clickOnActionMenu(content) {
        /** @type {?} */
        const row = (/** @type {?} */ (this)).dataTable.getRow('Display name', content);
        row.element((/** @type {?} */ (this)).optionButton).click();
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).actionMenu);
        browser.sleep(500);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkActionMenuIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotVisible((/** @type {?} */ (this)).actionMenu);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    dataTablePage() {
        return new DataTableComponentPage(this.rootElement);
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getAllRowsColumnValues(column) {
        return this.dataTable.getAllRowsColumnValues(column);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} nodeName
     * @return {THIS}
     */
    doubleClickRow(nodeName) {
        (/** @type {?} */ (this)).dataTable.doubleClickRow('Display name', nodeName);
        return (/** @type {?} */ (this));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ExampleAction {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentNodeSelectorDialogPage {
    constructor() {
        this.dialog = element(by.css(`adf-content-node-selector`));
        this.header = this.dialog.element(by.css(`header[data-automation-id='content-node-selector-title']`));
        this.searchInputElement = this.dialog.element(by.css(`input[data-automation-id='content-node-selector-search-input']`));
        this.searchLabel = this.searchInputElement.element(by.xpath("ancestor::div[@class='mat-form-field-infix']/span/label"));
        this.siteListDropdown = this.dialog.element(by.css(`mat-select[data-automation-id='site-my-files-option']`));
        this.cancelButton = element(by.css(`button[data-automation-id='content-node-selector-actions-cancel']`));
        this.moveCopyButton = element(by.css(`button[data-automation-id='content-node-selector-actions-choose']`));
        this.contentList = new DocumentListPage(this.dialog);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkDialogIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).dialog);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkDialogIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotOnPage((/** @type {?} */ (this)).dialog);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getDialogHeaderText() {
        BrowserVisibility.waitUntilElementIsVisible(this.header);
        return this.header.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkSearchInputIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).searchInputElement);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getSearchLabel() {
        BrowserVisibility.waitUntilElementIsVisible(this.searchLabel);
        return this.searchLabel.getText();
    }
    /**
     * @param {?} siteName
     * @return {?}
     */
    checkSelectedSiteIsDisplayed(siteName) {
        BrowserVisibility.waitUntilElementIsVisible(this.siteListDropdown.element(by.cssContainingText('.mat-select-value-text span', siteName)));
    }
    /**
     * @return {?}
     */
    checkCancelButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible(this.cancelButton);
    }
    /**
     * @return {?}
     */
    clickCancelButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.cancelButton);
        return this.cancelButton.click();
    }
    /**
     * @return {?}
     */
    checkMoveCopyButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible(this.moveCopyButton);
    }
    /**
     * @return {?}
     */
    getMoveCopyButtonText() {
        BrowserVisibility.waitUntilElementIsVisible(this.moveCopyButton);
        return this.moveCopyButton.getText();
    }
    /**
     * @return {?}
     */
    clickMoveCopyButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.moveCopyButton);
        return this.moveCopyButton.click();
    }
    /**
     * @return {?}
     */
    numberOfResultsDisplayed() {
        return this.contentList.dataTablePage().numberOfRows();
    }
    /**
     * @param {?} text
     * @return {?}
     */
    typeIntoNodeSelectorSearchField(text) {
        BrowserVisibility.waitUntilElementIsVisible(this.searchInputElement);
        this.searchInputElement.sendKeys(text);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    clickContentNodeSelectorResult(name) {
        this.contentList.dataTablePage().clickRowByContent(name);
    }
    /**
     * @return {?}
     */
    contentListPage() {
        return this.contentList;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormFieldsPage {
    constructor() {
        this.formContent = element(by.css('adf-form'));
        this.refreshButton = element(by.css('div[class*="form-reload-button"] mat-icon'));
        this.saveButton = element(by.cssContainingText('mat-card-actions[class*="adf-for"] span', 'SAVE'));
        this.valueLocator = by.css('input');
        this.labelLocator = by.css('label');
        this.noFormMessage = element(by.css('span[id*="no-form-message"]'));
        this.completedTaskNoFormMessage = element(by.css('div[id*="completed-form-message"] p'));
        this.attachFormButton = element(by.id('adf-no-form-attach-form-button'));
        this.selectFormDropDownArrow = element.all(by.css('adf-attach-form div[class*="mat-select-arrow"]')).first();
        this.selectFormContent = element(by.css('div[class*="mat-select-panel"]'));
        this.completeButton = element(by.id('adf-form-complete'));
        this.errorMessage = by.css('.adf-error-text-container .adf-error-text');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} locator
     * @param {?} field
     * @param {?} value
     * @return {THIS}
     */
    setFieldValue(locator, field, value) {
        /** @type {?} */
        const fieldElement = element(locator(field));
        BrowserVisibility.waitUntilElementIsVisible(fieldElement);
        fieldElement.clear().sendKeys(value);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} fieldId
     * @return {?}
     */
    checkWidgetIsVisible(fieldId) {
        /** @type {?} */
        const fieldElement = element.all(by.css(`adf-form-field div[id='field-${fieldId}-container']`)).first();
        BrowserVisibility.waitUntilElementIsVisible(fieldElement);
    }
    /**
     * @param {?} fieldId
     * @return {?}
     */
    checkWidgetIsHidden(fieldId) {
        /** @type {?} */
        const hiddenElement = element(by.css(`adf-form-field div[id='field-${fieldId}-container'][hidden]`));
        BrowserVisibility.waitUntilElementIsVisible(hiddenElement);
    }
    /**
     * @param {?} fieldId
     * @return {?}
     */
    getWidget(fieldId) {
        /** @type {?} */
        const widget = element(by.css(`adf-form-field div[id='field-${fieldId}-container']`));
        BrowserVisibility.waitUntilElementIsVisible(widget);
        return widget;
    }
    /**
     * @param {?} fieldId
     * @param {?} valueLocatorParam
     * @return {?}
     */
    getFieldValue(fieldId, valueLocatorParam) {
        /** @type {?} */
        const value = this.getWidget(fieldId).element(valueLocatorParam || this.valueLocator);
        BrowserVisibility.waitUntilElementIsVisible(value);
        return value.getAttribute('value');
    }
    /**
     * @param {?} fieldId
     * @param {?} labelLocatorParam
     * @return {?}
     */
    getFieldLabel(fieldId, labelLocatorParam) {
        /** @type {?} */
        const label = this.getWidget(fieldId).all(labelLocatorParam || this.labelLocator).first();
        BrowserVisibility.waitUntilElementIsVisible(label);
        return label.getText();
    }
    /**
     * @param {?} fieldId
     * @return {?}
     */
    getFieldErrorMessage(fieldId) {
        /** @type {?} */
        const error = this.getWidget(fieldId).element(this.errorMessage);
        return error.getText();
    }
    /**
     * @param {?} fieldId
     * @param {?} labelLocatorParam
     * @return {?}
     */
    getFieldText(fieldId, labelLocatorParam) {
        /** @type {?} */
        const label = this.getWidget(fieldId).element(labelLocatorParam || this.labelLocator);
        BrowserVisibility.waitUntilElementIsVisible(label);
        return label.getText();
    }
    /**
     * @param {?} fieldId
     * @param {?=} locator
     * @return {?}
     */
    getFieldPlaceHolder(fieldId, locator = 'input') {
        /** @type {?} */
        const placeHolderLocator = element(by.css(`${locator}#${fieldId}`)).getAttribute('placeholder');
        BrowserVisibility.waitUntilElementIsVisible(placeHolderLocator);
        return placeHolderLocator;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} locator
     * @param {?} field
     * @param {?} val
     * @return {THIS}
     */
    checkFieldValue(locator, field, val) {
        BrowserVisibility.waitUntilElementHasValue(element(locator(field)), val);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    refreshForm() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).refreshButton);
        (/** @type {?} */ (this)).refreshButton.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    saveForm() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).saveButton);
        BrowserVisibility.waitUntilElementIsClickable((/** @type {?} */ (this)).saveButton);
        (/** @type {?} */ (this)).saveButton.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    noFormIsDisplayed() {
        BrowserVisibility.waitUntilElementIsNotOnPage((/** @type {?} */ (this)).formContent);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkFormIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).formContent);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getNoFormMessage() {
        BrowserVisibility.waitUntilElementIsVisible(this.noFormMessage);
        return this.noFormMessage.getText();
    }
    /**
     * @return {?}
     */
    getCompletedTaskNoFormMessage() {
        BrowserVisibility.waitUntilElementIsVisible(this.completedTaskNoFormMessage);
        return this.completedTaskNoFormMessage.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickOnAttachFormButton() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).attachFormButton);
        (/** @type {?} */ (this)).attachFormButton.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} formName
     * @return {THIS}
     */
    selectForm(formName) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).selectFormDropDownArrow);
        (/** @type {?} */ (this)).selectFormDropDownArrow.click();
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).selectFormContent);
        (/** @type {?} */ (this)).selectFormFromDropDown(formName);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} formName
     * @return {?}
     */
    selectFormFromDropDown(formName) {
        /** @type {?} */
        const formNameElement = element(by.cssContainingText('span', formName));
        BrowserVisibility.waitUntilElementIsVisible(formNameElement);
        formNameElement.click();
    }
    /**
     * @param {?} fieldId
     * @return {?}
     */
    checkWidgetIsReadOnlyMode(fieldId) {
        /** @type {?} */
        const widget = element(by.css(`adf-form-field div[id='field-${fieldId}-container']`));
        /** @type {?} */
        const widgetReadOnly = widget.element(by.css('div[class*="adf-readonly"]'));
        BrowserVisibility.waitUntilElementIsVisible(widgetReadOnly);
        return widgetReadOnly;
    }
    /**
     * @return {?}
     */
    completeForm() {
        BrowserVisibility.waitUntilElementIsVisible(this.completeButton);
        return this.completeButton.click();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} fieldId
     * @param {?} value
     * @return {THIS}
     */
    setValueInInputById(fieldId, value) {
        /** @type {?} */
        const input = element(by.id(fieldId));
        BrowserVisibility.waitUntilElementIsVisible(input);
        input.clear().sendKeys(value);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    isCompleteFormButtonDisabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.completeButton);
        return this.completeButton.getAttribute('disabled');
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StartTasksCloudPage {
    constructor() {
        this.name = element(by.css('input[id="name_id"]'));
        this.dueDate = element(by.css('input[id="date_id"]'));
        this.description = element(by.css('textarea[id="description_id"]'));
        this.priority = element(by.css('input[formcontrolname="priority"]'));
        this.startButton = element(by.css('button[id="button-start"]'));
        this.startButtonEnabled = element(by.css('button[id="button-start"]:not(disabled)'));
        this.cancelButton = element(by.css('button[id="button-cancel"]'));
        this.form = element.all(by.css('adf-cloud-start-task form')).first();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkFormIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).form);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} userName
     * @return {THIS}
     */
    addName(userName) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).name);
        (/** @type {?} */ (this)).name.clear();
        (/** @type {?} */ (this)).name.sendKeys(userName);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} userDescription
     * @return {THIS}
     */
    addDescription(userDescription) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).description);
        (/** @type {?} */ (this)).description.sendKeys(userDescription);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} userPriority
     * @return {THIS}
     */
    addPriority(userPriority) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).priority);
        (/** @type {?} */ (this)).priority.sendKeys(userPriority);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} date
     * @return {THIS}
     */
    addDueDate(date) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).dueDate);
        (/** @type {?} */ (this)).clearField((/** @type {?} */ (this)).dueDate);
        (/** @type {?} */ (this)).dueDate.sendKeys(date);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    clickStartButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.startButton);
        BrowserVisibility.waitUntilElementIsClickable(this.startButton);
        return this.startButton.click();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkStartButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).startButtonEnabled);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkStartButtonIsDisabled() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).startButton.getAttribute('disabled'));
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    clickCancelButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.cancelButton);
        BrowserVisibility.waitUntilElementIsClickable(this.cancelButton);
        return this.cancelButton.click();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} locator
     * @return {THIS}
     */
    blur(locator) {
        locator.click();
        locator.sendKeys(Key.TAB);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} error
     * @param {?=} elementRef
     * @return {THIS}
     */
    checkValidationErrorIsDisplayed(error, elementRef = 'mat-error') {
        /** @type {?} */
        const errorElement = element(by.cssContainingText(elementRef, error));
        BrowserVisibility.waitUntilElementIsVisible(errorElement);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} error
     * @return {THIS}
     */
    validateAssignee(error) {
        (/** @type {?} */ (this)).checkValidationErrorIsDisplayed(error, '.adf-start-task-cloud-error');
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} error
     * @return {THIS}
     */
    validateDate(error) {
        (/** @type {?} */ (this)).checkValidationErrorIsDisplayed(error, '.adf-error-text');
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} locator
     * @return {?}
     */
    clearField(locator) {
        BrowserVisibility.waitUntilElementIsVisible(locator);
        BrowserVisibility.waitUntilElementIsClickable(locator);
        locator.getAttribute('value').then((/**
         * @param {?} result
         * @return {?}
         */
        (result) => {
            for (let i = result.length; i >= 0; i--) {
                locator.sendKeys(protractor.Key.BACK_SPACE);
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskHeaderCloudPage {
    constructor() {
        this.assigneeField = element(by.css('span[data-automation-id*="assignee"] span'));
        this.statusField = element(by.css('span[data-automation-id*="status"] span'));
        this.priorityField = element(by.css('span[data-automation-id*="priority"] span'));
        this.dueDateField = element.all(by.css('span[data-automation-id*="dueDate"] span')).first();
        this.categoryField = element(by.css('span[data-automation-id*="category"] span'));
        this.createdField = element(by.css('span[data-automation-id="card-dateitem-created"] span'));
        this.parentNameField = element(by.css('span[data-automation-id*="parentName"] span'));
        this.parentTaskIdField = element(by.css('span[data-automation-id*="parentTaskId"] span'));
        this.endDateField = element.all(by.css('span[data-automation-id*="endDate"] span')).first();
        this.idField = element.all(by.css('span[data-automation-id*="id"] span')).first();
        this.descriptionField = element(by.css('span[data-automation-id*="description"] span'));
        this.taskPropertyList = element(by.css('adf-cloud-task-header adf-card-view div[class="adf-property-list"]'));
    }
    /**
     * @return {?}
     */
    getAssignee() {
        BrowserVisibility.waitUntilElementIsVisible(this.assigneeField);
        return this.assigneeField.getText();
    }
    /**
     * @return {?}
     */
    getStatus() {
        BrowserVisibility.waitUntilElementIsVisible(this.statusField);
        return this.statusField.getText();
    }
    /**
     * @return {?}
     */
    getPriority() {
        BrowserVisibility.waitUntilElementIsVisible(this.priorityField);
        return this.priorityField.getText();
    }
    /**
     * @return {?}
     */
    getCategory() {
        BrowserVisibility.waitUntilElementIsVisible(this.categoryField);
        return this.categoryField.getText();
    }
    /**
     * @return {?}
     */
    getParentName() {
        BrowserVisibility.waitUntilElementIsVisible(this.parentNameField);
        return this.parentNameField.getText();
    }
    /**
     * @return {?}
     */
    getParentTaskId() {
        BrowserVisibility.waitUntilElementIsVisible(this.parentTaskIdField);
        return this.parentTaskIdField.getText();
    }
    /**
     * @return {?}
     */
    getEndDate() {
        BrowserVisibility.waitUntilElementIsVisible(this.endDateField);
        return this.endDateField.getText();
    }
    /**
     * @return {?}
     */
    getCreated() {
        BrowserVisibility.waitUntilElementIsVisible(this.createdField);
        return this.createdField.getText();
    }
    /**
     * @return {?}
     */
    getId() {
        BrowserVisibility.waitUntilElementIsVisible(this.idField);
        return this.idField.getText();
    }
    /**
     * @return {?}
     */
    getDescription() {
        BrowserVisibility.waitUntilElementIsVisible(this.descriptionField);
        return this.descriptionField.getText();
    }
    /**
     * @return {?}
     */
    getDueDate() {
        BrowserVisibility.waitUntilElementIsVisible(this.dueDateField);
        return this.dueDateField.getText();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessHeaderCloudPage {
    constructor() {
        this.idField = element.all(by.css('span[data-automation-id*="id"] span')).first();
        this.nameField = element.all(by.css('span[data-automation-id*="name"] span')).first();
        this.statusField = element(by.css('span[data-automation-id*="status"] span'));
        this.initiatorField = element(by.css('span[data-automation-id*="initiator"] span'));
        this.startDateField = element.all(by.css('span[data-automation-id*="startDate"] span')).first();
        this.lastModifiedField = element.all(by.css('span[data-automation-id*="lastModified"] span')).first();
        this.parentIdField = element(by.css('span[data-automation-id*="parentId"] span'));
        this.businessKeyField = element.all(by.css('span[data-automation-id*="businessKey"] span')).first();
    }
    /**
     * @return {?}
     */
    getId() {
        BrowserVisibility.waitUntilElementIsVisible(this.idField);
        return this.idField.getText();
    }
    /**
     * @return {?}
     */
    getName() {
        BrowserVisibility.waitUntilElementIsVisible(this.nameField);
        return this.nameField.getText();
    }
    /**
     * @return {?}
     */
    getStatus() {
        BrowserVisibility.waitUntilElementIsVisible(this.statusField);
        return this.statusField.getText();
    }
    /**
     * @return {?}
     */
    getInitiator() {
        BrowserVisibility.waitUntilElementIsVisible(this.initiatorField);
        return this.initiatorField.getText();
    }
    /**
     * @return {?}
     */
    getStartDate() {
        BrowserVisibility.waitUntilElementIsVisible(this.startDateField);
        return this.startDateField.getText();
    }
    /**
     * @return {?}
     */
    getLastModified() {
        BrowserVisibility.waitUntilElementIsVisible(this.lastModifiedField);
        return this.lastModifiedField.getText();
    }
    /**
     * @return {?}
     */
    getParentId() {
        BrowserVisibility.waitUntilElementIsVisible(this.parentIdField);
        return this.parentIdField.getText();
    }
    /**
     * @return {?}
     */
    getBusinessKey() {
        BrowserVisibility.waitUntilElementIsVisible(this.businessKeyField);
        return this.businessKeyField.getText();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EditProcessFilterDialogPage {
    constructor() {
        this.componentElement = element(by.css('adf-cloud-process-filter-dialog-cloud'));
        this.title = element(by.id('adf-process-filter-dialog-title'));
        this.filterNameInput = element(by.id('adf-filter-name-id'));
        this.saveButtonLocator = by.id('adf-save-button-id');
        this.cancelButtonLocator = by.id('adf-cancel-button-id');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickOnSaveButton() {
        /** @type {?} */
        const saveButton = (/** @type {?} */ (this)).componentElement.element((/** @type {?} */ (this)).saveButtonLocator);
        BrowserVisibility.waitUntilElementIsVisible(saveButton);
        saveButton.click();
        BrowserVisibility.waitUntilElementIsNotVisible((/** @type {?} */ (this)).componentElement);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    checkSaveButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.componentElement.element(this.saveButtonLocator));
        return this.componentElement.element(this.saveButtonLocator).isEnabled();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickOnCancelButton() {
        /** @type {?} */
        const cancelButton = (/** @type {?} */ (this)).componentElement.element((/** @type {?} */ (this)).cancelButtonLocator);
        BrowserVisibility.waitUntilElementIsVisible(cancelButton);
        cancelButton.click();
        BrowserVisibility.waitUntilElementIsNotVisible((/** @type {?} */ (this)).componentElement);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    checkCancelButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.componentElement.element(this.cancelButtonLocator));
        return this.componentElement.element(this.cancelButtonLocator).isEnabled();
    }
    /**
     * @return {?}
     */
    getFilterName() {
        BrowserVisibility.waitUntilElementIsVisible(this.filterNameInput);
        return this.filterNameInput.getAttribute('value');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} filterName
     * @return {THIS}
     */
    setFilterName(filterName) {
        (/** @type {?} */ (this)).clearFilterName();
        (/** @type {?} */ (this)).filterNameInput.sendKeys(filterName);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clearFilterName() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).filterNameInput);
        (/** @type {?} */ (this)).filterNameInput.click();
        (/** @type {?} */ (this)).filterNameInput.getAttribute('value').then((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            for (let i = value.length; i >= 0; i--) {
                (/** @type {?} */ (this)).filterNameInput.sendKeys(protractor.Key.BACK_SPACE);
            }
        }));
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.title);
        return this.title.getText();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EditProcessFilterCloudComponentPage {
    constructor() {
        this.customiseFilter = element(by.id('adf-edit-process-filter-title-id'));
        this.selectedOption = element.all(by.css('mat-option[class*="mat-selected"]')).first();
        this.saveButton = element(by.css('button[data-automation-id="adf-filter-action-save"]'));
        this.saveAsButton = element(by.css('button[data-automation-id="adf-filter-action-saveAs"]'));
        this.deleteButton = element(by.css('button[data-automation-id="adf-filter-action-delete"]'));
        this.editProcessFilterDialogPage = new EditProcessFilterDialogPage();
    }
    /**
     * @return {?}
     */
    editProcessFilterDialog() {
        return this.editProcessFilterDialogPage;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickCustomiseFilterHeader() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).customiseFilter);
        (/** @type {?} */ (this)).customiseFilter.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkCustomiseFilterHeaderIsExpanded() {
        /** @type {?} */
        const expansionPanelExtended = element.all(by.css('mat-expansion-panel-header[class*="mat-expanded"]')).first();
        BrowserVisibility.waitUntilElementIsVisible(expansionPanelExtended);
        /** @type {?} */
        const content = element.all(by.css('div[class*="mat-expansion-panel-content "][style*="visible"]')).first();
        BrowserVisibility.waitUntilElementIsVisible(content);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setStatusFilterDropDown(option) {
        (/** @type {?} */ (this)).clickOnDropDownArrow('status');
        /** @type {?} */
        const statusElement = element.all(by.cssContainingText('mat-option span', option)).first();
        BrowserVisibility.waitUntilElementIsClickable(statusElement);
        BrowserVisibility.waitUntilElementIsVisible(statusElement);
        statusElement.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getStateFilterDropDownValue() {
        return element(by.css("mat-form-field[data-automation-id='status'] span")).getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setSortFilterDropDown(option) {
        (/** @type {?} */ (this)).clickOnDropDownArrow('sort');
        /** @type {?} */
        const sortElement = element.all(by.cssContainingText('mat-option span', option)).first();
        BrowserVisibility.waitUntilElementIsClickable(sortElement);
        BrowserVisibility.waitUntilElementIsVisible(sortElement);
        sortElement.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getSortFilterDropDownValue() {
        /** @type {?} */
        const sortLocator = element.all(by.css("mat-form-field[data-automation-id='sort'] span")).first();
        BrowserVisibility.waitUntilElementIsVisible(sortLocator);
        return sortLocator.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setOrderFilterDropDown(option) {
        (/** @type {?} */ (this)).clickOnDropDownArrow('order');
        /** @type {?} */
        const orderElement = element.all(by.cssContainingText('mat-option span', option)).first();
        BrowserVisibility.waitUntilElementIsClickable(orderElement);
        BrowserVisibility.waitUntilElementIsVisible(orderElement);
        orderElement.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getOrderFilterDropDownValue() {
        return element(by.css("mat-form-field[data-automation-id='order'] span")).getText();
    }
    /**
     * @param {?} option
     * @return {?}
     */
    clickOnDropDownArrow(option) {
        /** @type {?} */
        const dropDownArrow = element.all(by.css("mat-form-field[data-automation-id='" + option + "'] div[class='mat-select-arrow-wrapper']")).first();
        BrowserVisibility.waitUntilElementIsVisible(dropDownArrow);
        BrowserVisibility.waitUntilElementIsClickable(dropDownArrow);
        dropDownArrow.click();
        BrowserVisibility.waitUntilElementIsVisible(this.selectedOption);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setAppNameDropDown(option) {
        (/** @type {?} */ (this)).clickOnDropDownArrow('appName');
        /** @type {?} */
        const appNameElement = element.all(by.cssContainingText('mat-option span', option)).first();
        BrowserVisibility.waitUntilElementIsClickable(appNameElement);
        BrowserVisibility.waitUntilElementIsVisible(appNameElement);
        appNameElement.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    checkAppNamesAreUnique() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const appNameList = element.all(by.css('mat-option[data-automation-id="adf-cloud-edit-process-property-optionsappName"] span'));
            /** @type {?} */
            const appTextList = yield appNameList.getText();
            /** @type {?} */
            const uniqueArray = appTextList.filter((/**
             * @param {?} appName
             * @return {?}
             */
            (appName) => {
                /** @type {?} */
                const sameAppNameArray = appTextList.filter((/**
                 * @param {?} eachApp
                 * @return {?}
                 */
                (eachApp) => eachApp === appName));
                return sameAppNameArray.length === 1;
            }));
            return uniqueArray.length === appTextList.length;
        });
    }
    /**
     * @return {?}
     */
    getNumberOfAppNameOptions() {
        this.clickOnDropDownArrow('appName');
        /** @type {?} */
        const dropdownOptions = element.all(by.css('.mat-select-panel mat-option'));
        return dropdownOptions.count();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setProcessInstanceId(option) {
        return (/** @type {?} */ (this)).setProperty('processInstanceId', option);
    }
    /**
     * @return {?}
     */
    getProcessInstanceId() {
        return this.getProperty('processInstanceId');
    }
    /**
     * @param {?} property
     * @return {?}
     */
    getProperty(property) {
        /** @type {?} */
        const locator = element.all(by.css('input[data-automation-id="adf-cloud-edit-process-property-' + property + '"]')).first();
        BrowserVisibility.waitUntilElementIsVisible(locator);
        return locator.getAttribute('value');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} property
     * @param {?} option
     * @return {THIS}
     */
    setProperty(property, option) {
        /** @type {?} */
        const locator = element.all(by.css('input[data-automation-id="adf-cloud-edit-process-property-' + property + '"]')).first();
        BrowserVisibility.waitUntilElementIsVisible(locator);
        locator.clear();
        locator.sendKeys(option);
        locator.sendKeys(protractor.Key.ENTER);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkSaveButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).saveButton);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkSaveAsButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).saveAsButton);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkDeleteButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).deleteButton);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    checkSaveButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.saveButton);
        return this.saveButton.isEnabled();
    }
    /**
     * @return {?}
     */
    checkSaveAsButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.saveAsButton);
        return this.saveAsButton.isEnabled();
    }
    /**
     * @return {?}
     */
    checkDeleteButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.deleteButton);
        return this.deleteButton.isEnabled();
    }
    /**
     * @return {?}
     */
    clickSaveAsButton() {
        /** @type {?} */
        const disabledButton = element(by.css(("button[data-automation-id='adf-filter-action-saveAs'][disabled]")));
        BrowserVisibility.waitUntilElementIsClickable(this.saveAsButton);
        BrowserVisibility.waitUntilElementIsVisible(this.saveAsButton);
        BrowserVisibility.waitUntilElementIsNotVisible(disabledButton);
        this.saveAsButton.click();
        return this.editProcessFilterDialogPage;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickDeleteButton() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).deleteButton);
        (/** @type {?} */ (this)).deleteButton.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickSaveButton() {
        /** @type {?} */
        const disabledButton = element(by.css(("button[id='adf-save-as-id'][disabled]")));
        BrowserVisibility.waitUntilElementIsClickable((/** @type {?} */ (this)).saveButton);
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).saveButton);
        BrowserVisibility.waitUntilElementIsNotVisible(disabledButton);
        (/** @type {?} */ (this)).saveButton.click();
        return (/** @type {?} */ (this));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EditTaskFilterDialogPage {
    constructor() {
        this.componentElement = element(by.css('adf-cloud-task-filter-dialog'));
        this.title = element(by.id('adf-task-filter-dialog-title'));
        this.filterNameInput = element(by.id('adf-filter-name-id'));
        this.saveButtonLocator = by.id('adf-save-button-id');
        this.cancelButtonLocator = by.id('adf-cancel-button-id');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickOnSaveButton() {
        /** @type {?} */
        const saveButton = (/** @type {?} */ (this)).componentElement.element((/** @type {?} */ (this)).saveButtonLocator);
        BrowserVisibility.waitUntilElementIsVisible(saveButton);
        saveButton.click();
        BrowserVisibility.waitUntilElementIsNotVisible((/** @type {?} */ (this)).componentElement);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    checkSaveButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.componentElement.element(this.saveButtonLocator));
        return this.componentElement.element(this.saveButtonLocator).isEnabled();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickOnCancelButton() {
        /** @type {?} */
        const cancelButton = (/** @type {?} */ (this)).componentElement.element((/** @type {?} */ (this)).cancelButtonLocator);
        BrowserVisibility.waitUntilElementIsVisible(cancelButton);
        cancelButton.click();
        BrowserVisibility.waitUntilElementIsNotVisible((/** @type {?} */ (this)).componentElement);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    checkCancelButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.componentElement.element(this.cancelButtonLocator));
        return this.componentElement.element(this.cancelButtonLocator).isEnabled();
    }
    /**
     * @return {?}
     */
    getFilterName() {
        BrowserVisibility.waitUntilElementIsVisible(this.filterNameInput);
        return this.filterNameInput.getAttribute('value');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} filterName
     * @return {THIS}
     */
    setFilterName(filterName) {
        (/** @type {?} */ (this)).clearFilterName();
        (/** @type {?} */ (this)).filterNameInput.sendKeys(filterName);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clearFilterName() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).filterNameInput);
        (/** @type {?} */ (this)).filterNameInput.click();
        (/** @type {?} */ (this)).filterNameInput.getAttribute('value').then((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            for (let i = value.length; i >= 0; i--) {
                (/** @type {?} */ (this)).filterNameInput.sendKeys(protractor.Key.BACK_SPACE);
            }
        }));
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getTitle() {
        BrowserVisibility.waitUntilElementIsVisible(this.title);
        return this.title.getText();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EditTaskFilterCloudComponentPage {
    constructor() {
        this.customiseFilter = element(by.id('adf-edit-task-filter-title-id'));
        this.selectedOption = element.all(by.css('mat-option[class*="mat-selected"]')).first();
        this.assignee = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-assignee"]'));
        this.priority = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-priority"]'));
        this.taskName = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-taskName"]'));
        this.id = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-taskId"]'));
        this.processDefinitionId = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-processDefinitionId"]'));
        this.processInstanceId = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-processInstanceId"]'));
        this.lastModifiedFrom = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-lastModifiedFrom"]'));
        this.lastModifiedTo = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-lastModifiedTo"]'));
        this.parentTaskId = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-parentTaskId"]'));
        this.owner = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-owner"]'));
        this.saveButton = element(by.css('[data-automation-id="adf-filter-action-save"]'));
        this.saveAsButton = element(by.css('[data-automation-id="adf-filter-action-saveAs"]'));
        this.deleteButton = element(by.css('[data-automation-id="adf-filter-action-delete"]'));
        this.editTaskFilterDialogPage = new EditTaskFilterDialogPage();
    }
    /**
     * @return {?}
     */
    editTaskFilterDialog() {
        return this.editTaskFilterDialogPage;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickCustomiseFilterHeader() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).customiseFilter);
        (/** @type {?} */ (this)).customiseFilter.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setStatusFilterDropDown(option) {
        (/** @type {?} */ (this)).clickOnDropDownArrow('status');
        /** @type {?} */
        const statusElement = element.all(by.cssContainingText('mat-option span', option)).first();
        BrowserVisibility.waitUntilElementIsVisible(statusElement);
        BrowserVisibility.waitUntilElementIsClickable(statusElement);
        statusElement.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getStatusFilterDropDownValue() {
        return element.all(by.css("mat-select[data-automation-id='adf-cloud-edit-task-property-status'] span")).first().getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setSortFilterDropDown(option) {
        (/** @type {?} */ (this)).clickOnDropDownArrow('sort');
        /** @type {?} */
        const sortElement = element.all(by.cssContainingText('mat-option span', option)).first();
        BrowserVisibility.waitUntilElementIsClickable(sortElement);
        BrowserVisibility.waitUntilElementIsVisible(sortElement);
        sortElement.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getSortFilterDropDownValue() {
        /** @type {?} */
        const elementSort = element.all(by.css("mat-select[data-automation-id='adf-cloud-edit-task-property-sort'] span")).first();
        BrowserVisibility.waitUntilElementIsVisible(elementSort);
        return elementSort.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setOrderFilterDropDown(option) {
        (/** @type {?} */ (this)).clickOnDropDownArrow('order');
        /** @type {?} */
        const orderElement = element.all(by.cssContainingText('mat-option span', option)).first();
        BrowserVisibility.waitUntilElementIsClickable(orderElement);
        BrowserVisibility.waitUntilElementIsVisible(orderElement);
        orderElement.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getOrderFilterDropDownValue() {
        return element.all(by.css("mat-select[data-automation-id='adf-cloud-edit-task-property-order'] span")).first().getText();
    }
    /**
     * @param {?} option
     * @return {?}
     */
    clickOnDropDownArrow(option) {
        /** @type {?} */
        const dropDownArrow = element.all(by.css("mat-form-field[data-automation-id='" + option + "'] div[class*='arrow']")).first();
        BrowserVisibility.waitUntilElementIsVisible(dropDownArrow);
        dropDownArrow.click();
        BrowserVisibility.waitUntilElementIsVisible(this.selectedOption);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setAssignee(option) {
        return (/** @type {?} */ (this)).setProperty('assignee', option);
    }
    /**
     * @return {?}
     */
    getAssignee() {
        return this.assignee.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setPriority(option) {
        return (/** @type {?} */ (this)).setProperty('priority', option);
    }
    /**
     * @return {?}
     */
    getPriority() {
        return this.priority.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setParentTaskId(option) {
        return (/** @type {?} */ (this)).setProperty('parentTaskId', option);
    }
    /**
     * @return {?}
     */
    getParentTaskId() {
        return this.parentTaskId.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setOwner(option) {
        return (/** @type {?} */ (this)).setProperty('owner', option);
    }
    /**
     * @return {?}
     */
    getOwner() {
        return this.owner.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setLastModifiedFrom(option) {
        (/** @type {?} */ (this)).clearField((/** @type {?} */ (this)).lastModifiedFrom);
        return (/** @type {?} */ (this)).setProperty('lastModifiedFrom', option);
    }
    /**
     * @return {?}
     */
    getLastModifiedFrom() {
        return this.lastModifiedFrom.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setLastModifiedTo(option) {
        (/** @type {?} */ (this)).clearField((/** @type {?} */ (this)).lastModifiedTo);
        return (/** @type {?} */ (this)).setProperty('lastModifiedTo', option);
    }
    /**
     * @return {?}
     */
    getLastModifiedTo() {
        return this.lastModifiedTo.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkSaveButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).saveButton);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkSaveAsButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).saveAsButton);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkDeleteButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).deleteButton);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    checkSaveButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.saveButton);
        return this.saveButton.isEnabled();
    }
    /**
     * @return {?}
     */
    checkSaveAsButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.saveButton);
        return this.saveAsButton.isEnabled();
    }
    /**
     * @return {?}
     */
    checkDeleteButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsVisible(this.saveButton);
        return this.deleteButton.isEnabled();
    }
    /**
     * @return {?}
     */
    clickSaveAsButton() {
        /** @type {?} */
        const disabledButton = element(by.css(("button[data-automation-id='adf-filter-action-saveAs'][disabled]")));
        BrowserVisibility.waitUntilElementIsClickable(this.saveAsButton);
        BrowserVisibility.waitUntilElementIsVisible(this.saveAsButton);
        BrowserVisibility.waitUntilElementIsNotVisible(disabledButton);
        this.saveAsButton.click();
        return this.editTaskFilterDialogPage;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickDeleteButton() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).deleteButton);
        (/** @type {?} */ (this)).deleteButton.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickSaveButton() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).saveButton);
        (/** @type {?} */ (this)).saveButton.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clearAssignee() {
        (/** @type {?} */ (this)).clearField((/** @type {?} */ (this)).assignee);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} locator
     * @return {?}
     */
    clearField(locator) {
        BrowserVisibility.waitUntilElementIsVisible(locator);
        locator.getAttribute('value').then((/**
         * @param {?} result
         * @return {?}
         */
        (result) => {
            for (let i = result.length; i >= 0; i--) {
                locator.sendKeys(protractor.Key.BACK_SPACE);
            }
        }));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setAppNameDropDown(option) {
        (/** @type {?} */ (this)).clickOnDropDownArrow('appName');
        /** @type {?} */
        const appNameElement = element.all(by.cssContainingText('mat-option span', option)).first();
        BrowserVisibility.waitUntilElementIsClickable(appNameElement);
        BrowserVisibility.waitUntilElementIsVisible(appNameElement);
        appNameElement.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getAppNameDropDownValue() {
        /** @type {?} */
        const locator = element.all(by.css("mat-select[data-automation-id='adf-cloud-edit-task-property-appName'] span")).first();
        BrowserVisibility.waitUntilElementIsVisible(locator);
        return locator.getText();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setId(option) {
        return (/** @type {?} */ (this)).setProperty('taskId', option);
    }
    /**
     * @return {?}
     */
    getId() {
        return this.id.getAttribute('value');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setTaskName(option) {
        return (/** @type {?} */ (this)).setProperty('taskName', option);
    }
    /**
     * @return {?}
     */
    getTaskName() {
        return this.taskName.getAttribute('value');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setProcessDefinitionId(option) {
        return (/** @type {?} */ (this)).setProperty('processDefinitionId', option);
    }
    /**
     * @return {?}
     */
    getProcessDefinitionId() {
        return this.processDefinitionId.getAttribute('value');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} option
     * @return {THIS}
     */
    setProcessInstanceId(option) {
        return (/** @type {?} */ (this)).setProperty('processInstanceId', option);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} property
     * @param {?} option
     * @return {THIS}
     */
    setProperty(property, option) {
        /** @type {?} */
        const locator = element(by.css('input[data-automation-id="adf-cloud-edit-task-property-' + property + '"]'));
        BrowserVisibility.waitUntilElementIsVisible(locator);
        locator.clear();
        locator.sendKeys(option);
        locator.sendKeys(protractor.Key.ENTER);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getProcessInstanceId() {
        return this.processInstanceId.getAttribute('value');
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GroupCloudComponentPage {
    constructor() {
        this.groupCloudSearch = element(by.css('input[data-automation-id="adf-cloud-group-search-input"]'));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    searchGroups(name) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).groupCloudSearch);
        browser.sleep(1000);
        (/** @type {?} */ (this)).groupCloudSearch.clear().then((/**
         * @return {?}
         */
        () => {
            for (let i = 0; i < name.length; i++) {
                (/** @type {?} */ (this)).groupCloudSearch.sendKeys(name[i]);
            }
            (/** @type {?} */ (this)).groupCloudSearch.sendKeys(protractor.Key.BACK_SPACE);
            (/** @type {?} */ (this)).groupCloudSearch.sendKeys(name[name.length - 1]);
        }));
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    searchGroupsToExisting(name) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).groupCloudSearch);
        for (let i = 0; i < name.length; i++) {
            (/** @type {?} */ (this)).groupCloudSearch.sendKeys(name[i]);
        }
        (/** @type {?} */ (this)).groupCloudSearch.sendKeys(protractor.Key.BACK_SPACE);
        (/** @type {?} */ (this)).groupCloudSearch.sendKeys(name[name.length - 1]);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getGroupsFieldContent() {
        BrowserVisibility.waitUntilElementIsVisible(this.groupCloudSearch);
        return this.groupCloudSearch.getAttribute('value');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    selectGroupFromList(name) {
        /** @type {?} */
        const groupRow = element.all(by.cssContainingText('mat-option span', name)).first();
        BrowserVisibility.waitUntilElementIsVisible(groupRow);
        browser.sleep(1000);
        groupRow.click();
        BrowserVisibility.waitUntilElementIsNotVisible(groupRow);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    checkGroupIsDisplayed(name) {
        /** @type {?} */
        const groupRow = element.all(by.cssContainingText('mat-option span', name)).first();
        BrowserVisibility.waitUntilElementIsVisible(groupRow);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    checkGroupIsNotDisplayed(name) {
        /** @type {?} */
        const groupRow = element.all(by.cssContainingText('mat-option span', name)).first();
        BrowserVisibility.waitUntilElementIsNotVisible(groupRow);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} group
     * @return {THIS}
     */
    checkSelectedGroup(group) {
        BrowserVisibility.waitUntilElementIsVisible(element(by.cssContainingText('mat-chip[data-automation-id*="adf-cloud-group-chip-"]', group)));
        return (/** @type {?} */ (this));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeopleCloudComponentPage {
    constructor() {
        this.peopleCloudSearch = element(by.css('input[data-automation-id="adf-people-cloud-search-input"]'));
        this.assigneeField = element(by.css('input[data-automation-id="adf-people-cloud-search-input"]'));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    searchAssigneeAndSelect(name) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).peopleCloudSearch);
        (/** @type {?} */ (this)).peopleCloudSearch.clear();
        (/** @type {?} */ (this)).peopleCloudSearch.sendKeys(name);
        (/** @type {?} */ (this)).selectAssigneeFromList(name);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    searchAssignee(name) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).peopleCloudSearch);
        BrowserVisibility.waitUntilElementIsClickable((/** @type {?} */ (this)).peopleCloudSearch);
        browser.sleep(1000);
        (/** @type {?} */ (this)).peopleCloudSearch.clear().then((/**
         * @return {?}
         */
        () => {
            for (let i = 0; i < name.length; i++) {
                (/** @type {?} */ (this)).peopleCloudSearch.sendKeys(name[i]);
            }
            (/** @type {?} */ (this)).peopleCloudSearch.sendKeys(protractor.Key.BACK_SPACE);
            (/** @type {?} */ (this)).peopleCloudSearch.sendKeys(name[name.length - 1]);
        }));
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    searchAssigneeToExisting(name) {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).peopleCloudSearch);
        for (let i = 0; i < name.length; i++) {
            (/** @type {?} */ (this)).peopleCloudSearch.sendKeys(name[i]);
        }
        (/** @type {?} */ (this)).peopleCloudSearch.sendKeys(protractor.Key.BACK_SPACE);
        (/** @type {?} */ (this)).peopleCloudSearch.sendKeys(name[name.length - 1]);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    selectAssigneeFromList(name) {
        /** @type {?} */
        const assigneeRow = element(by.cssContainingText('mat-option span.adf-people-label-name', name));
        BrowserVisibility.waitUntilElementIsVisible(assigneeRow);
        browser.sleep(1000);
        assigneeRow.click();
        BrowserVisibility.waitUntilElementIsNotVisible(assigneeRow);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getAssignee() {
        BrowserVisibility.waitUntilElementIsVisible(this.peopleCloudSearch);
        return this.peopleCloudSearch.getAttribute('value');
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    checkUserIsDisplayed(name) {
        /** @type {?} */
        const assigneeRow = element(by.cssContainingText('mat-option span.adf-people-label-name', name));
        BrowserVisibility.waitUntilElementIsVisible(assigneeRow);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    checkUserIsNotDisplayed(name) {
        /** @type {?} */
        const assigneeRow = element(by.cssContainingText('mat-option span.adf-people-label-name', name));
        BrowserVisibility.waitUntilElementIsNotVisible(assigneeRow);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} person
     * @return {THIS}
     */
    checkSelectedPeople(person) {
        BrowserVisibility.waitUntilElementIsVisible(element(by.cssContainingText('mat-chip-list mat-chip', person)));
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getAssigneeFieldContent() {
        BrowserVisibility.waitUntilElementIsVisible(this.assigneeField);
        browser.sleep(1000);
        return this.assigneeField.getAttribute('value');
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessFiltersCloudComponentPage {
    /**
     * @param {?} filter
     */
    constructor(filter) {
        this.filterIcon = by.xpath("ancestor::div[@class='mat-list-item-content']/mat-icon");
        this.filter = filter;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkProcessFilterIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).filter);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getProcessFilterIcon() {
        BrowserVisibility.waitUntilElementIsVisible(this.filter);
        /** @type {?} */
        const icon = this.filter.element(this.filterIcon);
        BrowserVisibility.waitUntilElementIsVisible(icon);
        return icon.getText();
    }
    /**
     * @return {?}
     */
    checkProcessFilterHasNoIcon() {
        BrowserVisibility.waitUntilElementIsVisible(this.filter);
        BrowserVisibility.waitUntilElementIsNotOnPage(this.filter.element(this.filterIcon));
    }
    /**
     * @return {?}
     */
    clickProcessFilter() {
        BrowserVisibility.waitUntilElementIsVisible(this.filter);
        BrowserVisibility.waitUntilElementIsClickable(this.filter);
        return this.filter.click();
    }
    /**
     * @return {?}
     */
    checkProcessFilterNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotVisible(this.filter);
        return this.filter;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessListCloudComponentPage {
    constructor() {
        this.columns = {
            id: 'Id',
            name: 'Name'
        };
        this.processList = element(by.css('adf-cloud-process-list'));
        this.noProcessFound = element.all(by.css("div[class='adf-empty-content__title']")).first();
        this.dataTable = new DataTableComponentPage(this.processList);
    }
    /**
     * @return {?}
     */
    getDataTable() {
        return this.dataTable;
    }
    /**
     * @param {?} processName
     * @return {?}
     */
    selectRow(processName) {
        return this.dataTable.selectRow(this.columns.name, processName);
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    selectRowById(processId) {
        return this.dataTable.selectRow(this.columns.id, processId);
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    checkRowIsSelectedById(processId) {
        return this.dataTable.checkRowIsSelected(this.columns.id, processId);
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    checkRowIsNotSelectedById(processId) {
        return this.dataTable.checkRowIsNotSelected(this.columns.id, processId);
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    checkRowIsCheckedById(processId) {
        return this.dataTable.checkRowIsChecked(this.columns.id, processId);
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    checkRowIsNotCheckedById(processId) {
        return this.dataTable.checkRowIsNotChecked(this.columns.id, processId);
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    checkCheckboxById(processId) {
        return this.dataTable.clickCheckbox(this.columns.id, processId);
    }
    /**
     * @param {?} processName
     * @return {?}
     */
    checkContentIsDisplayedByName(processName) {
        return this.dataTable.checkContentIsDisplayed(this.columns.name, processName);
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    checkContentIsDisplayedById(processId) {
        return this.dataTable.checkContentIsDisplayed(this.columns.id, processId);
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    checkContentIsNotDisplayedById(processId) {
        return this.dataTable.checkContentIsNotDisplayed(this.columns.id, processId);
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    selectRowWithKeyboard(processId) {
        return this.dataTable.selectRowWithKeyboard(this.columns.id, processId);
    }
    /**
     * @return {?}
     */
    getAllRowsNameColumn() {
        return this.dataTable.getAllRowsColumnValues(this.columns.name);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkProcessListIsLoaded() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).processList);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getNoProcessFoundMessage() {
        BrowserVisibility.waitUntilElementIsVisible(this.noProcessFound);
        return this.noProcessFound.getText();
    }
    /**
     * @param {?} column
     * @return {?}
     */
    getAllRowsByColumn(column) {
        return this.dataTable.getAllRowsColumnValues(column);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskFiltersCloudComponentPage {
    /**
     * @param {?} filter
     */
    constructor(filter) {
        this.taskIcon = by.xpath("ancestor::div[@class='mat-list-item-content']/mat-icon");
        this.filter = filter;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkTaskFilterIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).filter);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getTaskFilterIcon() {
        BrowserVisibility.waitUntilElementIsVisible(this.filter);
        /** @type {?} */
        const icon = this.filter.element(this.taskIcon);
        BrowserVisibility.waitUntilElementIsVisible(icon);
        return icon.getText();
    }
    /**
     * @return {?}
     */
    checkTaskFilterHasNoIcon() {
        BrowserVisibility.waitUntilElementIsVisible(this.filter);
        BrowserVisibility.waitUntilElementIsNotOnPage(this.filter.element(this.taskIcon));
    }
    /**
     * @return {?}
     */
    clickTaskFilter() {
        BrowserVisibility.waitUntilElementIsVisible(this.filter);
        return this.filter.click();
    }
    /**
     * @return {?}
     */
    checkTaskFilterNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotVisible(this.filter);
        return this.filter;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const column = {
    id: 'Id',
    name: 'Name',
    processInstanceId: 'ProcessInstanceId',
    processDefinitionId: 'ProcessDefinitionId',
    assignee: 'Assignee',
    parentTaskId: 'ParentTaskId',
    priority: 'Priority',
    standAlone: 'StandAlone',
    owner: 'Owner'
};
class TaskListCloudComponentPage {
    constructor() {
        this.taskList = element(by.css('adf-cloud-task-list'));
        this.noTasksFound = element.all(by.css("div[class='adf-empty-content__title']")).first();
        this.dataTable = new DataTableComponentPage(this.taskList);
    }
    /**
     * @return {?}
     */
    getDataTable() {
        return this.dataTable;
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    clickCheckbox(taskName) {
        return this.dataTable.clickCheckbox(column.name, taskName);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    checkRowIsNotChecked(taskName) {
        return this.dataTable.checkRowIsNotChecked(column.name, taskName);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    checkRowIsChecked(taskName) {
        return this.dataTable.checkRowIsChecked(column.name, taskName);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    getRowsWithSameName(taskName) {
        return this.dataTable.getRowsWithSameColumnValues(column.name, taskName);
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getRowsWithSameId(taskId) {
        return this.dataTable.getRowsWithSameColumnValues('Id', taskId);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    checkRowIsSelected(taskName) {
        return this.dataTable.checkRowIsSelected(column.name, taskName);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    checkRowIsNotSelected(taskName) {
        return this.dataTable.checkRowIsNotSelected(column.name, taskName);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    selectRowWithKeyboard(taskName) {
        return this.dataTable.selectRowWithKeyboard(column.name, taskName);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    selectRow(taskName) {
        return this.dataTable.selectRow(column.name, taskName);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    getRow(taskName) {
        return this.dataTable.getCellElementByValue(column.name, taskName);
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    checkContentIsDisplayedById(taskId) {
        return this.dataTable.checkContentIsDisplayed(column.id, taskId);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    checkContentIsDisplayedByProcessInstanceId(taskName) {
        return this.dataTable.checkContentIsDisplayed(column.processInstanceId, taskName);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    checkContentIsDisplayedByName(taskName) {
        return this.dataTable.checkContentIsDisplayed(column.name, taskName);
    }
    /**
     * @param {?} taskName
     * @return {?}
     */
    checkContentIsNotDisplayedByName(taskName) {
        return this.dataTable.checkContentIsNotDisplayed(column.name, taskName);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkTaskListIsLoaded() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).taskList);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getNoTasksFoundMessage() {
        BrowserVisibility.waitUntilElementIsVisible(this.noTasksFound);
        return this.noTasksFound.getText();
    }
    /**
     * @return {?}
     */
    getAllRowsNameColumn() {
        return this.dataTable.getAllRowsColumnValues(column.name);
    }
    /**
     * @return {?}
     */
    getAllRowsByIdColumn() {
        return this.dataTable.getAllRowsColumnValues(column.id);
    }
    /**
     * @return {?}
     */
    getAllRowsByProcessDefIdColumn() {
        return this.dataTable.getAllRowsColumnValues(column.processDefinitionId);
    }
    /**
     * @return {?}
     */
    getAllRowsByProcessInstanceIdColumn() {
        return this.dataTable.getAllRowsColumnValues(column.processInstanceId);
    }
    /**
     * @return {?}
     */
    getAllRowsByAssigneeColumn() {
        return this.dataTable.getAllRowsColumnValues(column.assignee);
    }
    /**
     * @return {?}
     */
    getAllRowsByParentTaskIdColumn() {
        return this.dataTable.getAllRowsColumnValues(column.parentTaskId);
    }
    /**
     * @return {?}
     */
    getAllRowsByPriorityColumn() {
        return this.dataTable.getAllRowsColumnValues(column.priority);
    }
    /**
     * @return {?}
     */
    getAllRowsByStandAloneColumn() {
        return this.dataTable.getAllRowsColumnValues(column.standAlone);
    }
    /**
     * @return {?}
     */
    getAllRowsByOwnerColumn() {
        return this.dataTable.getAllRowsColumnValues(column.owner);
    }
    /**
     * @param {?} rowName
     * @return {?}
     */
    getIdCellValue(rowName) {
        /** @type {?} */
        const locator = new DataTableComponentPage().getCellByRowContentAndColumn(column.name, rowName, column.id);
        BrowserVisibility.waitUntilElementIsVisible(locator);
        return locator.getText();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StartProcessCloudPage {
    constructor() {
        this.defaultProcessName = element(by.css('input[id="processName"]'));
        this.processNameInput = element(by.id('processName'));
        this.selectProcessDropdownArrow = element(by.css('button[id="adf-select-process-dropdown"]'));
        this.cancelProcessButton = element(by.id('cancel_process'));
        this.formStartProcessButton = element(by.css('button[data-automation-id="adf-form-start process"]'));
        this.startProcessButton = element(by.css('button[data-automation-id="btn-start"]'));
        this.noProcess = element(by.id('no-process-message'));
        this.processDefinition = element(by.css('input[id="processDefinitionName"]'));
        this.processDefinitionOptionsPanel = element(by.css('div[class*="processDefinitionOptions"]'));
    }
    /**
     * @return {?}
     */
    checkNoProcessMessage() {
        BrowserVisibility.waitUntilElementIsVisible(this.noProcess);
    }
    /**
     * @return {?}
     */
    pressDownArrowAndEnter() {
        this.processDefinition.sendKeys(protractor.Key.ARROW_DOWN);
        return browser.actions().sendKeys(protractor.Key.ENTER).perform();
    }
    /**
     * @return {?}
     */
    checkNoProcessDefinitionOptionIsDisplayed() {
        BrowserVisibility.waitUntilElementIsNotOnPage(this.processDefinitionOptionsPanel);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    enterProcessName(name) {
        BrowserVisibility.waitUntilElementIsVisible(this.processNameInput);
        this.clearProcessName();
        this.processNameInput.sendKeys(name);
    }
    /**
     * @return {?}
     */
    clearProcessName() {
        BrowserVisibility.waitUntilElementIsVisible(this.processNameInput);
        this.processNameInput.clear();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    selectFromProcessDropdown(name) {
        (/** @type {?} */ (this)).clickProcessDropdownArrow();
        return (/** @type {?} */ (this)).selectOption(name);
    }
    /**
     * @return {?}
     */
    clickProcessDropdownArrow() {
        BrowserVisibility.waitUntilElementIsVisible(this.selectProcessDropdownArrow);
        BrowserVisibility.waitUntilElementIsClickable(this.selectProcessDropdownArrow);
        this.selectProcessDropdownArrow.click();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    checkOptionIsDisplayed(name) {
        /** @type {?} */
        const selectProcessDropdown = element(by.cssContainingText('.mat-option-text', name));
        BrowserVisibility.waitUntilElementIsVisible(selectProcessDropdown);
        BrowserVisibility.waitUntilElementIsClickable(selectProcessDropdown);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @return {THIS}
     */
    selectOption(name) {
        /** @type {?} */
        const selectProcessDropdown = element(by.cssContainingText('.mat-option-text', name));
        BrowserVisibility.waitUntilElementIsVisible(selectProcessDropdown);
        BrowserVisibility.waitUntilElementIsClickable(selectProcessDropdown);
        selectProcessDropdown.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    clickCancelProcessButton() {
        BrowserVisibility.waitUntilElementIsVisible(this.cancelProcessButton);
        this.cancelProcessButton.click();
    }
    /**
     * @return {?}
     */
    checkStartProcessButtonIsEnabled() {
        BrowserVisibility.waitUntilElementIsClickable(this.startProcessButton);
        expect(this.startProcessButton.isEnabled()).toBe(true);
    }
    /**
     * @return {?}
     */
    checkStartProcessButtonIsDisabled() {
        expect(this.startProcessButton.isEnabled()).toBe(false);
    }
    /**
     * @return {?}
     */
    clickStartProcessButton() {
        BrowserVisibility.waitUntilElementIsClickable(this.startProcessButton);
        return this.startProcessButton.click();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} error
     * @param {?=} elementRef
     * @return {THIS}
     */
    checkValidationErrorIsDisplayed(error, elementRef = 'mat-error') {
        /** @type {?} */
        const errorElement = element(by.cssContainingText(elementRef, error));
        BrowserVisibility.waitUntilElementIsVisible(errorElement);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} locator
     * @return {THIS}
     */
    blur(locator) {
        locator.click();
        locator.sendKeys(Key.TAB);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} locator
     * @return {?}
     */
    clearField(locator) {
        BrowserVisibility.waitUntilElementIsVisible(locator);
        locator.getAttribute('value').then((/**
         * @param {?} result
         * @return {?}
         */
        (result) => {
            for (let i = result.length; i >= 0; i--) {
                locator.sendKeys(protractor.Key.BACK_SPACE);
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskFormCloudComponent {
    constructor() {
        this.cancelButton = element(by.css("button[id='adf-cloud-cancel-task']"));
        this.completeButton = element(by.css('button[adf-cloud-complete-task]'));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkCompleteButtonIsDisplayed() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).completeButton);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    checkCompleteButtonIsNotDisplayed() {
        BrowserVisibility.waitUntilElementIsNotVisible((/** @type {?} */ (this)).completeButton);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickCompleteButton() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).completeButton);
        (/** @type {?} */ (this)).completeButton.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    clickCancelButton() {
        BrowserVisibility.waitUntilElementIsVisible((/** @type {?} */ (this)).cancelButton);
        (/** @type {?} */ (this)).cancelButton.click();
        return (/** @type {?} */ (this));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TestingAlfrescoApiService extends AlfrescoApiService {
    /**
     * @param {?} appConfig
     */
    constructor(appConfig) {
        super(null);
        this.appConfig = appConfig;
        this.config = {};
        /** @type {?} */
        const oauth = Object.assign({}, this.appConfig.get(AppConfigValues.OAUTHCONFIG, null));
        this.config = new AlfrescoApiConfig({
            provider: this.appConfig.get(AppConfigValues.PROVIDERS),
            hostEcm: this.appConfig.get(AppConfigValues.ECMHOST),
            hostBpm: this.appConfig.get(AppConfigValues.BPMHOST),
            authType: this.appConfig.get(AppConfigValues.AUTHTYPE, 'BASIC'),
            contextRootBpm: this.appConfig.get(AppConfigValues.CONTEXTROOTBPM),
            contextRoot: this.appConfig.get(AppConfigValues.CONTEXTROOTECM),
            disableCsrf: this.appConfig.get(AppConfigValues.DISABLECSRF),
            withCredentials: this.appConfig.get(AppConfigValues.AUTH_WITH_CREDENTIALS, false),
            oauth2: oauth
        });
    }
    /**
     * @return {?}
     */
    getInstance() {
        if (this.alfrescoApi) {
            this.alfrescoApi.configureJsApi(this.config);
        }
        else {
            this.alfrescoApi = new AlfrescoApiCompatibility(this.config);
        }
        return this.alfrescoApi;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TestingAppConfigService extends AppConfigService {
    /**
     * @param {?=} config
     */
    constructor(config) {
        super(null);
        this.config = {};
        this.config = config;
    }
    /**
     * @return {?}
     */
    getLocationHostname() {
        return '';
    }
    /**
     * @param {?=} prefix
     * @return {?}
     */
    getLocationPort(prefix = '') {
        return '';
    }
    /**
     * @return {?}
     */
    getLocationProtocol() {
        return '';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessDefinitionsService {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
    }
    /**
     * @param {?} appName
     * @return {?}
     */
    getProcessDefinitions(appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/process-definitions';
            /** @type {?} */
            const method = 'GET';
            /** @type {?} */
            const queryParams = {};
            try {
                /** @type {?} */
                const data = yield this.api.performBpmOperation(path, method, queryParams, {});
                return data;
            }
            catch (error) {
                if (error.status === 404) {
                    // tslint:disable-next-line:no-console
                    console.log(`${appName} not present`);
                }
                else if (error.status === 403) {
                    // tslint:disable-next-line:no-console
                    console.log(`Access to the requested resource has been denied ${appName}`);
                }
            }
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstancesService {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
    }
    /**
     * @param {?} processDefKey
     * @param {?} appName
     * @param {?=} options
     * @return {?}
     */
    createProcessInstance(processDefKey, appName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/process-instances';
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = Object.assign({ 'processDefinitionKey': processDefKey, 'payloadType': 'StartProcessPayload' }, options);
            return yield this.api.performBpmOperation(path, method, queryParams, postBody);
        });
    }
    /**
     * @param {?} processInstanceId
     * @param {?} appName
     * @return {?}
     */
    suspendProcessInstance(processInstanceId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/process-instances/' + processInstanceId + '/suspend';
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            return yield this.api.performBpmOperation(path, method, queryParams, postBody);
        });
    }
    /**
     * @param {?} processInstanceId
     * @param {?} appName
     * @return {?}
     */
    deleteProcessInstance(processInstanceId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/process-instances/' + processInstanceId;
            /** @type {?} */
            const method = 'DELETE';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            return yield this.api.performBpmOperation(path, method, queryParams, postBody);
        });
    }
    /**
     * @param {?} processInstanceId
     * @param {?} appName
     * @return {?}
     */
    completeProcessInstance(processInstanceId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = '/' + appName + '/rb/v1/process-instances/' + processInstanceId + '/complete';
            /** @type {?} */
            const method = 'POST';
            /** @type {?} */
            const queryParams = {};
            /** @type {?} */
            const postBody = {};
            return yield this.api.performBpmOperation(path, method, queryParams, postBody);
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppListCloudPage {
    constructor() {
        this.apsAppsContainer = element(by.css('adf-cloud-app-list'));
    }
    /**
     * @return {?}
     */
    checkApsContainer() {
        BrowserVisibility.waitUntilElementIsVisible(this.apsAppsContainer);
    }
    /**
     * @param {?} applicationName
     * @return {?}
     */
    goToApp(applicationName) {
        /** @type {?} */
        const app = element(by.css('mat-card[title="' + applicationName + '"]'));
        BrowserVisibility.waitUntilElementIsVisible(app);
        app.click();
    }
    /**
     * @param {?} applicationName
     * @return {?}
     */
    checkAppIsNotDisplayed(applicationName) {
        /** @type {?} */
        const app = element(by.css('mat-card[title="' + applicationName + '"]'));
        return BrowserVisibility.waitUntilElementIsNotOnPage(app);
    }
    /**
     * @param {?} applicationName
     * @return {?}
     */
    checkAppIsDisplayed(applicationName) {
        /** @type {?} */
        const app = element(by.css('mat-card[title="' + applicationName + '"]'));
        return BrowserVisibility.waitUntilElementIsVisible(app);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TestingModule {
}
TestingModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [],
                exports: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TestingService {
    constructor() { }
}
TestingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TestingService.ctorParameters = () => [];
/** @nocollapse */ TestingService.ngInjectableDef = defineInjectable({ factory: function TestingService_Factory() { return new TestingService(); }, token: TestingService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IdentityService, GroupIdentityService, RolesService, TasksService, QueryService, ApiService, HeaderPage, UserInfoPage, LoginPage, SettingsPage, FormControllersPage, LoginSSOPage, DataTableComponentPage, PaginationPage, ErrorPage, UserModel, BrowserVisibility, StringUtil, byCss, LocalStorageUtil, TabsPage, DocumentListPage, ExampleAction, ContentNodeSelectorDialogPage, FormFieldsPage, StartTasksCloudPage, TaskHeaderCloudPage, ProcessHeaderCloudPage, EditProcessFilterCloudComponentPage, EditTaskFilterCloudComponentPage, GroupCloudComponentPage, PeopleCloudComponentPage, ProcessFiltersCloudComponentPage, ProcessListCloudComponentPage, TaskFiltersCloudComponentPage, TaskListCloudComponentPage, StartProcessCloudPage, TaskFormCloudComponent, EditProcessFilterDialogPage, EditTaskFilterDialogPage, TestingAlfrescoApiService, TestingAppConfigService, ProcessDefinitionsService, ProcessInstancesService, AppListCloudPage, TestingModule, TestingService };

//# sourceMappingURL=adf-testing.js.map