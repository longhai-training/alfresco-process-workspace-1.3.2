/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Directive, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import { Polyline } from './polyline';
import { RaphaelBase } from './raphael-base';
import { RaphaelService } from './raphael.service';
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
export class RaphaelFlowArrowDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.ARROW_WIDTH = 4;
        this.SEQUENCE_FLOW_STROKE = 1.5;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.flow);
    }
    /**
     * @param {?} flow
     * @return {?}
     */
    draw(flow) {
        /** @type {?} */
        const line = this.drawLine(flow);
        this.drawArrow(line);
    }
    /**
     * @param {?} flow
     * @return {?}
     */
    drawLine(flow) {
        /** @type {?} */
        const polyline = new Polyline(flow.id, flow.waypoints, this.SEQUENCE_FLOW_STROKE, this.paper);
        polyline.element = this.paper.path(polyline.path);
        polyline.element.attr({ 'stroke-width': this.SEQUENCE_FLOW_STROKE });
        polyline.element.attr({ 'stroke': '#585858' });
        polyline.element.node.id = this.flow.id;
        /** @type {?} */
        const lastLineIndex = polyline.getLinesCount() - 1;
        /** @type {?} */
        const line = polyline.getLine(lastLineIndex);
        return line;
    }
    /**
     * @param {?} line
     * @return {?}
     */
    drawArrow(line) {
        /** @type {?} */
        const doubleArrowWidth = 2 * this.ARROW_WIDTH;
        /** @type {?} */
        const width = this.ARROW_WIDTH / 2 + .5;
        /** @type {?} */
        const arrowHead = this.paper.path('M0 0L-' + width + '-' + doubleArrowWidth + 'L' + width + ' -' + doubleArrowWidth + 'z');
        arrowHead.transform('t' + line.x2 + ',' + line.y2);
        /** @type {?} */
        const angle = Raphael.deg(line.angle - Math.PI / 2);
        arrowHead.transform('...r' + angle + ' 0 0');
        arrowHead.attr('fill', '#585858');
        arrowHead.attr('stroke-width', this.SEQUENCE_FLOW_STROKE);
        arrowHead.attr('stroke', '#585858');
    }
}
RaphaelFlowArrowDirective.decorators = [
    { type: Directive, args: [{ selector: 'adf-raphael-flow-arrow, raphael-flow-arrow' },] }
];
/** @nocollapse */
RaphaelFlowArrowDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: RaphaelService }
];
RaphaelFlowArrowDirective.propDecorators = {
    paper: [{ type: Input }],
    flow: [{ type: Input }],
    error: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.paper;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.flow;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.error;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.ARROW_WIDTH;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.SEQUENCE_FLOW_STROKE;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFwaGFlbC1mbG93LWFycm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtaW5zaWdodHMvIiwic291cmNlcyI6WyJkaWFncmFtL2NvbXBvbmVudHMvcmFwaGFlbC9yYXBoYWVsLWZsb3ctYXJyb3cuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQVUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNGLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDdEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQzs7OztBQVFuRCxNQUFNLE9BQU8seUJBQTBCLFNBQVEsV0FBVzs7Ozs7SUFhdEQsWUFBbUIsVUFBc0IsRUFDN0IsY0FBOEI7UUFDdEMsS0FBSyxDQUFDLFVBQVUsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUZuQixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBTHpDLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRTNCLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLHlCQUFvQixHQUFHLEdBQUcsQ0FBQztJQUszQixDQUFDOzs7O0lBRUQsUUFBUTtRQUVKLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pCLENBQUM7Ozs7O0lBRU0sSUFBSSxDQUFDLElBQVM7O2NBQ1gsSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekIsQ0FBQzs7Ozs7SUFFTSxRQUFRLENBQUMsSUFBUzs7Y0FDZixRQUFRLEdBQUcsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQzdGLFFBQVEsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xELFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsRUFBQyxDQUFDLENBQUM7UUFDbkUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLENBQUMsQ0FBQztRQUU3QyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7O2NBRWxDLGFBQWEsR0FBRyxRQUFRLENBQUMsYUFBYSxFQUFFLEdBQUcsQ0FBQzs7Y0FDNUMsSUFBSSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO1FBQzVDLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Ozs7O0lBRU0sU0FBUyxDQUFDLElBQVM7O2NBQ2hCLGdCQUFnQixHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVzs7Y0FDdkMsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxHQUFHLEVBQUU7O2NBQ2pDLFNBQVMsR0FBUSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxnQkFBZ0IsR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLElBQUksR0FBRyxnQkFBZ0IsR0FBRyxHQUFHLENBQUM7UUFFL0gsU0FBUyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDOztjQUM3QyxLQUFLLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ25ELFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQztRQUU3QyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztRQUVsQyxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUMxRCxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUV4QyxDQUFDOzs7WUF4REosU0FBUyxTQUFDLEVBQUMsUUFBUSxFQUFFLDRDQUE0QyxFQUFDOzs7O1lBVi9DLFVBQVU7WUFHckIsY0FBYzs7O29CQVNsQixLQUFLO21CQUdMLEtBQUs7b0JBR0wsTUFBTTs7OztJQU5QLDBDQUNXOztJQUVYLHlDQUNVOztJQUVWLDBDQUMyQjs7SUFFM0IsZ0RBQWdCOztJQUNoQix5REFBMkI7O0lBRWYsK0NBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuL3BvbHlsaW5lJztcbmltcG9ydCB7IFJhcGhhZWxCYXNlIH0gZnJvbSAnLi9yYXBoYWVsLWJhc2UnO1xuaW1wb3J0IHsgUmFwaGFlbFNlcnZpY2UgfSBmcm9tICcuL3JhcGhhZWwuc2VydmljZSc7XG5cbmRlY2xhcmUgbGV0IFJhcGhhZWw6IGFueTtcblxuLyoqXG4gKiBEaXJlY3RpdmUgc2VsZWN0b3JzIHdpdGhvdXQgYWRmLSBwcmVmaXggd2lsbCBiZSBkZXByZWNhdGVkIG9uIDMuMC4wXG4gKi9cbkBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnYWRmLXJhcGhhZWwtZmxvdy1hcnJvdywgcmFwaGFlbC1mbG93LWFycm93J30pXG5leHBvcnQgY2xhc3MgUmFwaGFlbEZsb3dBcnJvd0RpcmVjdGl2ZSBleHRlbmRzIFJhcGhhZWxCYXNlIGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBASW5wdXQoKVxuICAgIHBhcGVyOiBhbnk7XG5cbiAgICBASW5wdXQoKVxuICAgIGZsb3c6IGFueTtcblxuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgQVJST1dfV0lEVEggPSA0O1xuICAgIFNFUVVFTkNFX0ZMT1dfU1RST0tFID0gMS41O1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgcmFwaGFlbFNlcnZpY2U6IFJhcGhhZWxTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnRSZWYsIHJhcGhhZWxTZXJ2aWNlKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcblxuICAgICAgICB0aGlzLmRyYXcodGhpcy5mbG93KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZHJhdyhmbG93OiBhbnkpIHtcbiAgICAgICAgY29uc3QgbGluZSA9IHRoaXMuZHJhd0xpbmUoZmxvdyk7XG4gICAgICAgIHRoaXMuZHJhd0Fycm93KGxpbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3TGluZShmbG93OiBhbnkpIHtcbiAgICAgICAgY29uc3QgcG9seWxpbmUgPSBuZXcgUG9seWxpbmUoZmxvdy5pZCwgZmxvdy53YXlwb2ludHMsIHRoaXMuU0VRVUVOQ0VfRkxPV19TVFJPS0UsIHRoaXMucGFwZXIpO1xuICAgICAgICBwb2x5bGluZS5lbGVtZW50ID0gdGhpcy5wYXBlci5wYXRoKHBvbHlsaW5lLnBhdGgpO1xuICAgICAgICBwb2x5bGluZS5lbGVtZW50LmF0dHIoeydzdHJva2Utd2lkdGgnOiB0aGlzLlNFUVVFTkNFX0ZMT1dfU1RST0tFfSk7XG4gICAgICAgIHBvbHlsaW5lLmVsZW1lbnQuYXR0cih7J3N0cm9rZSc6ICcjNTg1ODU4J30pO1xuXG4gICAgICAgIHBvbHlsaW5lLmVsZW1lbnQubm9kZS5pZCA9IHRoaXMuZmxvdy5pZDtcblxuICAgICAgICBjb25zdCBsYXN0TGluZUluZGV4ID0gcG9seWxpbmUuZ2V0TGluZXNDb3VudCgpIC0gMTtcbiAgICAgICAgY29uc3QgbGluZSA9IHBvbHlsaW5lLmdldExpbmUobGFzdExpbmVJbmRleCk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3QXJyb3cobGluZTogYW55KSB7XG4gICAgICAgIGNvbnN0IGRvdWJsZUFycm93V2lkdGggPSAyICogdGhpcy5BUlJPV19XSURUSDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLkFSUk9XX1dJRFRIIC8gMiArIC41O1xuICAgICAgICBjb25zdCBhcnJvd0hlYWQ6IGFueSA9IHRoaXMucGFwZXIucGF0aCgnTTAgMEwtJyArIHdpZHRoICsgJy0nICsgZG91YmxlQXJyb3dXaWR0aCArICdMJyArIHdpZHRoICsgJyAtJyArIGRvdWJsZUFycm93V2lkdGggKyAneicpO1xuXG4gICAgICAgIGFycm93SGVhZC50cmFuc2Zvcm0oJ3QnICsgbGluZS54MiArICcsJyArIGxpbmUueTIpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IFJhcGhhZWwuZGVnKGxpbmUuYW5nbGUgLSBNYXRoLlBJIC8gMik7XG4gICAgICAgIGFycm93SGVhZC50cmFuc2Zvcm0oJy4uLnInICsgYW5nbGUgKyAnIDAgMCcpO1xuXG4gICAgICAgIGFycm93SGVhZC5hdHRyKCdmaWxsJywgJyM1ODU4NTgnKTtcblxuICAgICAgICBhcnJvd0hlYWQuYXR0cignc3Ryb2tlLXdpZHRoJywgdGhpcy5TRVFVRU5DRV9GTE9XX1NUUk9LRSk7XG4gICAgICAgIGFycm93SGVhZC5hdHRyKCdzdHJva2UnLCAnIzU4NTg1OCcpO1xuXG4gICAgfVxufVxuIl19