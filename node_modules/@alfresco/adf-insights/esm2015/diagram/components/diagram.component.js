/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { DiagramModel } from '../models/diagram/diagram.model';
import { DiagramColorService } from '../services/diagram-color.service';
import { DiagramsService } from '../services/diagrams.service';
import { RaphaelService } from './raphael/raphael.service';
export class DiagramComponent {
    /**
     * @param {?} diagramColorService
     * @param {?} raphaelService
     * @param {?} diagramsService
     */
    constructor(diagramColorService, raphaelService, diagramsService) {
        this.diagramColorService = diagramColorService;
        this.raphaelService = raphaelService;
        this.diagramsService = diagramsService;
        this.metricType = '';
        this.width = 1000;
        this.height = 500;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.PADDING_WIDTH = 60;
        this.PADDING_HEIGHT = 60;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.reset();
        this.diagramColorService.setTotalColors(this.metricColor);
        if (this.processDefinitionId) {
            this.getProcessDefinitionModel(this.processDefinitionId);
        }
        else {
            this.getRunningProcessDefinitionModel(this.processInstanceId);
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    getRunningProcessDefinitionModel(processInstanceId) {
        this.diagramsService.getRunningProcessDefinitionModel(processInstanceId).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            this.diagram = new DiagramModel(res);
            this.raphaelService.setting(this.diagram.diagramWidth + this.PADDING_WIDTH, this.diagram.diagramHeight + this.PADDING_HEIGHT);
            this.setMetricValueToDiagramElement(this.diagram, this.metricPercentages, this.metricType);
            this.success.emit(res);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * @param {?} processDefinitionId
     * @return {?}
     */
    getProcessDefinitionModel(processDefinitionId) {
        this.diagramsService.getProcessDefinitionModel(processDefinitionId).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            this.diagram = new DiagramModel(res);
            this.raphaelService.setting(this.diagram.diagramWidth + this.PADDING_WIDTH, this.diagram.diagramHeight + this.PADDING_HEIGHT);
            this.setMetricValueToDiagramElement(this.diagram, this.metricPercentages, this.metricType);
            this.success.emit(res);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * @param {?} diagram
     * @param {?} metrics
     * @param {?} metricType
     * @return {?}
     */
    setMetricValueToDiagramElement(diagram, metrics, metricType) {
        for (const key in metrics) {
            if (metrics.hasOwnProperty(key)) {
                /** @type {?} */
                const foundElement = diagram.elements.find((/**
                 * @param {?} element
                 * @return {?}
                 */
                (element) => element.id === key));
                if (foundElement) {
                    foundElement.value = metrics[key];
                    foundElement.dataType = metricType;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.raphaelService.reset();
    }
}
DiagramComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-diagram',
                template: "<div *ngIf=\"diagram\" class=\"diagram\">\n    <div *ngFor=\"let element of diagram.elements\">\n        <div [ngSwitch]=\"element.type\">\n            <div *ngSwitchCase=\"'StartEvent'\">\n                <diagram-start-event [data]=\"element\"></diagram-start-event>\n            </div>\n            <div *ngSwitchCase=\"'ExclusiveGateway'\">\n                <diagram-exclusive-gateway [data]=\"element\"></diagram-exclusive-gateway>\n            </div>\n            <div *ngSwitchCase=\"'InclusiveGateway'\">\n                <diagram-inclusive-gateway [data]=\"element\"></diagram-inclusive-gateway>\n            </div>\n            <div *ngSwitchCase=\"'EventGateway'\">\n                <diagram-event-gateway [data]=\"element\"></diagram-event-gateway>\n            </div>\n            <div *ngSwitchCase=\"'ParallelGateway'\">\n                <diagram-parallel-gateway [data]=\"element\"></diagram-parallel-gateway>\n            </div>\n            <div *ngSwitchCase=\"'EndEvent'\">\n                <diagram-end-event [data]=\"element\"></diagram-end-event>\n            </div>\n            <div *ngSwitchCase=\"'UserTask'\">\n                <diagram-user-task [data]=\"element\"></diagram-user-task>\n            </div>\n            <div *ngSwitchCase=\"'ManualTask'\">\n                <diagram-manual-task [data]=\"element\"></diagram-manual-task>\n            </div>\n            <div *ngSwitchCase=\"'ServiceTask'\">\n                <diagram-container-service-task [data]=\"element\"></diagram-container-service-task>\n            </div>\n            <div *ngSwitchCase=\"'ReceiveTask'\">\n                <diagram-receive-task [data]=\"element\"></diagram-receive-task>\n            </div>\n            <div *ngSwitchCase=\"'ScriptTask'\">\n                <diagram-script-task [data]=\"element\"></diagram-script-task>\n            </div>\n            <div *ngSwitchCase=\"'BusinessRuleTask'\">\n                <diagram-business-rule-task [data]=\"element\"></diagram-business-rule-task>\n            </div>\n            <div *ngSwitchCase=\"'BoundaryEvent'\">\n                <diagram-boundary-event [data]=\"element\"></diagram-boundary-event>\n            </div>\n            <div *ngSwitchCase=\"'ThrowEvent'\">\n                <diagram-throw-event [data]=\"element\"></diagram-throw-event>\n            </div>\n            <div *ngSwitchCase=\"'IntermediateCatchEvent'\">\n                <diagram-intermediate-catching-event [data]=\"element\"></diagram-intermediate-catching-event>\n            </div>\n            <div *ngSwitchCase=\"'SubProcess'\">\n                <diagram-subprocess [data]=\"element\"></diagram-subprocess>\n            </div>\n            <div *ngSwitchCase=\"'EventSubProcess'\">\n                <diagram-event-subprocess [data]=\"element\"></diagram-event-subprocess>\n            </div>\n        </div>\n    </div>\n    <div *ngFor=\"let flow of diagram.flows\">\n        <div [ngSwitch]=\"flow.type\">\n            <div *ngSwitchCase=\"'sequenceFlow'\">\n                <adf-diagram-sequence-flow [flow]=\"flow\"></adf-diagram-sequence-flow>\n            </div>\n        </div>\n    </div>\n    <div *ngIf=\"diagram.pools\">\n        <diagram-pools [pools]=\"diagram.pools\"></diagram-pools>\n    </div>\n</div>\n",
                styles: [".diagram{border:1px solid #d3d3d3;overflow:auto}"]
            }] }
];
/** @nocollapse */
DiagramComponent.ctorParameters = () => [
    { type: DiagramColorService },
    { type: RaphaelService },
    { type: DiagramsService }
];
DiagramComponent.propDecorators = {
    processDefinitionId: [{ type: Input }],
    processInstanceId: [{ type: Input }],
    metricPercentages: [{ type: Input }],
    metricColor: [{ type: Input }],
    metricType: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    DiagramComponent.prototype.processDefinitionId;
    /** @type {?} */
    DiagramComponent.prototype.processInstanceId;
    /** @type {?} */
    DiagramComponent.prototype.metricPercentages;
    /** @type {?} */
    DiagramComponent.prototype.metricColor;
    /** @type {?} */
    DiagramComponent.prototype.metricType;
    /** @type {?} */
    DiagramComponent.prototype.width;
    /** @type {?} */
    DiagramComponent.prototype.height;
    /** @type {?} */
    DiagramComponent.prototype.success;
    /** @type {?} */
    DiagramComponent.prototype.error;
    /** @type {?} */
    DiagramComponent.prototype.PADDING_WIDTH;
    /** @type {?} */
    DiagramComponent.prototype.PADDING_HEIGHT;
    /** @type {?} */
    DiagramComponent.prototype.diagram;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.diagramColorService;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.raphaelService;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.diagramsService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhZ3JhbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWluc2lnaHRzLyIsInNvdXJjZXMiOlsiZGlhZ3JhbS9jb21wb25lbnRzL2RpYWdyYW0uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBYSxNQUFNLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBRWpHLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMvRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDL0QsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBTzNELE1BQU0sT0FBTyxnQkFBZ0I7Ozs7OztJQWlDekIsWUFBb0IsbUJBQXdDLEVBQ3hDLGNBQThCLEVBQzlCLGVBQWdDO1FBRmhDLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFDeEMsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLG9CQUFlLEdBQWYsZUFBZSxDQUFpQjtRQXJCcEQsZUFBVSxHQUFXLEVBQUUsQ0FBQztRQUd4QixVQUFLLEdBQVcsSUFBSSxDQUFDO1FBR3JCLFdBQU0sR0FBVyxHQUFHLENBQUM7UUFHckIsWUFBTyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFHN0IsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFFM0Isa0JBQWEsR0FBVyxFQUFFLENBQUM7UUFDM0IsbUJBQWMsR0FBVyxFQUFFLENBQUM7SUFPNUIsQ0FBQzs7Ozs7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDOUIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDMUQsSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7WUFDMUIsSUFBSSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQzVEO2FBQU07WUFDSCxJQUFJLENBQUMsZ0NBQWdDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7U0FDakU7SUFDTCxDQUFDOzs7OztJQUVELGdDQUFnQyxDQUFDLGlCQUF5QjtRQUN0RCxJQUFJLENBQUMsZUFBZSxDQUFDLGdDQUFnQyxDQUFDLGlCQUFpQixDQUFDLENBQUMsU0FBUzs7OztRQUM5RSxDQUFDLEdBQVEsRUFBRSxFQUFFO1lBQ1QsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyQyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxFQUM5QyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDOUUsSUFBSSxDQUFDLDhCQUE4QixDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUMzRixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMzQixDQUFDOzs7O1FBQ0QsQ0FBQyxHQUFRLEVBQUUsRUFBRTtZQUNULElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pCLENBQUMsRUFDSixDQUFDO0lBQ04sQ0FBQzs7Ozs7SUFFRCx5QkFBeUIsQ0FBQyxtQkFBMkI7UUFDakQsSUFBSSxDQUFDLGVBQWUsQ0FBQyx5QkFBeUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLFNBQVM7Ozs7UUFDekUsQ0FBQyxHQUFRLEVBQUUsRUFBRTtZQUNULElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDckMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFDOUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzlFLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDM0YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDM0IsQ0FBQzs7OztRQUNELENBQUMsR0FBUSxFQUFFLEVBQUU7WUFDVCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QixDQUFDLEVBQ0osQ0FBQztJQUNOLENBQUM7Ozs7Ozs7SUFFRCw4QkFBOEIsQ0FBQyxPQUFxQixFQUFFLE9BQVksRUFBRSxVQUFrQjtRQUNsRixLQUFLLE1BQU0sR0FBRyxJQUFJLE9BQU8sRUFBRTtZQUN2QixJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7O3NCQUN2QixZQUFZLEdBQXdCLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSTs7OztnQkFDM0QsQ0FBQyxPQUE0QixFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEdBQUcsRUFBQztnQkFDekQsSUFBSSxZQUFZLEVBQUU7b0JBQ2QsWUFBWSxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2xDLFlBQVksQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDO2lCQUN0QzthQUNKO1NBQ0o7SUFDTCxDQUFDOzs7O0lBRUQsS0FBSztRQUNELElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDaEMsQ0FBQzs7O1lBbEdKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsYUFBYTtnQkFFdkIsc3RHQUF1Qzs7YUFDMUM7Ozs7WUFSUSxtQkFBbUI7WUFFbkIsY0FBYztZQURkLGVBQWU7OztrQ0FTbkIsS0FBSztnQ0FHTCxLQUFLO2dDQUdMLEtBQUs7MEJBR0wsS0FBSzt5QkFHTCxLQUFLO29CQUdMLEtBQUs7cUJBR0wsS0FBSztzQkFHTCxNQUFNO29CQUdOLE1BQU07Ozs7SUF4QlAsK0NBQ3lCOztJQUV6Qiw2Q0FDdUI7O0lBRXZCLDZDQUN1Qjs7SUFFdkIsdUNBQ2lCOztJQUVqQixzQ0FDd0I7O0lBRXhCLGlDQUNxQjs7SUFFckIsa0NBQ3FCOztJQUVyQixtQ0FDNkI7O0lBRTdCLGlDQUMyQjs7SUFFM0IseUNBQTJCOztJQUMzQiwwQ0FBNEI7O0lBRTVCLG1DQUFzQjs7Ozs7SUFFViwrQ0FBZ0Q7Ozs7O0lBQ2hELDBDQUFzQzs7Ozs7SUFDdEMsMkNBQXdDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlhZ3JhbUVsZW1lbnRNb2RlbCB9IGZyb20gJy4uL21vZGVscy9kaWFncmFtL2RpYWdyYW1FbGVtZW50Lm1vZGVsJztcbmltcG9ydCB7IERpYWdyYW1Nb2RlbCB9IGZyb20gJy4uL21vZGVscy9kaWFncmFtL2RpYWdyYW0ubW9kZWwnO1xuaW1wb3J0IHsgRGlhZ3JhbUNvbG9yU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2RpYWdyYW0tY29sb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBEaWFncmFtc1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9kaWFncmFtcy5zZXJ2aWNlJztcbmltcG9ydCB7IFJhcGhhZWxTZXJ2aWNlIH0gZnJvbSAnLi9yYXBoYWVsL3JhcGhhZWwuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWRpYWdyYW0nLFxuICAgIHN0eWxlVXJsczogWycuL2RpYWdyYW0uY29tcG9uZW50LmNzcyddLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kaWFncmFtLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBEaWFncmFtQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgICBASW5wdXQoKVxuICAgIHByb2Nlc3NEZWZpbml0aW9uSWQ6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHJvY2Vzc0luc3RhbmNlSWQ6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgbWV0cmljUGVyY2VudGFnZXM6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgbWV0cmljQ29sb3I6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgbWV0cmljVHlwZTogc3RyaW5nID0gJyc7XG5cbiAgICBASW5wdXQoKVxuICAgIHdpZHRoOiBudW1iZXIgPSAxMDAwO1xuXG4gICAgQElucHV0KClcbiAgICBoZWlnaHQ6IG51bWJlciA9IDUwMDtcblxuICAgIEBPdXRwdXQoKVxuICAgIHN1Y2Nlc3MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIFBBRERJTkdfV0lEVEg6IG51bWJlciA9IDYwO1xuICAgIFBBRERJTkdfSEVJR0hUOiBudW1iZXIgPSA2MDtcblxuICAgIGRpYWdyYW06IERpYWdyYW1Nb2RlbDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGlhZ3JhbUNvbG9yU2VydmljZTogRGlhZ3JhbUNvbG9yU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJhcGhhZWxTZXJ2aWNlOiBSYXBoYWVsU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRpYWdyYW1zU2VydmljZTogRGlhZ3JhbXNTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZGlhZ3JhbUNvbG9yU2VydmljZS5zZXRUb3RhbENvbG9ycyh0aGlzLm1ldHJpY0NvbG9yKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0RlZmluaXRpb25JZCkge1xuICAgICAgICAgICAgdGhpcy5nZXRQcm9jZXNzRGVmaW5pdGlvbk1vZGVsKHRoaXMucHJvY2Vzc0RlZmluaXRpb25JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldFJ1bm5pbmdQcm9jZXNzRGVmaW5pdGlvbk1vZGVsKHRoaXMucHJvY2Vzc0luc3RhbmNlSWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UnVubmluZ1Byb2Nlc3NEZWZpbml0aW9uTW9kZWwocHJvY2Vzc0luc3RhbmNlSWQ6IHN0cmluZykge1xuICAgICAgICB0aGlzLmRpYWdyYW1zU2VydmljZS5nZXRSdW5uaW5nUHJvY2Vzc0RlZmluaXRpb25Nb2RlbChwcm9jZXNzSW5zdGFuY2VJZCkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKHJlczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFncmFtID0gbmV3IERpYWdyYW1Nb2RlbChyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmFwaGFlbFNlcnZpY2Uuc2V0dGluZyh0aGlzLmRpYWdyYW0uZGlhZ3JhbVdpZHRoICsgdGhpcy5QQURESU5HX1dJRFRILFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWdyYW0uZGlhZ3JhbUhlaWdodCArIHRoaXMuUEFERElOR19IRUlHSFQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWV0cmljVmFsdWVUb0RpYWdyYW1FbGVtZW50KHRoaXMuZGlhZ3JhbSwgdGhpcy5tZXRyaWNQZXJjZW50YWdlcywgdGhpcy5tZXRyaWNUeXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChyZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldFByb2Nlc3NEZWZpbml0aW9uTW9kZWwocHJvY2Vzc0RlZmluaXRpb25JZDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZGlhZ3JhbXNTZXJ2aWNlLmdldFByb2Nlc3NEZWZpbml0aW9uTW9kZWwocHJvY2Vzc0RlZmluaXRpb25JZCkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKHJlczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFncmFtID0gbmV3IERpYWdyYW1Nb2RlbChyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmFwaGFlbFNlcnZpY2Uuc2V0dGluZyh0aGlzLmRpYWdyYW0uZGlhZ3JhbVdpZHRoICsgdGhpcy5QQURESU5HX1dJRFRILFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWdyYW0uZGlhZ3JhbUhlaWdodCArIHRoaXMuUEFERElOR19IRUlHSFQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWV0cmljVmFsdWVUb0RpYWdyYW1FbGVtZW50KHRoaXMuZGlhZ3JhbSwgdGhpcy5tZXRyaWNQZXJjZW50YWdlcywgdGhpcy5tZXRyaWNUeXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChyZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldE1ldHJpY1ZhbHVlVG9EaWFncmFtRWxlbWVudChkaWFncmFtOiBEaWFncmFtTW9kZWwsIG1ldHJpY3M6IGFueSwgbWV0cmljVHlwZTogc3RyaW5nKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1ldHJpY3MpIHtcbiAgICAgICAgICAgIGlmIChtZXRyaWNzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEVsZW1lbnQ6IERpYWdyYW1FbGVtZW50TW9kZWwgPSBkaWFncmFtLmVsZW1lbnRzLmZpbmQoXG4gICAgICAgICAgICAgICAgICAgIChlbGVtZW50OiBEaWFncmFtRWxlbWVudE1vZGVsKSA9PiBlbGVtZW50LmlkID09PSBrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRFbGVtZW50LnZhbHVlID0gbWV0cmljc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEVsZW1lbnQuZGF0YVR5cGUgPSBtZXRyaWNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnJhcGhhZWxTZXJ2aWNlLnJlc2V0KCk7XG4gICAgfVxufVxuIl19