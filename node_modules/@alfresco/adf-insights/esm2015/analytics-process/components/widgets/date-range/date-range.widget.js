/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:no-input-rename  */
import { MOMENT_DATE_FORMATS, MomentDateAdapter, UserPreferencesService, UserPreferenceValues } from '@alfresco/adf-core';
import { Component, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material';
import moment from 'moment-es6';
const ɵ0 = MOMENT_DATE_FORMATS;
export class DateRangeWidgetComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.FORMAT_DATE_ACTIVITI = 'YYYY-MM-DD';
        this.SHOW_FORMAT = 'DD/MM/YYYY';
        this.dateRangeChanged = new EventEmitter();
        this.startDatePicker = moment();
        this.endDatePicker = moment();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            this.dateAdapter.setLocale(locale);
        }));
        /** @type {?} */
        const momentDateAdapter = (/** @type {?} */ (this.dateAdapter));
        momentDateAdapter.overrideDisplayFormat = this.SHOW_FORMAT;
        if (this.field) {
            if (this.field.value && this.field.value.startDate) {
                this.startDatePicker = moment(this.field.value.startDate, this.FORMAT_DATE_ACTIVITI);
            }
            if (this.field.value && this.field.value.endDate) {
                this.endDatePicker = moment(this.field.value.endDate, this.FORMAT_DATE_ACTIVITI);
            }
        }
        /** @type {?} */
        const startDateControl = new FormControl(this.startDatePicker);
        startDateControl.setValidators(Validators.required);
        this.dateRange.addControl('startDate', startDateControl);
        /** @type {?} */
        const endDateControl = new FormControl(this.endDatePicker);
        endDateControl.setValidators(Validators.required);
        this.dateRange.addControl('endDate', endDateControl);
        this.dateRange.setValidators(this.dateCheck);
        this.dateRange.valueChanges.subscribe((/**
         * @return {?}
         */
        () => this.onGroupValueChanged()));
    }
    /**
     * @return {?}
     */
    onGroupValueChanged() {
        if (this.dateRange.valid) {
            /** @type {?} */
            const dateStart = this.convertToMomentDateWithTime(this.dateRange.controls.startDate.value);
            /** @type {?} */
            const endStart = this.convertToMomentDateWithTime(this.dateRange.controls.endDate.value);
            this.dateRangeChanged.emit({ startDate: dateStart, endDate: endStart });
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    convertToMomentDateWithTime(date) {
        return moment(date, this.FORMAT_DATE_ACTIVITI, true).format(this.FORMAT_DATE_ACTIVITI) + 'T00:00:00.000Z';
    }
    /**
     * @param {?} formControl
     * @return {?}
     */
    dateCheck(formControl) {
        /** @type {?} */
        const startDate = moment(formControl.get('startDate').value);
        /** @type {?} */
        const endDate = moment(formControl.get('endDate').value);
        /** @type {?} */
        const isAfterCheck = startDate.isAfter(endDate);
        return isAfterCheck ? { 'greaterThan': true } : null;
    }
    /**
     * @return {?}
     */
    isStartDateGreaterThanEndDate() {
        return this.dateRange && this.dateRange.errors && this.dateRange.errors.greaterThan;
    }
    /**
     * @return {?}
     */
    isStartDateEmpty() {
        return this.dateRange && this.dateRange.controls.startDate && !this.dateRange.controls.startDate.valid;
    }
}
DateRangeWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-range-widget',
                template: "<label for=\"adf-dateRange\" >{{field.nameKey | translate}}</label><br>\n<div id=\"adf-dateRange\" [formGroup]=\"dateRange\">\n    <small *ngIf=\"isStartDateGreaterThanEndDate()\" class=\"adf-date-range-analytics-text-danger\">\n       {{'DATE-WIDGET.MESSAGES.START-LESS-THAN-END-DATE' | translate}}\n    </small>\n    <small *ngIf=\"isStartDateEmpty()\" class=\"adf-date-range-analytics-text-danger\">\n       {{'DATE-WIDGET.MESSAGES.START-DATE-REQUIRED' | translate}}\n    </small>\n\n            <mat-grid-list cols=\"2\" rowHeight=\"80px\">\n                <mat-grid-tile>\n                    <mat-form-field>\n                        <input\n                            matInput\n                            [min]=\"minDate\"\n                            [max]=\"maxDate\"\n                            formControlName=\"startDate\"\n                            [matDatepicker]=\"startDate\"\n                            [value]=\"startDatePicker\"\n                            (keydown)=\"true\"\n                            (dateChange)=\"onGroupValueChanged()\"\n                            placeholder=\"{{'DATE-WIDGET.START-DATE' | translate}}\"\n                            id=\"startDate_id\"\n                            required>\n                        <mat-datepicker-toggle matSuffix [for]=\"startDate\" ></mat-datepicker-toggle>\n                    </mat-form-field>\n                    <mat-datepicker\n                        #startDate\n                        [touchUi]=\"true\">\n                    </mat-datepicker>\n                </mat-grid-tile>\n                <mat-grid-tile>\n                    <mat-form-field>\n                        <input\n                            matInput\n                            [min]=\"minDate\"\n                            [max]=\"maxDate\"\n                            formControlName=\"endDate\"\n                            [matDatepicker]=\"endDate\"\n                            [value]=\"endDatePicker\"\n                            (keydown)=\"true\"\n                            (dateChange)=\"onGroupValueChanged()\"\n                            placeholder=\"{{'DATE-WIDGET.END-DATE' | translate}}\"\n                            id=\"endDate_id\"\n                            required>\n                        <mat-datepicker-toggle matSuffix [for]=\"endDate\" ></mat-datepicker-toggle>\n                    </mat-form-field>\n                    <mat-datepicker\n                        #endDate\n                        [touchUi]=\"true\">\n                    </mat-datepicker>\n                </mat-grid-tile>\n            </mat-grid-list>\n</div>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
DateRangeWidgetComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
DateRangeWidgetComponent.propDecorators = {
    dateRange: [{ type: Input, args: ['group',] }],
    field: [{ type: Input }],
    dateRangeChanged: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    DateRangeWidgetComponent.prototype.FORMAT_DATE_ACTIVITI;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.SHOW_FORMAT;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.dateRange;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.field;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.dateRangeChanged;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.minDate;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.maxDate;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.startDatePicker;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.endDatePicker;
    /**
     * @type {?}
     * @private
     */
    DateRangeWidgetComponent.prototype.dateAdapter;
    /**
     * @type {?}
     * @private
     */
    DateRangeWidgetComponent.prototype.userPreferencesService;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS53aWRnZXQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWluc2lnaHRzLyIsInNvdXJjZXMiOlsiYW5hbHl0aWNzLXByb2Nlc3MvY29tcG9uZW50cy93aWRnZXRzL2RhdGUtcmFuZ2UvZGF0ZS1yYW5nZS53aWRnZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSxzQkFBc0IsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzFILE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFtQixXQUFXLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JGLE9BQU8sRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNsRSxPQUFPLE1BQU0sTUFBTSxZQUFZLENBQUM7V0FRYyxtQkFBbUI7QUFJakUsTUFBTSxPQUFPLHdCQUF3Qjs7Ozs7SUFtQmpDLFlBQ1ksV0FBZ0MsRUFDaEMsc0JBQThDO1FBRDlDLGdCQUFXLEdBQVgsV0FBVyxDQUFxQjtRQUNoQywyQkFBc0IsR0FBdEIsc0JBQXNCLENBQXdCO1FBbkJuRCx5QkFBb0IsR0FBVyxZQUFZLENBQUM7UUFDNUMsZ0JBQVcsR0FBVyxZQUFZLENBQUM7UUFTMUMscUJBQWdCLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFJOUQsb0JBQWUsR0FBVyxNQUFNLEVBQUUsQ0FBQztRQUNuQyxrQkFBYSxHQUFXLE1BQU0sRUFBRSxDQUFDO0lBS2pDLENBQUM7Ozs7SUFFRCxRQUFRO1FBQ0osSUFBSSxDQUFDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMs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IENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIHRzbGludDpkaXNhYmxlOm5vLWlucHV0LXJlbmFtZSAgKi9cblxuaW1wb3J0IHsgTU9NRU5UX0RBVEVfRk9STUFUUywgTW9tZW50RGF0ZUFkYXB0ZXIsIFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UsIFVzZXJQcmVmZXJlbmNlVmFsdWVzIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIEZvcm1Db250cm9sLCBGb3JtR3JvdXAsIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBEYXRlQWRhcHRlciwgTUFUX0RBVEVfRk9STUFUUyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50LWVzNic7XG5pbXBvcnQgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1kYXRlLXJhbmdlLXdpZGdldCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2RhdGUtcmFuZ2Uud2lkZ2V0Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBNb21lbnREYXRlQWRhcHRlcn0sXG4gICAgICAgIHtwcm92aWRlOiBNQVRfREFURV9GT1JNQVRTLCB1c2VWYWx1ZTogTU9NRU5UX0RBVEVfRk9STUFUU31dLFxuICAgIHN0eWxlVXJsczogWycuL2RhdGUtcmFuZ2Uud2lkZ2V0LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIERhdGVSYW5nZVdpZGdldENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBwdWJsaWMgRk9STUFUX0RBVEVfQUNUSVZJVEk6IHN0cmluZyA9ICdZWVlZLU1NLUREJztcbiAgICBwdWJsaWMgU0hPV19GT1JNQVQ6IHN0cmluZyA9ICdERC9NTS9ZWVlZJztcblxuICAgIEBJbnB1dCgnZ3JvdXAnKVxuICAgIHB1YmxpYyBkYXRlUmFuZ2U6IEZvcm1Hcm91cDtcblxuICAgIEBJbnB1dCgpXG4gICAgZmllbGQ6IGFueTtcblxuICAgIEBPdXRwdXQoKVxuICAgIGRhdGVSYW5nZUNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBtaW5EYXRlOiBNb21lbnQ7XG4gICAgbWF4RGF0ZTogTW9tZW50O1xuICAgIHN0YXJ0RGF0ZVBpY2tlcjogTW9tZW50ID0gbW9tZW50KCk7XG4gICAgZW5kRGF0ZVBpY2tlcjogTW9tZW50ID0gbW9tZW50KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBkYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8TW9tZW50PixcbiAgICAgICAgcHJpdmF0ZSB1c2VyUHJlZmVyZW5jZXNTZXJ2aWNlOiBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMudXNlclByZWZlcmVuY2VzU2VydmljZS5zZWxlY3QoVXNlclByZWZlcmVuY2VWYWx1ZXMuTG9jYWxlKS5zdWJzY3JpYmUoKGxvY2FsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRlQWRhcHRlci5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbW9tZW50RGF0ZUFkYXB0ZXIgPSA8TW9tZW50RGF0ZUFkYXB0ZXI+IHRoaXMuZGF0ZUFkYXB0ZXI7XG4gICAgICAgIG1vbWVudERhdGVBZGFwdGVyLm92ZXJyaWRlRGlzcGxheUZvcm1hdCA9IHRoaXMuU0hPV19GT1JNQVQ7XG5cbiAgICAgICAgaWYgKHRoaXMuZmllbGQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpZWxkLnZhbHVlICYmIHRoaXMuZmllbGQudmFsdWUuc3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGVQaWNrZXIgPSBtb21lbnQodGhpcy5maWVsZC52YWx1ZS5zdGFydERhdGUsIHRoaXMuRk9STUFUX0RBVEVfQUNUSVZJVEkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5maWVsZC52YWx1ZSAmJiB0aGlzLmZpZWxkLnZhbHVlLmVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGVQaWNrZXIgPSBtb21lbnQodGhpcy5maWVsZC52YWx1ZS5lbmREYXRlLCB0aGlzLkZPUk1BVF9EQVRFX0FDVElWSVRJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0RGF0ZUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2wodGhpcy5zdGFydERhdGVQaWNrZXIpO1xuICAgICAgICBzdGFydERhdGVDb250cm9sLnNldFZhbGlkYXRvcnMoVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlLmFkZENvbnRyb2woJ3N0YXJ0RGF0ZScsIHN0YXJ0RGF0ZUNvbnRyb2wpO1xuXG4gICAgICAgIGNvbnN0IGVuZERhdGVDb250cm9sID0gbmV3IEZvcm1Db250cm9sKHRoaXMuZW5kRGF0ZVBpY2tlcik7XG4gICAgICAgIGVuZERhdGVDb250cm9sLnNldFZhbGlkYXRvcnMoVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlLmFkZENvbnRyb2woJ2VuZERhdGUnLCBlbmREYXRlQ29udHJvbCk7XG5cbiAgICAgICAgdGhpcy5kYXRlUmFuZ2Uuc2V0VmFsaWRhdG9ycyh0aGlzLmRhdGVDaGVjayk7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlLnZhbHVlQ2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vbkdyb3VwVmFsdWVDaGFuZ2VkKCkpO1xuICAgIH1cblxuICAgIG9uR3JvdXBWYWx1ZUNoYW5nZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGVSYW5nZS52YWxpZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0ZVN0YXJ0ID0gdGhpcy5jb252ZXJ0VG9Nb21lbnREYXRlV2l0aFRpbWUodGhpcy5kYXRlUmFuZ2UuY29udHJvbHMuc3RhcnREYXRlLnZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZFN0YXJ0ID0gdGhpcy5jb252ZXJ0VG9Nb21lbnREYXRlV2l0aFRpbWUodGhpcy5kYXRlUmFuZ2UuY29udHJvbHMuZW5kRGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRhdGVSYW5nZUNoYW5nZWQuZW1pdCh7c3RhcnREYXRlOiBkYXRlU3RhcnQsIGVuZERhdGU6IGVuZFN0YXJ0fSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb252ZXJ0VG9Nb21lbnREYXRlV2l0aFRpbWUoZGF0ZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQoZGF0ZSwgdGhpcy5GT1JNQVRfREFURV9BQ1RJVklUSSwgdHJ1ZSkuZm9ybWF0KHRoaXMuRk9STUFUX0RBVEVfQUNUSVZJVEkpICsgJ1QwMDowMDowMC4wMDBaJztcbiAgICB9XG5cbiAgICBkYXRlQ2hlY2soZm9ybUNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCkge1xuICAgICAgICBjb25zdCBzdGFydERhdGUgPSBtb21lbnQoZm9ybUNvbnRyb2wuZ2V0KCdzdGFydERhdGUnKS52YWx1ZSk7XG4gICAgICAgIGNvbnN0IGVuZERhdGUgPSBtb21lbnQoZm9ybUNvbnRyb2wuZ2V0KCdlbmREYXRlJykudmFsdWUpO1xuICAgICAgICBjb25zdCBpc0FmdGVyQ2hlY2sgPSBzdGFydERhdGUuaXNBZnRlcihlbmREYXRlKTtcbiAgICAgICAgcmV0dXJuIGlzQWZ0ZXJDaGVjayA/IHsnZ3JlYXRlclRoYW4nOiB0cnVlfSA6IG51bGw7XG4gICAgfVxuXG4gICAgaXNTdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZSAmJiB0aGlzLmRhdGVSYW5nZS5lcnJvcnMgJiYgdGhpcy5kYXRlUmFuZ2UuZXJyb3JzLmdyZWF0ZXJUaGFuO1xuICAgIH1cblxuICAgIGlzU3RhcnREYXRlRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZSAmJiB0aGlzLmRhdGVSYW5nZS5jb250cm9scy5zdGFydERhdGUgJiYgIXRoaXMuZGF0ZVJhbmdlLmNvbnRyb2xzLnN0YXJ0RGF0ZS52YWxpZDtcbiAgICB9XG59XG4iXX0=