/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation, Input, EventEmitter, Output } from '@angular/core';
import { NodesApiService } from '@alfresco/adf-core';
import { PermissionDisplayModel } from '../../models/permission.model';
import { NodePermissionService } from '../../services/node-permission.service';
export class PermissionListComponent {
    /**
     * @param {?} nodeService
     * @param {?} nodePermissionService
     */
    constructor(nodeService, nodePermissionService) {
        this.nodeService = nodeService;
        this.nodePermissionService = nodePermissionService;
        /**
         * ID of the node whose permissions you want to show.
         */
        this.nodeId = '';
        /**
         * Emitted when the permission is updated.
         */
        this.update = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.fetchNodePermissions();
    }
    /**
     * @return {?}
     */
    reload() {
        this.fetchNodePermissions();
    }
    /**
     * @private
     * @return {?}
     */
    fetchNodePermissions() {
        this.nodeService.getNode(this.nodeId).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.actualNode = node;
            this.permissionList = this.getPermissionList(node);
            this.nodePermissionService.getNodeRoles(node).subscribe((/**
             * @param {?} settableList
             * @return {?}
             */
            (settableList) => {
                this.settableRoles = settableList;
            }));
        }));
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getPermissionList(node) {
        /** @type {?} */
        const allPermissions = [];
        if (node.permissions.locallySet) {
            node.permissions.locallySet.map((/**
             * @param {?} permissionElement
             * @return {?}
             */
            (permissionElement) => {
                /** @type {?} */
                const permission = new PermissionDisplayModel(permissionElement);
                allPermissions.push(permission);
            }));
        }
        if (node.permissions.inherited) {
            node.permissions.inherited.map((/**
             * @param {?} permissionElement
             * @return {?}
             */
            (permissionElement) => {
                /** @type {?} */
                const permissionInherited = new PermissionDisplayModel(permissionElement);
                permissionInherited.isInherited = true;
                allPermissions.push(permissionInherited);
            }));
        }
        return allPermissions;
    }
    /**
     * @param {?} event
     * @param {?} permissionRow
     * @return {?}
     */
    saveNewRole(event, permissionRow) {
        /** @type {?} */
        const updatedPermissionRole = this.buildUpdatedPermission(event.value, permissionRow);
        this.nodePermissionService.updatePermissionRole(this.actualNode, updatedPermissionRole)
            .subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.update.emit(updatedPermissionRole);
        }));
    }
    /**
     * @private
     * @param {?} newRole
     * @param {?} permissionRow
     * @return {?}
     */
    buildUpdatedPermission(newRole, permissionRow) {
        /** @type {?} */
        const permissionRole = {};
        permissionRole.accessStatus = permissionRow.accessStatus;
        permissionRole.name = newRole;
        permissionRole.authorityId = permissionRow.authorityId;
        return permissionRole;
    }
    /**
     * @param {?} permissionRow
     * @return {?}
     */
    removePermission(permissionRow) {
        this.nodePermissionService.removePermission(this.actualNode, permissionRow).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.update.emit(node);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.error.emit(error)));
    }
}
PermissionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-permission-list',
                template: "<div id=\"adf-permission-display-container\" class=\"adf-display-permission-container\">\n\n    <div *ngIf=\"!permissionList || !permissionList.length\" id=\"adf-no-permissions-template\">\n        <div #ref>\n            <ng-content select=\"adf-no-permission-template\"></ng-content>\n        </div>\n\n        <p *ngIf=\"ref.children.length == 0\">\n            {{ 'PERMISSION_MANAGER.PERMISSION_DISPLAY.NO_PERMISSIONS' | translate }}\n        </p>\n    </div>\n\n    <adf-datatable [rows]=\"permissionList\" class=\"adf-datatable-permission\" *ngIf=\"permissionList && permissionList.length\">\n        <data-columns>\n            <data-column [class] = \"'adf-key-icon'\" key=\"icon\" type=\"icon\" [sortable]=\"false\">\n            </data-column>\n            <data-column [class]= \"'adf-authorityId-label adf-ellipsis-cell adf-expand-cell-2'\" title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.AUTHORITY_ID' | translate}}\" key=\"authorityId\"></data-column>\n            <data-column [class]=\"'adf-ellipsis-cell adf-expand-cell-1'\" title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.ROLE' | translate}}\" key=\"name\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-form-field *ngIf=\"!entry.row.getValue('isInherited') else show_only_label\">\n                        <mat-select id=\"adf-select-role-permission\"\n                                    [placeholder]=\"entry.data.getValue(entry.row, entry.col)\"\n                                    value=\"{{entry.data.getValue(entry.row, entry.col)}}\"\n                                    (selectionChange)=\"saveNewRole($event, entry.row.obj)\">\n                          <mat-option *ngFor=\"let role of settableRoles\" [value]=\"role\">\n                            {{ role }}\n                          </mat-option>\n                        </mat-select>\n                      </mat-form-field>\n                      <ng-template #show_only_label>\n                          <span>{{entry.data.getValue(entry.row, entry.col)}}</span>\n                      </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column [class]=\"'adf-permission-label'\" title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}\" key=\"isInherited\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-chip-list>\n                        <mat-chip [class]=\"'mat-chip mat-primary mat-standard-chip mat-chip-selected adf-inherited-label '\"\n                                  *ngIf=\"!!entry.data.getValue(entry.row, entry.col) else locally_set_chip\"\n                                id=\"adf-permission-inherited-label\"\n                                color=\"primary\" selected=\"true\">{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}</mat-chip>\n                    </mat-chip-list>\n                    <ng-template #locally_set_chip>\n                            <mat-chip-list [class] = \"'adf-locallyset-label'\">\n                                    <mat-chip id=\"adf-permission-locallyset-label\"\n                                              color=\"accent\" selected=\"true\">\n                                              {{'PERMISSION_MANAGER.PERMISSION_DISPLAY.LOCALLY_SET' | translate}}\n                                    </mat-chip>\n                            </mat-chip-list>\n                    </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column [class]=\"'adf-delete-permission'\" key=\"delete\">\n            <ng-template let-entry=\"$implicit\">\n                <button *ngIf=\"!entry.row.getValue('isInherited')\" mat-icon-button color=\"primary\" (click)=\"removePermission(entry.row.obj)\" data-automation-id=\"adf-delete-permission-button\">\n                    <mat-icon>highlight_off</mat-icon>\n                </button>\n            </ng-template>\n        </data-column>\n        </data-columns>\n    </adf-datatable>\n</div>\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
PermissionListComponent.ctorParameters = () => [
    { type: NodesApiService },
    { type: NodePermissionService }
];
PermissionListComponent.propDecorators = {
    nodeId: [{ type: Input }],
    update: [{ type: Output }],
    error: [{ type: Output }]
};
if (false) {
    /**
     * ID of the node whose permissions you want to show.
     * @type {?}
     */
    PermissionListComponent.prototype.nodeId;
    /**
     * Emitted when the permission is updated.
     * @type {?}
     */
    PermissionListComponent.prototype.update;
    /**
     * Emitted when an error occurs.
     * @type {?}
     */
    PermissionListComponent.prototype.error;
    /** @type {?} */
    PermissionListComponent.prototype.permissionList;
    /** @type {?} */
    PermissionListComponent.prototype.settableRoles;
    /** @type {?} */
    PermissionListComponent.prototype.actualNode;
    /**
     * @type {?}
     * @private
     */
    PermissionListComponent.prototype.nodeService;
    /**
     * @type {?}
     * @private
     */
    PermissionListComponent.prototype.nodePermissionService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybWlzc2lvbi1saXN0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy8iLCJzb3VyY2VzIjpbInBlcm1pc3Npb24tbWFuYWdlci9jb21wb25lbnRzL3Blcm1pc3Npb24tbGlzdC9wZXJtaXNzaW9uLWxpc3QuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsS0FBSyxFQUFVLFlBQVksRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXJELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBUS9FLE1BQU0sT0FBTyx1QkFBdUI7Ozs7O0lBa0JoQyxZQUFvQixXQUE0QixFQUM1QixxQkFBNEM7UUFENUMsZ0JBQVcsR0FBWCxXQUFXLENBQWlCO1FBQzVCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBdUI7Ozs7UUFmaEUsV0FBTSxHQUFXLEVBQUUsQ0FBQzs7OztRQUlwQixXQUFNLEdBQW9DLElBQUksWUFBWSxFQUFFLENBQUM7Ozs7UUFJN0QsVUFBSyxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO0lBUzlDLENBQUM7Ozs7SUFFRCxRQUFRO1FBQ0osSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFDaEMsQ0FBQzs7OztJQUVELE1BQU07UUFDRixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUNoQyxDQUFDOzs7OztJQUVPLG9CQUFvQjtRQUN4QixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUzs7OztRQUFDLENBQUMsSUFB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Ozs7cUJBV3pCLEtBQUs7cUJBSUwsTUFBTTtvQkFJTixNQUFNOzs7Ozs7O0lBUlAseUNBQ29COzs7OztJQUdwQix5Q0FDNkQ7Ozs7O0lBRzdELHdDQUM4Qzs7SUFFOUMsaURBQXlDOztJQUN6QyxnREFBcUI7O0lBQ3JCLDZDQUFpQjs7Ozs7SUFFTCw4Q0FBb0M7Ozs7O0lBQ3BDLHdEQUFvRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24sIElucHV0LCBPbkluaXQsIEV2ZW50RW1pdHRlciwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOb2Rlc0FwaVNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgTm9kZSwgUGVybWlzc2lvbkVsZW1lbnQgfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcbmltcG9ydCB7IFBlcm1pc3Npb25EaXNwbGF5TW9kZWwgfSBmcm9tICcuLi8uLi9tb2RlbHMvcGVybWlzc2lvbi5tb2RlbCc7XG5pbXBvcnQgeyBOb2RlUGVybWlzc2lvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9ub2RlLXBlcm1pc3Npb24uc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXBlcm1pc3Npb24tbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3Blcm1pc3Npb24tbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vcGVybWlzc2lvbi1saXN0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBQZXJtaXNzaW9uTGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvKiogSUQgb2YgdGhlIG5vZGUgd2hvc2UgcGVybWlzc2lvbnMgeW91IHdhbnQgdG8gc2hvdy4gKi9cbiAgICBASW5wdXQoKVxuICAgIG5vZGVJZDogc3RyaW5nID0gJyc7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBwZXJtaXNzaW9uIGlzIHVwZGF0ZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgdXBkYXRlOiBFdmVudEVtaXR0ZXI8UGVybWlzc2lvbkVsZW1lbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgcGVybWlzc2lvbkxpc3Q6IFBlcm1pc3Npb25EaXNwbGF5TW9kZWxbXTtcbiAgICBzZXR0YWJsZVJvbGVzOiBhbnlbXTtcbiAgICBhY3R1YWxOb2RlOiBOb2RlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBub2RlU2VydmljZTogTm9kZXNBcGlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbm9kZVBlcm1pc3Npb25TZXJ2aWNlOiBOb2RlUGVybWlzc2lvblNlcnZpY2UpIHtcblxuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmZldGNoTm9kZVBlcm1pc3Npb25zKCk7XG4gICAgfVxuXG4gICAgcmVsb2FkKCkge1xuICAgICAgICB0aGlzLmZldGNoTm9kZVBlcm1pc3Npb25zKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmZXRjaE5vZGVQZXJtaXNzaW9ucygpIHtcbiAgICAgICAgdGhpcy5ub2RlU2VydmljZS5nZXROb2RlKHRoaXMubm9kZUlkKS5zdWJzY3JpYmUoKG5vZGU6IE5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0dWFsTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25MaXN0ID0gdGhpcy5nZXRQZXJtaXNzaW9uTGlzdChub2RlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZVBlcm1pc3Npb25TZXJ2aWNlLmdldE5vZGVSb2xlcyhub2RlKS5zdWJzY3JpYmUoKHNldHRhYmxlTGlzdDogc3RyaW5nW10pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRhYmxlUm9sZXMgPSBzZXR0YWJsZUxpc3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRQZXJtaXNzaW9uTGlzdChub2RlOiBOb2RlKTogUGVybWlzc2lvbkRpc3BsYXlNb2RlbFtdIHtcbiAgICAgICAgY29uc3QgYWxsUGVybWlzc2lvbnM6IFBlcm1pc3Npb25EaXNwbGF5TW9kZWxbXSA9IFtdO1xuICAgICAgICBpZiAobm9kZS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0KSB7XG4gICAgICAgICAgICBub2RlLnBlcm1pc3Npb25zLmxvY2FsbHlTZXQubWFwKChwZXJtaXNzaW9uRWxlbWVudDogUGVybWlzc2lvbkVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uID0gbmV3IFBlcm1pc3Npb25EaXNwbGF5TW9kZWwocGVybWlzc2lvbkVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGFsbFBlcm1pc3Npb25zLnB1c2gocGVybWlzc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wZXJtaXNzaW9ucy5pbmhlcml0ZWQpIHtcbiAgICAgICAgICAgIG5vZGUucGVybWlzc2lvbnMuaW5oZXJpdGVkLm1hcCgocGVybWlzc2lvbkVsZW1lbnQ6IFBlcm1pc3Npb25FbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbkluaGVyaXRlZCA9IG5ldyBQZXJtaXNzaW9uRGlzcGxheU1vZGVsKHBlcm1pc3Npb25FbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uSW5oZXJpdGVkLmlzSW5oZXJpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhbGxQZXJtaXNzaW9ucy5wdXNoKHBlcm1pc3Npb25Jbmhlcml0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbFBlcm1pc3Npb25zO1xuICAgIH1cblxuICAgIHNhdmVOZXdSb2xlKGV2ZW50OiBhbnksIHBlcm1pc3Npb25Sb3c6IFBlcm1pc3Npb25EaXNwbGF5TW9kZWwpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFBlcm1pc3Npb25Sb2xlOiBQZXJtaXNzaW9uRWxlbWVudCA9IHRoaXMuYnVpbGRVcGRhdGVkUGVybWlzc2lvbihldmVudC52YWx1ZSwgcGVybWlzc2lvblJvdyk7XG4gICAgICAgIHRoaXMubm9kZVBlcm1pc3Npb25TZXJ2aWNlLnVwZGF0ZVBlcm1pc3Npb25Sb2xlKHRoaXMuYWN0dWFsTm9kZSwgdXBkYXRlZFBlcm1pc3Npb25Sb2xlKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgobm9kZTogTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQodXBkYXRlZFBlcm1pc3Npb25Sb2xlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYnVpbGRVcGRhdGVkUGVybWlzc2lvbihuZXdSb2xlOiBzdHJpbmcsIHBlcm1pc3Npb25Sb3c6IFBlcm1pc3Npb25EaXNwbGF5TW9kZWwpOiBQZXJtaXNzaW9uRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25Sb2xlOiBQZXJtaXNzaW9uRWxlbWVudCA9IHt9O1xuICAgICAgICBwZXJtaXNzaW9uUm9sZS5hY2Nlc3NTdGF0dXMgPSBwZXJtaXNzaW9uUm93LmFjY2Vzc1N0YXR1cztcbiAgICAgICAgcGVybWlzc2lvblJvbGUubmFtZSA9IG5ld1JvbGU7XG4gICAgICAgIHBlcm1pc3Npb25Sb2xlLmF1dGhvcml0eUlkID0gcGVybWlzc2lvblJvdy5hdXRob3JpdHlJZDtcbiAgICAgICAgcmV0dXJuIHBlcm1pc3Npb25Sb2xlO1xuICAgIH1cblxuICAgIHJlbW92ZVBlcm1pc3Npb24ocGVybWlzc2lvblJvdzogUGVybWlzc2lvbkRpc3BsYXlNb2RlbCkge1xuICAgICAgICB0aGlzLm5vZGVQZXJtaXNzaW9uU2VydmljZS5yZW1vdmVQZXJtaXNzaW9uKHRoaXMuYWN0dWFsTm9kZSwgcGVybWlzc2lvblJvdykuc3Vic2NyaWJlKChub2RlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5vZGUpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHRoaXMuZXJyb3IuZW1pdChlcnJvcikpO1xuICAgIH1cblxufVxuIl19