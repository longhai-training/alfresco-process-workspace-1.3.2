/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, Input, ChangeDetectionStrategy, ViewEncapsulation } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { AlfrescoApiService } from '@alfresco/adf-core';
import { Site } from '@alfresco/js-api';
export class LibraryRoleColumnComponent {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
        this.displayText$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateValue();
        this.sub = this.api.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            /** @type {?} */
            const row = this.context.row;
            if (row) {
                const { entry } = row.node;
                if (entry === node) {
                    row.node = { entry };
                    this.updateValue();
                }
            }
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    updateValue() {
        /** @type {?} */
        const node = this.context.row.node;
        if (node && node.entry) {
            /** @type {?} */
            const role = node.entry.role;
            switch (role) {
                case Site.RoleEnum.SiteManager:
                    this.displayText$.next('LIBRARY.ROLE.MANAGER');
                    break;
                case Site.RoleEnum.SiteCollaborator:
                    this.displayText$.next('LIBRARY.ROLE.COLLABORATOR');
                    break;
                case Site.RoleEnum.SiteContributor:
                    this.displayText$.next('LIBRARY.ROLE.CONTRIBUTOR');
                    break;
                case Site.RoleEnum.SiteConsumer:
                    this.displayText$.next('LIBRARY.ROLE.CONSUMER');
                    break;
                default:
                    this.displayText$.next('');
                    break;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    }
}
LibraryRoleColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-library-role-column',
                template: `
        <span class="adf-datatable-cell-value" title="{{ (displayText$ | async) | translate }}">
            {{ (displayText$ | async) | translate }}
        </span>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-library-role-column adf-datatable-content-cell' }
            }] }
];
/** @nocollapse */
LibraryRoleColumnComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];
LibraryRoleColumnComponent.propDecorators = {
    context: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    LibraryRoleColumnComponent.prototype.context;
    /** @type {?} */
    LibraryRoleColumnComponent.prototype.displayText$;
    /**
     * @type {?}
     * @private
     */
    LibraryRoleColumnComponent.prototype.sub;
    /**
     * @type {?}
     * @private
     */
    LibraryRoleColumnComponent.prototype.api;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlicmFyeS1yb2xlLWNvbHVtbi5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJkb2N1bWVudC1saXN0L2NvbXBvbmVudHMvbGlicmFyeS1yb2xlLWNvbHVtbi9saWJyYXJ5LXJvbGUtY29sdW1uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQ0gsU0FBUyxFQUVULEtBQUssRUFDTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBRXBCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBZ0IsZUFBZSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3JELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3hELE9BQU8sRUFBbUIsSUFBSSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFjekQsTUFBTSxPQUFPLDBCQUEwQjs7OztJQVFuQyxZQUFvQixHQUF1QjtRQUF2QixRQUFHLEdBQUgsR0FBRyxDQUFvQjtRQUozQyxpQkFBWSxHQUFHLElBQUksZUFBZSxDQUFTLEVBQUUsQ0FBQyxDQUFDO0lBSUQsQ0FBQzs7OztJQUUvQyxRQUFRO1FBQ0osSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRW5CLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsU0FBUzs7OztRQUFDLENBQUMsSUFBVSxFQUFFLEVBQUU7O2tCQUMvQyxHQUFHLEdBQWlCLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRztZQUMxQyxJQUFJLEdBQUcsRUFBRTtzQkFDQyxFQUFFLEtBQUssRUFBRSxHQUFHLEdBQUcsQ0FBQyxJQUFJO2dCQUUxQixJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7b0JBQ2hCLEdBQUcsQ0FBQyxJQUFJLEdBQUcsRUFBRSxLQUFLLEVBQUUsQ0FBQztvQkFDckIsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2lCQUN0QjthQUNKO1FBQ0wsQ0FBQyxFQUFDLENBQUM7SUFDUCxDQUFDOzs7OztJQUVTLFdBQVc7O2NBQ1gsSUFBSSxHQUFjLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUk7UUFDN0MsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTs7a0JBQ2QsSUFBSSxHQUFXLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSTtZQUNwQyxRQUFRLElBQUksRUFBRTtnQkFDVixLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVztvQkFDMUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztvQkFDL0MsTUFBTTtnQkFDVixLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCO29CQUMvQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO29CQUNwRCxNQUFNO2dCQUNWLEtBQUssSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlO29CQUM5QixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO29CQUNuRCxNQUFNO2dCQUNWLEtBQUssSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZO29CQUMzQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO29CQUNoRCxNQUFNO2dCQUNWO29CQUNJLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUMzQixNQUFNO2FBQ2I7U0FDSjtJQUNMLENBQUM7Ozs7SUFFRCxXQUFXO1FBQ1AsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUN2QixJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztTQUNuQjtJQUNMLENBQUM7OztZQWxFSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHlCQUF5QjtnQkFDbkMsUUFBUSxFQUFFOzs7O0tBSVQ7Z0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07Z0JBQy9DLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsb0RBQW9ELEVBQUU7YUFDeEU7Ozs7WUFkUSxrQkFBa0I7OztzQkFnQnRCLEtBQUs7Ozs7SUFBTiw2Q0FDYTs7SUFFYixrREFBK0M7Ozs7O0lBRS9DLHlDQUEwQjs7Ozs7SUFFZCx5Q0FBK0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBPbkluaXQsXG4gICAgSW5wdXQsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXG4gICAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBOb2RlLCBTaXRlRW50cnksIFNpdGUgfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcbmltcG9ydCB7IFNoYXJlRGF0YVJvdyB9IGZyb20gJy4uLy4uL2RhdGEvc2hhcmUtZGF0YS1yb3cubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1saWJyYXJ5LXJvbGUtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c3BhbiBjbGFzcz1cImFkZi1kYXRhdGFibGUtY2VsbC12YWx1ZVwiIHRpdGxlPVwie3sgKGRpc3BsYXlUZXh0JCB8IGFzeW5jKSB8IHRyYW5zbGF0ZSB9fVwiPlxuICAgICAgICAgICAge3sgKGRpc3BsYXlUZXh0JCB8IGFzeW5jKSB8IHRyYW5zbGF0ZSB9fVxuICAgICAgICA8L3NwYW4+XG4gICAgYCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHsgY2xhc3M6ICdhZGYtbGlicmFyeS1yb2xlLWNvbHVtbiBhZGYtZGF0YXRhYmxlLWNvbnRlbnQtY2VsbCcgfVxufSlcbmV4cG9ydCBjbGFzcyBMaWJyYXJ5Um9sZUNvbHVtbkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBASW5wdXQoKVxuICAgIGNvbnRleHQ6IGFueTtcblxuICAgIGRpc3BsYXlUZXh0JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPignJyk7XG5cbiAgICBwcml2YXRlIHN1YjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGk6IEFsZnJlc2NvQXBpU2VydmljZSkge31cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG5cbiAgICAgICAgdGhpcy5zdWIgPSB0aGlzLmFwaS5ub2RlVXBkYXRlZC5zdWJzY3JpYmUoKG5vZGU6IE5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdzogU2hhcmVEYXRhUm93ID0gdGhpcy5jb250ZXh0LnJvdztcbiAgICAgICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVudHJ5IH0gPSByb3cubm9kZTtcblxuICAgICAgICAgICAgICAgIGlmIChlbnRyeSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByb3cubm9kZSA9IHsgZW50cnkgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVZhbHVlKCkge1xuICAgICAgICBjb25zdCBub2RlOiBTaXRlRW50cnkgPSB0aGlzLmNvbnRleHQucm93Lm5vZGU7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvbGU6IHN0cmluZyA9IG5vZGUuZW50cnkucm9sZTtcbiAgICAgICAgICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU2l0ZS5Sb2xlRW51bS5TaXRlTWFuYWdlcjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5VGV4dCQubmV4dCgnTElCUkFSWS5ST0xFLk1BTkFHRVInKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTaXRlLlJvbGVFbnVtLlNpdGVDb2xsYWJvcmF0b3I6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVRleHQkLm5leHQoJ0xJQlJBUlkuUk9MRS5DT0xMQUJPUkFUT1InKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTaXRlLlJvbGVFbnVtLlNpdGVDb250cmlidXRvcjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5VGV4dCQubmV4dCgnTElCUkFSWS5ST0xFLkNPTlRSSUJVVE9SJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU2l0ZS5Sb2xlRW51bS5TaXRlQ29uc3VtZXI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVRleHQkLm5leHQoJ0xJQlJBUlkuUk9MRS5DT05TVU1FUicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlUZXh0JC5uZXh0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ViKSB7XG4gICAgICAgICAgICB0aGlzLnN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19