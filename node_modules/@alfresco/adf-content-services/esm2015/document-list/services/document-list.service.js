/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AlfrescoApiService, ContentService, LogService } from '@alfresco/adf-core';
import { Injectable } from '@angular/core';
import { DocumentLoaderNode } from '../models/document-folder.model';
import { from, throwError, forkJoin } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { CustomResourcesService } from './custom-resources.service';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
import * as i2 from "./custom-resources.service";
export class DocumentListService {
    /**
     * @param {?} contentService
     * @param {?} apiService
     * @param {?} logService
     * @param {?} customResourcesService
     */
    constructor(contentService, apiService, logService, customResourcesService) {
        this.contentService = contentService;
        this.apiService = apiService;
        this.logService = logService;
        this.customResourcesService = customResourcesService;
    }
    /**
     * Deletes a node.
     * @param {?} nodeId ID of the node to delete
     * @return {?} Empty response when the operation is complete
     */
    deleteNode(nodeId) {
        return from(this.apiService.getInstance().nodes.deleteNode(nodeId));
    }
    /**
     * Copy a node to destination node
     *
     * @param {?} nodeId The id of the node to be copied
     * @param {?} targetParentId The id of the folder where the node will be copied
     * @return {?} NodeEntry for the copied node
     */
    copyNode(nodeId, targetParentId) {
        return from(this.apiService.getInstance().nodes.copyNode(nodeId, { targetParentId })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Moves a node to destination node.
     *
     * @param {?} nodeId The id of the node to be moved
     * @param {?} targetParentId The id of the folder where the node will be moved
     * @return {?} NodeEntry for the moved node
     */
    moveNode(nodeId, targetParentId) {
        return from(this.apiService.getInstance().nodes.moveNode(nodeId, { targetParentId })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the folder node with the specified relative name path below the root node.
     * @param {?} folder Path to folder.
     * @param {?=} opts Options.
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getFolder(folder, opts, includeFields = []) {
        /** @type {?} */
        let rootNodeId = DocumentListService.ROOT_ID;
        if (opts && opts.rootFolderId) {
            rootNodeId = opts.rootFolderId;
        }
        /** @type {?} */
        const includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        (element, index, array) => index === array.indexOf(element)));
        /** @type {?} */
        const params = {
            includeSource: true,
            include: includeFieldsRequest
        };
        if (folder) {
            params.relativePath = folder;
        }
        if (opts) {
            if (opts.maxItems) {
                params.maxItems = opts.maxItems;
            }
            if (opts.skipCount) {
                params.skipCount = opts.skipCount;
            }
            if (opts.where) {
                params.where = opts.where;
            }
        }
        return from(this.apiService.getInstance().nodes.getNodeChildren(rootNodeId, params)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a node via its node ID.
     * @param {?} nodeId ID of the target node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getNode(nodeId, includeFields = []) {
        /** @type {?} */
        const includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', ...includeFields]
            .filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        (element, index, array) => index === array.indexOf(element)));
        /** @type {?} */
        const opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return this.contentService.getNode(nodeId, opts);
    }
    /**
     * Gets a folder node via its node ID.
     * @param {?} nodeId ID of the folder node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getFolderNode(nodeId, includeFields = []) {
        /** @type {?} */
        const includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        (element, index, array) => index === array.indexOf(element)));
        /** @type {?} */
        const opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return from(this.apiService.getInstance().nodes.getNode(nodeId, opts)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    isCustomSourceService(nodeId) {
        return this.customResourcesService.isCustomSource(nodeId);
    }
    /**
     * @param {?} nodeId
     * @param {?} pagination
     * @param {?} includeFields
     * @param {?=} where
     * @return {?}
     */
    loadFolderByNodeId(nodeId, pagination, includeFields, where) {
        if (this.customResourcesService.isCustomSource(nodeId)) {
            return this.customResourcesService.loadFolderByNodeId(nodeId, pagination, includeFields).pipe(map((/**
             * @param {?} result
             * @return {?}
             */
            (result) => new DocumentLoaderNode(null, result))));
        }
        else {
            return this.retrieveDocumentNode(nodeId, pagination, includeFields, where);
        }
    }
    /**
     * @private
     * @param {?} nodeId
     * @param {?} pagination
     * @param {?} includeFields
     * @param {?=} where
     * @return {?}
     */
    retrieveDocumentNode(nodeId, pagination, includeFields, where) {
        return forkJoin(this.getFolderNode(nodeId, includeFields), this.getFolder(null, {
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount,
            rootFolderId: nodeId,
            where: where
        }, includeFields)).pipe(map((/**
         * @param {?} results
         * @return {?}
         */
        (results) => new DocumentLoaderNode(results[0], results[1]))));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
DocumentListService.ROOT_ID = '-root-';
DocumentListService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DocumentListService.ctorParameters = () => [
    { type: ContentService },
    { type: AlfrescoApiService },
    { type: LogService },
    { type: CustomResourcesService }
];
/** @nocollapse */ DocumentListService.ngInjectableDef = i0.defineInjectable({ factory: function DocumentListService_Factory() { return new DocumentListService(i0.inject(i1.ContentService), i0.inject(i1.AlfrescoApiService), i0.inject(i1.LogService), i0.inject(i2.CustomResourcesService)); }, token: DocumentListService, providedIn: "root" });
if (false) {
    /** @type {?} */
    DocumentListService.ROOT_ID;
    /**
     * @type {?}
     * @private
     */
    DocumentListService.prototype.contentService;
    /**
     * @type {?}
     * @private
     */
    DocumentListService.prototype.apiService;
    /**
     * @type {?}
     * @private
     */
    DocumentListService.prototype.logService;
    /**
     * @type {?}
     * @private
     */
    DocumentListService.prototype.customResourcesService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jdW1lbnQtbGlzdC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzLyIsInNvdXJjZXMiOlsiZG9jdW1lbnQtbGlzdC9zZXJ2aWNlcy9kb2N1bWVudC1saXN0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUNILGtCQUFrQixFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQ2pELE1BQU0sb0JBQW9CLENBQUM7QUFFNUIsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNyRSxPQUFPLEVBQWMsSUFBSSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDOUQsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVqRCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQzs7OztBQUtwRSxNQUFNLE9BQU8sbUJBQW1COzs7Ozs7O0lBSTVCLFlBQW9CLGNBQThCLEVBQzlCLFVBQThCLEVBQzlCLFVBQXNCLEVBQ3RCLHNCQUE4QztRQUg5QyxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsZUFBVSxHQUFWLFVBQVUsQ0FBb0I7UUFDOUIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QiwyQkFBc0IsR0FBdEIsc0JBQXNCLENBQXdCO0lBQ2xFLENBQUM7Ozs7OztJQU9ELFVBQVUsQ0FBQyxNQUFjO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7Ozs7Ozs7O0lBU0QsUUFBUSxDQUFDLE1BQWMsRUFBRSxjQUFzQjtRQUMz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SUFDdEMseUNBQThCOzs7OztJQUM5QixxREFBc0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIEFsZnJlc2NvQXBpU2VydmljZSwgQ29udGVudFNlcnZpY2UsIExvZ1NlcnZpY2UsIFBhZ2luYXRpb25Nb2RlbFxufSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOb2RlRW50cnksIE5vZGVQYWdpbmcgfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcbmltcG9ydCB7IERvY3VtZW50TG9hZGVyTm9kZSB9IGZyb20gJy4uL21vZGVscy9kb2N1bWVudC1mb2xkZXIubW9kZWwnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSwgdGhyb3dFcnJvciwgZm9ya0pvaW4gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERvY3VtZW50TGlzdExvYWRlciB9IGZyb20gJy4uL2ludGVyZmFjZXMvZG9jdW1lbnQtbGlzdC1sb2FkZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IEN1c3RvbVJlc291cmNlc1NlcnZpY2UgfSBmcm9tICcuL2N1c3RvbS1yZXNvdXJjZXMuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgRG9jdW1lbnRMaXN0U2VydmljZSBpbXBsZW1lbnRzIERvY3VtZW50TGlzdExvYWRlciB7XG5cbiAgICBzdGF0aWMgUk9PVF9JRCA9ICctcm9vdC0nO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBjb250ZW50U2VydmljZTogQ29udGVudFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY3VzdG9tUmVzb3VyY2VzU2VydmljZTogQ3VzdG9tUmVzb3VyY2VzU2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIG5vZGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybnMgRW1wdHkgcmVzcG9uc2Ugd2hlbiB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgZGVsZXRlTm9kZShub2RlSWQ6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm5vZGVzLmRlbGV0ZU5vZGUobm9kZUlkKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29weSBhIG5vZGUgdG8gZGVzdGluYXRpb24gbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVJZCBUaGUgaWQgb2YgdGhlIG5vZGUgdG8gYmUgY29waWVkXG4gICAgICogQHBhcmFtIHRhcmdldFBhcmVudElkIFRoZSBpZCBvZiB0aGUgZm9sZGVyIHdoZXJlIHRoZSBub2RlIHdpbGwgYmUgY29waWVkXG4gICAgICogQHJldHVybnMgTm9kZUVudHJ5IGZvciB0aGUgY29waWVkIG5vZGVcbiAgICAgKi9cbiAgICBjb3B5Tm9kZShub2RlSWQ6IHN0cmluZywgdGFyZ2V0UGFyZW50SWQ6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5ub2Rlcy5jb3B5Tm9kZShub2RlSWQsIHsgdGFyZ2V0UGFyZW50SWQgfSkpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKChlcnIpID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIG5vZGUgdG8gZGVzdGluYXRpb24gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgVGhlIGlkIG9mIHRoZSBub2RlIHRvIGJlIG1vdmVkXG4gICAgICogQHBhcmFtIHRhcmdldFBhcmVudElkIFRoZSBpZCBvZiB0aGUgZm9sZGVyIHdoZXJlIHRoZSBub2RlIHdpbGwgYmUgbW92ZWRcbiAgICAgKiBAcmV0dXJucyBOb2RlRW50cnkgZm9yIHRoZSBtb3ZlZCBub2RlXG4gICAgICovXG4gICAgbW92ZU5vZGUobm9kZUlkOiBzdHJpbmcsIHRhcmdldFBhcmVudElkOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkubm9kZXMubW92ZU5vZGUobm9kZUlkLCB7IHRhcmdldFBhcmVudElkIH0pKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZm9sZGVyIG5vZGUgd2l0aCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIG5hbWUgcGF0aCBiZWxvdyB0aGUgcm9vdCBub2RlLlxuICAgICAqIEBwYXJhbSBmb2xkZXIgUGF0aCB0byBmb2xkZXIuXG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gaW5jbHVkZUZpZWxkcyBFeHRyYSBpbmZvcm1hdGlvbiB0byBpbmNsdWRlIChhdmFpbGFibGUgb3B0aW9ucyBhcmUgXCJhc3BlY3ROYW1lc1wiLCBcImlzTGlua1wiIGFuZCBcImFzc29jaWF0aW9uXCIpXG4gICAgICogQHJldHVybnMgRGV0YWlscyBvZiB0aGUgZm9sZGVyXG4gICAgICovXG4gICAgZ2V0Rm9sZGVyKGZvbGRlcjogc3RyaW5nLCBvcHRzPzogYW55LCBpbmNsdWRlRmllbGRzOiBzdHJpbmdbXSA9IFtdKTogT2JzZXJ2YWJsZTxOb2RlUGFnaW5nPiB7XG4gICAgICAgIGxldCByb290Tm9kZUlkID0gRG9jdW1lbnRMaXN0U2VydmljZS5ST09UX0lEO1xuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLnJvb3RGb2xkZXJJZCkge1xuICAgICAgICAgICAgcm9vdE5vZGVJZCA9IG9wdHMucm9vdEZvbGRlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5jbHVkZUZpZWxkc1JlcXVlc3QgPSBbJ3BhdGgnLCAncHJvcGVydGllcycsICdhbGxvd2FibGVPcGVyYXRpb25zJywgJ3Blcm1pc3Npb25zJywgJ2FzcGVjdE5hbWVzJywgLi4uaW5jbHVkZUZpZWxkc11cbiAgICAgICAgICAgIC5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gaW5kZXggPT09IGFycmF5LmluZGV4T2YoZWxlbWVudCkpO1xuXG4gICAgICAgIGNvbnN0IHBhcmFtczogYW55ID0ge1xuICAgICAgICAgICAgaW5jbHVkZVNvdXJjZTogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1ZGU6IGluY2x1ZGVGaWVsZHNSZXF1ZXN0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZvbGRlcikge1xuICAgICAgICAgICAgcGFyYW1zLnJlbGF0aXZlUGF0aCA9IGZvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5tYXhJdGVtcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5tYXhJdGVtcyA9IG9wdHMubWF4SXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5za2lwQ291bnQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2tpcENvdW50ID0gb3B0cy5za2lwQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy53aGVyZSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy53aGVyZSA9IG9wdHMud2hlcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5ub2Rlcy5nZXROb2RlQ2hpbGRyZW4ocm9vdE5vZGVJZCwgcGFyYW1zKSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBub2RlIHZpYSBpdHMgbm9kZSBJRC5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEBwYXJhbSBpbmNsdWRlRmllbGRzIEV4dHJhIGluZm9ybWF0aW9uIHRvIGluY2x1ZGUgKGF2YWlsYWJsZSBvcHRpb25zIGFyZSBcImFzcGVjdE5hbWVzXCIsIFwiaXNMaW5rXCIgYW5kIFwiYXNzb2NpYXRpb25cIilcbiAgICAgKiBAcmV0dXJucyBEZXRhaWxzIG9mIHRoZSBmb2xkZXJcbiAgICAgKi9cbiAgICBnZXROb2RlKG5vZGVJZDogc3RyaW5nLCBpbmNsdWRlRmllbGRzOiBzdHJpbmdbXSA9IFtdKTogT2JzZXJ2YWJsZTxOb2RlRW50cnk+IHtcblxuICAgICAgICBjb25zdCBpbmNsdWRlRmllbGRzUmVxdWVzdCA9IFsncGF0aCcsICdwcm9wZXJ0aWVzJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnLCAncGVybWlzc2lvbnMnLCAuLi5pbmNsdWRlRmllbGRzXVxuICAgICAgICAgICAgLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBpbmRleCA9PT0gYXJyYXkuaW5kZXhPZihlbGVtZW50KSk7XG5cbiAgICAgICAgY29uc3Qgb3B0czogYW55ID0ge1xuICAgICAgICAgICAgaW5jbHVkZVNvdXJjZTogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1ZGU6IGluY2x1ZGVGaWVsZHNSZXF1ZXN0XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFNlcnZpY2UuZ2V0Tm9kZShub2RlSWQsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBmb2xkZXIgbm9kZSB2aWEgaXRzIG5vZGUgSUQuXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgZm9sZGVyIG5vZGVcbiAgICAgKiBAcGFyYW0gaW5jbHVkZUZpZWxkcyBFeHRyYSBpbmZvcm1hdGlvbiB0byBpbmNsdWRlIChhdmFpbGFibGUgb3B0aW9ucyBhcmUgXCJhc3BlY3ROYW1lc1wiLCBcImlzTGlua1wiIGFuZCBcImFzc29jaWF0aW9uXCIpXG4gICAgICogQHJldHVybnMgRGV0YWlscyBvZiB0aGUgZm9sZGVyXG4gICAgICovXG4gICAgZ2V0Rm9sZGVyTm9kZShub2RlSWQ6IHN0cmluZywgaW5jbHVkZUZpZWxkczogc3RyaW5nW10gPSBbXSk6IE9ic2VydmFibGU8Tm9kZUVudHJ5PiB7XG5cbiAgICAgICAgY29uc3QgaW5jbHVkZUZpZWxkc1JlcXVlc3QgPSBbJ3BhdGgnLCAncHJvcGVydGllcycsICdhbGxvd2FibGVPcGVyYXRpb25zJywgJ3Blcm1pc3Npb25zJywgJ2FzcGVjdE5hbWVzJywgLi4uaW5jbHVkZUZpZWxkc11cbiAgICAgICAgICAgIC5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gaW5kZXggPT09IGFycmF5LmluZGV4T2YoZWxlbWVudCkpO1xuXG4gICAgICAgIGNvbnN0IG9wdHM6IGFueSA9IHtcbiAgICAgICAgICAgIGluY2x1ZGVTb3VyY2U6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlRmllbGRzUmVxdWVzdFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm5vZGVzLmdldE5vZGUobm9kZUlkLCBvcHRzKSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlzQ3VzdG9tU291cmNlU2VydmljZShub2RlSWQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tUmVzb3VyY2VzU2VydmljZS5pc0N1c3RvbVNvdXJjZShub2RlSWQpO1xuICAgIH1cblxuICAgIGxvYWRGb2xkZXJCeU5vZGVJZChub2RlSWQ6IHN0cmluZywgcGFnaW5hdGlvbjogUGFnaW5hdGlvbk1vZGVsLCBpbmNsdWRlRmllbGRzOiBzdHJpbmdbXSwgd2hlcmU/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPERvY3VtZW50TG9hZGVyTm9kZT4ge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21SZXNvdXJjZXNTZXJ2aWNlLmlzQ3VzdG9tU291cmNlKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbVJlc291cmNlc1NlcnZpY2UubG9hZEZvbGRlckJ5Tm9kZUlkKG5vZGVJZCwgcGFnaW5hdGlvbiwgaW5jbHVkZUZpZWxkcykucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHJlc3VsdDogYW55KSA9PiBuZXcgRG9jdW1lbnRMb2FkZXJOb2RlKG51bGwsIHJlc3VsdCkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVEb2N1bWVudE5vZGUobm9kZUlkLCBwYWdpbmF0aW9uLCBpbmNsdWRlRmllbGRzLCB3aGVyZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJldHJpZXZlRG9jdW1lbnROb2RlKG5vZGVJZDogc3RyaW5nLCBwYWdpbmF0aW9uOiBQYWdpbmF0aW9uTW9kZWwsIGluY2x1ZGVGaWVsZHM6IHN0cmluZ1tdLCB3aGVyZT86IHN0cmluZyk6IE9ic2VydmFibGU8RG9jdW1lbnRMb2FkZXJOb2RlPiB7XG4gICAgICAgIHJldHVybiBmb3JrSm9pbihcbiAgICAgICAgICAgIHRoaXMuZ2V0Rm9sZGVyTm9kZShub2RlSWQsIGluY2x1ZGVGaWVsZHMpLFxuICAgICAgICAgICAgdGhpcy5nZXRGb2xkZXIobnVsbCwge1xuICAgICAgICAgICAgICAgIG1heEl0ZW1zOiBwYWdpbmF0aW9uLm1heEl0ZW1zLFxuICAgICAgICAgICAgICAgIHNraXBDb3VudDogcGFnaW5hdGlvbi5za2lwQ291bnQsXG4gICAgICAgICAgICAgICAgcm9vdEZvbGRlcklkOiBub2RlSWQsXG4gICAgICAgICAgICAgICAgd2hlcmU6IHdoZXJlXG4gICAgICAgICAgICB9LCBpbmNsdWRlRmllbGRzKSkucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHJlc3VsdHMpID0+IG5ldyBEb2N1bWVudExvYWRlck5vZGUocmVzdWx0c1swXSwgcmVzdWx0c1sxXSkpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlRXJyb3IoZXJyb3I6IGFueSkge1xuICAgICAgICB0aGlzLmxvZ1NlcnZpY2UuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciB8fCAnU2VydmVyIGVycm9yJyk7XG4gICAgfVxufVxuIl19