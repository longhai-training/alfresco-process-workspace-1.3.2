/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation } from '@angular/core';
import { FormControl, Validators, FormGroup } from '@angular/forms';
import { LiveErrorStateMatcher } from '../../forms/live-error-state-matcher';
export class SearchNumberRangeComponent {
    constructor() {
        this.matcher = new LiveErrorStateMatcher();
        this.format = '[{FROM} TO {TO}]';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.field = this.settings.field;
            this.format = this.settings.format || '[{FROM} TO {TO}]';
        }
        this.validators = Validators.compose([
            Validators.required,
            Validators.pattern(/^-?(0|[1-9]\d*)?$/),
            Validators.min(0)
        ]);
        this.from = new FormControl('', this.validators);
        this.to = new FormControl('', this.validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        }, this.formValidator);
    }
    /**
     * @param {?} formGroup
     * @return {?}
     */
    formValidator(formGroup) {
        return parseInt(formGroup.get('from').value, 10) < parseInt(formGroup.get('to').value, 10) ? null : { 'mismatch': true };
    }
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    apply(model, isValid) {
        if (isValid && this.id && this.context && this.field) {
            /** @type {?} */
            const map = new Map();
            map.set('FROM', model.from);
            map.set('TO', model.to);
            /** @type {?} */
            const value = this.formatString(this.format, map);
            this.context.queryFragments[this.id] = `${this.field}:${value}`;
            this.context.update();
        }
    }
    /**
     * @private
     * @param {?} str
     * @param {?} map
     * @return {?}
     */
    formatString(str, map) {
        /** @type {?} */
        let result = str;
        map.forEach((/**
         * @param {?} value
         * @param {?} key
         * @return {?}
         */
        (value, key) => {
            /** @type {?} */
            const expr = new RegExp('{' + key + '}', 'gm');
            result = result.replace(expr, value);
        }));
        return result;
    }
    /**
     * @return {?}
     */
    reset() {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    }
}
SearchNumberRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-number-range',
                template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"from\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM' | translate }}\"\n            autocomplete=\"off\"\n            data-automation-id=\"number-range-from-input\">\n        <mat-error *ngIf=\"from.hasError('pattern') || from.hasError('min')\" data-automation-id=\"number-range-from-error-invalid\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"from.hasError('required')\" data-automation-id=\"number-range-from-error-required\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"to\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO' | translate }}\"\n            autocomplete=\"off\"\n            data-automation-id=\"number-range-to-input\">\n        <mat-error *ngIf=\"to.hasError('pattern') || to.hasError('min')\" data-automation-id=\"number-range-to-error-invalid\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"to.hasError('required')\" data-automation-id=\"number-range-to-error-required\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n\n    <div class=\"adf-facet-buttons\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\" data-automation-id=\"number-range-btn-clear\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\" data-automation-id=\"number-range-btn-apply\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-number-range' },
                styles: [".adf-search-number-range>form{display:inline-flex;flex-direction:column;width:100%}"]
            }] }
];
if (false) {
    /** @type {?} */
    SearchNumberRangeComponent.prototype.from;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.to;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.form;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.matcher;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.id;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.settings;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.context;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.field;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.format;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.validators;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLW51bWJlci1yYW5nZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJzZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtbnVtYmVyLXJhbmdlL3NlYXJjaC1udW1iZXItcmFuZ2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBVSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFJcEUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFTN0UsTUFBTSxPQUFPLDBCQUEwQjtJQVB2QztRQWFJLFlBQU8sR0FBRyxJQUFJLHFCQUFxQixFQUFFLENBQUM7UUFPdEMsV0FBTSxHQUFHLGtCQUFrQixDQUFDO0lBaUVoQyxDQUFDOzs7O0lBN0RHLFFBQVE7UUFFSixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDZixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksa0JBQWtCLENBQUM7U0FDNUQ7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUM7WUFDakMsVUFBVSxDQUFDLFFBQVE7WUFDbkIsVUFBVSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztZQUN2QyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNwQixDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksV0FBVyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFD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OztJQUVwQywyQ0FBYzs7SUFDZCw0Q0FBNEI7O0lBRTVCLGdEQUF1QiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE9uSW5pdCwgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIFZhbGlkYXRvcnMsIEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFNlYXJjaFdpZGdldCB9IGZyb20gJy4uLy4uL3NlYXJjaC13aWRnZXQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaFdpZGdldFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC1zZXR0aW5ncy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoUXVlcnlCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlYXJjaC1xdWVyeS1idWlsZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGl2ZUVycm9yU3RhdGVNYXRjaGVyIH0gZnJvbSAnLi4vLi4vZm9ybXMvbGl2ZS1lcnJvci1zdGF0ZS1tYXRjaGVyJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtc2VhcmNoLW51bWJlci1yYW5nZScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NlYXJjaC1udW1iZXItcmFuZ2UuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3NlYXJjaC1udW1iZXItcmFuZ2UuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHsgY2xhc3M6ICdhZGYtc2VhcmNoLW51bWJlci1yYW5nZScgfVxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hOdW1iZXJSYW5nZUNvbXBvbmVudCBpbXBsZW1lbnRzIFNlYXJjaFdpZGdldCwgT25Jbml0IHtcblxuICAgIGZyb206IEZvcm1Db250cm9sO1xuICAgIHRvOiBGb3JtQ29udHJvbDtcblxuICAgIGZvcm06IEZvcm1Hcm91cDtcbiAgICBtYXRjaGVyID0gbmV3IExpdmVFcnJvclN0YXRlTWF0Y2hlcigpO1xuXG4gICAgaWQ6IHN0cmluZztcbiAgICBzZXR0aW5ncz86IFNlYXJjaFdpZGdldFNldHRpbmdzO1xuICAgIGNvbnRleHQ/OiBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlO1xuXG4gICAgZmllbGQ6IHN0cmluZztcbiAgICBmb3JtYXQgPSAnW3tGUk9NfSBUTyB7VE99XSc7XG5cbiAgICB2YWxpZGF0b3JzOiBWYWxpZGF0b3JzO1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSB0aGlzLnNldHRpbmdzLmZpZWxkO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSB0aGlzLnNldHRpbmdzLmZvcm1hdCB8fCAnW3tGUk9NfSBUTyB7VE99XSc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbGlkYXRvcnMgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW1xuICAgICAgICAgICAgVmFsaWRhdG9ycy5yZXF1aXJlZCxcbiAgICAgICAgICAgIFZhbGlkYXRvcnMucGF0dGVybigvXi0/KDB8WzEtOV1cXGQqKT8kLyksXG4gICAgICAgICAgICBWYWxpZGF0b3JzLm1pbigwKVxuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLmZyb20gPSBuZXcgRm9ybUNvbnRyb2woJycsIHRoaXMudmFsaWRhdG9ycyk7XG4gICAgICAgIHRoaXMudG8gPSBuZXcgRm9ybUNvbnRyb2woJycsIHRoaXMudmFsaWRhdG9ycyk7XG5cbiAgICAgICAgdGhpcy5mb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICB0bzogdGhpcy50b1xuICAgICAgICB9LCB0aGlzLmZvcm1WYWxpZGF0b3IpO1xuICAgIH1cblxuICAgIGZvcm1WYWxpZGF0b3IoZm9ybUdyb3VwOiBGb3JtR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGZvcm1Hcm91cC5nZXQoJ2Zyb20nKS52YWx1ZSwgMTApIDwgcGFyc2VJbnQoZm9ybUdyb3VwLmdldCgndG8nKS52YWx1ZSwgMTApID8gbnVsbCA6IHsnbWlzbWF0Y2gnOiB0cnVlfTtcbiAgICB9XG5cbiAgICBhcHBseShtb2RlbDogeyBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcgfSwgaXNWYWxpZDogYm9vbGVhbikge1xuICAgICAgICBpZiAoaXNWYWxpZCAmJiB0aGlzLmlkICYmIHRoaXMuY29udGV4dCAmJiB0aGlzLmZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgICAgICAgICAgbWFwLnNldCgnRlJPTScsIG1vZGVsLmZyb20pO1xuICAgICAgICAgICAgbWFwLnNldCgnVE8nLCBtb2RlbC50byk7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5mb3JtYXRTdHJpbmcodGhpcy5mb3JtYXQsIG1hcCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9IGAke3RoaXMuZmllbGR9OiR7dmFsdWV9YDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZm9ybWF0U3RyaW5nKHN0cjogc3RyaW5nLCBtYXA6IE1hcDxzdHJpbmcsIHN0cmluZz4pOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RyO1xuXG4gICAgICAgIG1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHByID0gbmV3IFJlZ0V4cCgneycgKyBrZXkgKyAnfScsICdnbScpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoZXhwciwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmZvcm0ucmVzZXQoe1xuICAgICAgICAgICAgZnJvbTogJycsXG4gICAgICAgICAgICB0bzogJydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucXVlcnlGcmFnbWVudHNbdGhpcy5pZF0gPSAnJztcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==