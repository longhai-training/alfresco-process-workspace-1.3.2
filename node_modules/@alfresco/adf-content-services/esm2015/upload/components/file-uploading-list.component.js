/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { FileUploadStatus, NodesApiService, TranslationService, UploadService } from '@alfresco/adf-core';
import { Component, ContentChild, Input, Output, TemplateRef, EventEmitter } from '@angular/core';
import { forkJoin, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
export class FileUploadingListComponent {
    /**
     * @param {?} uploadService
     * @param {?} nodesApi
     * @param {?} translateService
     */
    constructor(uploadService, nodesApi, translateService) {
        this.uploadService = uploadService;
        this.nodesApi = nodesApi;
        this.translateService = translateService;
        this.FileUploadStatus = FileUploadStatus;
        this.files = [];
        /**
         * Emitted when a file in the list has an error.
         */
        this.error = new EventEmitter();
    }
    /**
     * Cancel file upload
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to cancel upload for.
     *
     * @return {?}
     */
    cancelFile(file) {
        this.uploadService.cancelUpload(file);
    }
    /**
     * Remove uploaded file
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to remove upload for.
     *
     * @return {?}
     */
    removeFile(file) {
        this.deleteNode(file).subscribe((/**
         * @return {?}
         */
        () => {
            if (file.status === FileUploadStatus.Error) {
                this.notifyError(file);
            }
            this.cancelNodeVersionInstances(file);
            this.uploadService.cancelUpload(file);
        }));
    }
    /**
     * Call the appropriate method for each file, depending on state
     * @return {?}
     */
    cancelAllFiles() {
        this.getUploadingFiles().forEach((/**
         * @param {?} file
         * @return {?}
         */
        (file) => this.uploadService.cancelUpload(file)));
        /** @type {?} */
        const deletedFiles = this.files
            .filter((/**
         * @param {?} file
         * @return {?}
         */
        (file) => file.status === FileUploadStatus.Complete))
            .map((/**
         * @param {?} file
         * @return {?}
         */
        (file) => this.deleteNode(file)));
        forkJoin(...deletedFiles).subscribe((/**
         * @param {?} files
         * @return {?}
         */
        (files) => {
            /** @type {?} */
            const errors = files.filter((/**
             * @param {?} file
             * @return {?}
             */
            (file) => file.status === FileUploadStatus.Error));
            if (errors.length) {
                this.notifyError(...errors);
            }
            this.uploadService.cancelUpload(...files);
        }));
    }
    /**
     * Checks if all the files are uploaded false if there is at least one file in Progress | Starting | Pending
     * @return {?}
     */
    isUploadCompleted() {
        return (!this.isUploadCancelled() &&
            Boolean(this.files.length) &&
            !this.files.some((/**
             * @param {?} __0
             * @return {?}
             */
            ({ status }) => status === FileUploadStatus.Starting ||
                status === FileUploadStatus.Progress ||
                status === FileUploadStatus.Pending)));
    }
    /**
     * Check if all the files are Cancelled | Aborted | Error. false if there is at least one file in uploading states
     * @return {?}
     */
    isUploadCancelled() {
        return (!!this.files.length &&
            this.files.every((/**
             * @param {?} __0
             * @return {?}
             */
            ({ status }) => status === FileUploadStatus.Aborted ||
                status === FileUploadStatus.Cancelled ||
                status === FileUploadStatus.Deleted)));
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    deleteNode(file) {
        const { id } = file.data.entry;
        return this.nodesApi.deleteNode(id, { permanent: true }).pipe(map((/**
         * @return {?}
         */
        () => {
            file.status = FileUploadStatus.Deleted;
            return file;
        })), catchError((/**
         * @return {?}
         */
        () => {
            file.status = FileUploadStatus.Error;
            return of(file);
        })));
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    cancelNodeVersionInstances(file) {
        this.files
            .filter((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.data.entry.id === file.data.entry.id &&
            item.options.newVersion))
            .map((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            item.status = FileUploadStatus.Deleted;
        }));
    }
    /**
     * @private
     * @param {...?} files
     * @return {?}
     */
    notifyError(...files) {
        /** @type {?} */
        let messageError = null;
        if (files.length === 1) {
            messageError = this.translateService.instant('FILE_UPLOAD.MESSAGES.REMOVE_FILE_ERROR', { fileName: files[0].name });
        }
        else {
            messageError = this.translateService.instant('FILE_UPLOAD.MESSAGES.REMOVE_FILES_ERROR', { total: files.length });
        }
        this.error.emit(messageError);
    }
    /**
     * @private
     * @return {?}
     */
    getUploadingFiles() {
        return this.files.filter((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (item.status === FileUploadStatus.Pending ||
                item.status === FileUploadStatus.Progress ||
                item.status === FileUploadStatus.Starting) {
                return item;
            }
        }));
    }
}
FileUploadingListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-list',
                template: "<div class=\"upload-list\">\n    <ng-template\n        ngFor\n        [ngForOf]=\"files\"\n        [ngForTemplate]=\"template\">\n    </ng-template>\n</div>\n",
                styles: [":host{display:flex;flex-direction:column}"]
            }] }
];
/** @nocollapse */
FileUploadingListComponent.ctorParameters = () => [
    { type: UploadService },
    { type: NodesApiService },
    { type: TranslationService }
];
FileUploadingListComponent.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    files: [{ type: Input }],
    error: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    FileUploadingListComponent.prototype.FileUploadStatus;
    /** @type {?} */
    FileUploadingListComponent.prototype.template;
    /** @type {?} */
    FileUploadingListComponent.prototype.files;
    /**
     * Emitted when a file in the list has an error.
     * @type {?}
     */
    FileUploadingListComponent.prototype.error;
    /**
     * @type {?}
     * @private
     */
    FileUploadingListComponent.prototype.uploadService;
    /**
     * @type {?}
     * @private
     */
    FileUploadingListComponent.prototype.nodesApi;
    /**
     * @type {?}
     * @private
     */
    FileUploadingListComponent.prototype.translateService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS11cGxvYWRpbmctbGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJ1cGxvYWQvY29tcG9uZW50cy9maWxlLXVwbG9hZGluZy1saXN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBRUgsZ0JBQWdCLEVBQ2hCLGVBQWUsRUFDZixrQkFBa0IsRUFDbEIsYUFBYSxFQUNoQixNQUFNLG9CQUFvQixDQUFDO0FBQzVCLE9BQU8sRUFDSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLEtBQUssRUFDTCxNQUFNLEVBQ04sV0FBVyxFQUNYLFlBQVksRUFDZixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQWMsUUFBUSxFQUFFLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNoRCxPQUFPLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBT2pELE1BQU0sT0FBTywwQkFBMEI7Ozs7OztJQWFuQyxZQUNZLGFBQTRCLEVBQzVCLFFBQXlCLEVBQ3pCLGdCQUFvQztRQUZwQyxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUM1QixhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUN6QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQW9CO1FBZmhELHFCQUFnQixHQUFHLGdCQUFnQixDQUFDO1FBTXBDLFVBQUssR0FBZ0IsRUFBRSxDQUFDOzs7O1FBSXhCLFVBQUssR0FBc0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztJQU0zQyxDQUFDOzs7Ozs7Ozs7SUFTSixVQUFVLENBQUMsSUFBZTtRQUN0QixJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQyxDQUFDOzs7Ozs7Ozs7SUFTRCxVQUFVLENBQUMsSUFBZTtRQUN0QixJQUFJLENBQUMsVUFBVSxDQUFDLElB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Ozs7O1FBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUM5QixJQUNJLElBQUksQ0FBQyxNQUFNLEtBQUssZ0JBQWdCLENBQUMsT0FBTztnQkFDeEMsSUFBSSxDQUFDLE1BQU0sS0FBSyxnQkFBZ0IsQ0FBQyxRQUFRO2dCQUN6QyxJQUFJLENBQUMsTUFBTSxLQUFLLGdCQUFnQixDQUFDLFFBQVEsRUFDM0M7Z0JBQ0UsT0FBTyxJQUFJLENBQUM7YUFDZjtRQUNMLENBQUMsRUFBQyxDQUFDO0lBQ1AsQ0FBQzs7O1lBcEtKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUseUJBQXlCO2dCQUNuQywwS0FBbUQ7O2FBRXREOzs7O1lBakJHLGFBQWE7WUFGYixlQUFlO1lBQ2Ysa0JBQWtCOzs7dUJBc0JqQixZQUFZLFNBQUMsV0FBVztvQkFHeEIsS0FBSztvQkFJTCxNQUFNOzs7O0lBVFAsc0RBQW9DOztJQUVwQyw4Q0FDYzs7SUFFZCwyQ0FDd0I7Ozs7O0lBR3hCLDJDQUM4Qzs7Ozs7SUFHMUMsbURBQW9DOzs7OztJQUNwQyw4Q0FBaUM7Ozs7O0lBQ2pDLHNEQUE0QyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgRmlsZU1vZGVsLFxuICAgIEZpbGVVcGxvYWRTdGF0dXMsXG4gICAgTm9kZXNBcGlTZXJ2aWNlLFxuICAgIFRyYW5zbGF0aW9uU2VydmljZSxcbiAgICBVcGxvYWRTZXJ2aWNlXG59IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIEV2ZW50RW1pdHRlclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGZvcmtKb2luLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1maWxlLXVwbG9hZGluZy1saXN0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmlsZS11cGxvYWRpbmctbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vZmlsZS11cGxvYWRpbmctbGlzdC5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIEZpbGVVcGxvYWRpbmdMaXN0Q29tcG9uZW50IHtcbiAgICBGaWxlVXBsb2FkU3RhdHVzID0gRmlsZVVwbG9hZFN0YXR1cztcblxuICAgIEBDb250ZW50Q2hpbGQoVGVtcGxhdGVSZWYpXG4gICAgdGVtcGxhdGU6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgZmlsZXM6IEZpbGVNb2RlbFtdID0gW107XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgZmlsZSBpbiB0aGUgbGlzdCBoYXMgYW4gZXJyb3IuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgdXBsb2FkU2VydmljZTogVXBsb2FkU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBub2Rlc0FwaTogTm9kZXNBcGlTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0aW9uU2VydmljZVxuICAgICkge31cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBmaWxlIHVwbG9hZFxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgRmlsZSBtb2RlbCB0byBjYW5jZWwgdXBsb2FkIGZvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBGaWxlVXBsb2FkaW5nTGlzdENvbXBvbmVudFxuICAgICAqL1xuICAgIGNhbmNlbEZpbGUoZmlsZTogRmlsZU1vZGVsKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBsb2FkU2VydmljZS5jYW5jZWxVcGxvYWQoZmlsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHVwbG9hZGVkIGZpbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlIEZpbGUgbW9kZWwgdG8gcmVtb3ZlIHVwbG9hZCBmb3IuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRmlsZVVwbG9hZGluZ0xpc3RDb21wb25lbnRcbiAgICAgKi9cbiAgICByZW1vdmVGaWxlKGZpbGU6IEZpbGVNb2RlbCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRlbGV0ZU5vZGUoZmlsZSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxlLnN0YXR1cyA9PT0gRmlsZVVwbG9hZFN0YXR1cy5FcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5RXJyb3IoZmlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2FuY2VsTm9kZVZlcnNpb25JbnN0YW5jZXMoZmlsZSk7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuY2FuY2VsVXBsb2FkKGZpbGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgZm9yIGVhY2ggZmlsZSwgZGVwZW5kaW5nIG9uIHN0YXRlXG4gICAgICovXG4gICAgY2FuY2VsQWxsRmlsZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2V0VXBsb2FkaW5nRmlsZXMoKS5mb3JFYWNoKChmaWxlKSA9PlxuICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLmNhbmNlbFVwbG9hZChmaWxlKVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWRGaWxlcyA9IHRoaXMuZmlsZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKGZpbGUpID0+IGZpbGUuc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkNvbXBsZXRlKVxuICAgICAgICAgICAgLm1hcCgoZmlsZSkgPT4gdGhpcy5kZWxldGVOb2RlKGZpbGUpKTtcblxuICAgICAgICBmb3JrSm9pbiguLi5kZWxldGVkRmlsZXMpLnN1YnNjcmliZSgoZmlsZXM6IEZpbGVNb2RlbFtdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBmaWxlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKGZpbGUpID0+IGZpbGUuc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkVycm9yXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5RXJyb3IoLi4uZXJyb3JzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLmNhbmNlbFVwbG9hZCguLi5maWxlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbGwgdGhlIGZpbGVzIGFyZSB1cGxvYWRlZCBmYWxzZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZmlsZSBpbiBQcm9ncmVzcyB8IFN0YXJ0aW5nIHwgUGVuZGluZ1xuICAgICAqL1xuICAgIGlzVXBsb2FkQ29tcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgIXRoaXMuaXNVcGxvYWRDYW5jZWxsZWQoKSAmJlxuICAgICAgICAgICAgQm9vbGVhbih0aGlzLmZpbGVzLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICF0aGlzLmZpbGVzLnNvbWUoXG4gICAgICAgICAgICAgICAgKHsgc3RhdHVzIH0pID0+XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9PT0gRmlsZVVwbG9hZFN0YXR1cy5TdGFydGluZyB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuUHJvZ3Jlc3MgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLlBlbmRpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbGwgdGhlIGZpbGVzIGFyZSBDYW5jZWxsZWQgfCBBYm9ydGVkIHwgRXJyb3IuIGZhbHNlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBmaWxlIGluIHVwbG9hZGluZyBzdGF0ZXNcbiAgICAgKi9cbiAgICBpc1VwbG9hZENhbmNlbGxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICEhdGhpcy5maWxlcy5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMuZmlsZXMuZXZlcnkoXG4gICAgICAgICAgICAgICAgKHsgc3RhdHVzIH0pID0+XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9PT0gRmlsZVVwbG9hZFN0YXR1cy5BYm9ydGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9PT0gRmlsZVVwbG9hZFN0YXR1cy5DYW5jZWxsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkRlbGV0ZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlbGV0ZU5vZGUoZmlsZTogRmlsZU1vZGVsKTogT2JzZXJ2YWJsZTxGaWxlTW9kZWw+IHtcbiAgICAgICAgY29uc3QgeyBpZCB9ID0gZmlsZS5kYXRhLmVudHJ5O1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzQXBpLmRlbGV0ZU5vZGUoaWQsIHsgcGVybWFuZW50OiB0cnVlIH0pLnBpcGUoXG4gICAgICAgICAgICBtYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZpbGUuc3RhdHVzID0gRmlsZVVwbG9hZFN0YXR1cy5EZWxldGVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjYXRjaEVycm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmaWxlLnN0YXR1cyA9IEZpbGVVcGxvYWRTdGF0dXMuRXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKGZpbGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbmNlbE5vZGVWZXJzaW9uSW5zdGFuY2VzKGZpbGUpIHtcbiAgICAgICAgdGhpcy5maWxlc1xuICAgICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAgICAgICAoaXRlbSkgPT5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kYXRhLmVudHJ5LmlkID09PSBmaWxlLmRhdGEuZW50cnkuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5vcHRpb25zLm5ld1ZlcnNpb25cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9IEZpbGVVcGxvYWRTdGF0dXMuRGVsZXRlZDtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgbm90aWZ5RXJyb3IoLi4uZmlsZXM6IEZpbGVNb2RlbFtdKSB7XG4gICAgICAgIGxldCBtZXNzYWdlRXJyb3I6IHN0cmluZyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbWVzc2FnZUVycm9yID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoXG4gICAgICAgICAgICAgICAgJ0ZJTEVfVVBMT0FELk1FU1NBR0VTLlJFTU9WRV9GSUxFX0VSUk9SJyxcbiAgICAgICAgICAgICAgICB7IGZpbGVOYW1lOiBmaWxlc1swXS5uYW1lIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlRXJyb3IgPSB0aGlzLnRyYW5zbGF0ZVNlcnZpY2UuaW5zdGFudChcbiAgICAgICAgICAgICAgICAnRklMRV9VUExPQUQuTUVTU0FHRVMuUkVNT1ZFX0ZJTEVTX0VSUk9SJyxcbiAgICAgICAgICAgICAgICB7IHRvdGFsOiBmaWxlcy5sZW5ndGggfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXJyb3IuZW1pdChtZXNzYWdlRXJyb3IpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VXBsb2FkaW5nRmlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLlBlbmRpbmcgfHxcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gRmlsZVVwbG9hZFN0YXR1cy5Qcm9ncmVzcyB8fFxuICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLlN0YXJ0aW5nXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19