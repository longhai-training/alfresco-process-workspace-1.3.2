/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation } from '@angular/core';
import { FormControl, Validators, FormGroup } from '@angular/forms';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { MomentDateAdapter, MOMENT_DATE_FORMATS } from '@alfresco/adf-core';
import { LiveErrorStateMatcher } from '../../forms/live-error-state-matcher';
import { UserPreferencesService, UserPreferenceValues } from '@alfresco/adf-core';
/** @type {?} */
var DEFAULT_FORMAT_DATE = 'DD/MM/YYYY';
var ɵ0 = MOMENT_DATE_FORMATS;
var SearchDateRangeComponent = /** @class */ (function () {
    function SearchDateRangeComponent(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.matcher = new LiveErrorStateMatcher();
        this.datePickerDateFormat = DEFAULT_FORMAT_DATE;
    }
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.getFromValidationMessage = /**
     * @return {?}
     */
    function () {
        return this.from.hasError('invalidOnChange') || this.hasParseError(this.from) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.from.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                this.from.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                    '';
    };
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.getToValidationMessage = /**
     * @return {?}
     */
    function () {
        return this.to.hasError('invalidOnChange') || this.hasParseError(this.to) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.to.hasError('matDatepickerMin') ? 'SEARCH.FILTER.VALIDATION.NO-DAYS' :
                this.to.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                    this.to.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                        '';
    };
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.settings) {
            this.datePickerDateFormat = this.settings.dateFormat || DEFAULT_FORMAT_DATE;
        }
        /** @type {?} */
        var theCustomDateAdapter = (/** @type {?} */ ((/** @type {?} */ (this.dateAdapter))));
        theCustomDateAdapter.overrideDisplayFormat = this.datePickerDateFormat;
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        function (locale) {
            _this.setLocale(locale);
        }));
        /** @type {?} */
        var validators = Validators.compose([
            Validators.required
        ]);
        this.from = new FormControl('', validators);
        this.to = new FormControl('', validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        });
        this.maxDate = this.dateAdapter.today().startOf('day');
    };
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    SearchDateRangeComponent.prototype.apply = /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    function (model, isValid) {
        if (isValid && this.id && this.context && this.settings && this.settings.field) {
            /** @type {?} */
            var start = moment(model.from).startOf('day').format();
            /** @type {?} */
            var end = moment(model.to).endOf('day').format();
            this.context.queryFragments[this.id] = this.settings.field + ":['" + start + "' TO '" + end + "']";
            this.context.update();
        }
    };
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    };
    /**
     * @param {?} event
     * @param {?} formControl
     * @return {?}
     */
    SearchDateRangeComponent.prototype.onChangedHandler = /**
     * @param {?} event
     * @param {?} formControl
     * @return {?}
     */
    function (event, formControl) {
        /** @type {?} */
        var inputValue = event.srcElement.value;
        /** @type {?} */
        var formatDate = this.dateAdapter.parse(inputValue, this.datePickerDateFormat);
        if (formatDate && formatDate.isValid()) {
            formControl.setValue(formatDate);
        }
        else if (formatDate) {
            formControl.setErrors({
                'invalidOnChange': true
            });
        }
        else {
            formControl.setErrors({
                'required': true
            });
        }
    };
    /**
     * @param {?} locale
     * @return {?}
     */
    SearchDateRangeComponent.prototype.setLocale = /**
     * @param {?} locale
     * @return {?}
     */
    function (locale) {
        this.dateAdapter.setLocale(locale);
        moment.locale(locale);
    };
    /**
     * @param {?} formControl
     * @return {?}
     */
    SearchDateRangeComponent.prototype.hasParseError = /**
     * @param {?} formControl
     * @return {?}
     */
    function (formControl) {
        return formControl.hasError('matDatepickerParse') && formControl.getError('matDatepickerParse').text;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchDateRangeComponent.prototype.forcePlaceholder = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.srcElement.click();
    };
    SearchDateRangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-date-range',
                    template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"from\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM-DATE' | translate }}\"\n                [matDatepicker]=\"fromDatepicker\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, from)\"\n                data-automation-id=\"date-range-from-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"fromDatepicker\" data-automation-id=\"date-range-from-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #fromDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"from.invalid\" data-automation-id=\"date-range-from-error\">\n            {{ getFromValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"to\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO-DATE' | translate }}\"\n                [matDatepicker]=\"toDatepicker\"\n                [min]=\"from.value\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, to)\"\n                data-automation-id=\"date-range-to-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"toDatepicker\" data-automation-id=\"date-range-to-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #toDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"to.invalid\" data-automation-id=\"date-range-to-error\">\n            {{ getToValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <div class=\"adf-facet-buttons adf-facet-buttons--topSpace\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\" data-automation-id=\"date-range-clear-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\" data-automation-id=\"date-range-apply-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                    providers: [
                        { provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                        { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                    ],
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-date-range' },
                    styles: [".adf-search-date-range>form{display:inline-flex;flex-direction:column;width:100%}"]
                }] }
    ];
    /** @nocollapse */
    SearchDateRangeComponent.ctorParameters = function () { return [
        { type: DateAdapter },
        { type: UserPreferencesService }
    ]; };
    return SearchDateRangeComponent;
}());
export { SearchDateRangeComponent };
if (false) {
    /** @type {?} */
    SearchDateRangeComponent.prototype.from;
    /** @type {?} */
    SearchDateRangeComponent.prototype.to;
    /** @type {?} */
    SearchDateRangeComponent.prototype.form;
    /** @type {?} */
    SearchDateRangeComponent.prototype.matcher;
    /** @type {?} */
    SearchDateRangeComponent.prototype.id;
    /** @type {?} */
    SearchDateRangeComponent.prototype.settings;
    /** @type {?} */
    SearchDateRangeComponent.prototype.context;
    /** @type {?} */
    SearchDateRangeComponent.prototype.maxDate;
    /** @type {?} */
    SearchDateRangeComponent.prototype.datePickerDateFormat;
    /**
     * @type {?}
     * @private
     */
    SearchDateRangeComponent.prototype.dateAdapter;
    /**
     * @type {?}
     * @private
     */
    SearchDateRangeComponent.prototype.userPreferencesService;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzLyIsInNvdXJjZXMiOlsic2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLWRhdGUtcmFuZ2Uvc2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBVSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEUsT0FBTyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUs1RSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUU3RSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7SUFJNUUsbUJBQW1CLEdBQVcsWUFBWTtTQVFGLG1CQUFtQjtBQU5qRTtJQXlCSSxrQ0FBb0IsV0FBZ0MsRUFDaEMsc0JBQThDO1FBRDlDLGdCQUFXLEdBQVgsV0FBVyxDQUFxQjtRQUNoQywyQkFBc0IsR0FBdEIsc0JBQXNCLENBQXdCO1FBVGxFLFlBQU8sR0FBRyxJQUFJLHFCQUFxQixFQUFFLENBQUM7UUFNdEMseUJBQW9CLEdBQUcsbUJBQW1CLENBQUM7SUFJM0MsQ0FBQzs7OztJQUVELDJEQUF3Qjs7O0lBQXhCO1FBQ0ksT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FB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aWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBPbkluaXQsIENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBWYWxpZGF0b3JzLCBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBEYXRlQWRhcHRlciwgTUFUX0RBVEVfRk9STUFUUywgTUFUX0RBVEVfTE9DQUxFIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XG5pbXBvcnQgeyBNb21lbnREYXRlQWRhcHRlciwgTU9NRU5UX0RBVEVfRk9STUFUUyB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbmltcG9ydCB7IFNlYXJjaFdpZGdldCB9IGZyb20gJy4uLy4uL3NlYXJjaC13aWRnZXQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaFdpZGdldFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC1zZXR0aW5ncy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoUXVlcnlCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlYXJjaC1xdWVyeS1idWlsZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGl2ZUVycm9yU3RhdGVNYXRjaGVyIH0gZnJvbSAnLi4vLi4vZm9ybXMvbGl2ZS1lcnJvci1zdGF0ZS1tYXRjaGVyJztcbmltcG9ydCB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlLCBVc2VyUHJlZmVyZW5jZVZhbHVlcyB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbmRlY2xhcmUgbGV0IG1vbWVudDogYW55O1xuXG5jb25zdCBERUZBVUxUX0ZPUk1BVF9EQVRFOiBzdHJpbmcgPSAnREQvTU0vWVlZWSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXNlYXJjaC1kYXRlLXJhbmdlJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3NlYXJjaC1kYXRlLXJhbmdlLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBEYXRlQWRhcHRlciwgdXNlQ2xhc3M6IE1vbWVudERhdGVBZGFwdGVyLCBkZXBzOiBbTUFUX0RBVEVfTE9DQUxFXX0sXG4gICAgICAgIHtwcm92aWRlOiBNQVRfREFURV9GT1JNQVRTLCB1c2VWYWx1ZTogTU9NRU5UX0RBVEVfRk9STUFUU31cbiAgICBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDogeyBjbGFzczogJ2FkZi1zZWFyY2gtZGF0ZS1yYW5nZScgfVxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQgaW1wbGVtZW50cyBTZWFyY2hXaWRnZXQsIE9uSW5pdCB7XG5cbiAgICBmcm9tOiBGb3JtQ29udHJvbDtcbiAgICB0bzogRm9ybUNvbnRyb2w7XG5cbiAgICBmb3JtOiBGb3JtR3JvdXA7XG4gICAgbWF0Y2hlciA9IG5ldyBMaXZlRXJyb3JTdGF0ZU1hdGNoZXIoKTtcblxuICAgIGlkOiBzdHJpbmc7XG4gICAgc2V0dGluZ3M/OiBTZWFyY2hXaWRnZXRTZXR0aW5ncztcbiAgICBjb250ZXh0PzogU2VhcmNoUXVlcnlCdWlsZGVyU2VydmljZTtcbiAgICBtYXhEYXRlOiBhbnk7XG4gICAgZGF0ZVBpY2tlckRhdGVGb3JtYXQgPSBERUZBVUxUX0ZPUk1BVF9EQVRFO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8TW9tZW50PixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHVzZXJQcmVmZXJlbmNlc1NlcnZpY2U6IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UpIHtcbiAgICB9XG5cbiAgICBnZXRGcm9tVmFsaWRhdGlvbk1lc3NhZ2UoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbS5oYXNFcnJvcignaW52YWxpZE9uQ2hhbmdlJykgfHwgdGhpcy5oYXNQYXJzZUVycm9yKHRoaXMuZnJvbSkgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLklOVkFMSUQtREFURScgOlxuICAgICAgICAgICAgdGhpcy5mcm9tLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyTWF4JykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLkJFWU9ORC1NQVgtREFURScgOlxuICAgICAgICAgICAgdGhpcy5mcm9tLmhhc0Vycm9yKCdyZXF1aXJlZCcpID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5SRVFVSVJFRC1WQUxVRScgOlxuICAgICAgICAgICAgJyc7XG4gICAgfVxuXG4gICAgZ2V0VG9WYWxpZGF0aW9uTWVzc2FnZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50by5oYXNFcnJvcignaW52YWxpZE9uQ2hhbmdlJykgfHwgdGhpcy5oYXNQYXJzZUVycm9yKHRoaXMudG8pID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5JTlZBTElELURBVEUnIDpcbiAgICAgICAgICAgIHRoaXMudG8uaGFzRXJyb3IoJ21hdERhdGVwaWNrZXJNaW4nKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uTk8tREFZUycgOlxuICAgICAgICAgICAgdGhpcy50by5oYXNFcnJvcignbWF0RGF0ZXBpY2tlck1heCcpID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5CRVlPTkQtTUFYLURBVEUnIDpcbiAgICAgICAgICAgIHRoaXMudG8uaGFzRXJyb3IoJ3JlcXVpcmVkJykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLlJFUVVJUkVELVZBTFVFJyA6XG4gICAgICAgICAgICAnJztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZVBpY2tlckRhdGVGb3JtYXQgPSB0aGlzLnNldHRpbmdzLmRhdGVGb3JtYXQgfHwgREVGQVVMVF9GT1JNQVRfREFURTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGVDdXN0b21EYXRlQWRhcHRlciA9IDxNb21lbnREYXRlQWRhcHRlcj4gPGFueT4gdGhpcy5kYXRlQWRhcHRlcjtcbiAgICAgICAgdGhlQ3VzdG9tRGF0ZUFkYXB0ZXIub3ZlcnJpZGVEaXNwbGF5Rm9ybWF0ID0gdGhpcy5kYXRlUGlja2VyRGF0ZUZvcm1hdDtcblxuICAgICAgICB0aGlzLnVzZXJQcmVmZXJlbmNlc1NlcnZpY2Uuc2VsZWN0KFVzZXJQcmVmZXJlbmNlVmFsdWVzLkxvY2FsZSkuc3Vic2NyaWJlKChsb2NhbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW1xuICAgICAgICAgICAgVmFsaWRhdG9ycy5yZXF1aXJlZFxuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLmZyb20gPSBuZXcgRm9ybUNvbnRyb2woJycsIHZhbGlkYXRvcnMpO1xuICAgICAgICB0aGlzLnRvID0gbmV3IEZvcm1Db250cm9sKCcnLCB2YWxpZGF0b3JzKTtcblxuICAgICAgICB0aGlzLmZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWF4RGF0ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIudG9kYXkoKS5zdGFydE9mKCdkYXknKTtcbiAgICB9XG5cbiAgICBhcHBseShtb2RlbDogeyBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcgfSwgaXNWYWxpZDogYm9vbGVhbikge1xuICAgICAgICBpZiAoaXNWYWxpZCAmJiB0aGlzLmlkICYmIHRoaXMuY29udGV4dCAmJiB0aGlzLnNldHRpbmdzICYmIHRoaXMuc2V0dGluZ3MuZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbW9tZW50KG1vZGVsLmZyb20pLnN0YXJ0T2YoJ2RheScpLmZvcm1hdCgpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gbW9tZW50KG1vZGVsLnRvKS5lbmRPZignZGF5JykuZm9ybWF0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9IGAke3RoaXMuc2V0dGluZ3MuZmllbGR9OlsnJHtzdGFydH0nIFRPICcke2VuZH0nXWA7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5mb3JtLnJlc2V0KHtcbiAgICAgICAgICAgIGZyb206ICcnLFxuICAgICAgICAgICAgdG86ICcnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5pZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DaGFuZ2VkSGFuZGxlcihldmVudDogYW55LCBmb3JtQ29udHJvbDogRm9ybUNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgaW5wdXRWYWx1ZSA9IGV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XG5cbiAgICAgICAgY29uc3QgZm9ybWF0RGF0ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIucGFyc2UoaW5wdXRWYWx1ZSwgdGhpcy5kYXRlUGlja2VyRGF0ZUZvcm1hdCk7XG4gICAgICAgIGlmIChmb3JtYXREYXRlICYmIGZvcm1hdERhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICBmb3JtQ29udHJvbC5zZXRWYWx1ZShmb3JtYXREYXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXREYXRlKSB7XG4gICAgICAgICAgICBmb3JtQ29udHJvbC5zZXRFcnJvcnMoe1xuICAgICAgICAgICAgICAgICdpbnZhbGlkT25DaGFuZ2UnOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1Db250cm9sLnNldEVycm9ycyh7XG4gICAgICAgICAgICAgICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgICAgIHRoaXMuZGF0ZUFkYXB0ZXIuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgICAgIG1vbWVudC5sb2NhbGUobG9jYWxlKTtcbiAgICB9XG5cbiAgICBoYXNQYXJzZUVycm9yKGZvcm1Db250cm9sKSB7XG4gICAgICAgIHJldHVybiBmb3JtQ29udHJvbC5oYXNFcnJvcignbWF0RGF0ZXBpY2tlclBhcnNlJykgJiYgZm9ybUNvbnRyb2wuZ2V0RXJyb3IoJ21hdERhdGVwaWNrZXJQYXJzZScpLnRleHQ7XG4gICAgfVxuXG4gICAgZm9yY2VQbGFjZWhvbGRlcihldmVudDogYW55KSB7XG4gICAgICAgIGV2ZW50LnNyY0VsZW1lbnQuY2xpY2soKTtcbiAgICB9XG5cbn1cbiJdfQ==