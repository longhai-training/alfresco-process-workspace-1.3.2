/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { FileModel } from '@alfresco/adf-core';
import { EventEmitter, Input, Output } from '@angular/core';
import { UploadFilesEvent } from '../upload-files.event';
/**
 * @abstract
 */
var UploadBase = /** @class */ (function () {
    function UploadBase(uploadService, translationService, ngZone) {
        this.uploadService = uploadService;
        this.translationService = translationService;
        this.ngZone = ngZone;
        /**
         * The ID of the root. Use the nodeId for
         * Content Services or the taskId/processId for Process Services.
         */
        this.rootFolderId = '-root-';
        /**
         * Toggles component disabled state (if there is no node permission checking).
         */
        this.disabled = false;
        /**
         * Filter for accepted file types.
         */
        this.acceptedFilesType = '*';
        /**
         * Toggles versioning.
         */
        this.versioning = false;
        /**
         * majorVersion boolean field to true to indicate a major version should be created.
         */
        this.majorVersion = false;
        /**
         * Custom node type for uploaded file
         */
        this.nodeType = 'cm:content';
        /**
         * Emitted when the file is uploaded successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the upload begins.
         */
        this.beginUpload = new EventEmitter();
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    UploadBase.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.uploadService.fileUploadError.subscribe((/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            _this.error.emit(error);
        })));
    };
    /**
     * @return {?}
     */
    UploadBase.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        function (subscription) { return subscription.unsubscribe(); }));
        this.subscriptions = [];
    };
    /**
     * Upload a list of file in the specified path
     * @param files
     * @param path
     */
    /**
     * Upload a list of file in the specified path
     * @param {?} files
     * @return {?}
     */
    UploadBase.prototype.uploadFiles = /**
     * Upload a list of file in the specified path
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        /** @type {?} */
        var filteredFiles = files
            .map((/**
         * @param {?} file
         * @return {?}
         */
        function (file) {
            return _this.createFileModel(file, _this.rootFolderId, (((/** @type {?} */ (file))).webkitRelativePath || '').replace(/\/[^\/]*$/, ''));
        }));
        this.uploadQueue(filteredFiles);
    };
    /**
     * @param {?} files
     * @return {?}
     */
    UploadBase.prototype.uploadFilesInfo = /**
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        /** @type {?} */
        var filteredFiles = files
            .map((/**
         * @param {?} fileInfo
         * @return {?}
         */
        function (fileInfo) {
            return _this.createFileModel(fileInfo.file, _this.rootFolderId, fileInfo.relativeFolder);
        }));
        this.uploadQueue(filteredFiles);
    };
    /**
     * @private
     * @param {?} files
     * @return {?}
     */
    UploadBase.prototype.uploadQueue = /**
     * @private
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        /** @type {?} */
        var filteredFiles = files
            .filter(this.isFileAcceptable.bind(this))
            .filter(this.isFileSizeAcceptable.bind(this));
        this.ngZone.run((/**
         * @return {?}
         */
        function () {
            var _a;
            /** @type {?} */
            var event = new UploadFilesEvent(tslib_1.__spread(filteredFiles), _this.uploadService, _this.success);
            _this.beginUpload.emit(event);
            if (!event.defaultPrevented) {
                if (filteredFiles.length > 0) {
                    (_a = _this.uploadService).addToQueue.apply(_a, tslib_1.__spread(filteredFiles));
                    _this.uploadService.uploadFilesInTheQueue(_this.success);
                }
            }
        }));
    };
    /**
     * Checks if the given file is allowed by the extension filters
     *
     * @param file FileModel
     */
    /**
     * Checks if the given file is allowed by the extension filters
     *
     * @protected
     * @param {?} file FileModel
     * @return {?}
     */
    UploadBase.prototype.isFileAcceptable = /**
     * Checks if the given file is allowed by the extension filters
     *
     * @protected
     * @param {?} file FileModel
     * @return {?}
     */
    function (file) {
        if (this.acceptedFilesType === '*') {
            return true;
        }
        /** @type {?} */
        var allowedExtensions = this.acceptedFilesType
            .split(',')
            .map((/**
         * @param {?} ext
         * @return {?}
         */
        function (ext) { return ext.trim().replace(/^\./, ''); }));
        if (allowedExtensions.indexOf(file.extension) !== -1) {
            return true;
        }
        return false;
    };
    /**
     * Creates FileModel from File
     *
     * @param file
     */
    /**
     * Creates FileModel from File
     *
     * @protected
     * @param {?} file
     * @param {?} parentId
     * @param {?} path
     * @param {?=} id
     * @return {?}
     */
    UploadBase.prototype.createFileModel = /**
     * Creates FileModel from File
     *
     * @protected
     * @param {?} file
     * @param {?} parentId
     * @param {?} path
     * @param {?=} id
     * @return {?}
     */
    function (file, parentId, path, id) {
        return new FileModel(file, {
            comment: this.comment,
            majorVersion: this.majorVersion,
            newVersion: this.versioning,
            parentId: parentId,
            path: path,
            nodeType: this.nodeType
        }, id);
    };
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    UploadBase.prototype.isFileSizeAllowed = /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    function (file) {
        /** @type {?} */
        var isFileSizeAllowed = true;
        if (this.isMaxFileSizeDefined()) {
            isFileSizeAllowed = this.isFileSizeCorrect(file);
        }
        return isFileSizeAllowed;
    };
    /**
     * @protected
     * @return {?}
     */
    UploadBase.prototype.isMaxFileSizeDefined = /**
     * @protected
     * @return {?}
     */
    function () {
        return this.maxFilesSize !== undefined && this.maxFilesSize !== null;
    };
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    UploadBase.prototype.isFileSizeCorrect = /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    function (file) {
        return this.maxFilesSize >= 0 && file.size <= this.maxFilesSize;
    };
    /**
     * Checks if the given file is an acceptable size
     *
     * @param file FileModel
     */
    /**
     * Checks if the given file is an acceptable size
     *
     * @private
     * @param {?} file FileModel
     * @return {?}
     */
    UploadBase.prototype.isFileSizeAcceptable = /**
     * Checks if the given file is an acceptable size
     *
     * @private
     * @param {?} file FileModel
     * @return {?}
     */
    function (file) {
        /** @type {?} */
        var acceptableSize = true;
        if (!this.isFileSizeAllowed(file)) {
            acceptableSize = false;
            /** @type {?} */
            var message = this.translationService.instant('FILE_UPLOAD.MESSAGES.EXCEED_MAX_FILE_SIZE', { fileName: file.name });
            this.error.emit(message);
        }
        return acceptableSize;
    };
    UploadBase.propDecorators = {
        maxFilesSize: [{ type: Input }],
        rootFolderId: [{ type: Input }],
        disabled: [{ type: Input }],
        acceptedFilesType: [{ type: Input }],
        versioning: [{ type: Input }],
        majorVersion: [{ type: Input }],
        comment: [{ type: Input }],
        nodeType: [{ type: Input }],
        success: [{ type: Output }],
        error: [{ type: Output }],
        beginUpload: [{ type: Output }]
    };
    return UploadBase;
}());
export { UploadBase };
if (false) {
    /**
     * Sets a limit on the maximum size (in bytes) of a file to be uploaded.
     * Has no effect if undefined.
     * @type {?}
     */
    UploadBase.prototype.maxFilesSize;
    /**
     * The ID of the root. Use the nodeId for
     * Content Services or the taskId/processId for Process Services.
     * @type {?}
     */
    UploadBase.prototype.rootFolderId;
    /**
     * Toggles component disabled state (if there is no node permission checking).
     * @type {?}
     */
    UploadBase.prototype.disabled;
    /**
     * Filter for accepted file types.
     * @type {?}
     */
    UploadBase.prototype.acceptedFilesType;
    /**
     * Toggles versioning.
     * @type {?}
     */
    UploadBase.prototype.versioning;
    /**
     * majorVersion boolean field to true to indicate a major version should be created.
     * @type {?}
     */
    UploadBase.prototype.majorVersion;
    /**
     * When you overwrite existing content, you can use the comment field to add a version comment that appears in the version history
     * @type {?}
     */
    UploadBase.prototype.comment;
    /**
     * Custom node type for uploaded file
     * @type {?}
     */
    UploadBase.prototype.nodeType;
    /**
     * Emitted when the file is uploaded successfully.
     * @type {?}
     */
    UploadBase.prototype.success;
    /**
     * Emitted when an error occurs.
     * @type {?}
     */
    UploadBase.prototype.error;
    /**
     * Emitted when the upload begins.
     * @type {?}
     */
    UploadBase.prototype.beginUpload;
    /**
     * @type {?}
     * @protected
     */
    UploadBase.prototype.subscriptions;
    /**
     * @type {?}
     * @protected
     */
    UploadBase.prototype.uploadService;
    /**
     * @type {?}
     * @protected
     */
    UploadBase.prototype.translationService;
    /**
     * @type {?}
     * @protected
     */
    UploadBase.prototype.ngZone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBsb2FkLWJhc2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJ1cGxvYWQvY29tcG9uZW50cy9iYXNlLXVwbG9hZC91cGxvYWQtYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLFNBQVMsRUFBWSxNQUFNLG9CQUFvQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBNkIsTUFBTSxlQUFlLENBQUM7QUFHdkYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7QUFFekQ7SUFvREksb0JBQXNCLGFBQTRCLEVBQzVCLGtCQUFzQyxFQUN0QyxNQUFjO1FBRmQsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN0QyxXQUFNLEdBQU4sTUFBTSxDQUFROzs7OztRQTFDcEMsaUJBQVksR0FBVyxRQUFRLENBQUM7Ozs7UUFJaEMsYUFBUSxHQUFZLEtBQUssQ0FBQzs7OztRQUkxQixzQkFBaUIsR0FBVyxHQUFHLENBQUM7Ozs7UUFJaEMsZUFBVSxHQUFZLEtBQUssQ0FBQzs7OztRQUk1QixpQkFBWSxHQUFZLEtBQUssQ0FBQzs7OztRQVE5QixhQUFRLEdBQVcsWUFBWSxDQUFDOzs7O1FBSWhDLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDOzs7O1FBSTdCLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDOzs7O1FBSTNCLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQW9CLENBQUM7UUFFekMsa0JBQWEsR0FBbUIsRUFBRSxDQUFDO0lBSzdDLENBQUM7Ozs7SUFFRCw2QkFBUTs7O0lBQVI7UUFBQSxpQkFPQztRQU5HLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNuQixJQUFJLENBQUMsYUFBYSxD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QUFDO0lBRUQ7Ozs7T0FJRzs7Ozs7Ozs7SUFDSyx5Q0FBb0I7Ozs7Ozs7SUFBNUIsVUFBNkIsSUFBZTs7WUFDcEMsY0FBYyxHQUFHLElBQUk7UUFFekIsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMvQixjQUFjLEdBQUcsS0FBSyxDQUFDOztnQkFFakIsT0FBTyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQzNDLDJDQUEyQyxFQUMzQyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQzFCO1lBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDNUI7UUFFRCxPQUFPLGNBQWMsQ0FBQztJQUMxQixDQUFDOzsrQkF6TEEsS0FBSzsrQkFNTCxLQUFLOzJCQUlMLEtBQUs7b0NBSUwsS0FBSzs2QkFJTCxLQUFLOytCQUlMLEtBQUs7MEJBSUwsS0FBSzsyQkFJTCxLQUFLOzBCQUlMLE1BQU07d0JBSU4sTUFBTTs4QkFJTixNQUFNOztJQWlKWCxpQkFBQztDQUFBLEFBaE1ELElBZ01DO1NBaE1xQixVQUFVOzs7Ozs7O0lBSzVCLGtDQUNxQjs7Ozs7O0lBS3JCLGtDQUNnQzs7Ozs7SUFHaEMsOEJBQzBCOzs7OztJQUcxQix1Q0FDZ0M7Ozs7O0lBR2hDLGdDQUM0Qjs7Ozs7SUFHNUIsa0NBQzhCOzs7OztJQUc5Qiw2QkFDZ0I7Ozs7O0lBR2hCLDhCQUNnQzs7Ozs7SUFHaEMsNkJBQzZCOzs7OztJQUc3QiwyQkFDMkI7Ozs7O0lBRzNCLGlDQUNtRDs7Ozs7SUFFbkQsbUNBQTZDOzs7OztJQUVqQyxtQ0FBc0M7Ozs7O0lBQ3RDLHdDQUFnRDs7Ozs7SUFDaEQsNEJBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlsZU1vZGVsLCBGaWxlSW5mbyB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIE9uSW5pdCwgT25EZXN0cm95LCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwbG9hZFNlcnZpY2UsIFRyYW5zbGF0aW9uU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFVwbG9hZEZpbGVzRXZlbnQgfSBmcm9tICcuLi91cGxvYWQtZmlsZXMuZXZlbnQnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVXBsb2FkQmFzZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKiBTZXRzIGEgbGltaXQgb24gdGhlIG1heGltdW0gc2l6ZSAoaW4gYnl0ZXMpIG9mIGEgZmlsZSB0byBiZSB1cGxvYWRlZC5cbiAgICAgKiBIYXMgbm8gZWZmZWN0IGlmIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heEZpbGVzU2l6ZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBJRCBvZiB0aGUgcm9vdC4gVXNlIHRoZSBub2RlSWQgZm9yXG4gICAgICogQ29udGVudCBTZXJ2aWNlcyBvciB0aGUgdGFza0lkL3Byb2Nlc3NJZCBmb3IgUHJvY2VzcyBTZXJ2aWNlcy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvb3RGb2xkZXJJZDogc3RyaW5nID0gJy1yb290LSc7XG5cbiAgICAvKiogVG9nZ2xlcyBjb21wb25lbnQgZGlzYWJsZWQgc3RhdGUgKGlmIHRoZXJlIGlzIG5vIG5vZGUgcGVybWlzc2lvbiBjaGVja2luZykuICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEZpbHRlciBmb3IgYWNjZXB0ZWQgZmlsZSB0eXBlcy4gKi9cbiAgICBASW5wdXQoKVxuICAgIGFjY2VwdGVkRmlsZXNUeXBlOiBzdHJpbmcgPSAnKic7XG5cbiAgICAvKiogVG9nZ2xlcyB2ZXJzaW9uaW5nLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmVyc2lvbmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIG1ham9yVmVyc2lvbiBib29sZWFuIGZpZWxkIHRvIHRydWUgdG8gaW5kaWNhdGUgYSBtYWpvciB2ZXJzaW9uIHNob3VsZCBiZSBjcmVhdGVkLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWFqb3JWZXJzaW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogV2hlbiB5b3Ugb3ZlcndyaXRlIGV4aXN0aW5nIGNvbnRlbnQsIHlvdSBjYW4gdXNlIHRoZSBjb21tZW50IGZpZWxkIHRvIGFkZCBhIHZlcnNpb24gY29tbWVudCB0aGF0IGFwcGVhcnMgaW4gdGhlIHZlcnNpb24gaGlzdG9yeSAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29tbWVudDogc3RyaW5nO1xuXG4gICAgLyoqIEN1c3RvbSBub2RlIHR5cGUgZm9yIHVwbG9hZGVkIGZpbGUgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vZGVUeXBlOiBzdHJpbmcgPSAnY206Y29udGVudCc7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBmaWxlIGlzIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBzdWNjZXNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3IgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSB1cGxvYWQgYmVnaW5zLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGJlZ2luVXBsb2FkID0gbmV3IEV2ZW50RW1pdHRlcjxVcGxvYWRGaWxlc0V2ZW50PigpO1xuXG4gICAgcHJvdGVjdGVkIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgdXBsb2FkU2VydmljZTogVXBsb2FkU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgdHJhbnNsYXRpb25TZXJ2aWNlOiBUcmFuc2xhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIG5nWm9uZTogTmdab25lKSB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLmZpbGVVcGxvYWRFcnJvci5zdWJzY3JpYmUoKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvci5lbWl0KGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YnNjcmlwdGlvbikgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBsaXN0IG9mIGZpbGUgaW4gdGhlIHNwZWNpZmllZCBwYXRoXG4gICAgICogQHBhcmFtIGZpbGVzXG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKi9cbiAgICB1cGxvYWRGaWxlcyhmaWxlczogRmlsZVtdKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRmlsZXM6IEZpbGVNb2RlbFtdID0gZmlsZXNcbiAgICAgICAgICAgIC5tYXA8RmlsZU1vZGVsPigoZmlsZTogRmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZpbGVNb2RlbChmaWxlLCB0aGlzLnJvb3RGb2xkZXJJZCwgKCg8YW55PiBmaWxlKS53ZWJraXRSZWxhdGl2ZVBhdGggfHwgJycpLnJlcGxhY2UoL1xcL1teXFwvXSokLywgJycpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudXBsb2FkUXVldWUoZmlsdGVyZWRGaWxlcyk7XG4gICAgfVxuXG4gICAgdXBsb2FkRmlsZXNJbmZvKGZpbGVzOiBGaWxlSW5mb1tdKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRmlsZXM6IEZpbGVNb2RlbFtdID0gZmlsZXNcbiAgICAgICAgICAgIC5tYXA8RmlsZU1vZGVsPigoZmlsZUluZm86IEZpbGVJbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRmlsZU1vZGVsKGZpbGVJbmZvLmZpbGUsIHRoaXMucm9vdEZvbGRlcklkLCBmaWxlSW5mby5yZWxhdGl2ZUZvbGRlcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnVwbG9hZFF1ZXVlKGZpbHRlcmVkRmlsZXMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBsb2FkUXVldWUoZmlsZXM6IEZpbGVNb2RlbFtdKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRmlsZXMgPSBmaWxlc1xuICAgICAgICAgICAgLmZpbHRlcih0aGlzLmlzRmlsZUFjY2VwdGFibGUuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5maWx0ZXIodGhpcy5pc0ZpbGVTaXplQWNjZXB0YWJsZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgVXBsb2FkRmlsZXNFdmVudChcbiAgICAgICAgICAgICAgICBbLi4uZmlsdGVyZWRGaWxlc10sXG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuYmVnaW5VcGxvYWQuZW1pdChldmVudCk7XG5cbiAgICAgICAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZEZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLmFkZFRvUXVldWUoLi4uZmlsdGVyZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBsb2FkU2VydmljZS51cGxvYWRGaWxlc0luVGhlUXVldWUodGhpcy5zdWNjZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZmlsZSBpcyBhbGxvd2VkIGJ5IHRoZSBleHRlbnNpb24gZmlsdGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgRmlsZU1vZGVsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGlzRmlsZUFjY2VwdGFibGUoZmlsZTogRmlsZU1vZGVsKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmFjY2VwdGVkRmlsZXNUeXBlID09PSAnKicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWxsb3dlZEV4dGVuc2lvbnMgPSB0aGlzLmFjY2VwdGVkRmlsZXNUeXBlXG4gICAgICAgICAgICAuc3BsaXQoJywnKVxuICAgICAgICAgICAgLm1hcCgoZXh0KSA9PiBleHQudHJpbSgpLnJlcGxhY2UoL15cXC4vLCAnJykpO1xuXG4gICAgICAgIGlmIChhbGxvd2VkRXh0ZW5zaW9ucy5pbmRleE9mKGZpbGUuZXh0ZW5zaW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgRmlsZU1vZGVsIGZyb20gRmlsZVxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlRmlsZU1vZGVsKGZpbGU6IEZpbGUsIHBhcmVudElkOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgaWQ/OiBzdHJpbmcpOiBGaWxlTW9kZWwge1xuICAgICAgICByZXR1cm4gbmV3IEZpbGVNb2RlbChmaWxlLCB7XG4gICAgICAgICAgICBjb21tZW50OiB0aGlzLmNvbW1lbnQsXG4gICAgICAgICAgICBtYWpvclZlcnNpb246IHRoaXMubWFqb3JWZXJzaW9uLFxuICAgICAgICAgICAgbmV3VmVyc2lvbjogdGhpcy52ZXJzaW9uaW5nLFxuICAgICAgICAgICAgcGFyZW50SWQ6IHBhcmVudElkLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIG5vZGVUeXBlOiB0aGlzLm5vZGVUeXBlXG4gICAgICAgIH0sIGlkKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaXNGaWxlU2l6ZUFsbG93ZWQoZmlsZTogRmlsZU1vZGVsKSB7XG4gICAgICAgIGxldCBpc0ZpbGVTaXplQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmlzTWF4RmlsZVNpemVEZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIGlzRmlsZVNpemVBbGxvd2VkID0gdGhpcy5pc0ZpbGVTaXplQ29ycmVjdChmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0ZpbGVTaXplQWxsb3dlZDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaXNNYXhGaWxlU2l6ZURlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEZpbGVzU2l6ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMubWF4RmlsZXNTaXplICE9PSBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpc0ZpbGVTaXplQ29ycmVjdChmaWxlOiBGaWxlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RmlsZXNTaXplID49IDAgJiYgZmlsZS5zaXplIDw9IHRoaXMubWF4RmlsZXNTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZmlsZSBpcyBhbiBhY2NlcHRhYmxlIHNpemVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlIEZpbGVNb2RlbFxuICAgICAqL1xuICAgIHByaXZhdGUgaXNGaWxlU2l6ZUFjY2VwdGFibGUoZmlsZTogRmlsZU1vZGVsKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBhY2NlcHRhYmxlU2l6ZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRmlsZVNpemVBbGxvd2VkKGZpbGUpKSB7XG4gICAgICAgICAgICBhY2NlcHRhYmxlU2l6ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy50cmFuc2xhdGlvblNlcnZpY2UuaW5zdGFudChcbiAgICAgICAgICAgICAgICAnRklMRV9VUExPQUQuTUVTU0FHRVMuRVhDRUVEX01BWF9GSUxFX1NJWkUnLFxuICAgICAgICAgICAgICAgIHsgZmlsZU5hbWU6IGZpbGUubmFtZSB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQobWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjZXB0YWJsZVNpemU7XG4gICAgfVxuXG59XG4iXX0=