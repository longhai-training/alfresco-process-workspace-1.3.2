import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { DomSanitizer } from '@angular/platform-browser';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { MatDatetimepickerModule } from '@mat-datetimepicker/core';
import { MatMomentDatetimeModule } from '@mat-datetimepicker/moment';
import { __awaiter } from 'tslib';
import { FlexLayoutModule } from '@angular/flex-layout';
import { MatDialog as MatDialog$1 } from '@angular/material/dialog';
import moment$1 from 'moment-es6';
import { MatButtonModule, MatChipsModule, MatDialogModule, MatIconModule, MatCardModule, MatInputModule, MatListModule, MatMenuModule, MatOptionModule, MatProgressBarModule, MatProgressSpinnerModule, MatRippleModule, MatExpansionModule, MatSelectModule, MatCheckboxModule, MatDatepickerModule, MatSlideToggleModule, MatRadioModule, MatSliderModule, MatTreeModule, MAT_DIALOG_DATA, MatDialogRef, MatDialog, MatListItem } from '@angular/material';
import { TranslateModule } from '@ngx-translate/core';
import { Observable, from, of, throwError, forkJoin, Subject, BehaviorSubject, merge, fromEvent, defer, iif } from 'rxjs';
import { FlatTreeControl } from '@angular/cdk/tree';
import { SearchRequest, SiteMemberPaging, NodeBodyLock, RatingBody, TagBody, Pagination, Site, RequestSortDefinitionInner, SiteEntry, NodeEntry } from '@alfresco/js-api';
import { catchError, map, switchMap, debounceTime, filter, takeUntil, takeWhile, mergeMap, tap, skip } from 'rxjs/operators';
import { CommonModule, DOCUMENT } from '@angular/common';
import { NgModule, Injectable, Directive, ElementRef, Renderer2, HostListener, Input, Component, ViewEncapsulation, ViewChild, ViewContainerRef, ComponentFactoryResolver, Inject, EventEmitter, Output, NgZone, Optional, SecurityContext, ChangeDetectionStrategy, ContentChild, Pipe, defineInjectable, inject, ViewChildren, TemplateRef, forwardRef, ChangeDetectorRef } from '@angular/core';
import { FormBuilder, FormsModule, ReactiveFormsModule, NG_VALUE_ACCESSOR, FormControl, Validators, FormGroup } from '@angular/forms';
import { AlfrescoApiService, LogService, ContentService, CoreModule, TranslationService, ObjectDataTableAdapter, SearchService, AuthenticationService, ThumbnailService, FileUploadStatus, UploadService, FileModel, NodesApiService, EXTENDIBLE_COMPONENT, FileUtils, AllowableOperationsEnum, NotificationService, BaseEvent, DataSorting, ObjectUtils, CardViewUpdateService, MOMENT_DATE_FORMATS, UserPreferenceValues, MomentDateAdapter, UserPreferencesService, SitesService, AppConfigService, TRANSLATION_PROVIDER, CardViewTextItemModel, CardViewDateItemModel, FileSizePipe, CardViewIntItemModel, CardViewFloatItemModel, CardViewDatetimeItemModel, CardViewBoolItemModel, MultiValuePipe, SharedLinksApiService, RenditionsService, HighlightDirective, InfinitePaginationComponent, SearchConfigurationService, DisplayMode, ObjectDataColumn, LockService, DataColumnListComponent, CustomLoadingContentTemplateDirective, CustomNoPermissionTemplateDirective, CustomEmptyContentTemplateDirective, NodeDownloadDirective } from '@alfresco/adf-core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function modules() {
    return [
        MatButtonModule,
        MatChipsModule,
        MatDialogModule,
        MatIconModule,
        MatCardModule,
        MatInputModule,
        MatListModule,
        MatProgressSpinnerModule,
        MatProgressBarModule,
        MatRippleModule,
        MatMenuModule,
        MatOptionModule,
        MatExpansionModule,
        MatSelectModule,
        MatCheckboxModule,
        MatDatepickerModule,
        MatSlideToggleModule,
        MatRadioModule,
        MatSliderModule,
        MatTreeModule
    ];
}
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                imports: modules(),
                exports: modules()
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentLoaderNode {
    /**
     * @param {?} currentNode
     * @param {?} children
     */
    constructor(currentNode, children) {
        this.currentNode = currentNode;
        this.children = children;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomResourcesService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.CREATE_PERMISSION = 'create';
    }
    /**
     * Gets files recently accessed by a user.
     * @param {?} personId ID of the user
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} filters Specifies additional filters to apply (joined with **AND**)
     * @return {?} List of nodes for the recently used files
     */
    getRecentFiles(personId, pagination, filters) {
        /** @type {?} */
        const defaultFilter = [
            'TYPE:"content"',
            '-PNAME:"0/wiki"',
            '-TYPE:"app:filelink"',
            '-TYPE:"cm:thumbnail"',
            '-TYPE:"cm:failedThumbnail"',
            '-TYPE:"cm:rating"',
            '-TYPE:"dl:dataList"',
            '-TYPE:"dl:todoList"',
            '-TYPE:"dl:issue"',
            '-TYPE:"dl:contact"',
            '-TYPE:"dl:eventAgenda"',
            '-TYPE:"dl:event"',
            '-TYPE:"dl:task"',
            '-TYPE:"dl:simpletask"',
            '-TYPE:"dl:meetingAgenda"',
            '-TYPE:"dl:location"',
            '-TYPE:"fm:topic"',
            '-TYPE:"fm:post"',
            '-TYPE:"ia:calendarEvent"',
            '-TYPE:"lnk:link"'
        ];
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.apiService.peopleApi.getPerson(personId)
                .then((/**
             * @param {?} person
             * @return {?}
             */
            (person) => {
                /** @type {?} */
                const username = person.entry.id;
                /** @type {?} */
                const filterQueries = [
                    { query: `cm:modified:[NOW/DAY-30DAYS TO NOW/DAY+1DAY]` },
                    { query: `cm:modifier:${username} OR cm:creator:${username}` },
                    { query: defaultFilter.join(' AND ') }
                ];
                if (filters && filters.length > 0) {
                    filterQueries.push({
                        query: filters.join()
                    });
                }
                /** @type {?} */
                const query = new SearchRequest({
                    query: {
                        query: '*',
                        language: 'afts'
                    },
                    filterQueries,
                    include: ['path', 'properties', 'allowableOperations'],
                    sort: [{
                            type: 'FIELD',
                            field: 'cm:modified',
                            ascending: false
                        }],
                    paging: {
                        maxItems: pagination.maxItems,
                        skipCount: pagination.skipCount
                    }
                });
                return this.apiService.searchApi.search(query)
                    .then((/**
                 * @param {?} searchResult
                 * @return {?}
                 */
                (searchResult) => {
                    observer.next(searchResult);
                    observer.complete();
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => {
                    observer.error(err);
                    observer.complete();
                }));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                observer.error(err);
                observer.complete();
            }));
        })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets favorite files for the current user.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of favorite files
     */
    loadFavorites(pagination, includeFields = []) {
        /** @type {?} */
        const includeFieldsRequest = this.getIncludesFields(includeFields);
        /** @type {?} */
        const options = {
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: includeFieldsRequest
        };
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.apiService.favoritesApi.getFavorites('-me-', options)
                .then((/**
             * @param {?} result
             * @return {?}
             */
            (result) => {
                /** @type {?} */
                const page = {
                    list: {
                        entries: result.list.entries
                            .map((/**
                         * @param {?} __0
                         * @return {?}
                         */
                        ({ entry: { target } }) => ({
                            entry: target.file || target.folder
                        })))
                            .map((/**
                         * @param {?} __0
                         * @return {?}
                         */
                        ({ entry }) => {
                            entry.properties = {
                                'cm:title': entry.title,
                                'cm:description': entry.description
                            };
                            return { entry };
                        })),
                        pagination: result.list.pagination
                    }
                };
                observer.next(page);
                observer.complete();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                observer.error(err);
                observer.complete();
            }));
        })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets sites that the current user is a member of.
     * @param {?} pagination Specifies how to paginate the results
     * @return {?} List of sites
     */
    loadMemberSites(pagination) {
        /** @type {?} */
        const options = {
            include: ['properties'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.apiService.peopleApi.listSiteMembershipsForPerson('-me-', options)
                .then((/**
             * @param {?} result
             * @return {?}
             */
            (result) => {
                /** @type {?} */
                const page = new SiteMemberPaging({
                    list: {
                        entries: result.list.entries
                            .map((/**
                         * @param {?} __0
                         * @return {?}
                         */
                        ({ entry: { site } }) => {
                            site.allowableOperations = site.allowableOperations ? site.allowableOperations : [this.CREATE_PERMISSION];
                            site.name = site.name || site.title;
                            return {
                                entry: site
                            };
                        })),
                        pagination: result.list.pagination
                    }
                });
                observer.next(page);
                observer.complete();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                observer.error(err);
                observer.complete();
            }));
        })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets all sites in the repository.
     * @param {?} pagination Specifies how to paginate the results
     * @return {?} List of sites
     */
    loadSites(pagination) {
        /** @type {?} */
        const options = {
            include: ['properties', 'aspectNames'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.apiService.sitesApi.getSites(options)
                .then((/**
             * @param {?} page
             * @return {?}
             */
            (page) => {
                page.list.entries.map((/**
                 * @param {?} __0
                 * @return {?}
                 */
                ({ entry }) => {
                    entry.name = entry.name || entry.title;
                    return { entry };
                }));
                observer.next(page);
                observer.complete();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                observer.error(err);
                observer.complete();
            }));
        })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets all items currently in the trash.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of deleted items
     */
    loadTrashcan(pagination, includeFields = []) {
        /** @type {?} */
        const includeFieldsRequest = this.getIncludesFields(includeFields);
        /** @type {?} */
        const options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return from(this.apiService.nodesApi.getDeletedNodes(options))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets shared links for the current user.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of shared links
     */
    loadSharedLinks(pagination, includeFields = []) {
        /** @type {?} */
        const includeFieldsRequest = this.getIncludesFields(includeFields);
        /** @type {?} */
        const options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return from(this.apiService.sharedLinksApi.findSharedLinks(options))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Is the folder ID one of the well-known aliases?
     * @param {?} folderId Folder ID name to check
     * @return {?} True if the ID is a well-known name, false otherwise
     */
    isCustomSource(folderId) {
        /** @type {?} */
        let isCustomSources = false;
        /** @type {?} */
        const sources = ['-trashcan-', '-sharedlinks-', '-sites-', '-mysites-', '-favorites-', '-recent-'];
        if (sources.indexOf(folderId) > -1) {
            isCustomSources = true;
        }
        return isCustomSources;
    }
    /**
     * Is the folder ID a "-my", "-root-", or "-shared-" alias?
     * @param {?} folderId Folder ID name to check
     * @return {?} True if the ID is one of the supported sources, false otherwise
     */
    isSupportedSource(folderId) {
        /** @type {?} */
        let isSupportedSources = false;
        /** @type {?} */
        const sources = ['-my-', '-root-', '-shared-'];
        if (sources.indexOf(folderId) > -1) {
            isSupportedSources = true;
        }
        return isSupportedSources;
    }
    /**
     * Gets a folder's contents.
     * @param {?} nodeId ID of the target folder node
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of items contained in the folder
     */
    loadFolderByNodeId(nodeId, pagination, includeFields = []) {
        if (nodeId === '-trashcan-') {
            return this.loadTrashcan(pagination, includeFields);
        }
        else if (nodeId === '-sharedlinks-') {
            return this.loadSharedLinks(pagination, includeFields);
        }
        else if (nodeId === '-sites-') {
            return this.loadSites(pagination);
        }
        else if (nodeId === '-mysites-') {
            return this.loadMemberSites(pagination);
        }
        else if (nodeId === '-favorites-') {
            return this.loadFavorites(pagination, includeFields);
        }
        else if (nodeId === '-recent-') {
            return this.getRecentFiles('-me-', pagination);
        }
    }
    // TODO: remove it from here
    /**
     * Gets the contents of one of the well-known aliases in the form of node ID strings.
     * @param {?} nodeId ID of the target folder node
     * @param {?=} pagination Specifies how to paginate the results
     * @return {?} List of node IDs
     */
    getCorrespondingNodeIds(nodeId, pagination = {}) {
        if (this.isCustomSource(nodeId)) {
            return this.loadFolderByNodeId(nodeId, pagination)
                .pipe(map((/**
             * @param {?} result
             * @return {?}
             */
            (result) => {
                return result.list.entries.map((/**
                 * @param {?} node
                 * @return {?}
                 */
                (node) => this.getIdFromEntry(node, nodeId)));
            })));
        }
        else if (nodeId) {
            // cases when nodeId is '-my-', '-root-' or '-shared-'
            return from(this.apiService.nodesApi.getNode(nodeId)
                .then((/**
             * @param {?} node
             * @return {?}
             */
            (node) => [node.entry.id])));
        }
        return of([]);
    }
    /**
     * Chooses the correct ID for a node entry.
     * @param {?} node Node object
     * @param {?} nodeId ID of the node object
     * @return {?} ID value
     */
    getIdFromEntry(node, nodeId) {
        if (nodeId === '-sharedlinks-') {
            return node.entry.nodeId;
        }
        else if (nodeId === '-sites-' || nodeId === '-mysites-') {
            return node.entry.guid;
        }
        else if (nodeId === '-favorites-') {
            return node.entry.targetGuid;
        }
        else {
            return node.entry.id;
        }
    }
    /**
     * Does the well-known alias have a corresponding node ID?
     * @param {?} nodeId Node to check
     * @return {?} True if the alias has a corresponding node ID, false otherwise
     */
    hasCorrespondingNodeIds(nodeId) {
        return this.isCustomSource(nodeId) || this.isSupportedSource(nodeId);
    }
    /**
     * @private
     * @param {?} includeFields
     * @return {?}
     */
    getIncludesFields(includeFields) {
        return ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        (element, index, array) => index === array.indexOf(element)));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
CustomResourcesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CustomResourcesService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ CustomResourcesService.ngInjectableDef = defineInjectable({ factory: function CustomResourcesService_Factory() { return new CustomResourcesService(inject(AlfrescoApiService), inject(LogService)); }, token: CustomResourcesService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DocumentListService {
    /**
     * @param {?} contentService
     * @param {?} apiService
     * @param {?} logService
     * @param {?} customResourcesService
     */
    constructor(contentService, apiService, logService, customResourcesService) {
        this.contentService = contentService;
        this.apiService = apiService;
        this.logService = logService;
        this.customResourcesService = customResourcesService;
    }
    /**
     * Deletes a node.
     * @param {?} nodeId ID of the node to delete
     * @return {?} Empty response when the operation is complete
     */
    deleteNode(nodeId) {
        return from(this.apiService.getInstance().nodes.deleteNode(nodeId));
    }
    /**
     * Copy a node to destination node
     *
     * @param {?} nodeId The id of the node to be copied
     * @param {?} targetParentId The id of the folder where the node will be copied
     * @return {?} NodeEntry for the copied node
     */
    copyNode(nodeId, targetParentId) {
        return from(this.apiService.getInstance().nodes.copyNode(nodeId, { targetParentId })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Moves a node to destination node.
     *
     * @param {?} nodeId The id of the node to be moved
     * @param {?} targetParentId The id of the folder where the node will be moved
     * @return {?} NodeEntry for the moved node
     */
    moveNode(nodeId, targetParentId) {
        return from(this.apiService.getInstance().nodes.moveNode(nodeId, { targetParentId })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the folder node with the specified relative name path below the root node.
     * @param {?} folder Path to folder.
     * @param {?=} opts Options.
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getFolder(folder, opts, includeFields = []) {
        /** @type {?} */
        let rootNodeId = DocumentListService.ROOT_ID;
        if (opts && opts.rootFolderId) {
            rootNodeId = opts.rootFolderId;
        }
        /** @type {?} */
        const includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        (element, index, array) => index === array.indexOf(element)));
        /** @type {?} */
        const params = {
            includeSource: true,
            include: includeFieldsRequest
        };
        if (folder) {
            params.relativePath = folder;
        }
        if (opts) {
            if (opts.maxItems) {
                params.maxItems = opts.maxItems;
            }
            if (opts.skipCount) {
                params.skipCount = opts.skipCount;
            }
            if (opts.where) {
                params.where = opts.where;
            }
        }
        return from(this.apiService.getInstance().nodes.getNodeChildren(rootNodeId, params)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a node via its node ID.
     * @param {?} nodeId ID of the target node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getNode(nodeId, includeFields = []) {
        /** @type {?} */
        const includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', ...includeFields]
            .filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        (element, index, array) => index === array.indexOf(element)));
        /** @type {?} */
        const opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return this.contentService.getNode(nodeId, opts);
    }
    /**
     * Gets a folder node via its node ID.
     * @param {?} nodeId ID of the folder node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getFolderNode(nodeId, includeFields = []) {
        /** @type {?} */
        const includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        (element, index, array) => index === array.indexOf(element)));
        /** @type {?} */
        const opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return from(this.apiService.getInstance().nodes.getNode(nodeId, opts)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    isCustomSourceService(nodeId) {
        return this.customResourcesService.isCustomSource(nodeId);
    }
    /**
     * @param {?} nodeId
     * @param {?} pagination
     * @param {?} includeFields
     * @param {?=} where
     * @return {?}
     */
    loadFolderByNodeId(nodeId, pagination, includeFields, where) {
        if (this.customResourcesService.isCustomSource(nodeId)) {
            return this.customResourcesService.loadFolderByNodeId(nodeId, pagination, includeFields).pipe(map((/**
             * @param {?} result
             * @return {?}
             */
            (result) => new DocumentLoaderNode(null, result))));
        }
        else {
            return this.retrieveDocumentNode(nodeId, pagination, includeFields, where);
        }
    }
    /**
     * @private
     * @param {?} nodeId
     * @param {?} pagination
     * @param {?} includeFields
     * @param {?=} where
     * @return {?}
     */
    retrieveDocumentNode(nodeId, pagination, includeFields, where) {
        return forkJoin(this.getFolderNode(nodeId, includeFields), this.getFolder(null, {
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount,
            rootFolderId: nodeId,
            where: where
        }, includeFields)).pipe(map((/**
         * @param {?} results
         * @return {?}
         */
        (results) => new DocumentLoaderNode(results[0], results[1]))));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
DocumentListService.ROOT_ID = '-root-';
DocumentListService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DocumentListService.ctorParameters = () => [
    { type: ContentService },
    { type: AlfrescoApiService },
    { type: LogService },
    { type: CustomResourcesService }
];
/** @nocollapse */ DocumentListService.ngInjectableDef = defineInjectable({ factory: function DocumentListService_Factory() { return new DocumentListService(inject(ContentService), inject(AlfrescoApiService), inject(LogService), inject(CustomResourcesService)); }, token: DocumentListService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentNodeSelectorComponent {
    /**
     * @param {?} data
     */
    constructor(data) {
        this.data = data;
        this.buttonActionName = data.actionName ? `NODE_SELECTOR.${data.actionName.toUpperCase()}` : 'NODE_SELECTOR.CHOOSE';
    }
    /**
     * @return {?}
     */
    close() {
        this.data.select.complete();
    }
    /**
     * @param {?} nodeList
     * @return {?}
     */
    onSelect(nodeList) {
        this.chosenNode = nodeList;
    }
    /**
     * @return {?}
     */
    onClick() {
        this.data.select.next(this.chosenNode);
        this.data.select.complete();
    }
}
ContentNodeSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-node-selector',
                template: "<header\n    mat-dialog-title\n    data-automation-id=\"content-node-selector-title\">{{data?.title}}\n</header>\n\n<mat-dialog-content>\n    <adf-content-node-selector-panel\n        [currentFolderId]=\"data?.currentFolderId\"\n        [dropdownHideMyFiles]=\"data?.dropdownHideMyFiles\"\n        [dropdownSiteList]=\"data?.dropdownSiteList\"\n        [rowFilter]=\"data?.rowFilter\"\n        [imageResolver]=\"data?.imageResolver\"\n        [isSelectionValid]=\"data?.isSelectionValid\"\n        [breadcrumbTransform]=\"data?.breadcrumbTransform\"\n        [excludeSiteContent]=\"data?.excludeSiteContent\"\n        [where]=\"data?.where\"\n        (select)=\"onSelect($event)\">\n    </adf-content-node-selector-panel>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n    <button\n        mat-button\n        (click)=\"close()\"\n        data-automation-id=\"content-node-selector-actions-cancel\">{{ 'NODE_SELECTOR.CANCEL' | translate }}\n    </button>\n\n    <button mat-button\n        [disabled]=\"!chosenNode\"\n        class=\"adf-choose-action\"\n        (click)=\"onClick()\"\n        data-automation-id=\"content-node-selector-actions-choose\">{{ buttonActionName | translate }}\n    </button>\n</mat-dialog-actions>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
ContentNodeSelectorComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodeLockDialogComponent {
    /**
     * @param {?} formBuilder
     * @param {?} dialog
     * @param {?} alfrescoApi
     * @param {?} data
     */
    constructor(formBuilder, dialog, alfrescoApi, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.alfrescoApi = alfrescoApi;
        this.data = data;
        this.node = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const { node } = this.data;
        this.nodeName = node.name;
        this.form = this.formBuilder.group({
            isLocked: node.isLocked || false,
            allowOwner: node.properties['cm:lockType'] === 'WRITE_LOCK',
            isTimeLock: !!node.properties['cm:expiryDate'],
            time: !!node.properties['cm:expiryDate'] ? moment$1(node.properties['cm:expiryDate']) : moment$1()
        });
    }
    /**
     * @private
     * @return {?}
     */
    get lockTimeInSeconds() {
        if (this.form.value.isTimeLock) {
            /** @type {?} */
            const duration = moment$1.duration(moment$1(this.form.value.time).diff(moment$1()));
            return duration.asSeconds();
        }
        return 0;
    }
    /**
     * @private
     * @return {?}
     */
    get nodeBodyLock() {
        return new NodeBodyLock({
            'timeToExpire': this.lockTimeInSeconds,
            'type': this.form.value.allowOwner ? 'ALLOW_OWNER_CHANGES' : 'FULL',
            'lifetime': 'PERSISTENT'
        });
    }
    /**
     * @private
     * @return {?}
     */
    toggleLock() {
        const { alfrescoApi: { nodesApi }, data: { node } } = this;
        if (this.form.value.isLocked) {
            return nodesApi.lockNode(node.id, this.nodeBodyLock);
        }
        return nodesApi.unlockNode(node.id);
    }
    /**
     * @return {?}
     */
    submit() {
        this.toggleLock()
            .then((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.data.node.isLocked = this.form.value.isLocked;
            this.dialog.close(node.entry);
        }))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.data.onError(error)));
    }
}
NodeLockDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-node-lock',
                template: "<h2 mat-dialog-title>\n    {{ 'CORE.FILE_DIALOG.FILE_LOCK' | translate }}\n</h2>\n\n<mat-dialog-content>\n    <br />\n    <form [formGroup]=\"form\" (submit)=\"submit()\">\n        <mat-checkbox  data-automation-id=\"adf-lock-node-checkbox\" class=\"adf-lock-file-name\" [formControl]=\"form.controls['isLocked']\" ngDefaultControl>\n            {{ 'CORE.FILE_DIALOG.FILE_LOCK_CHECKBOX' | translate }} <strong>\"{{ nodeName }}\"</strong>\n        </mat-checkbox>\n\n        <br />\n\n        <div *ngIf=\"form.value.isLocked\">\n            <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['allowOwner']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.ALLOW_OTHERS_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['isTimeLock']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.TIME_LOCK_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-form-field *ngIf=\"form.value.isTimeLock\">\n                <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\n                <mat-datetimepicker #datetimePicker type=\"datetime\" openOnFocus=\"true\" timeInterval=\"1\"></mat-datetimepicker>\n                <input matInput [formControl]=\"form.controls['time']\" [matDatetimepicker]=\"datetimePicker\" required autocomplete=\"false\">\n            </mat-form-field>\n        </div>\n    </form>\n    <br />\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button mat-button mat-dialog-close data-automation-id=\"lock-dialog-btn-cancel\">\n        {{ 'CORE.FILE_DIALOG.CANCEL_BUTTON.LABEL' | translate }}\n    </button>\n\n    <button class=\"adf-dialog-action-button\" mat-button (click)=\"submit()\">\n        {{ 'CORE.FILE_DIALOG.SAVE_BUTTON.LABEL' | translate }}\n    </button>\n</mat-dialog-actions>\n",
                styles: [".adf-fill-remaining-space{flex:1 1 auto}.adf-full-width,.adf-lock-file-name .mat-checkbox-layout{width:100%}.adf-lock-file-name .mat-checkbox-label{text-overflow:ellipsis;overflow:hidden}.adf-lock-file-name .mat-checkbox-inner-container{margin:auto 8px auto 0}"]
            }] }
];
/** @nocollapse */
NodeLockDialogComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialogRef },
    { type: AlfrescoApiService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentNodeDialogService {
    /**
     * @param {?} dialog
     * @param {?} contentService
     * @param {?} documentListService
     * @param {?} siteService
     * @param {?} translation
     * @param {?} thumbnailService
     */
    constructor(dialog, contentService, documentListService, siteService, translation, thumbnailService) {
        this.dialog = dialog;
        this.contentService = contentService;
        this.documentListService = documentListService;
        this.siteService = siteService;
        this.translation = translation;
        this.thumbnailService = thumbnailService;
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * Opens a file browser at a chosen folder location.
     * @param {?} folderNodeId ID of the folder to use
     * @return {?} Information about the selected file(s)
     */
    openFileBrowseDialogByFolderId(folderNodeId) {
        return this.documentListService.getFolderNode(folderNodeId).pipe(switchMap((/**
         * @param {?} nodeEntry
         * @return {?}
         */
        (nodeEntry) => {
            return this.openUploadFileDialog('Choose', nodeEntry.entry);
        })));
    }
    /**
     * Opens a lock node dialog.
     * @param {?} contentEntry Node to lock
     * @return {?} Error/status message (if any)
     */
    openLockNodeDialog(contentEntry) {
        /** @type {?} */
        const observable = new Subject();
        if (this.contentService.hasAllowableOperations(contentEntry, AllowableOperationsEnum.LOCK)) {
            this.dialog.open(NodeLockDialogComponent, {
                data: {
                    node: contentEntry,
                    onError: (/**
                     * @param {?} error
                     * @return {?}
                     */
                    (error) => {
                        this.error.emit(error);
                        observable.error(error);
                    })
                },
                width: '400px'
            });
        }
        else {
            observable.error('OPERATION.FAIL.NODE.NO_PERMISSION');
        }
        return observable;
    }
    /**
     * Opens a file browser at a chosen site location.
     * @return {?} Information about the selected file(s)
     */
    openFileBrowseDialogBySite() {
        return this.siteService.getSites().pipe(switchMap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return this.openFileBrowseDialogByFolderId(response.list.entries[0].entry.guid);
        })));
    }
    /**
     * Opens a folder browser at a chosen site location.
     * @return {?} Information about the selected folder(s)
     */
    openFolderBrowseDialogBySite() {
        return this.openFolderBrowseDialogByFolderId('-my-');
    }
    /**
     * Opens a folder browser at a chosen folder location.
     * @param {?} folderNodeId ID of the folder to use
     * @return {?} Information about the selected folder(s)
     */
    openFolderBrowseDialogByFolderId(folderNodeId) {
        return this.documentListService.getFolderNode(folderNodeId).pipe(switchMap((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            return this.openUploadFolderDialog('Choose', node.entry);
        })));
    }
    /**
     * Opens a dialog to copy or move an item to a new location.
     * @param {?} action Name of the action (eg, "Copy" or "Move") to show in the title
     * @param {?} contentEntry Item to be copied or moved
     * @param {?=} permission Permission for the operation
     * @param {?=} excludeSiteContent The site content that should be filtered out
     * @return {?} Information about files that were copied/moved
     */
    openCopyMoveDialog(action, contentEntry, permission, excludeSiteContent) {
        if (this.contentService.hasAllowableOperations(contentEntry, permission)) {
            /** @type {?} */
            const select = new Subject();
            select.subscribe({
                complete: this.close.bind(this)
            });
            /** @type {?} */
            const title = this.getTitleTranslation(action, contentEntry.name);
            /** @type {?} */
            const data = {
                title: title,
                actionName: action,
                currentFolderId: contentEntry.parentId,
                imageResolver: this.imageResolver.bind(this),
                where: '(isFolder=true)',
                isSelectionValid: this.isCopyMoveSelectionValid.bind(this),
                excludeSiteContent: excludeSiteContent || ContentNodeDialogService.nonDocumentSiteContent,
                select: select
            };
            this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
            return select;
        }
        else {
            /** @type {?} */
            const errors = new Error(JSON.stringify({ error: { statusCode: 403 } }));
            return throwError(errors);
        }
    }
    /**
     * Gets the translation of the dialog title.
     * @param {?} action Name of the action to display in the dialog title
     * @param {?} name Name of the item on which the action is being performed
     * @return {?} Translated version of the title
     */
    getTitleTranslation(action, name) {
        return this.translation.instant(`NODE_SELECTOR.${action.toUpperCase()}_ITEM`, { name });
    }
    /**
     * Opens a dialog to choose folders to upload.
     * @param {?} action Name of the action to show in the title
     * @param {?} contentEntry  Item to upload
     * @return {?} Information about the chosen folder(s)
     */
    openUploadFolderDialog(action, contentEntry) {
        /** @type {?} */
        const select = new Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        /** @type {?} */
        const data = {
            title: `${action} '${contentEntry.name}' to ...`,
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.hasAllowableOperationsOnNodeFolder.bind(this),
            where: '(isFolder=true)',
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    }
    /**
     * Opens a dialog to choose a file to upload.
     * @param {?} action Name of the action to show in the title
     * @param {?} contentEntry Item to upload
     * @return {?} Information about the chosen file(s)
     */
    openUploadFileDialog(action, contentEntry) {
        /** @type {?} */
        const select = new Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        /** @type {?} */
        const data = {
            title: `${action} '${contentEntry.name}' to ...`,
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.isNodeFile.bind(this),
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    }
    /**
     * @private
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    openContentNodeDialog(data, currentPanelClass, chosenWidth) {
        this.dialog.open(ContentNodeSelectorComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
    }
    /**
     * @private
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    imageResolver(row, col) {
        /** @type {?} */
        const entry = row.node.entry;
        if (!this.contentService.hasAllowableOperations(entry, 'create')) {
            return this.thumbnailService.getMimeTypeIcon('disable/folder');
        }
        return null;
    }
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    isNodeFile(entry) {
        return entry.isFile;
    }
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    hasAllowableOperationsOnNodeFolder(entry) {
        return this.isNodeFolder(entry) && this.contentService.hasAllowableOperations(entry, 'create');
    }
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    isNodeFolder(entry) {
        return entry.isFolder;
    }
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    isCopyMoveSelectionValid(entry) {
        return this.hasEntityCreatePermission(entry) && !this.isSite(entry);
    }
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    hasEntityCreatePermission(entry) {
        return this.contentService.hasAllowableOperations(entry, 'create');
    }
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    isSite(entry) {
        return !!entry.guid || entry.nodeType === 'st:site' || entry.nodeType === 'st:sites';
    }
    /**
     * Closes the currently open dialog.
     * @return {?}
     */
    close() {
        this.dialog.closeAll();
    }
}
ContentNodeDialogService.nonDocumentSiteContent = [
    'blog',
    'calendar',
    'dataLists',
    'discussions',
    'links',
    'wiki'
];
ContentNodeDialogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ContentNodeDialogService.ctorParameters = () => [
    { type: MatDialog },
    { type: ContentService },
    { type: DocumentListService },
    { type: SitesService },
    { type: TranslationService },
    { type: ThumbnailService }
];
ContentNodeDialogService.propDecorators = {
    error: [{ type: Output }]
};
/** @nocollapse */ ContentNodeDialogService.ngInjectableDef = defineInjectable({ factory: function ContentNodeDialogService_Factory() { return new ContentNodeDialogService(inject(MatDialog$1), inject(ContentService), inject(DocumentListService), inject(SitesService), inject(TranslationService), inject(ThumbnailService)); }, token: ContentNodeDialogService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodeLockDirective {
    /**
     * @param {?} element
     * @param {?} renderer
     * @param {?} contentService
     * @param {?} contentNodeDialogService
     */
    constructor(element, renderer, contentService, contentNodeDialogService) {
        this.element = element;
        this.renderer = renderer;
        this.contentService = contentService;
        this.contentNodeDialogService = contentNodeDialogService;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        this.contentNodeDialogService.openLockNodeDialog(this.node);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const hasAllowableOperations = this.contentService.hasAllowableOperations(this.node, AllowableOperationsEnum.LOCK);
        this.renderer.setProperty(this.element.nativeElement, 'disabled', !hasAllowableOperations);
    }
}
NodeLockDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-lock]'
            },] }
];
/** @nocollapse */
NodeLockDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ContentService },
    { type: ContentNodeDialogService }
];
NodeLockDirective.propDecorators = {
    node: [{ type: Input, args: ['adf-node-lock',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentDirectiveModule {
}
ContentDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    NodeLockDirective
                ],
                exports: [
                    NodeLockDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RatingService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * Gets the current user's rating for a node.
     * @param {?} nodeId Node to get the rating from
     * @param {?} ratingType Type of rating (can be "likes" or "fiveStar")
     * @return {?} The rating value
     */
    getRating(nodeId, ratingType) {
        return from(this.apiService.getInstance().core.ratingsApi.getRating(nodeId, ratingType))
            .pipe(catchError(this.handleError));
    }
    /**
     * Adds the current user's rating for a node.
     * @param {?} nodeId Target node for the rating
     * @param {?} ratingType Type of rating (can be "likes" or "fiveStar")
     * @param {?} vote Rating value (boolean for "likes", numeric 0..5 for "fiveStar")
     * @return {?} Details about the rating, including the new value
     */
    postRating(nodeId, ratingType, vote) {
        /** @type {?} */
        const ratingBody = new RatingBody({
            'id': ratingType,
            'myRating': vote
        });
        return from(this.apiService.getInstance().core.ratingsApi.rate(nodeId, ratingBody))
            .pipe(catchError(this.handleError));
    }
    /**
     * Removes the current user's rating for a node.
     * @param {?} nodeId Target node
     * @param {?} ratingType Type of rating to remove (can be "likes" or "fiveStar")
     * @return {?} Null response indicating that the operation is complete
     */
    deleteRating(nodeId, ratingType) {
        return from(this.apiService.getInstance().core.ratingsApi.removeRating(nodeId, ratingType))
            .pipe(catchError(this.handleError));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.error(error);
        return throwError(error || 'Server error');
    }
}
RatingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
RatingService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ RatingService.ngInjectableDef = defineInjectable({ factory: function RatingService_Factory() { return new RatingService(inject(AlfrescoApiService)); }, token: RatingService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RatingComponent {
    /**
     * @param {?} ratingService
     */
    constructor(ratingService) {
        this.ratingService = ratingService;
        this.average = 0;
        this.ratingType = 'fiveStar';
        /**
         * Emitted when the "vote" gets changed.
         */
        this.changeVote = new EventEmitter();
        this.stars = [];
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        /** @type {?} */
        const ratingObserver = this.ratingService.getRating(this.nodeId, this.ratingType);
        ratingObserver.subscribe((/**
         * @param {?} ratingEntry
         * @return {?}
         */
        (ratingEntry) => {
            if (ratingEntry.entry.aggregate) {
                this.average = ratingEntry.entry.aggregate.average;
                this.calculateStars();
            }
        }));
        return ratingObserver;
    }
    /**
     * @return {?}
     */
    calculateStars() {
        this.stars = [];
        for (let i = 0; i < 5; i++) {
            if (i < this.average) {
                this.stars.push({ fill: true });
            }
            else {
                this.stars.push({ fill: false });
            }
        }
        this.changeVote.emit(this.average);
    }
    /**
     * @param {?} vote
     * @return {?}
     */
    updateVote(vote) {
        this.ratingService.postRating(this.nodeId, this.ratingType, vote).subscribe((/**
         * @param {?} ratingEntry
         * @return {?}
         */
        (ratingEntry) => {
            if (ratingEntry.entry.aggregate) {
                if (this.average !== ratingEntry.entry.aggregate.average) {
                    this.average = ratingEntry.entry.aggregate.average;
                    this.calculateStars();
                }
            }
        }));
    }
}
RatingComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-rating',
                template: "<mat-list id=\"adf-rating-container\" class=\"adf-rating-container\">\n    <mat-list-item class=\"adf-rating-star\" *ngFor=\"let currentRate of stars; let idx = index\">\n            <span id=\"adf-rate-{{idx}}\">\n                <mat-icon id=\"adf-grey-star-{{idx}}\" *ngIf=\"currentRate.fill\" class=\"adf-colored-star\"\n                         (click)=\"updateVote(idx + 1)\">star_rate\n                </mat-icon>\n                <mat-icon id=\"adf-colored-star-{{idx}}\" *ngIf=\"!currentRate.fill\" class=\"adf-grey-star\"\n                         (click)=\"updateVote(idx + 1)\">star_border\n                </mat-icon>\n            </span>\n    </mat-list-item>\n</mat-list>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-rating-container{overflow:hidden;width:100%}.adf-rating-container .adf-rating-star{float:left;transition:.3s;padding:1px;cursor:pointer;width:25px!important}.adf-rating-container .adf-rating-star .mat-list-item-content{padding:0 2px!important}.adf-rating-container .adf-colored-star{color:#ffe944}.adf-rating-container .adf-grey-star{color:grey}.adf-rating-container .adf-stars-container{padding:0!important;margin:0!important;display:inline-block}.adf-rating-container .adf-rating-star:hover{-webkit-transform:rotate(13deg) scale(1.2);transform:rotate(13deg) scale(1.2)}"]
            }] }
];
/** @nocollapse */
RatingComponent.ctorParameters = () => [
    { type: RatingService }
];
RatingComponent.propDecorators = {
    nodeId: [{ type: Input }],
    changeVote: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LikeComponent {
    /**
     * @param {?} ratingService
     */
    constructor(ratingService) {
        this.ratingService = ratingService;
        /**
         * Emitted when the "vote" gets changed.
         */
        this.changeVote = new EventEmitter();
        this.likesCounter = 0;
        this.ratingType = 'likes';
        this.isLike = false;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.clean();
        this.ratingService.getRating(this.nodeId, this.ratingType).subscribe((/**
         * @param {?} ratingEntry
         * @return {?}
         */
        (ratingEntry) => {
            if (ratingEntry.entry.aggregate) {
                this.likesCounter = ratingEntry.entry.aggregate.numberOfRatings;
                if (ratingEntry.entry.ratedAt) {
                    this.isLike = true;
                }
            }
        }));
    }
    /**
     * @return {?}
     */
    likeClick() {
        if (this.isLike) {
            this.ratingService.deleteRating(this.nodeId, this.ratingType).subscribe((/**
             * @return {?}
             */
            () => {
                this.likesCounter -= 1;
                this.isLike = false;
                this.changeVote.emit(this.likesCounter);
            }));
        }
        else {
            this.ratingService.postRating(this.nodeId, this.ratingType, true).subscribe((/**
             * @param {?} ratingEntry
             * @return {?}
             */
            (ratingEntry) => {
                this.likesCounter = ratingEntry.entry.aggregate.numberOfRatings;
                this.isLike = true;
                this.changeVote.emit(this.likesCounter);
            }));
        }
    }
    /**
     * @return {?}
     */
    clean() {
        this.isLike = false;
        this.likesCounter = 0;
    }
}
LikeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-like',
                template: "<div id=\"adf-like-container\" class=\"adf-like-container\">\n    <div class=\"adf-like\">\n        <span id=\"adf-like-{{nodeId}}\" [ngClass]=\"{'adf-like-select': isLike ,'adf-like-grey': !isLike  }\"\n              (click)=\"likeClick()\">\n            <mat-icon>thumb_up</mat-icon>\n        </span>\n    </div>\n    <div id=\"adf-like-counter\" class=\"adf-like-counter\">{{likesCounter}}</div>\n    <div class=\"adf-left\" *ngIf=\"likesCounter<=1\">Like</div>\n    <div class=\"adf-left\" *ngIf=\"likesCounter>1\">Likes</div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-like-container{overflow:hidden;width:100%}.adf-like-container .adf-like{padding:5px;cursor:pointer;float:left;margin:5px 0 5px 5px}.adf-like-container .adf-like-select{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-grey,.adf-like-container .adf-like-select:hover{cursor:pointer;color:grey}.adf-like-container .adf-like-grey:hover{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-counter{float:left;padding:13px 0 0}.adf-like-container .adf-left{float:left;padding:13px 0 0 4px}"]
            }] }
];
/** @nocollapse */
LikeComponent.ctorParameters = () => [
    { type: RatingService }
];
LikeComponent.propDecorators = {
    nodeId: [{ type: Input }],
    changeVote: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SocialModule {
}
SocialModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                exports: [
                    RatingComponent,
                    LikeComponent
                ],
                declarations: [
                    RatingComponent,
                    LikeComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TagService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        /**
         * Emitted when tag information is updated.
         */
        this.refresh = new EventEmitter();
    }
    /**
     * Gets a list of tags added to a node.
     * @param {?} nodeId ID of the target node
     * @return {?} TagPaging object (defined in JS-API) containing the tags
     */
    getTagsByNodeId(nodeId) {
        return from(this.apiService.getInstance().core.tagsApi.getNodeTags(nodeId)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a list of all the tags already defined in the repository.
     * @param {?=} opts Options supported by JS-API
     * @return {?} TagPaging object (defined in JS-API) containing the tags
     */
    getAllTheTags(opts) {
        return from(this.apiService.getInstance().core.tagsApi.getTags(opts))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Adds a tag to a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tagName Name of the tag to add
     * @return {?} TagEntry object (defined in JS-API) with details of the new tag
     */
    addTag(nodeId, tagName) {
        /** @type {?} */
        const tagBody = new TagBody();
        tagBody.tag = tagName;
        /** @type {?} */
        const observableAdd = from(this.apiService.getInstance().core.tagsApi.addTag(nodeId, tagBody));
        observableAdd.subscribe((/**
         * @param {?} tagEntry
         * @return {?}
         */
        (tagEntry) => {
            this.refresh.emit(tagEntry);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.handleError(err);
        }));
        return observableAdd;
    }
    /**
     * Removes a tag from a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tag Name of the tag to remove
     * @return {?} Null object when the operation completes
     */
    removeTag(nodeId, tag) {
        /** @type {?} */
        const observableRemove = from(this.apiService.getInstance().core.tagsApi.removeTag(nodeId, tag));
        observableRemove.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            this.refresh.emit(data);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.handleError(err);
        }));
        return observableRemove;
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
TagService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TagService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
TagService.propDecorators = {
    refresh: [{ type: Output }]
};
/** @nocollapse */ TagService.ngInjectableDef = defineInjectable({ factory: function TagService_Factory() { return new TagService(inject(AlfrescoApiService), inject(LogService)); }, token: TagService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * This component, provide a list of the tags relative a node with actions button to add or remove new tag
 */
class TagActionsComponent {
    /**
     * @param {?} tagService
     * @param {?} translateService
     */
    constructor(tagService, translateService) {
        this.tagService = tagService;
        this.translateService = translateService;
        /**
         * Emitted when a tag is added successfully.
         */
        this.successAdd = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when an action is chosen.
         */
        this.result = new EventEmitter();
        this.disableAddTag = true;
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.tagService.refresh.subscribe((/**
         * @return {?}
         */
        () => {
            this.refreshTag();
        })));
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        return this.refreshTag();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => subscription.unsubscribe()));
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    refreshTag() {
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe((/**
             * @param {?} tagPaging
             * @return {?}
             */
            (tagPaging) => {
                this.tagsEntries = tagPaging.list.entries;
                this.disableAddTag = false;
                this.result.emit(this.tagsEntries);
            }), (/**
             * @return {?}
             */
            () => {
                this.tagsEntries = null;
                this.disableAddTag = true;
                this.result.emit(this.tagsEntries);
            }));
        }
    }
    /**
     * @return {?}
     */
    addTag() {
        if (this.searchTag(this.newTagName)) {
            this.translateService.get('TAG.MESSAGES.EXIST').subscribe((/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                this.errorMsg = error;
            }));
            this.error.emit(this.errorMsg);
        }
        else {
            this.tagService.addTag(this.nodeId, this.newTagName).subscribe((/**
             * @return {?}
             */
            () => {
                this.newTagName = '';
                this.successAdd.emit(this.nodeId);
            }));
        }
    }
    /**
     * @param {?} searchTagName
     * @return {?}
     */
    searchTag(searchTagName) {
        if (this.tagsEntries) {
            return this.tagsEntries.find((/**
             * @param {?} currentTag
             * @return {?}
             */
            (currentTag) => {
                return (searchTagName === currentTag.entry.tag);
            }));
        }
    }
    /**
     * @return {?}
     */
    cleanErrorMsg() {
        this.errorMsg = '';
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    removeTag(tag) {
        this.tagService.removeTag(this.nodeId, tag);
    }
}
TagActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-node-actions-list',
                template: "<mat-list>\n    <mat-list-item *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <div class=\"adf-tag-actions-container\" id=\"tag_delete_{{currentEntry.entry.tag}}\" (click)=\"removeTag(currentEntry.entry.id)\">\n            <div class=\"adf-tag-actions-delete-text\" id=\"tag_name_{{currentEntry.entry.tag}}\">\n                {{currentEntry.entry.tag}}\n            </div>\n            <mat-icon class=\"adf-tag-actions-delete-icon\">delete</mat-icon>\n        </div>\n    </mat-list-item>\n</mat-list>\n<table class=\"adf-full-width\" cellspacing=\"0\">\n    <tr>\n        <td>\n            <mat-form-field class=\"adf-full-width\">\n                <input matInput placeholder=\"{{'TAG.LABEL.NEWTAG' | translate }}\"\n                       type=\"text\"\n                       (keypress)=\"cleanErrorMsg()\"\n                       [(ngModel)]=\"newTagName\"\n                       id=\"new-tag-text\"/>\n                <mat-hint data-automation-id=\"errorMessage\" *ngIf=\"error\" [ngStyle]=\"{'color': 'red'}\" align=\"start\">{{errorMsg}}</mat-hint>\n            </mat-form-field>\n        </td>\n        <td>\n            <button class=\"adf-full-width\" color=\"primary\" id=\"add-tag\" (click)=\"addTag()\" [disabled]=\"disableAddTag\"\n                    mat-raised-button>\n                {{'TAG.BUTTON.ADD' | translate }}\n            </button>\n        </td>\n    </tr>\n</table>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-full-width{width:100%}.adf-tag-actions-delete-icon{float:right;cursor:pointer}.adf-tag-actions-delete-text{font-size:16px;float:left}.adf-tag-actions-container{padding:8px 0;height:20px}"]
            }] }
];
/** @nocollapse */
TagActionsComponent.ctorParameters = () => [
    { type: TagService },
    { type: TranslationService }
];
TagActionsComponent.propDecorators = {
    nodeId: [{ type: Input }],
    successAdd: [{ type: Output }],
    error: [{ type: Output }],
    result: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This component provide a list of all the tag inside the ECM
 */
class TagListComponent {
    /**
     * Constructor
     * @param {?} tagService
     */
    constructor(tagService) {
        this.tagService = tagService;
        /**
         * Emitted when a tag is selected.
         */
        this.result = new EventEmitter();
        /**
         * Array of tags that are displayed
         */
        this.tagsEntries = [];
        /**
         * Number of items per iteration
         */
        this.size = 10;
        this.isLoading = false;
        this.isSizeMinimum = true;
        this.defaultPagination = {
            skipCount: 0,
            maxItems: this.size,
            hasMoreItems: false
        };
        this.pagination = this.defaultPagination;
        this.tagService.refresh.subscribe((/**
         * @return {?}
         */
        () => {
            this.tagsEntries = [];
            this.refreshTag(this.defaultPagination);
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        return this.refreshTag(this.defaultPagination);
    }
    /**
     * @param {?=} opts
     * @return {?}
     */
    refreshTag(opts) {
        this.tagService.getAllTheTags(opts).subscribe((/**
         * @param {?} tags
         * @return {?}
         */
        (tags) => {
            this.tagsEntries = this.tagsEntries.concat(tags.list.entries);
            this.pagination = tags.list.pagination;
            this.result.emit(this.tagsEntries);
            this.isLoading = false;
        }));
    }
    /**
     * @return {?}
     */
    loadMoreTags() {
        if (this.pagination.hasMoreItems) {
            this.isLoading = true;
            this.isSizeMinimum = false;
            this.refreshTag({
                skipCount: this.pagination.skipCount + this.pagination.count,
                maxItems: this.size
            });
        }
    }
    /**
     * @return {?}
     */
    loadLessTags() {
        this.isSizeMinimum = false;
        this.tagsEntries = this.tagsEntries.slice(0, this.tagsEntries.length - this.pagination.count);
        this.pagination.skipCount = this.pagination.skipCount - this.pagination.count;
        this.pagination.hasMoreItems = true;
        if (this.tagsEntries.length <= this.size) {
            this.isSizeMinimum = true;
        }
    }
}
TagListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-list',
                template: "<mat-chip-list class=\"adf-tag-chips-list\">\n    <div class=\"adf-list-tag\" *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <mat-chip class=\"adf-primary-background-color\">\n            <span id=\"tag_name_{{idx}}\">{{currentEntry.entry.tag}}</span>\n        </mat-chip>\n    </div>\n</mat-chip-list>\n\n<div class=\"adf-tag-list-controls\">\n    <button\n        *ngIf=\"!isSizeMinimum\"\n        [disabled]=\"isLoading\"\n        data-automation-id=\"show-fewer-tags\"\n        mat-icon-button\n        (click)=\"loadLessTags()\">\n        <mat-icon>keyboard_arrow_up</mat-icon>\n    </button>\n    <button\n        *ngIf=\"pagination.hasMoreItems\"\n        [disabled]=\"isLoading\"\n        data-automation-id=\"show-more-tags\"\n        mat-icon-button\n        (click)=\"loadMoreTags()\">\n        <mat-icon>keyboard_arrow_down</mat-icon>\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-tag-chips-list,.adf-tag-chips-list div{display:flex;flex-direction:column}.adf-list-tag{display:block;font-size:16px}.adf-tag-list-controls{margin-top:30px;display:flex;justify-content:center}"]
            }] }
];
/** @nocollapse */
TagListComponent.ctorParameters = () => [
    { type: TagService }
];
TagListComponent.propDecorators = {
    result: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * This component, ShowNodeTag a list of the tag on relative a node
 */
class TagNodeListComponent {
    /**
     * Constructor
     * @param {?} tagService
     */
    constructor(tagService) {
        this.tagService = tagService;
        /**
         * Show delete button
         */
        this.showDelete = true;
        /**
         * Emitted when a tag is selected.
         */
        this.results = new EventEmitter();
        this.tagService.refresh.subscribe((/**
         * @return {?}
         */
        () => {
            this.refreshTag();
        }));
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        return this.refreshTag();
    }
    /**
     * @return {?}
     */
    refreshTag() {
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe((/**
             * @param {?} tagPaging
             * @return {?}
             */
            (tagPaging) => {
                this.tagsEntries = tagPaging.list.entries;
                this.results.emit(this.tagsEntries);
            }));
        }
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    removeTag(tag) {
        this.tagService.removeTag(this.nodeId, tag).subscribe((/**
         * @return {?}
         */
        () => {
            this.refreshTag();
        }));
    }
}
TagNodeListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-node-list',
                template: "<mat-chip-list>\n    <mat-chip class=\"adf-tag-chips adf-primary-background-color\"\n              *ngFor=\"let currentEntry of tagsEntries; let idx = index\" (removed)=\"removeTag(currentEntry.entry.id)\">\n        <span id=\"tag_name_{{idx}}\">{{currentEntry.entry.tag}}</span>\n        <mat-icon *ngIf=\"showDelete\" id=\"tag_chips_delete_{{currentEntry.entry.tag}}\"\n                  class=\"adf-tag-chips-delete-icon adf-primary-contrast-text-color\" matChipRemove>cancel\n        </mat-icon>\n    </mat-chip>\n</mat-chip-list>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-tag-chips-delete{overflow:visible;cursor:pointer;height:17px;width:20px;float:right;border:0;background:0 0;padding:0;margin:-1px 0 0 10px}.adf-tag-chips-delete-icon{font-size:20px;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:20px;width:20px}"]
            }] }
];
/** @nocollapse */
TagNodeListComponent.ctorParameters = () => [
    { type: TagService }
];
TagNodeListComponent.propDecorators = {
    nodeId: [{ type: Input }],
    showDelete: [{ type: Input }],
    results: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TagModule {
}
TagModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule.forChild()
                ],
                exports: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ],
                declarations: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * <adf-webscript-get [scriptPath]="string"
 *                         [scriptArgs]="Object"
 *                         [contextRoot]="string"
 *                         [servicePath]="string"
 *                         [contentType]="JSON|HTML|DATATABLE"
 *                         (success)="customMethod($event)>
 * </adf-webscript-get>
 *
 * This component, provide a get webscript viewer
 *
 * \@InputParam {string} scriptPath path to Web Script (as defined by Web Script)
 * \@InputParam {Object} scriptArgs arguments to pass to Web Script
 * \@InputParam {string} contextRoot path where application is deployed default value 'alfresco'
 * \@InputParam {string} servicePath path where Web Script service is mapped default value 'service'
 * \@InputParam {string} contentType JSON | HTML | DATATABLE | TEXT
 *
 * \@Output - success - The event is emitted when the data are received
 *
 */
class WebscriptComponent {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        /**
         * Toggles whether to show or hide the data.
         */
        this.showData = true;
        /**
         * Path where the application is deployed
         */
        this.contextRoot = 'alfresco';
        /**
         * Path that the webscript service is mapped to.
         */
        this.servicePath = 'service';
        /**
         * Content type to interpret the data received from the webscript.
         * Can be "JSON" , "HTML" , "DATATABLE" or "TEXT"
         */
        this.contentType = 'TEXT';
        /**
         * Emitted when the operation succeeds. You can get the plain data from
         * the webscript through the **success** event parameter and use it as you
         * need in your application.
         */
        this.success = new EventEmitter();
        this.data = undefined;
        this.showError = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.showData) {
            this.clean();
        }
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.apiService.getInstance().webScript.executeWebScript('GET', this.scriptPath, this.scriptArgs, this.contextRoot, this.servicePath).then((/**
             * @param {?} webScriptData
             * @return {?}
             */
            (webScriptData) => {
                this.data = webScriptData;
                if (this.showData) {
                    if (this.contentType === 'DATATABLE') {
                        this.data = this.showDataAsDataTable(webScriptData);
                    }
                }
                this.success.emit(this.data);
                resolve();
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                this.logService.log('Error' + error);
                reject();
            }));
        }));
    }
    /**
     * show the data in a ng2-alfresco-datatable
     *
     * @param {?} data
     *
     * @return {?} the data as datatable
     */
    showDataAsDataTable(data) {
        /** @type {?} */
        const datatableData = null;
        try {
            if (!data.schema) {
                data.schema = ObjectDataTableAdapter.generateSchema(data.data);
            }
            if (data.schema && data.schema.length > 0) {
                this.data = new ObjectDataTableAdapter(data.data, data.schema);
            }
        }
        catch (error) {
            this.logService.error('error during the cast as datatable');
        }
        return datatableData;
    }
    /**
     * @return {?}
     */
    clean() {
        this.data = undefined;
    }
    /**
     * @return {?}
     */
    isDataTableContent() {
        return this.contentType === 'DATATABLE';
    }
}
WebscriptComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-webscript-get',
                template: "<div *ngIf=\"showData\">\n    <div *ngIf=\"contentType === 'JSON'\" id=\"webscript-data-JSON\">{{data | json}}</div>\n    <div *ngIf=\"contentType === 'HTML'\" id=\"webscript-data-HTML\" [innerHTML]=\"data\"></div>\n    <div *ngIf=\"contentType === 'TEXT'\" id=\"webscript-data-TEXT\">{{data}}</div>\n    <div *ngIf=\"isDataTableContent()\">\n        <adf-datatable id=\"webscript-datatable-wrapper\" [data]=\"data\"></adf-datatable>\n        <div>\n            <div *ngIf=\"showError\" id=\"error\">{{'WEBSCRIPT.ERROR' | translate: {\n                data: data,\n                contentType: contentType\n                }\n                }}\n            </div>\n        </div>\n    </div>\n</div>\n"
            }] }
];
/** @nocollapse */
WebscriptComponent.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
WebscriptComponent.propDecorators = {
    scriptPath: [{ type: Input }],
    scriptArgs: [{ type: Input }],
    showData: [{ type: Input }],
    contextRoot: [{ type: Input }],
    servicePath: [{ type: Input }],
    contentType: [{ type: Input }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WebScriptModule {
}
WebScriptModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule.forChild()
                ],
                exports: [
                    WebscriptComponent
                ],
                declarations: [
                    WebscriptComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShareDataRow {
    /**
     * @param {?} obj
     * @param {?} contentService
     * @param {?} permissionsStyle
     * @param {?=} thumbnailService
     */
    constructor(obj, contentService, permissionsStyle, thumbnailService) {
        this.obj = obj;
        this.contentService = contentService;
        this.permissionsStyle = permissionsStyle;
        this.thumbnailService = thumbnailService;
        this.cache = {};
        this.isSelected = false;
        this.cssClass = '';
        if (!obj) {
            throw new Error(ShareDataRow.ERR_OBJECT_NOT_FOUND);
        }
        this.isDropTarget = this.isFolderAndHasPermissionToUpload(obj);
        if (permissionsStyle) {
            this.cssClass = this.getPermissionClass(obj);
        }
    }
    /**
     * @return {?}
     */
    get node() {
        return this.obj;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set node(value) {
        this.obj = value;
        this.cache = {};
    }
    /**
     * @param {?} nodeEntity
     * @return {?}
     */
    getPermissionClass(nodeEntity) {
        /** @type {?} */
        let permissionsClasses = '';
        this.permissionsStyle.forEach((/**
         * @param {?} currentPermissionsStyle
         * @return {?}
         */
        (currentPermissionsStyle) => {
            if (this.applyPermissionStyleToFolder(nodeEntity.entry, currentPermissionsStyle) || this.applyPermissionStyleToFile(nodeEntity.entry, currentPermissionsStyle)) {
                if (this.contentService.hasAllowableOperations(nodeEntity.entry, currentPermissionsStyle.permission)) {
                    permissionsClasses += ` ${currentPermissionsStyle.css}`;
                }
            }
        }));
        return permissionsClasses;
    }
    /**
     * @private
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    applyPermissionStyleToFile(node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFile && node.isFile);
    }
    /**
     * @private
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    applyPermissionStyleToFolder(node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFolder && node.isFolder);
    }
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    isFolderAndHasPermissionToUpload(nodeEntry) {
        return this.isFolder(nodeEntry) && this.contentService.hasAllowableOperations(nodeEntry.entry, 'create');
    }
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    isFolder(nodeEntry) {
        return nodeEntry.entry && nodeEntry.entry.isFolder;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    cacheValue(key, value) {
        this.cache[key] = value;
        return value;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getValue(key) {
        if (this.cache[key] !== undefined) {
            return this.cache[key];
        }
        return ObjectUtils.getValue(this.obj.entry, key);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    imageErrorResolver(event) {
        if (this.obj.entry.content) {
            return this.thumbnailService.getMimeTypeIcon(this.obj.entry.content.mimeType);
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    hasValue(key) {
        return this.getValue(key) !== undefined;
    }
}
ShareDataRow.ERR_OBJECT_NOT_FOUND = 'Object source not found';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShareDataTableAdapter {
    /**
     * @param {?} thumbnailService
     * @param {?} contentService
     * @param {?=} schema
     * @param {?=} sorting
     * @param {?=} sortingMode
     */
    constructor(thumbnailService, contentService, schema = [], sorting, sortingMode = 'client') {
        this.thumbnailService = thumbnailService;
        this.contentService = contentService;
        this.ERR_ROW_NOT_FOUND = 'Row not found';
        this.ERR_COL_NOT_FOUND = 'Column not found';
        this.thumbnails = false;
        this.rows = [];
        this.columns = schema || [];
        this.sorting = sorting;
        this.sortingMode = sortingMode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sortingMode(value) {
        /** @type {?} */
        let newValue = (value || 'client').toLowerCase();
        if (newValue !== 'client' && newValue !== 'server') {
            newValue = 'client';
        }
        this._sortingMode = newValue;
    }
    /**
     * @return {?}
     */
    get sortingMode() {
        return this._sortingMode;
    }
    /**
     * @return {?}
     */
    getRows() {
        return this.rows;
    }
    // TODO: disable this api
    /**
     * @param {?} rows
     * @return {?}
     */
    setRows(rows) {
        this.rows = rows || [];
        this.sort();
    }
    /**
     * @return {?}
     */
    getColumns() {
        return this.columns;
    }
    /**
     * @param {?} columns
     * @return {?}
     */
    setColumns(columns) {
        this.columns = columns || [];
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getValue(row, col) {
        if (!row) {
            throw new Error(this.ERR_ROW_NOT_FOUND);
        }
        if (!col) {
            throw new Error(this.ERR_COL_NOT_FOUND);
        }
        /** @type {?} */
        const dataRow = (/** @type {?} */ (row));
        /** @type {?} */
        const value = row.getValue(col.key);
        if (dataRow.cache[col.key] !== undefined) {
            return dataRow.cache[col.key];
        }
        if (col.key === '$thumbnail') {
            if (this.imageResolver) {
                /** @type {?} */
                const resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
            /** @type {?} */
            const node = ((/** @type {?} */ (row))).node;
            if (node.entry.isFolder) {
                return this.getFolderIcon(node);
            }
            if (node.entry.isFile) {
                if (this.thumbnails) {
                    return this.thumbnailService.getDocumentThumbnailUrl(node);
                }
            }
            if (node.entry.content) {
                /** @type {?} */
                const mimeType = node.entry.content.mimeType;
                if (mimeType) {
                    return this.thumbnailService.getMimeTypeIcon(mimeType);
                }
            }
            return this.thumbnailService.getDefaultMimeTypeIcon();
        }
        if (col.type === 'image') {
            if (this.imageResolver) {
                /** @type {?} */
                const resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
        }
        return dataRow.cacheValue(col.key, value);
    }
    /**
     * @return {?}
     */
    getSorting() {
        return this.sorting;
    }
    /**
     * @param {?} sorting
     * @return {?}
     */
    setSorting(sorting) {
        this.sorting = sorting;
        this.sortRows(this.rows, this.sorting);
    }
    /**
     * @param {?=} key
     * @param {?=} direction
     * @return {?}
     */
    sort(key, direction) {
        /** @type {?} */
        const sorting = this.sorting || new DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    setFilter(filter$$1) {
        this.filter = filter$$1;
    }
    /**
     * @param {?} resolver
     * @return {?}
     */
    setImageResolver(resolver) {
        this.imageResolver = resolver;
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getFolderIcon(node) {
        if (this.isSmartFolder(node)) {
            return this.thumbnailService.getMimeTypeIcon('smartFolder');
        }
        else if (this.isRuleFolder(node)) {
            return this.thumbnailService.getMimeTypeIcon('ruleFolder');
        }
        else if (this.isALinkFolder(node)) {
            return this.thumbnailService.getMimeTypeIcon('linkFolder');
        }
        else {
            return this.thumbnailService.getMimeTypeIcon('folder');
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isSmartFolder(node) {
        /** @type {?} */
        const nodeAspects = this.getNodeAspectNames(node);
        return nodeAspects.indexOf('smf:customConfigSmartFolder') > -1 ||
            (nodeAspects.indexOf('smf:systemConfigSmartFolder') > -1);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isRuleFolder(node) {
        /** @type {?} */
        const nodeAspects = this.getNodeAspectNames(node);
        return nodeAspects.indexOf('rule:rules') > -1 ||
            (nodeAspects.indexOf('rule:rules') > -1);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isALinkFolder(node) {
        /** @type {?} */
        const nodeType = node.entry ? node.entry.nodeType : node.nodeType;
        return nodeType === 'app:folderlink';
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getNodeAspectNames(node) {
        return node.entry && node.entry.aspectNames ? node.entry.aspectNames : node.aspectNames ? node.aspectNames : [];
    }
    /**
     * @private
     * @param {?} rows
     * @param {?} sorting
     * @return {?}
     */
    sortRows(rows, sorting) {
        if (this.sortingMode === 'server') {
            return;
        }
        /** @type {?} */
        const options = {};
        if (sorting && sorting.key && rows && rows.length > 0) {
            if (sorting.key.includes('sizeInBytes') || sorting.key === 'name') {
                options.numeric = true;
            }
            rows.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => {
                if (a.node.entry.isFolder !== b.node.entry.isFolder) {
                    return a.node.entry.isFolder ? -1 : 1;
                }
                /** @type {?} */
                let left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                /** @type {?} */
                let right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right, undefined, options)
                    : right.localeCompare(left, undefined, options);
            }));
        }
    }
    /**
     * @param {?} nodePaging
     * @param {?=} merge
     * @return {?}
     */
    loadPage(nodePaging, merge$$1 = false) {
        /** @type {?} */
        let shareDataRows = [];
        if (nodePaging && nodePaging.list) {
            /** @type {?} */
            const nodeEntries = nodePaging.list.entries;
            if (nodeEntries && nodeEntries.length > 0) {
                shareDataRows = nodeEntries.map((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => new ShareDataRow(item, this.contentService, this.permissionsStyle, this.thumbnailService)));
                if (this.filter) {
                    shareDataRows = shareDataRows.filter(this.filter);
                }
                if (this.sortingMode !== 'server') {
                    // Sort by first sortable or just first column
                    if (this.columns && this.columns.length > 0) {
                        /** @type {?} */
                        const sorting = this.getSorting();
                        if (sorting) {
                            this.sortRows(shareDataRows, sorting);
                        }
                        else {
                            /** @type {?} */
                            const sortable = this.columns.filter((/**
                             * @param {?} c
                             * @return {?}
                             */
                            (c) => c.sortable));
                            if (sortable.length > 0) {
                                this.sort(sortable[0].key, 'asc');
                            }
                            else {
                                this.sort(this.columns[0].key, 'asc');
                            }
                        }
                    }
                }
            }
        }
        if (merge$$1) {
            /** @type {?} */
            const listPrunedDuplicate = shareDataRows.filter((/**
             * @param {?} elementToFilter
             * @return {?}
             */
            (elementToFilter) => {
                /** @type {?} */
                const isPresent = this.rows.find((/**
                 * @param {?} currentRow
                 * @return {?}
                 */
                (currentRow) => {
                    return currentRow.obj.entry.id === elementToFilter.obj.entry.id;
                }));
                return !isPresent;
            }));
            this.rows = this.rows.concat(listPrunedDuplicate);
        }
        else {
            this.rows = shareDataRows;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let presetsDefaultModel = {
    '-trashcan-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'archivedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'archivedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_BY',
            sortable: true
        }
    ],
    '-sites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-mysites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-favorites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ],
    '-recent-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        }
    ],
    '-sharedlinks-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        },
        {
            key: 'sharedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SHARED_BY',
            sortable: true
        }
    ],
    'default': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentActionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.disableWithNoPermission = false;
        this.disabled = false;
        this.visible = true;
        if (obj) {
            this.icon = obj.icon;
            this.title = obj.title;
            this.handler = obj.handler;
            this.execute = obj.execute;
            this.target = obj.target;
            this.permission = obj.permission;
            this.disableWithNoPermission = obj.disableWithNoPermission;
            if (obj.hasOwnProperty('disabled')) {
                this.disabled = obj.disabled;
            }
            if (obj.hasOwnProperty('visible')) {
                this.visible = obj.visible;
            }
        }
    }
}
/** @enum {string} */
const ContentActionTarget = {
    Document: 'document',
    Folder: 'folder',
    All: 'all',
};
class DocumentActionModel extends ContentActionModel {
    /**
     * @param {?=} json
     */
    constructor(json) {
        super(json);
        this.target = 'document';
    }
}
class FolderActionModel extends ContentActionModel {
    /**
     * @param {?=} json
     */
    constructor(json) {
        super(json);
        this.target = 'folder';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodeEntityEvent extends BaseEvent {
    /**
     * @param {?} nodeEntry
     */
    constructor(nodeEntry) {
        super();
        this.value = nodeEntry;
    }
}
class NodeEntryEvent extends BaseEvent {
    /**
     * @param {?} node
     */
    constructor(node) {
        super();
        this.value = node;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DocumentListComponent {
    /**
     * @param {?} documentListService
     * @param {?} ngZone
     * @param {?} elementRef
     * @param {?} appConfig
     * @param {?} userPreferencesService
     * @param {?} contentService
     * @param {?} thumbnailService
     * @param {?} alfrescoApiService
     * @param {?} lockService
     */
    constructor(documentListService, ngZone, elementRef, appConfig, userPreferencesService, contentService, thumbnailService, alfrescoApiService, lockService) {
        this.documentListService = documentListService;
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.appConfig = appConfig;
        this.userPreferencesService = userPreferencesService;
        this.contentService = contentService;
        this.thumbnailService = thumbnailService;
        this.alfrescoApiService = alfrescoApiService;
        this.lockService = lockService;
        this.DEFAULT_PAGINATION = new Pagination({
            hasMoreItems: false,
            skipCount: 0,
            maxItems: 25,
            totalItems: 0
        });
        /**
         * Change the display mode of the table. Can be "list" or "gallery".
         */
        this.display = DisplayMode.List;
        /**
         * Define a set of CSS styles to apply depending on the permission
         * of the user on that node. See the Permission Style model
         * page for further details and examples.
         */
        this.permissionsStyle = [];
        /**
         * The default route for all the location-based columns (if declared).
         */
        this.locationFormat = '/';
        /**
         * Toggles navigation to folder content or file preview
         */
        this.navigate = true;
        /**
         * Toggles the header
         */
        this.showHeader = true;
        /**
         * User interaction for folder navigation or file preview.
         * Valid values are "click" and "dblclick". Default value: "dblclick"
         */
        this.navigationMode = DocumentListComponent.DOUBLE_CLICK_NAVIGATION; // click|dblclick
        // click|dblclick
        /**
         * Show document thumbnails rather than icons
         */
        this.thumbnails = false;
        /**
         * Row selection mode. Can be null, `single` or `multiple`. For `multiple` mode,
         * you can use Cmd (macOS) or Ctrl (Win) modifier key to toggle selection for multiple rows.
         */
        this.selectionMode = 'single'; // null|single|multiple
        // null|single|multiple
        /**
         * Toggles multiselect mode
         */
        this.multiselect = false;
        /**
         * Toggles content actions for each row
         */
        this.contentActions = false;
        /**
         * Position of the content actions dropdown menu. Can be set to "left" or "right".
         */
        this.contentActionsPosition = 'right'; // left|right
        // left|right
        /**
         * Toggles context menus for each row
         */
        this.contextMenuActions = false;
        /**
         * Custom image for empty folder. Default value: './assets/images/empty_doc_lib.svg'
         */
        this.emptyFolderImageUrl = './assets/images/empty_doc_lib.svg';
        /**
         * When true, this enables you to drop files directly into subfolders shown
         * as items in the list. When false, the dropped file will be added to the
         * current folder (ie, the one containing all the items shown in the list).
         * See the Upload directive for further details about how the file drop is
         * handled.
         */
        this.allowDropFiles = false;
        /**
         * Defines default sorting. The format is an array of 2 strings `[key, direction]`
         * i.e. `['name', 'desc']` or `['name', 'asc']`. Set this value only if you want to
         * override the default sorting detected by the component based on columns.
         */
        this.sorting = ['name', 'asc'];
        /**
         * Defines sorting mode. Can be either `client` (items in the list
         * are sorted client-side) or `server` (the ordering supplied by the
         * server is used without further client-side sorting).
         * Note that the `server` option *does not* request the server to sort the data
         * before delivering it.
         */
        this.sortingMode = 'client';
        /**
         * Toggles the loading state and animated spinners for the component. Used in
         * combination with `navigate=false` to perform custom navigation and loading
         * state indication.
         */
        this.loading = false;
        /**
         * @hidden
         */
        this._rowFilter = null;
        /**
         * Custom function to choose image file paths to show. See the
         * [Image Resolver Model](image-resolver.model.md) page for
         * more information.
         */
        this.imageResolver = null;
        /**
         * Toggles the sticky header mode.
         */
        this.stickyHeader = false;
        this._currentFolderId = null;
        /**
         * The Document list will show all the nodes contained in the NodePaging entity
         */
        this.node = null;
        /**
         * Default value is stored in the user preference settings. Use this only if you are not using pagination.
         */
        this.maxItems = this.DEFAULT_PAGINATION.maxItems;
        /**
         * Emitted when the user clicks a list node
         */
        this.nodeClick = new EventEmitter();
        /**
         * Emitted when the user double-clicks a list node
         */
        this.nodeDblClick = new EventEmitter();
        /**
         * Emitted when the current display folder changes
         */
        this.folderChange = new EventEmitter();
        /**
         * Emitted when the user acts upon files with either single or double click
         * (depends on `navigation-mode`). Useful for integration with the
         * Viewer component.
         */
        this.preview = new EventEmitter();
        /**
         * Emitted when the Document List has loaded all items and is ready for use
         */
        this.ready = new EventEmitter();
        /**
         * Emitted when the API fails to get the Document List data
         */
        this.error = new EventEmitter();
        this.actions = [];
        this.contextActionHandler = new Subject();
        this.noPermission = false;
        this.selection = new Array();
        this.$folderNode = new Subject();
        this._pagination = this.DEFAULT_PAGINATION;
        this.pagination = new BehaviorSubject(this.DEFAULT_PAGINATION);
        this.layoutPresets = {};
        this.subscriptions = [];
        this.rowMenuCache = {};
        this.userPreferencesService.select(UserPreferenceValues.PaginationSize).subscribe((/**
         * @param {?} pagSize
         * @return {?}
         */
        (pagSize) => {
            this.maxItems = this._pagination.maxItems = pagSize;
        }));
    }
    /**
     * Custom function to choose whether to show or hide rows.
     * See the [Row Filter Model](row-filter.model.md) page for
     * more information.
     * @param {?} rowFilter
     * @return {?}
     */
    set rowFilter(rowFilter) {
        this._rowFilter = rowFilter;
        if (this.data) {
            this.data.setFilter(this._rowFilter);
            if (this._currentFolderId) {
                this.reload();
            }
        }
    }
    /**
     * @return {?}
     */
    get rowFilter() {
        return this._rowFilter;
    }
    /**
     * The ID of the folder node to display or a reserved string alias for special sources
     * @param {?} currentFolderId
     * @return {?}
     */
    set currentFolderId(currentFolderId) {
        if (this._currentFolderId !== currentFolderId) {
            this._currentFolderId = currentFolderId;
            if (this.data) {
                this.data.loadPage(null, false);
                this.resetNewFolderPagination();
            }
            if (this._currentFolderId) {
                this.loadFolder();
            }
        }
    }
    /**
     * @return {?}
     */
    get currentFolderId() {
        return this._currentFolderId;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getContextActions(node) {
        if (node && node.entry) {
            /** @type {?} */
            const actions = this.getNodeActions(node);
            if (actions && actions.length > 0) {
                return actions.map((/**
                 * @param {?} currentAction
                 * @return {?}
                 */
                (currentAction) => {
                    return {
                        model: currentAction,
                        node: node,
                        subject: this.contextActionHandler
                    };
                }));
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    get hasCustomLayout() {
        return this.columnList && this.columnList.columns && this.columnList.columns.length > 0;
    }
    /**
     * @private
     * @return {?}
     */
    getDefaultSorting() {
        /** @type {?} */
        let defaultSorting;
        if (this.sorting) {
            const [key, direction] = this.sorting;
            defaultSorting = new DataSorting(key, direction);
        }
        return defaultSorting;
    }
    /**
     * @private
     * @param {?=} name
     * @return {?}
     */
    getLayoutPreset(name = 'default') {
        return (this.layoutPresets[name] || this.layoutPresets['default']).map((/**
         * @param {?} col
         * @return {?}
         */
        (col) => new ObjectDataColumn(col)));
    }
    /**
     * @return {?}
     */
    isMobile() {
        return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return !this.data || this.data.getRows().length === 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.rowMenuCache = {};
        this.loadLayoutPresets();
        this.data = new ShareDataTableAdapter(this.thumbnailService, this.contentService, null, this.getDefaultSorting(), this.sortingMode);
        this.data.thumbnails = this.thumbnails;
        this.data.permissionsStyle = this.permissionsStyle;
        if (this._rowFilter) {
            this.data.setFilter(this._rowFilter);
        }
        if (this.imageResolver) {
            this.data.setImageResolver(this.imageResolver);
        }
        this.subscriptions.push(this.contextActionHandler.subscribe((/**
         * @param {?} val
         * @return {?}
         */
        (val) => this.contextActionCallback(val))));
        this.enforceSingleClickNavigationForMobile();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.columnList) {
            this.subscriptions.push(this.columnList.columns.changes.subscribe((/**
             * @return {?}
             */
            () => {
                this.setTableSchema();
            })));
        }
        this.setTableSchema();
    }
    /**
     * @private
     * @return {?}
     */
    setTableSchema() {
        /** @type {?} */
        let schema = [];
        if (this.hasCustomLayout) {
            schema = this.columnList.columns.map((/**
             * @param {?} c
             * @return {?}
             */
            (c) => (/** @type {?} */ (c))));
        }
        if (!this.data) {
            this.data = new ShareDataTableAdapter(this.thumbnailService, this.contentService, schema, this.getDefaultSorting(), this.sortingMode);
        }
        else if (schema && schema.length > 0) {
            this.data.setColumns(schema);
        }
        /** @type {?} */
        const columns = this.data.getColumns();
        if (!columns || columns.length === 0) {
            this.setupDefaultColumns(this._currentFolderId);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.resetSelection();
        if (this.data) {
            this.data.thumbnails = this.thumbnails;
        }
        if (changes.sortingMode && !changes.sortingMode.firstChange && this.data) {
            this.data.sortingMode = changes.sortingMode.currentValue;
        }
        if (changes.sorting && !changes.sorting.firstChange && this.data) {
            /** @type {?} */
            const newValue = changes.sorting.currentValue;
            if (newValue && newValue.length > 0) {
                const [key, direction] = newValue;
                this.data.setSorting(new DataSorting(key, direction));
            }
        }
        if (this.data) {
            if (changes.node && changes.node.currentValue) {
                /** @type {?} */
                const merge$$1 = this._pagination ? this._pagination.merge : false;
                this.data.loadPage(changes.node.currentValue, merge$$1);
                this.onDataReady(changes.node.currentValue);
            }
            else if (changes.imageResolver) {
                this.data.setImageResolver(changes.imageResolver.currentValue);
            }
        }
    }
    /**
     * @return {?}
     */
    reload() {
        this.ngZone.run((/**
         * @return {?}
         */
        () => {
            this.resetSelection();
            if (this.node) {
                this.data.loadPage(this.node, this._pagination.merge);
                this.onDataReady(this.node);
            }
            else {
                this.loadFolder();
            }
        }));
    }
    /**
     * @param {?} action
     * @return {?}
     */
    contextActionCallback(action) {
        if (action) {
            this.executeContentAction(action.node, action.model);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getNodeActions(node) {
        if (node && node.entry) {
            /** @type {?} */
            let target = null;
            if (node.entry.isFile) {
                target = 'document';
            }
            else if (node.entry.isFolder) {
                target = 'folder';
            }
            if (target) {
                /** @type {?} */
                const actions = this.rowMenuCache[node.entry.id];
                if (actions) {
                    actions.forEach((/**
                     * @param {?} action
                     * @return {?}
                     */
                    (action) => {
                        this.refreshAction(action, node);
                    }));
                    return actions;
                }
                /** @type {?} */
                const actionsByTarget = this.actions
                    .filter((/**
                 * @param {?} entry
                 * @return {?}
                 */
                (entry) => {
                    /** @type {?} */
                    const isVisible = (typeof entry.visible === 'function')
                        ? entry.visible(node)
                        : entry.visible;
                    return isVisible && entry.target.toLowerCase() === target;
                }))
                    .map((/**
                 * @param {?} action
                 * @return {?}
                 */
                (action) => new ContentActionModel(action)));
                actionsByTarget.forEach((/**
                 * @param {?} action
                 * @return {?}
                 */
                (action) => {
                    this.refreshAction(action, node);
                }));
                this.rowMenuCache[node.entry.id] = actionsByTarget;
                return actionsByTarget;
            }
        }
        return [];
    }
    /**
     * @private
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    refreshAction(action, node) {
        action.disabled = this.isActionDisabled(action, node);
        action.visible = this.isActionVisible(action, node);
    }
    /**
     * @private
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    isActionVisible(action, node) {
        if (typeof action.visible === 'function') {
            return action.visible(node);
        }
        return action.visible;
    }
    /**
     * @private
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    isActionDisabled(action, node) {
        if (typeof action.disabled === 'function') {
            return action.disabled(node);
        }
        if ((action.permission &&
            action.disableWithNoPermission &&
            !this.contentService.hasAllowableOperations(node.entry, action.permission)) ||
            this.lockService.isLocked(node.entry)) {
            return true;
        }
        else {
            return action.disabled;
        }
    }
    /**
     * @param {?=} e
     * @return {?}
     */
    onShowContextMenu(e) {
        if (e && this.contextMenuActions) {
            e.preventDefault();
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    navigateTo(node) {
        if (typeof node === 'string') {
            this.resetNewFolderPagination();
            this._currentFolderId = node;
            this.folderChange.emit(new NodeEntryEvent((/** @type {?} */ ({ id: node }))));
            this.reload();
            return true;
        }
        else {
            if (this.canNavigateFolder(node)) {
                this.resetNewFolderPagination();
                this._currentFolderId = this.getNodeFolderDestinationId(node);
                this.folderChange.emit(new NodeEntryEvent((/** @type {?} */ ({ id: this._currentFolderId }))));
                this.reload();
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getNodeFolderDestinationId(node) {
        return this.isLinkFolder(node) ? node.properties['cm:destination'] : node.id;
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    isLinkFolder(node) {
        return node.nodeType === 'app:folderlink' && node.properties &&
            node.properties['cm:destination'];
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    updateCustomSourceData(nodeId) {
        this._currentFolderId = nodeId;
    }
    /**
     * Invoked when executing content action for a document or folder.
     * @param {?} node Node to be the context of the execution.
     * @param {?} action Action to be executed against the context.
     * @return {?}
     */
    executeContentAction(node, action) {
        if (node && node.entry && action) {
            /** @type {?} */
            let handlerSub;
            if (typeof action.handler === 'function') {
                handlerSub = action.handler(node, this, action.permission);
            }
            else {
                handlerSub = of(true);
            }
            if (typeof action.execute === 'function' && handlerSub) {
                handlerSub.subscribe((/**
                 * @return {?}
                 */
                () => {
                    action.execute(node);
                }));
            }
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setLoadingState(value) {
        if (value) {
            clearTimeout(this.loadingTimeout);
            this.loadingTimeout = setTimeout((/**
             * @return {?}
             */
            () => {
                this.loading = true;
            }), 1000);
        }
        else {
            clearTimeout(this.loadingTimeout);
            this.loading = false;
        }
    }
    /**
     * @return {?}
     */
    loadFolder() {
        if (!this._pagination.merge) {
            this.setLoadingState(true);
        }
        if (!this.hasCustomLayout) {
            this.setupDefaultColumns(this._currentFolderId);
        }
        if (this.documentListService.isCustomSourceService(this._currentFolderId)) {
            this.updateCustomSourceData(this._currentFolderId);
        }
        this.documentListService.loadFolderByNodeId(this._currentFolderId, this._pagination, this.includeFields, this.where)
            .subscribe((/**
         * @param {?} documentNode
         * @return {?}
         */
        (documentNode) => {
            if (documentNode.currentNode) {
                this.folderNode = documentNode.currentNode.entry;
                this.$folderNode.next(documentNode.currentNode.entry);
            }
            this.onPageLoaded(documentNode.children);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.handleError(err);
        }));
    }
    /**
     * @return {?}
     */
    resetSelection() {
        this.dataTable.resetSelection();
        this.selection = [];
        this.noPermission = false;
    }
    /**
     * @param {?} nodePaging
     * @return {?}
     */
    onPageLoaded(nodePaging) {
        if (nodePaging) {
            this.data.loadPage(nodePaging, this._pagination.merge);
            this.setLoadingState(false);
            this.onDataReady(nodePaging);
        }
    }
    /**
     * Creates a set of predefined columns.
     * @param {?=} preset
     * @return {?}
     */
    setupDefaultColumns(preset = 'default') {
        if (this.data) {
            /** @type {?} */
            const columns = this.getLayoutPreset(preset);
            this.data.setColumns(columns);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onPreviewFile(node) {
        if (node) {
            this.preview.emit(new NodeEntityEvent(node));
        }
    }
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    onNodeClick(nodeEntry) {
        /** @type {?} */
        const domEvent = new CustomEvent('node-click', {
            detail: {
                sender: this,
                node: nodeEntry
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        /** @type {?} */
        const event = new NodeEntityEvent(nodeEntry);
        this.nodeClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.SINGLE_CLICK_NAVIGATION) {
                this.executeActionClick(nodeEntry);
            }
        }
    }
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    onNodeDblClick(nodeEntry) {
        /** @type {?} */
        const domEvent = new CustomEvent('node-dblclick', {
            detail: {
                sender: this,
                node: nodeEntry
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        /** @type {?} */
        const event = new NodeEntityEvent(nodeEntry);
        this.nodeDblClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.DOUBLE_CLICK_NAVIGATION) {
                this.executeActionClick(nodeEntry);
            }
        }
    }
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    executeActionClick(nodeEntry) {
        if (nodeEntry && nodeEntry.entry) {
            if (nodeEntry.entry.isFile) {
                this.onPreviewFile(nodeEntry);
            }
            if (nodeEntry.entry.isFolder) {
                this.navigateTo(nodeEntry.entry);
            }
            if (nodeEntry.entry['guid']) {
                /** @type {?} */
                const options = {
                    include: this.includeFields
                };
                this.alfrescoApiService.nodesApi.getNode(nodeEntry.entry['guid'], options)
                    .then((/**
                 * @param {?} node
                 * @return {?}
                 */
                (node) => {
                    this.navigateTo(node.entry);
                }));
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onNodeSelect(event) {
        this.selection = event.selection.map((/**
         * @param {?} entry
         * @return {?}
         */
        (entry) => entry.node));
        /** @type {?} */
        const domEvent = new CustomEvent('node-select', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onNodeUnselect(event) {
        this.selection = event.selection.map((/**
         * @param {?} entry
         * @return {?}
         */
        (entry) => entry.node));
        /** @type {?} */
        const domEvent = new CustomEvent('node-unselect', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowContextMenu(event) {
        if (this.contextMenuActions) {
            /** @type {?} */
            const args = event.value;
            /** @type {?} */
            const node = ((/** @type {?} */ (args.row))).node;
            if (node) {
                args.actions = this.getContextActions(node) || [];
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowActionsMenu(event) {
        if (this.contentActions) {
            /** @type {?} */
            const args = event.value;
            /** @type {?} */
            const node = ((/** @type {?} */ (args.row))).node;
            if (node) {
                args.actions = this.getNodeActions(node) || [];
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExecuteRowAction(event) {
        if (this.contentActions) {
            /** @type {?} */
            const args = event.value;
            /** @type {?} */
            const node = ((/** @type {?} */ (args.row))).node;
            /** @type {?} */
            const action = ((/** @type {?} */ (args.action)));
            this.executeContentAction(node, action);
        }
    }
    /**
     * @private
     * @return {?}
     */
    enforceSingleClickNavigationForMobile() {
        if (this.isMobile()) {
            this.navigationMode = DocumentListComponent.SINGLE_CLICK_NAVIGATION;
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    canNavigateFolder(node) {
        /** @type {?} */
        let canNavigateFolder = false;
        if (node && node.isFolder) {
            canNavigateFolder = true;
        }
        return canNavigateFolder;
    }
    /**
     * @private
     * @return {?}
     */
    loadLayoutPresets() {
        /** @type {?} */
        const externalSettings = this.appConfig.get('document-list.presets', null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, presetsDefaultModel, externalSettings);
        }
        else {
            this.layoutPresets = presetsDefaultModel;
        }
    }
    /**
     * @private
     * @param {?} nodePaging
     * @return {?}
     */
    onDataReady(nodePaging) {
        this.ready.emit(nodePaging);
        this.pagination.next(nodePaging.list.pagination);
    }
    /**
     * @param {?} requestPaginationModel
     * @return {?}
     */
    updatePagination(requestPaginationModel) {
        this._pagination.maxItems = requestPaginationModel.maxItems;
        this._pagination.merge = requestPaginationModel.merge;
        this._pagination.skipCount = requestPaginationModel.skipCount;
        this.reload();
    }
    /**
     * @private
     * @return {?}
     */
    resetNewFolderPagination() {
        this._pagination.skipCount = 0;
        this._pagination.maxItems = this.maxItems;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} s
         * @return {?}
         */
        (s) => s.unsubscribe()));
        this.subscriptions = [];
    }
    /**
     * @private
     * @param {?} err
     * @return {?}
     */
    handleError(err) {
        if (err.message) {
            try {
                if (JSON.parse(err.message).error.statusCode === 403) {
                    this.setLoadingState(false);
                    this.noPermission = true;
                }
            }
            catch (error) {
            }
        }
        this.error.emit(err);
    }
}
DocumentListComponent.SINGLE_CLICK_NAVIGATION = 'click';
DocumentListComponent.DOUBLE_CLICK_NAVIGATION = 'dblclick';
DocumentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-document-list',
                template: "<adf-datatable\n    #dataTable\n    [selectionMode]=\"selectionMode\"\n    [data]=\"data\"\n    [actions]=\"contentActions\"\n    [actionsPosition]=\"contentActionsPosition\"\n    [multiselect]=\"multiselect\"\n    [allowDropFiles]=\"allowDropFiles\"\n    [contextMenu]=\"contextMenuActions\"\n    [rowStyle]=\"rowStyle\"\n    [rowStyleClass]=\"rowStyleClass\"\n    [loading]=\"loading\"\n    [display]=\"display\"\n    [noPermission]=\"noPermission\"\n    [showHeader]=\"!isEmpty() && showHeader\"\n    [rowMenuCacheEnabled]=\"false\"\n    [stickyHeader]=\"stickyHeader\"\n    (showRowContextMenu)=\"onShowRowContextMenu($event)\"\n    (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n    (executeRowAction)=\"onExecuteRowAction($event)\"\n    (rowClick)=\"onNodeClick($event.value?.node)\"\n    (rowDblClick)=\"onNodeDblClick($event.value?.node)\"\n    (row-select)=\"onNodeSelect($event.detail)\"\n    (row-unselect)=\"onNodeUnselect($event.detail)\"\n    [class.adf-datatable-gallery-thumbnails]=\"data.thumbnails\">\n\n    <adf-no-content-template>\n        <ng-template>\n            <adf-empty-list *ngIf=\"!customNoContentTemplate\">\n                <div class=\"adf-empty-list_template adf-empty-folder\">\n                    <div class=\"adf-empty-folder-this-space-is-empty\">{{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}}</div>\n                    <div fxHide.lt-md=\"true\" class=\"adf-empty-folder-drag-drop\">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.TITLE' | translate }}</div>\n                    <div fxHide.lt-md=\"true\" class=\"adf-empty-folder-any-files-here-to-add\">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.SUBTITLE' | translate }}</div>\n                    <img [alt]=\"'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.TITLE' | translate\" class=\"adf-empty-folder-image\" [src]=\"emptyFolderImageUrl\">\n                </div>\n            </adf-empty-list>\n            <ng-content select=\"adf-custom-empty-content-template, empty-folder-content\"></ng-content>\n        </ng-template>\n    </adf-no-content-template>\n\n    <adf-no-permission-template>\n        <ng-template>\n            <div class=\"adf-no-permission__template\" *ngIf=\"!customNoPermissionsTemplate\">\n                <mat-icon>ic_error</mat-icon>\n                <p class=\"adf-no-permission__template--text\">{{ 'ADF-DOCUMENT-LIST.NO_PERMISSION' | translate }}</p>\n            </div>\n            <ng-content select=\"adf-custom-no-permission-template, no-permission-content\"></ng-content>\n        </ng-template>\n    </adf-no-permission-template>\n\n    <adf-loading-content-template>\n        <ng-template>\n            <div class=\"adf-document-list-loading-container\" *ngIf=\"!customLoadingContent\">\n                <mat-progress-spinner\n                    id=\"adf-document-list-loading\"\n                    class=\"adf-document-list-loading-margin\"\n                    [color]=\"'primary'\"\n                    [mode]=\"'indeterminate'\">\n                </mat-progress-spinner>\n            </div>\n            <ng-content select=\"adf-custom-loading-content-template\"></ng-content>\n        </ng-template>\n    </adf-loading-content-template>\n\n</adf-datatable>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: '.adf-document-list' },
                styles: [""]
            }] }
];
/** @nocollapse */
DocumentListComponent.ctorParameters = () => [
    { type: DocumentListService },
    { type: NgZone },
    { type: ElementRef },
    { type: AppConfigService },
    { type: UserPreferencesService },
    { type: ContentService },
    { type: ThumbnailService },
    { type: AlfrescoApiService },
    { type: LockService }
];
DocumentListComponent.propDecorators = {
    columnList: [{ type: ContentChild, args: [DataColumnListComponent,] }],
    customLoadingContent: [{ type: ContentChild, args: [CustomLoadingContentTemplateDirective,] }],
    customNoPermissionsTemplate: [{ type: ContentChild, args: [CustomNoPermissionTemplateDirective,] }],
    customNoContentTemplate: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    includeFields: [{ type: Input }],
    where: [{ type: Input }],
    display: [{ type: Input }],
    permissionsStyle: [{ type: Input }],
    locationFormat: [{ type: Input }],
    navigate: [{ type: Input }],
    showHeader: [{ type: Input }],
    navigationMode: [{ type: Input }],
    thumbnails: [{ type: Input }],
    selectionMode: [{ type: Input }],
    multiselect: [{ type: Input }],
    contentActions: [{ type: Input }],
    contentActionsPosition: [{ type: Input }],
    contextMenuActions: [{ type: Input }],
    emptyFolderImageUrl: [{ type: Input }],
    allowDropFiles: [{ type: Input }],
    sorting: [{ type: Input }],
    sortingMode: [{ type: Input }],
    rowStyle: [{ type: Input }],
    rowStyleClass: [{ type: Input }],
    loading: [{ type: Input }],
    _rowFilter: [{ type: Input }],
    rowFilter: [{ type: Input }],
    imageResolver: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    currentFolderId: [{ type: Input }],
    node: [{ type: Input }],
    maxItems: [{ type: Input }],
    nodeClick: [{ type: Output }],
    nodeDblClick: [{ type: Output }],
    folderChange: [{ type: Output }],
    preview: [{ type: Output }],
    ready: [{ type: Output }],
    error: [{ type: Output }],
    dataTable: [{ type: ViewChild, args: ['dataTable',] }],
    onShowContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentColumnListComponent {
    /**
     * @param {?} documentList
     * @param {?} logService
     */
    constructor(documentList, logService) {
        this.documentList = documentList;
        this.logService = logService;
        this.logService.log('ContentColumnListComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnListComponent instead.');
    }
    /**
     * Registers column model within the parent document list component.
     * @param {?} column Column definition model to register.
     * @return {?}
     */
    registerColumn(column) {
        if (this.documentList && column) {
            /** @type {?} */
            const columns = this.documentList.data.getColumns();
            columns.push(column);
            return true;
        }
        return false;
    }
}
ContentColumnListComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-columns',
                template: ''
            }] }
];
/** @nocollapse */
ContentColumnListComponent.ctorParameters = () => [
    { type: DocumentListComponent },
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentColumnComponent {
    /**
     * @param {?} list
     * @param {?} logService
     */
    constructor(list, logService) {
        this.list = list;
        this.logService = logService;
        this.type = 'text';
        this.sortable = false;
        this.title = '';
        this.logService.log('ContentColumnComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnComponent instead.');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.register();
    }
    /**
     * @return {?}
     */
    register() {
        if (this.list) {
            return this.list.registerColumn(this);
        }
        return false;
    }
}
ContentColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-column',
                template: ''
            }] }
];
/** @nocollapse */
ContentColumnComponent.ctorParameters = () => [
    { type: ContentColumnListComponent },
    { type: LogService }
];
ContentColumnComponent.propDecorators = {
    key: [{ type: Input }],
    type: [{ type: Input }],
    format: [{ type: Input }],
    sortable: [{ type: Input }],
    title: [{ type: Input }],
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    srTitle: [{ type: Input, args: ['sr-title',] }],
    cssClass: [{ type: Input, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PermissionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.type = obj.type || null;
            this.action = obj.action || null;
            this.permission = obj.permission || null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodeActionsService {
    /**
     * @param {?} contentDialogService
     * @param {?} dialogRef
     * @param {?} content
     * @param {?=} documentListService
     * @param {?=} apiService
     * @param {?=} dialog
     */
    constructor(contentDialogService, dialogRef, content, documentListService, apiService, dialog) {
        this.contentDialogService = contentDialogService;
        this.dialogRef = dialogRef;
        this.content = content;
        this.documentListService = documentListService;
        this.apiService = apiService;
        this.dialog = dialog;
        this.error = new EventEmitter();
    }
    /**
     * @param {?} node
     * @return {?}
     */
    downloadNode(node) {
        new NodeDownloadDirective(this.apiService, this.dialog)
            .downloadNode(node);
    }
    /**
     * Copy content node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    copyContent(contentEntry, permission) {
        return this.doFileOperation('copy', 'content', contentEntry, permission);
    }
    /**
     * Copy folder node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    copyFolder(contentEntry, permission) {
        return this.doFileOperation('copy', 'folder', contentEntry, permission);
    }
    /**
     * Move content node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    moveContent(contentEntry, permission) {
        return this.doFileOperation('move', 'content', contentEntry, permission);
    }
    /**
     * Move folder node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    moveFolder(contentEntry, permission) {
        return this.doFileOperation('move', 'folder', contentEntry, permission);
    }
    /**
     * General method for performing the given operation (copy|move)
     *
     * @private
     * @param {?} action the action to perform (copy|move)
     * @param {?} type type of the content (content|folder)
     * @param {?} contentEntry the contentEntry which has to have the action performed on
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    doFileOperation(action, type, contentEntry, permission) {
        /** @type {?} */
        const observable = new Subject();
        this.contentDialogService
            .openCopyMoveDialog(action, contentEntry, permission)
            .subscribe((/**
         * @param {?} selections
         * @return {?}
         */
        (selections) => {
            /** @type {?} */
            const selection = selections[0];
            this.documentListService[`${action}Node`].call(this.documentListService, contentEntry.id, selection.id)
                .subscribe(observable.next.bind(observable, `OPERATION.SUCCESS.${type.toUpperCase()}.${action.toUpperCase()}`), observable.error.bind(observable));
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            observable.error(error);
            return observable;
        }));
        return observable;
    }
}
NodeActionsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NodeActionsService.ctorParameters = () => [
    { type: ContentNodeDialogService },
    { type: MatDialog },
    { type: ContentService },
    { type: DocumentListService },
    { type: AlfrescoApiService },
    { type: MatDialog }
];
NodeActionsService.propDecorators = {
    error: [{ type: Output }]
};
/** @nocollapse */ NodeActionsService.ngInjectableDef = defineInjectable({ factory: function NodeActionsService_Factory() { return new NodeActionsService(inject(ContentNodeDialogService), inject(MatDialog$1), inject(ContentService), inject(DocumentListService), inject(AlfrescoApiService), inject(MatDialog$1)); }, token: NodeActionsService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DocumentActionsService {
    /**
     * @param {?} nodeActionsService
     * @param {?} contentNodeDialogService
     * @param {?} translation
     * @param {?=} documentListService
     * @param {?=} contentService
     */
    constructor(nodeActionsService, contentNodeDialogService, translation, documentListService, contentService) {
        this.nodeActionsService = nodeActionsService;
        this.contentNodeDialogService = contentNodeDialogService;
        this.translation = translation;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.permissionEvent = new Subject();
        this.error = new Subject();
        this.success = new Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    /**
     * Gets the handler for an action.
     * @param {?} key Identifier of the action
     * @return {?} The handler for the action
     */
    getHandler(key) {
        if (key) {
            /** @type {?} */
            const lKey = key.toLowerCase();
            return this.handlers[lKey] || null;
        }
        return null;
    }
    /**
     * Sets a new handler for an action.
     * @param {?} key Identifier of the action
     * @param {?} handler Handler for the action
     * @return {?} False if the key was an empty/null string, true otherwise
     */
    setHandler(key, handler) {
        if (key) {
            /** @type {?} */
            const lKey = key.toLowerCase();
            this.handlers[lKey] = handler;
            return true;
        }
        return false;
    }
    /**
     * Checks if actions can be executed for an item.
     * @param {?} nodeEntry Item to receive an action
     * @return {?} True if the action can be executed on this item, false otherwise
     */
    canExecuteAction(nodeEntry) {
        return this.documentListService && nodeEntry && nodeEntry.entry.isFile === true;
    }
    /**
     * @private
     * @return {?}
     */
    setupActionHandlers() {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
        this.handlers['lock'] = this.lockNode.bind(this);
    }
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    lockNode(node, target, permission) {
        return this.contentNodeDialogService.openLockNodeDialog(node.entry);
    }
    /**
     * @private
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    downloadNode(obj, target, permission) {
        this.nodeActionsService.downloadNode(obj);
    }
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    copyNode(node, target, permission) {
        /** @type {?} */
        const actionObservable = this.nodeActionsService.copyContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'copy', target, permission);
        return actionObservable;
    }
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    moveNode(node, target, permission) {
        /** @type {?} */
        const actionObservable = this.nodeActionsService.moveContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'move', target, permission);
        return actionObservable;
    }
    /**
     * @private
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    prepareHandlers(actionObservable, type, action, target, permission) {
        actionObservable.subscribe((/**
         * @param {?} fileOperationMessage
         * @return {?}
         */
        (fileOperationMessage) => {
            this.success.next(fileOperationMessage);
        }), this.error.next.bind(this.error));
    }
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    deleteNode(node, target, permission) {
        /** @type {?} */
        let handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasAllowableOperations(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const message = this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    this.success.next(message);
                }), (/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const message = this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    this.error.next(message);
                }));
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({
                    type: 'content',
                    action: 'delete',
                    permission: permission
                }));
                return throwError(new Error('No permission to delete'));
            }
        }
    }
}
DocumentActionsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DocumentActionsService.ctorParameters = () => [
    { type: NodeActionsService },
    { type: ContentNodeDialogService },
    { type: TranslationService },
    { type: DocumentListService },
    { type: ContentService }
];
/** @nocollapse */ DocumentActionsService.ngInjectableDef = defineInjectable({ factory: function DocumentActionsService_Factory() { return new DocumentActionsService(inject(NodeActionsService), inject(ContentNodeDialogService), inject(TranslationService), inject(DocumentListService), inject(ContentService)); }, token: DocumentActionsService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FolderActionsService {
    /**
     * @param {?} nodeActionsService
     * @param {?} documentListService
     * @param {?} contentService
     * @param {?} translation
     */
    constructor(nodeActionsService, documentListService, contentService, translation) {
        this.nodeActionsService = nodeActionsService;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.translation = translation;
        this.permissionEvent = new Subject();
        this.error = new Subject();
        this.success = new Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    /**
     * Gets the handler function for an action.
     * @param {?} key Identifier for the action
     * @return {?} The handler function
     */
    getHandler(key) {
        if (key) {
            /** @type {?} */
            const lKey = key.toLowerCase();
            return this.handlers[lKey] || null;
        }
        return null;
    }
    /**
     * Sets a new handler function for an action.
     * @param {?} key Identifier for the action
     * @param {?} handler The new handler function
     * @return {?} True if the key was a valid action identifier, false otherwise
     */
    setHandler(key, handler) {
        if (key) {
            /** @type {?} */
            const lKey = key.toLowerCase();
            this.handlers[lKey] = handler;
            return true;
        }
        return false;
    }
    /**
     * Checks if an action is available for a particular item.
     * @param {?} nodeEntry Item to check
     * @return {?} True if the action is available, false otherwise
     */
    canExecuteAction(nodeEntry) {
        return this.documentListService && nodeEntry && nodeEntry.entry.isFolder === true;
    }
    /**
     * @private
     * @return {?}
     */
    setupActionHandlers() {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
    }
    /**
     * @private
     * @param {?} nodeEntry
     * @return {?}
     */
    downloadNode(nodeEntry) {
        this.nodeActionsService.downloadNode(nodeEntry);
    }
    /**
     * @private
     * @param {?} nodeEntry
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    copyNode(nodeEntry, target, permission) {
        /** @type {?} */
        const actionObservable = this.nodeActionsService.copyFolder(nodeEntry.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'copy', target, permission);
        return actionObservable;
    }
    /**
     * @private
     * @param {?} nodeEntry
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    moveNode(nodeEntry, target, permission) {
        /** @type {?} */
        const actionObservable = this.nodeActionsService.moveFolder(nodeEntry.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'move', target, permission);
        return actionObservable;
    }
    /**
     * @private
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    prepareHandlers(actionObservable, type, action, target, permission) {
        actionObservable.subscribe((/**
         * @param {?} fileOperationMessage
         * @return {?}
         */
        (fileOperationMessage) => {
            if (target && typeof target.reload === 'function') {
                target.reload();
            }
            this.success.next(fileOperationMessage);
        }), this.error.next.bind(this.error));
    }
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    deleteNode(node, target, permission) {
        /** @type {?} */
        let handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasAllowableOperations(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe((/**
                 * @return {?}
                 */
                () => {
                    if (target && typeof target.reload === 'function') {
                        target.reload();
                    }
                    /** @type {?} */
                    const message = this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    this.success.next(message);
                }), (/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const message = this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    this.error.next(message);
                }));
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({ type: 'folder', action: 'delete', permission: permission }));
                return throwError(new Error('No permission to delete'));
            }
        }
    }
}
FolderActionsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FolderActionsService.ctorParameters = () => [
    { type: NodeActionsService },
    { type: DocumentListService },
    { type: ContentService },
    { type: TranslationService }
];
/** @nocollapse */ FolderActionsService.ngInjectableDef = defineInjectable({ factory: function FolderActionsService_Factory() { return new FolderActionsService(inject(NodeActionsService), inject(DocumentListService), inject(ContentService), inject(TranslationService)); }, token: FolderActionsService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentActionListComponent {
    /**
     * @param {?} documentList
     */
    constructor(documentList) {
        this.documentList = documentList;
    }
    /**
     * Registers action handler within the parent document list component.
     * @param {?} action Action model to register.
     * @return {?}
     */
    registerAction(action) {
        if (this.documentList && action) {
            this.documentList.actions.push(action);
            return true;
        }
        return false;
    }
    /**
     * @param {?} action
     * @return {?}
     */
    unregisterAction(action) {
        if (this.documentList && action) {
            /** @type {?} */
            const idx = this.documentList.actions.indexOf(action);
            if (idx >= 0) {
                this.documentList.actions.splice(idx, 1);
                return true;
            }
        }
        return false;
    }
}
ContentActionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-actions',
                template: ''
            }] }
];
/** @nocollapse */
ContentActionListComponent.ctorParameters = () => [
    { type: DocumentListComponent }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentActionComponent {
    /**
     * @param {?} list
     * @param {?} documentActions
     * @param {?} folderActions
     */
    constructor(list, documentActions, folderActions) {
        this.list = list;
        this.documentActions = documentActions;
        this.folderActions = folderActions;
        /**
         * The title of the action as shown in the menu.
         */
        this.title = 'Action';
        /**
         * Visibility state (see examples).
         */
        this.visible = true;
        /**
         * Type of item that the action applies to. Can be "document" or "folder"
         */
        this.target = ContentActionTarget.All;
        /**
         * Is the menu item disabled?
         */
        this.disabled = false;
        /**
         * Emitted when the user selects the action from the menu.
         */
        this.execute = new EventEmitter();
        /**
         * Emitted when a permission error occurs
         */
        this.permissionEvent = new EventEmitter();
        /**
         * Emitted when an error occurs during the action.
         * Applies to copy and move actions.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the action succeeds with the success string message.
         * Applies to copy, move and delete actions.
         */
        this.success = new EventEmitter();
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.target === ContentActionTarget.All) {
            this.folderActionModel = this.generateAction(ContentActionTarget.Folder);
            this.documentActionModel = this.generateAction(ContentActionTarget.Document);
        }
        else {
            this.documentActionModel = this.generateAction(this.target);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.visible && !changes.visible.firstChange) {
            if (this.documentActionModel) {
                this.documentActionModel.visible = changes.visible.currentValue;
            }
            if (this.folderActionModel) {
                this.folderActionModel.visible = changes.visible.currentValue;
            }
        }
        if (changes.disabled && !changes.disabled.firstChange) {
            if (this.documentActionModel) {
                this.documentActionModel.disabled = changes.disabled.currentValue;
            }
            if (this.folderActionModel) {
                this.folderActionModel.disabled = changes.disabled.currentValue;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => subscription.unsubscribe()));
        this.subscriptions = [];
        if (this.documentActionModel) {
            this.unregister(this.documentActionModel);
            this.documentActionModel = null;
        }
        if (this.folderActionModel) {
            this.unregister(this.folderActionModel);
            this.folderActionModel = null;
        }
    }
    /**
     * @param {?} model
     * @return {?}
     */
    register(model) {
        if (this.list) {
            return this.list.registerAction(model);
        }
        return false;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    unregister(model) {
        if (this.list) {
            return this.list.unregisterAction(model);
        }
        return false;
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    generateAction(target) {
        /** @type {?} */
        const model = new ContentActionModel({
            title: this.title,
            icon: this.icon,
            permission: this.permission,
            disableWithNoPermission: this.disableWithNoPermission,
            target: target,
            disabled: this.disabled,
            visible: this.visible
        });
        if (this.handler) {
            model.handler = this.getSystemHandler(target, this.handler);
        }
        if (this.execute) {
            model.execute = (/**
             * @param {?} value
             * @return {?}
             */
            (value) => {
                this.execute.emit({ value });
            });
        }
        this.register(model);
        return model;
    }
    /**
     * @param {?} target
     * @param {?} name
     * @return {?}
     */
    getSystemHandler(target, name) {
        if (target) {
            target = target.toLowerCase();
            if (target === ContentActionTarget.Document) {
                if (this.documentActions) {
                    this.subscriptions.push(this.documentActions.permissionEvent.subscribe((/**
                     * @param {?} permission
                     * @return {?}
                     */
                    (permission) => {
                        this.permissionEvent.emit(permission);
                    })), this.documentActions.error.subscribe((/**
                     * @param {?} errors
                     * @return {?}
                     */
                    (errors) => {
                        this.error.emit(errors);
                    })), this.documentActions.success.subscribe((/**
                     * @param {?} message
                     * @return {?}
                     */
                    (message) => {
                        this.success.emit(message);
                    })));
                    return this.documentActions.getHandler(name);
                }
                return null;
            }
            if (target === ContentActionTarget.Folder) {
                if (this.folderActions) {
                    this.subscriptions.push(this.folderActions.permissionEvent.subscribe((/**
                     * @param {?} permission
                     * @return {?}
                     */
                    (permission) => {
                        this.permissionEvent.emit(permission);
                    })), this.folderActions.error.subscribe((/**
                     * @param {?} errors
                     * @return {?}
                     */
                    (errors) => {
                        this.error.emit(errors);
                    })), this.folderActions.success.subscribe((/**
                     * @param {?} message
                     * @return {?}
                     */
                    (message) => {
                        this.success.emit(message);
                    })));
                    return this.folderActions.getHandler(name);
                }
                return null;
            }
        }
        return null;
    }
}
ContentActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-action',
                template: '',
                providers: [
                    DocumentActionsService,
                    FolderActionsService
                ]
            }] }
];
/** @nocollapse */
ContentActionComponent.ctorParameters = () => [
    { type: ContentActionListComponent },
    { type: DocumentActionsService },
    { type: FolderActionsService }
];
ContentActionComponent.propDecorators = {
    title: [{ type: Input }],
    icon: [{ type: Input }],
    visible: [{ type: Input }],
    handler: [{ type: Input }],
    target: [{ type: Input }],
    permission: [{ type: Input }],
    disableWithNoPermission: [{ type: Input }],
    disabled: [{ type: Input }],
    execute: [{ type: Output }],
    permissionEvent: [{ type: Output }],
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LibraryNameColumnComponent {
    /**
     * @param {?} element
     * @param {?} alfrescoApiService
     */
    constructor(element, alfrescoApiService) {
        this.element = element;
        this.alfrescoApiService = alfrescoApiService;
        this.displayTooltip$ = new BehaviorSubject('');
        this.displayText$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateValue();
        this.sub = this.alfrescoApiService.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            /** @type {?} */
            const row = this.context.row;
            if (row) {
                const { entry } = row.node;
                if (entry === node) {
                    row.node = { entry };
                    this.updateValue();
                }
            }
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    updateValue() {
        this.node = this.context.row.node;
        /** @type {?} */
        const rows = this.context.data.rows || [];
        if (this.node && this.node.entry) {
            this.displayText$.next(this.makeLibraryTitle((/** @type {?} */ (this.node.entry)), rows));
            this.displayTooltip$.next(this.makeLibraryTooltip(this.node.entry));
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        this.element.nativeElement.dispatchEvent(new CustomEvent('name-click', {
            bubbles: true,
            detail: {
                node: this.node
            }
        }));
    }
    /**
     * @param {?} library
     * @return {?}
     */
    makeLibraryTooltip(library) {
        const { description, title } = library;
        return description || title || '';
    }
    /**
     * @param {?} library
     * @param {?} rows
     * @return {?}
     */
    makeLibraryTitle(library, rows) {
        /** @type {?} */
        const entries = rows.map((/**
         * @param {?} row
         * @return {?}
         */
        (row) => row.node.entry));
        const { title, id } = library;
        /** @type {?} */
        let isDuplicate = false;
        if (entries) {
            isDuplicate = entries.some((/**
             * @param {?} entry
             * @return {?}
             */
            (entry) => {
                return entry.id !== id && entry.title === title;
            }));
        }
        return isDuplicate ? `${title} (${id})` : `${title}`;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    }
}
LibraryNameColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-library-name-column',
                template: `
        <span class="adf-datatable-cell-value" title="{{ displayTooltip$ | async }}" (click)="onClick()">
            {{ displayText$ | async }}
        </span>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    class: 'adf-datatable-content-cell adf-datatable-link adf-library-name-column'
                }
            }] }
];
/** @nocollapse */
LibraryNameColumnComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: AlfrescoApiService }
];
LibraryNameColumnComponent.propDecorators = {
    context: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LibraryRoleColumnComponent {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
        this.displayText$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateValue();
        this.sub = this.api.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            /** @type {?} */
            const row = this.context.row;
            if (row) {
                const { entry } = row.node;
                if (entry === node) {
                    row.node = { entry };
                    this.updateValue();
                }
            }
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    updateValue() {
        /** @type {?} */
        const node = this.context.row.node;
        if (node && node.entry) {
            /** @type {?} */
            const role = node.entry.role;
            switch (role) {
                case Site.RoleEnum.SiteManager:
                    this.displayText$.next('LIBRARY.ROLE.MANAGER');
                    break;
                case Site.RoleEnum.SiteCollaborator:
                    this.displayText$.next('LIBRARY.ROLE.COLLABORATOR');
                    break;
                case Site.RoleEnum.SiteContributor:
                    this.displayText$.next('LIBRARY.ROLE.CONTRIBUTOR');
                    break;
                case Site.RoleEnum.SiteConsumer:
                    this.displayText$.next('LIBRARY.ROLE.CONSUMER');
                    break;
                default:
                    this.displayText$.next('');
                    break;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    }
}
LibraryRoleColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-library-role-column',
                template: `
        <span class="adf-datatable-cell-value" title="{{ (displayText$ | async) | translate }}">
            {{ (displayText$ | async) | translate }}
        </span>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-library-role-column adf-datatable-content-cell' }
            }] }
];
/** @nocollapse */
LibraryRoleColumnComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];
LibraryRoleColumnComponent.propDecorators = {
    context: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LibraryStatusColumnComponent {
    /**
     * @param {?} api
     */
    constructor(api) {
        this.api = api;
        this.displayText$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateValue();
        this.sub = this.api.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            /** @type {?} */
            const row = this.context.row;
            if (row) {
                const { entry } = row.node;
                if (entry === node) {
                    row.node = { entry };
                    this.updateValue();
                }
            }
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    updateValue() {
        /** @type {?} */
        const node = this.context.row.node;
        if (node && node.entry) {
            /** @type {?} */
            const visibility = node.entry.visibility;
            switch (visibility) {
                case Site.VisibilityEnum.PUBLIC:
                    this.displayText$.next('LIBRARY.VISIBILITY.PUBLIC');
                    break;
                case Site.VisibilityEnum.PRIVATE:
                    this.displayText$.next('LIBRARY.VISIBILITY.PRIVATE');
                    break;
                case Site.VisibilityEnum.MODERATED:
                    this.displayText$.next('LIBRARY.VISIBILITY.MODERATED');
                    break;
                default:
                    this.displayText$.next('UNKNOWN');
                    break;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    }
}
LibraryStatusColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-library-status-column',
                template: `
        <span class="adf-datatable-cell-value" title="{{ (displayText$ | async) | translate }}">
            {{ (displayText$ | async) | translate }}
        </span>
    `,
                host: { class: 'adf-library-status-column adf-datatable-content-cell' }
            }] }
];
/** @nocollapse */
LibraryStatusColumnComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];
LibraryStatusColumnComponent.propDecorators = {
    context: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NameColumnComponent {
    /**
     * @param {?} element
     * @param {?} alfrescoApiService
     */
    constructor(element, alfrescoApiService) {
        this.element = element;
        this.alfrescoApiService = alfrescoApiService;
        this.displayText$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateValue();
        this.sub = this.alfrescoApiService.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            /** @type {?} */
            const row = this.context.row;
            if (row) {
                const { entry } = row.node;
                if (entry === node) {
                    row.node = { entry };
                    this.updateValue();
                }
            }
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    updateValue() {
        this.node = this.context.row.node;
        if (this.node && this.node.entry) {
            this.displayText$.next(this.node.entry.name || this.node.entry.id);
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        this.element.nativeElement.dispatchEvent(new CustomEvent('name-click', {
            bubbles: true,
            detail: {
                node: this.node
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    }
}
NameColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-name-column',
                template: `
        <span class="adf-datatable-cell-value" title="{{ node | adfNodeNameTooltip }}" (click)="onClick()">
            {{ displayText$ | async }}
        </span>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable-content-cell adf-datatable-link adf-name-column' }
            }] }
];
/** @nocollapse */
NameColumnComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: AlfrescoApiService }
];
NameColumnComponent.propDecorators = {
    context: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrashcanNameColumnComponent {
    constructor() {
        this.isLibrary = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.node = this.context.row.node;
        /** @type {?} */
        const rows = this.context.data.rows || [];
        if (this.node && this.node.entry) {
            this.isLibrary = this.node.entry.nodeType === 'st:site';
            if (this.isLibrary) {
                const { properties } = this.node.entry;
                this.displayText = this.makeLibraryTitle(this.node.entry, rows);
                this.displayTooltip =
                    properties['cm:description'] || properties['cm:title'];
            }
            else {
                this.displayText = this.node.entry.name || this.node.entry.id;
            }
        }
    }
    /**
     * @param {?} library
     * @param {?} rows
     * @return {?}
     */
    makeLibraryTitle(library, rows) {
        /** @type {?} */
        const entries = rows.map((/**
         * @param {?} r
         * @return {?}
         */
        (r) => r.node.entry));
        const { id } = library;
        /** @type {?} */
        const title = library.properties['cm:title'];
        /** @type {?} */
        let isDuplicate = false;
        if (entries) {
            isDuplicate = entries.some((/**
             * @param {?} entry
             * @return {?}
             */
            (entry) => {
                return entry.id !== id && entry.properties['cm:title'] === title;
            }));
        }
        return isDuplicate
            ? `${library.properties['cm:title']} (${library.name})`
            : `${library.properties['cm:title']}`;
    }
}
TrashcanNameColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-trashcan-name-column',
                template: `
    <ng-container *ngIf="!isLibrary">
      <span class="adf-datatable-cell-value" title="{{ node | adfNodeNameTooltip }}">{{ displayText }}</span>
    </ng-container>
    <ng-container *ngIf="isLibrary">
      <span class="adf-datatable-cell-value" title="{{ displayTooltip }}">{{ displayText }}</span>
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable-content-cell adf-trashcan-name-column' }
            }] }
];
TrashcanNameColumnComponent.propDecorators = {
    context: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// note: contains only limited subset of available fields
class NodePaging {
}
class NodePagingList {
}
class NodeMinimalEntry {
}
class Pagination$1 {
}
class NodeMinimal {
    constructor() {
        this.properties = {};
    }
}
class UserInfo {
}
class ContentInfo {
}
class PathInfoEntity {
}
class PathElementEntity {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PermissionStyleModel {
    /**
     * @param {?} css
     * @param {?} permission
     * @param {?=} isFile
     * @param {?=} isFolder
     */
    constructor(css, permission, isFile = true, isFolder = true) {
        this.isFolder = true;
        this.isFile = true;
        this.css = css;
        this.permission = permission;
        this.isFile = isFile;
        this.isFolder = isFolder;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileUploadingListComponent {
    /**
     * @param {?} uploadService
     * @param {?} nodesApi
     * @param {?} translateService
     */
    constructor(uploadService, nodesApi, translateService) {
        this.uploadService = uploadService;
        this.nodesApi = nodesApi;
        this.translateService = translateService;
        this.FileUploadStatus = FileUploadStatus;
        this.files = [];
        /**
         * Emitted when a file in the list has an error.
         */
        this.error = new EventEmitter();
    }
    /**
     * Cancel file upload
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to cancel upload for.
     *
     * @return {?}
     */
    cancelFile(file) {
        this.uploadService.cancelUpload(file);
    }
    /**
     * Remove uploaded file
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to remove upload for.
     *
     * @return {?}
     */
    removeFile(file) {
        this.deleteNode(file).subscribe((/**
         * @return {?}
         */
        () => {
            if (file.status === FileUploadStatus.Error) {
                this.notifyError(file);
            }
            this.cancelNodeVersionInstances(file);
            this.uploadService.cancelUpload(file);
        }));
    }
    /**
     * Call the appropriate method for each file, depending on state
     * @return {?}
     */
    cancelAllFiles() {
        this.getUploadingFiles().forEach((/**
         * @param {?} file
         * @return {?}
         */
        (file) => this.uploadService.cancelUpload(file)));
        /** @type {?} */
        const deletedFiles = this.files
            .filter((/**
         * @param {?} file
         * @return {?}
         */
        (file) => file.status === FileUploadStatus.Complete))
            .map((/**
         * @param {?} file
         * @return {?}
         */
        (file) => this.deleteNode(file)));
        forkJoin(...deletedFiles).subscribe((/**
         * @param {?} files
         * @return {?}
         */
        (files) => {
            /** @type {?} */
            const errors = files.filter((/**
             * @param {?} file
             * @return {?}
             */
            (file) => file.status === FileUploadStatus.Error));
            if (errors.length) {
                this.notifyError(...errors);
            }
            this.uploadService.cancelUpload(...files);
        }));
    }
    /**
     * Checks if all the files are uploaded false if there is at least one file in Progress | Starting | Pending
     * @return {?}
     */
    isUploadCompleted() {
        return (!this.isUploadCancelled() &&
            Boolean(this.files.length) &&
            !this.files.some((/**
             * @param {?} __0
             * @return {?}
             */
            ({ status }) => status === FileUploadStatus.Starting ||
                status === FileUploadStatus.Progress ||
                status === FileUploadStatus.Pending)));
    }
    /**
     * Check if all the files are Cancelled | Aborted | Error. false if there is at least one file in uploading states
     * @return {?}
     */
    isUploadCancelled() {
        return (!!this.files.length &&
            this.files.every((/**
             * @param {?} __0
             * @return {?}
             */
            ({ status }) => status === FileUploadStatus.Aborted ||
                status === FileUploadStatus.Cancelled ||
                status === FileUploadStatus.Deleted)));
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    deleteNode(file) {
        const { id } = file.data.entry;
        return this.nodesApi.deleteNode(id, { permanent: true }).pipe(map((/**
         * @return {?}
         */
        () => {
            file.status = FileUploadStatus.Deleted;
            return file;
        })), catchError((/**
         * @return {?}
         */
        () => {
            file.status = FileUploadStatus.Error;
            return of(file);
        })));
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    cancelNodeVersionInstances(file) {
        this.files
            .filter((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.data.entry.id === file.data.entry.id &&
            item.options.newVersion))
            .map((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            item.status = FileUploadStatus.Deleted;
        }));
    }
    /**
     * @private
     * @param {...?} files
     * @return {?}
     */
    notifyError(...files) {
        /** @type {?} */
        let messageError = null;
        if (files.length === 1) {
            messageError = this.translateService.instant('FILE_UPLOAD.MESSAGES.REMOVE_FILE_ERROR', { fileName: files[0].name });
        }
        else {
            messageError = this.translateService.instant('FILE_UPLOAD.MESSAGES.REMOVE_FILES_ERROR', { total: files.length });
        }
        this.error.emit(messageError);
    }
    /**
     * @private
     * @return {?}
     */
    getUploadingFiles() {
        return this.files.filter((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (item.status === FileUploadStatus.Pending ||
                item.status === FileUploadStatus.Progress ||
                item.status === FileUploadStatus.Starting) {
                return item;
            }
        }));
    }
}
FileUploadingListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-list',
                template: "<div class=\"upload-list\">\n    <ng-template\n        ngFor\n        [ngForOf]=\"files\"\n        [ngForTemplate]=\"template\">\n    </ng-template>\n</div>\n",
                styles: [":host{display:flex;flex-direction:column}"]
            }] }
];
/** @nocollapse */
FileUploadingListComponent.ctorParameters = () => [
    { type: UploadService },
    { type: NodesApiService },
    { type: TranslationService }
];
FileUploadingListComponent.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    files: [{ type: Input }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileUploadingDialogComponent {
    /**
     * @param {?} uploadService
     * @param {?} changeDetector
     */
    constructor(uploadService, changeDetector) {
        this.uploadService = uploadService;
        this.changeDetector = changeDetector;
        /**
         * Dialog position. Can be 'left' or 'right'.
         */
        this.position = 'right';
        /**
         * Emitted when a file in the list has an error.
         */
        this.error = new EventEmitter();
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.isDialogMinimized = false;
        this.isConfirmation = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.listSubscription = this.uploadService
            .queueChanged.subscribe((/**
         * @param {?} fileList
         * @return {?}
         */
        (fileList) => {
            this.filesUploadingList = fileList;
            if (this.filesUploadingList.length) {
                this.isDialogActive = true;
            }
        }));
        this.counterSubscription = merge(this.uploadService.fileUploadComplete, this.uploadService.fileUploadDeleted)
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.totalCompleted = event.totalComplete;
            this.changeDetector.detectChanges();
        }));
        this.errorSubscription = this.uploadService.fileUploadError
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.totalErrors = event.totalError;
            this.changeDetector.detectChanges();
        }));
        this.fileUploadSubscription = this.uploadService
            .fileUpload.subscribe((/**
         * @return {?}
         */
        () => {
            this.changeDetector.detectChanges();
        }));
        this.uploadService.fileDeleted.subscribe((/**
         * @param {?} objId
         * @return {?}
         */
        (objId) => {
            if (this.filesUploadingList) {
                /** @type {?} */
                const file = this.filesUploadingList.find((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => {
                    return item.data.entry.id === objId;
                }));
                if (file) {
                    file.status = FileUploadStatus.Cancelled;
                    this.changeDetector.detectChanges();
                }
            }
        }));
    }
    /**
     * Toggle confirmation message.
     * @return {?}
     */
    toggleConfirmation() {
        this.isConfirmation = !this.isConfirmation;
        if (this.isDialogMinimized) {
            this.isDialogMinimized = false;
        }
    }
    /**
     * Cancel uploads and hide confirmation
     * @return {?}
     */
    cancelAllUploads() {
        this.toggleConfirmation();
        this.uploadList.cancelAllFiles();
    }
    /**
     * Toggle dialog minimized state.
     * @return {?}
     */
    toggleMinimized() {
        this.isDialogMinimized = !this.isDialogMinimized;
        this.changeDetector.detectChanges();
    }
    /**
     * Dismiss dialog
     * @return {?}
     */
    close() {
        this.isConfirmation = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.isDialogMinimized = false;
        this.uploadService.clearQueue();
        this.changeDetector.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.uploadService.clearQueue();
        this.listSubscription.unsubscribe();
        this.counterSubscription.unsubscribe();
        this.fileUploadSubscription.unsubscribe();
        this.errorSubscription.unsubscribe();
    }
}
FileUploadingDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-dialog',
                template: "<div *ngIf=\"isDialogActive\"\n     class=\"adf-upload-dialog\"\n     id=\"upload-dialog\"\n     [class.adf-upload-dialog--minimized]=\"isDialogMinimized\"\n     [class.adf-upload-dialog--position-left]=\"position === 'left'\"\n     [class.adf-upload-dialog--position-right]=\"position === 'right'\">\n    <header class=\"adf-upload-dialog__header\">\n        <button\n            mat-button\n            color=\"secondary\"\n            [disabled]=\"isConfirmation\"\n            (click)=\"toggleMinimized()\">\n            <mat-icon\n                mat-list-icon\n                title=\"{{ (isDialogMinimized ? 'ADF_FILE_UPLOAD.BUTTON.MAXIMIZE': 'ADF_FILE_UPLOAD.BUTTON.MINIMIZE') | translate }}\">\n                    {{ isDialogMinimized ? 'keyboard_arrow_up' : 'keyboard_arrow_down' }}\n            </mat-icon>\n        </button>\n\n        <span\n            class=\"adf-upload-dialog__title\"\n            *ngIf=\"!uploadList.isUploadCancelled()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_PROGRESS'\n                | translate: {\n                    completed: totalCompleted,\n                    total: filesUploadingList.length\n                }\n            }}\n        </span>\n\n        <span\n            class=\"adf-upload-dialog__title\"\n            *ngIf=\"uploadList.isUploadCancelled()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_CANCELED' | translate }}\n        </span>\n    </header>\n\n    <section class=\"adf-upload-dialog__info\"\n        *ngIf=\"totalErrors\">\n        {{\n            (totalErrors > 1\n                 ? 'FILE_UPLOAD.MESSAGES.UPLOAD_ERRORS'\n                 : 'FILE_UPLOAD.MESSAGES.UPLOAD_ERROR')\n                 | translate: { total: totalErrors }\n        }}\n    </section>\n\n    <section class=\"adf-upload-dialog__content\"\n        [class.adf-upload-dialog--padding]=\"isConfirmation\">\n        <adf-file-uploading-list\n            [class.adf-upload-dialog--hide]=\"isConfirmation\"\n            #uploadList\n            [files]=\"filesUploadingList\">\n                <ng-template let-file=\"$implicit\">\n                     <adf-file-uploading-list-row\n                        [file]=\"file\"\n                        (remove)=\"uploadList.removeFile(file)\"\n                        (cancel)=\"uploadList.cancelFile(file)\">\n                    </adf-file-uploading-list-row>\n                </ng-template>\n        </adf-file-uploading-list>\n\n        <div\n            class=\"adf-upload-dialog__confirmation\"\n            [class.adf-upload-dialog--hide]=\"!isConfirmation\">\n                <p class=\"adf-upload-dialog__confirmation--title\">\n                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TITLE' | translate }}\n                </p>\n\n                <p class=\"adf-upload-dialog__confirmation--text\">\n                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TEXT' | translate }}\n                </p>\n        </div>\n    </section>\n\n    <footer class=\"adf-upload-dialog__actions\"\n            *ngIf=\"!isConfirmation\">\n        <button\n            id=\"adf-upload-dialog-cancel-all\"\n            color=\"primary\"\n            mat-button\n            *ngIf=\"!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()\"\n            (click)=\"toggleConfirmation()\">\n            {{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_ALL' | translate }}\n        </button>\n\n        <button\n            id=\"adf-upload-dialog-close\"\n            *ngIf=\"uploadList.isUploadCompleted() || uploadList.isUploadCancelled()\"\n            mat-button\n            color=\"primary\"\n            (click)=\"close()\">\n            {{ 'ADF_FILE_UPLOAD.BUTTON.CLOSE' | translate }}\n        </button>\n    </footer>\n\n    <footer class=\"adf-upload-dialog__actions\"\n            *ngIf=\"isConfirmation\">\n        <button\n            id=\"adf-upload-dialog-cancel\"\n            color=\"secondary\"\n            mat-button\n            (click)=\"cancelAllUploads()\">\n            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CANCEL' | translate }}\n        </button>\n\n        <button\n            id=\"adf-upload-dialog-confirm\"\n            mat-button\n            color=\"primary\"\n            (click)=\"toggleConfirmation()\">\n            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CONTINUE' | translate }}\n        </button>\n    </footer>\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
FileUploadingDialogComponent.ctorParameters = () => [
    { type: UploadService },
    { type: ChangeDetectorRef }
];
FileUploadingDialogComponent.propDecorators = {
    uploadList: [{ type: ViewChild, args: ['uploadList',] }],
    position: [{ type: Input }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileUploadingListRowComponent {
    constructor() {
        this.cancel = new EventEmitter();
        this.remove = new EventEmitter();
        this.FileUploadStatus = FileUploadStatus;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onCancel(file) {
        this.cancel.emit(file);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onRemove(file) {
        this.remove.emit(file);
    }
    /**
     * @return {?}
     */
    showCancelledStatus() {
        return this.file.status === FileUploadStatus.Cancelled ||
            this.file.status === FileUploadStatus.Aborted ||
            this.file.status === FileUploadStatus.Deleted;
    }
    /**
     * @return {?}
     */
    get versionNumber() {
        return this.file.data.entry.properties['cm:versionLabel'];
    }
    /**
     * @return {?}
     */
    get mimeType() {
        if (this.file && this.file.file && this.file.file.type) {
            return this.file.file.type;
        }
        return 'default';
    }
    /**
     * @return {?}
     */
    isUploadVersion() {
        return (!!this.file.data &&
            this.file.options &&
            this.file.options.newVersion &&
            this.file.data.entry.properties &&
            this.file.data.entry.properties['cm:versionLabel']);
    }
}
FileUploadingListRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-list-row',
                template: "<div class=\"adf-file-uploading-row\">\n    <mat-icon *ngIf=\"mimeType === 'default'\" mat-list-icon class=\"adf-file-uploading-row__type\">\n        insert_drive_file\n    </mat-icon>\n\n    <adf-icon *ngIf=\"mimeType !== 'default'\" value=\"adf:{{ mimeType }}\"></adf-icon>\n\n    <span\n        class=\"adf-file-uploading-row__name\"\n        title=\"{{ file.name }}\">\n        {{ file.name }}\n    </span>\n\n    <span *ngIf=\"isUploadVersion()\" class=\"adf-file-uploading-row__version\">\n        <mat-chip color=\"primary\" [attr.aria-label]=\"'ADF_FILE_UPLOAD.ARIA-LABEL.VERSION' | translate\" [title]=\"'version' + versionNumber\" disabled>{{\n            versionNumber\n        }}</mat-chip>\n    </span>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Progress || file.status === FileUploadStatus.Starting\"\n        (click)=\"onCancel(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\"\n        title=\"{{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_FILE' | translate }}\">\n        <span class=\"adf-file-uploading-row__status\">\n            {{ file.progress.loaded | adfFileSize }} / {{ file.progress.total | adfFileSize }}\n        </span>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--cancel\">\n            clear\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Complete && !isUploadVersion()\"\n        (click)=\"onRemove(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\"\n        title=\"{{ 'ADF_FILE_UPLOAD.BUTTON.REMOVE_FILE' | translate }}\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status adf-file-uploading-row__status--done\">\n            check_circle\n        </mat-icon>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--remove\">\n            remove_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Complete && isUploadVersion()\"\n        class=\"adf-file-uploading-row__file-version\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status--done\">\n            check_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Pending\"\n        (click)=\"onCancel(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status adf-file-uploading-row__status--pending\">\n            schedule\n        </mat-icon>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--remove\">\n            remove_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Error\"\n        class=\"adf-file-uploading-row__block adf-file-uploading-row__status--error\">\n        <mat-icon mat-list-icon\n            [attr.aria-label]=\"'ADF_FILE_UPLOAD.ARIA-LABEL.ERROR' | translate\"\n            [matTooltip]=\"file.errorCode | adfFileUploadError\">\n            report_problem\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"showCancelledStatus()\"\n        class=\"adf-file-uploading-row__block adf-file-uploading-row__status--cancelled\">\n        {{ 'ADF_FILE_UPLOAD.STATUS.FILE_CANCELED_STATUS' | translate }}\n    </div>\n</div>\n",
                styles: [""]
            }] }
];
FileUploadingListRowComponent.propDecorators = {
    file: [{ type: Input }],
    cancel: [{ type: Output }],
    remove: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadFilesEvent {
    /**
     * @param {?} files
     * @param {?} uploadService
     * @param {?} callback
     */
    constructor(files, uploadService, callback) {
        this.files = files;
        this.uploadService = uploadService;
        this.callback = callback;
        this.isDefaultPrevented = false;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this.isDefaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this.isDefaultPrevented = true;
    }
    /**
     * @return {?}
     */
    pauseUpload() {
        this.preventDefault();
    }
    /**
     * @return {?}
     */
    resumeUpload() {
        if (this.files && this.files.length > 0) {
            this.uploadService.addToQueue(...this.files);
            this.uploadService.uploadFilesInTheQueue(this.callback);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class UploadBase {
    /**
     * @param {?} uploadService
     * @param {?} translationService
     * @param {?} ngZone
     */
    constructor(uploadService, translationService, ngZone) {
        this.uploadService = uploadService;
        this.translationService = translationService;
        this.ngZone = ngZone;
        /**
         * The ID of the root. Use the nodeId for
         * Content Services or the taskId/processId for Process Services.
         */
        this.rootFolderId = '-root-';
        /**
         * Toggles component disabled state (if there is no node permission checking).
         */
        this.disabled = false;
        /**
         * Filter for accepted file types.
         */
        this.acceptedFilesType = '*';
        /**
         * Toggles versioning.
         */
        this.versioning = false;
        /**
         * majorVersion boolean field to true to indicate a major version should be created.
         */
        this.majorVersion = false;
        /**
         * Custom node type for uploaded file
         */
        this.nodeType = 'cm:content';
        /**
         * Emitted when the file is uploaded successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the upload begins.
         */
        this.beginUpload = new EventEmitter();
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.uploadService.fileUploadError.subscribe((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
        })));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => subscription.unsubscribe()));
        this.subscriptions = [];
    }
    /**
     * Upload a list of file in the specified path
     * @param {?} files
     * @return {?}
     */
    uploadFiles(files) {
        /** @type {?} */
        const filteredFiles = files
            .map((/**
         * @param {?} file
         * @return {?}
         */
        (file) => {
            return this.createFileModel(file, this.rootFolderId, (((/** @type {?} */ (file))).webkitRelativePath || '').replace(/\/[^\/]*$/, ''));
        }));
        this.uploadQueue(filteredFiles);
    }
    /**
     * @param {?} files
     * @return {?}
     */
    uploadFilesInfo(files) {
        /** @type {?} */
        const filteredFiles = files
            .map((/**
         * @param {?} fileInfo
         * @return {?}
         */
        (fileInfo) => {
            return this.createFileModel(fileInfo.file, this.rootFolderId, fileInfo.relativeFolder);
        }));
        this.uploadQueue(filteredFiles);
    }
    /**
     * @private
     * @param {?} files
     * @return {?}
     */
    uploadQueue(files) {
        /** @type {?} */
        const filteredFiles = files
            .filter(this.isFileAcceptable.bind(this))
            .filter(this.isFileSizeAcceptable.bind(this));
        this.ngZone.run((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const event = new UploadFilesEvent([...filteredFiles], this.uploadService, this.success);
            this.beginUpload.emit(event);
            if (!event.defaultPrevented) {
                if (filteredFiles.length > 0) {
                    this.uploadService.addToQueue(...filteredFiles);
                    this.uploadService.uploadFilesInTheQueue(this.success);
                }
            }
        }));
    }
    /**
     * Checks if the given file is allowed by the extension filters
     *
     * @protected
     * @param {?} file FileModel
     * @return {?}
     */
    isFileAcceptable(file) {
        if (this.acceptedFilesType === '*') {
            return true;
        }
        /** @type {?} */
        const allowedExtensions = this.acceptedFilesType
            .split(',')
            .map((/**
         * @param {?} ext
         * @return {?}
         */
        (ext) => ext.trim().replace(/^\./, '')));
        if (allowedExtensions.indexOf(file.extension) !== -1) {
            return true;
        }
        return false;
    }
    /**
     * Creates FileModel from File
     *
     * @protected
     * @param {?} file
     * @param {?} parentId
     * @param {?} path
     * @param {?=} id
     * @return {?}
     */
    createFileModel(file, parentId, path, id) {
        return new FileModel(file, {
            comment: this.comment,
            majorVersion: this.majorVersion,
            newVersion: this.versioning,
            parentId: parentId,
            path: path,
            nodeType: this.nodeType
        }, id);
    }
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    isFileSizeAllowed(file) {
        /** @type {?} */
        let isFileSizeAllowed = true;
        if (this.isMaxFileSizeDefined()) {
            isFileSizeAllowed = this.isFileSizeCorrect(file);
        }
        return isFileSizeAllowed;
    }
    /**
     * @protected
     * @return {?}
     */
    isMaxFileSizeDefined() {
        return this.maxFilesSize !== undefined && this.maxFilesSize !== null;
    }
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    isFileSizeCorrect(file) {
        return this.maxFilesSize >= 0 && file.size <= this.maxFilesSize;
    }
    /**
     * Checks if the given file is an acceptable size
     *
     * @private
     * @param {?} file FileModel
     * @return {?}
     */
    isFileSizeAcceptable(file) {
        /** @type {?} */
        let acceptableSize = true;
        if (!this.isFileSizeAllowed(file)) {
            acceptableSize = false;
            /** @type {?} */
            const message = this.translationService.instant('FILE_UPLOAD.MESSAGES.EXCEED_MAX_FILE_SIZE', { fileName: file.name });
            this.error.emit(message);
        }
        return acceptableSize;
    }
}
UploadBase.propDecorators = {
    maxFilesSize: [{ type: Input }],
    rootFolderId: [{ type: Input }],
    disabled: [{ type: Input }],
    acceptedFilesType: [{ type: Input }],
    versioning: [{ type: Input }],
    majorVersion: [{ type: Input }],
    comment: [{ type: Input }],
    nodeType: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    beginUpload: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UploadButtonComponent extends UploadBase {
    /**
     * @param {?} uploadService
     * @param {?} contentService
     * @param {?} translationService
     * @param {?} logService
     * @param {?} ngZone
     */
    constructor(uploadService, contentService, translationService, logService, ngZone) {
        super(uploadService, translationService, ngZone);
        this.uploadService = uploadService;
        this.contentService = contentService;
        this.translationService = translationService;
        this.logService = logService;
        this.ngZone = ngZone;
        /**
         * Allows/disallows upload folders (only for Chrome).
         */
        this.uploadFolders = false;
        /**
         * Allows/disallows multiple files
         */
        this.multipleFiles = false;
        /**
         * Custom tooltip text.
         */
        this.tooltip = null;
        /**
         * Emitted when create permission is missing.
         */
        this.permissionEvent = new EventEmitter();
        this.hasAllowableOperations = false;
        this.permissionValue = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.permissionValue.subscribe((/**
         * @param {?} permission
         * @return {?}
         */
        (permission) => {
            this.hasAllowableOperations = permission;
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const rootFolderId = changes['rootFolderId'];
        if (rootFolderId && rootFolderId.currentValue) {
            this.checkPermission();
        }
    }
    /**
     * @return {?}
     */
    isButtonDisabled() {
        return this.disabled ? true : undefined;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onFilesAdded($event) {
        /** @type {?} */
        const files = FileUtils.toFileArray($event.currentTarget.files);
        if (this.hasAllowableOperations) {
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        // reset the value of the input file
        $event.target.value = '';
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDirectoryAdded($event) {
        if (this.hasAllowableOperations) {
            /** @type {?} */
            const files = FileUtils.toFileArray($event.currentTarget.files);
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        // reset the value of the input file
        $event.target.value = '';
    }
    /**
     * @return {?}
     */
    checkPermission() {
        if (this.rootFolderId) {
            /** @type {?} */
            const opts = {
                includeSource: true,
                include: ['allowableOperations']
            };
            this.contentService.getNode(this.rootFolderId, opts).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => this.permissionValue.next(this.nodeHasPermission(res.entry, AllowableOperationsEnum.CREATE))), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => this.error.emit(error)));
        }
    }
    /**
     * @param {?} node
     * @param {?} permission
     * @return {?}
     */
    nodeHasPermission(node, permission) {
        return this.contentService.hasAllowableOperations(node, permission);
    }
}
UploadButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-button',
                template: "<form class=\"adf-upload-button-file-container\">\n    <!--Files Upload-->\n    <a *ngIf=\"!uploadFolders\"\n        [disabled]=\"isButtonDisabled()\"\n        mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n\n        <!--Multiple Files Upload-->\n        <span *ngIf=\"multipleFiles\">\n            <label\n                id=\"upload-multiple-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-multiple-files\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-multiple-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-multiple-files\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-multiple-files\"\n                data-automation-id=\"upload-multiple-files\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n\n        <!--Single Files Upload-->\n        <span *ngIf=\"!multipleFiles\">\n            <label\n                id=\"upload-single-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-single-file\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-single-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-single-file\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-single-file\"\n                data-automation-id=\"upload-single-file\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n    </a>\n\n    <!--Folders Upload-->\n    <a *ngIf=\"uploadFolders\"\n        [disabled]=\"isButtonDisabled()\" mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n        <label\n            id=\"uploadFolder-label\"\n            *ngIf=\"!staticTitle\"\n            for=\"uploadFolder\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>\n        <label\n            id=\"uploadFolder-label-static\"\n            *ngIf=\"staticTitle\"\n            for=\"uploadFolder\">{{ staticTitle }}</label>\n        <input #uploadFolders\n            id=\"uploadFolder\"\n            data-automation-id=\"uploadFolder\"\n            type=\"file\"\n            name=\"uploadFiles\"\n            multiple=\"multiple\"\n            accept=\"{{acceptedFilesType}}\"\n            webkitdirectory directory\n            [attr.disabled]=\"isButtonDisabled()\"\n            [title]=\"tooltip\"\n            (change)=\"onDirectoryAdded($event)\">\n    </a>\n</form>\n",
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => UploadButtonComponent)) }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}"]
            }] }
];
/** @nocollapse */
UploadButtonComponent.ctorParameters = () => [
    { type: UploadService },
    { type: ContentService },
    { type: TranslationService },
    { type: LogService },
    { type: NgZone }
];
UploadButtonComponent.propDecorators = {
    uploadFolders: [{ type: Input }],
    multipleFiles: [{ type: Input }],
    staticTitle: [{ type: Input }],
    tooltip: [{ type: Input }],
    permissionEvent: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UploadVersionButtonComponent extends UploadButtonComponent {
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    createFileModel(file) {
        /** @type {?} */
        const fileModel = super.createFileModel(file, this.rootFolderId, (((/** @type {?} */ (file))).webkitRelativePath || '').replace(/\/[^\/]*$/, ''), this.node.id);
        if (!this.isFileAcceptable(fileModel)) {
            /** @type {?} */
            const message = this.translationService.instant('FILE_UPLOAD.VERSION.MESSAGES.INCOMPATIBLE_VERSION');
            this.error.emit(message);
        }
        return fileModel;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.checkPermission();
    }
    /**
     * @return {?}
     */
    checkPermission() {
        this.permissionValue.next(this.nodeHasPermission(this.node, AllowableOperationsEnum.UPDATE));
    }
}
UploadVersionButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-version-button',
                template: "<form class=\"adf-upload-button-file-container\">\n    <!--Files Upload-->\n    <a *ngIf=\"!uploadFolders\"\n        [disabled]=\"isButtonDisabled()\"\n        mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n\n        <!--Multiple Files Upload-->\n        <span *ngIf=\"multipleFiles\">\n            <label\n                id=\"upload-multiple-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-multiple-files\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-multiple-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-multiple-files\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-multiple-files\"\n                data-automation-id=\"upload-multiple-files\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n\n        <!--Single Files Upload-->\n        <span *ngIf=\"!multipleFiles\">\n            <label\n                id=\"upload-single-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-single-file\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-single-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-single-file\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-single-file\"\n                data-automation-id=\"upload-single-file\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n    </a>\n\n    <!--Folders Upload-->\n    <a *ngIf=\"uploadFolders\"\n        [disabled]=\"isButtonDisabled()\" mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n        <label\n            id=\"uploadFolder-label\"\n            *ngIf=\"!staticTitle\"\n            for=\"uploadFolder\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>\n        <label\n            id=\"uploadFolder-label-static\"\n            *ngIf=\"staticTitle\"\n            for=\"uploadFolder\">{{ staticTitle }}</label>\n        <input #uploadFolders\n            id=\"uploadFolder\"\n            data-automation-id=\"uploadFolder\"\n            type=\"file\"\n            name=\"uploadFiles\"\n            multiple=\"multiple\"\n            accept=\"{{acceptedFilesType}}\"\n            webkitdirectory directory\n            [attr.disabled]=\"isButtonDisabled()\"\n            [title]=\"tooltip\"\n            (change)=\"onDirectoryAdded($event)\">\n    </a>\n</form>\n",
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => UploadVersionButtonComponent)) }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}"]
            }] }
];
UploadVersionButtonComponent.propDecorators = {
    node: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UploadDragAreaComponent extends UploadBase {
    /**
     * @param {?} uploadService
     * @param {?} translationService
     * @param {?} notificationService
     * @param {?} contentService
     * @param {?} ngZone
     */
    constructor(uploadService, translationService, notificationService, contentService, ngZone) {
        super(uploadService, translationService, ngZone);
        this.uploadService = uploadService;
        this.translationService = translationService;
        this.notificationService = notificationService;
        this.contentService = contentService;
        this.ngZone = ngZone;
    }
    /**
     * Method called when files are dropped in the drag area.
     *
     * @param {?} files - files dropped in the drag area.
     * @return {?}
     */
    onFilesDropped(files) {
        if (!this.disabled && files.length) {
            this.uploadFiles(files);
        }
    }
    /**
     * Called when a folder are dropped in the drag area
     *
     * @param {?} folder - name of the dropped folder
     * @return {?}
     */
    onFolderEntityDropped(folder) {
        if (!this.disabled && folder.isDirectory) {
            FileUtils.flatten(folder).then((/**
             * @param {?} filesInfo
             * @return {?}
             */
            (filesInfo) => {
                this.uploadFilesInfo(filesInfo);
            }));
        }
    }
    /**
     * Show undo notification bar.
     *
     * @param {?} latestFilesAdded - files in the upload queue enriched with status flag and xhr object.
     * @return {?}
     */
    showUndoNotificationBar(latestFilesAdded) {
        /** @type {?} */
        let messageTranslate;
        /** @type {?} */
        let actionTranslate;
        messageTranslate = this.translationService.get('FILE_UPLOAD.MESSAGES.PROGRESS');
        actionTranslate = this.translationService.get('FILE_UPLOAD.ACTION.UNDO');
        this.notificationService.openSnackMessageAction(messageTranslate.value, actionTranslate.value, 3000).onAction().subscribe((/**
         * @return {?}
         */
        () => {
            this.uploadService.cancelUpload(...latestFilesAdded);
        }));
    }
    /**
     * Returns true or false considering the component options and node permissions
     * @return {?}
     */
    isDroppable() {
        return !this.disabled;
    }
    /**
     * Handles 'upload-files' events raised by child components.
     *
     * @param {?} event DOM event
     * @return {?}
     */
    onUploadFiles(event) {
        event.stopPropagation();
        event.preventDefault();
        /** @type {?} */
        const isAllowed = this.contentService.hasAllowableOperations(event.detail.data.obj.entry, AllowableOperationsEnum.CREATE);
        if (isAllowed) {
            /** @type {?} */
            const fileInfo = event.detail.files;
            if (this.isTargetNodeFolder(event)) {
                /** @type {?} */
                const destinationFolderName = event.detail.data.obj.entry.name;
                fileInfo.map((/**
                 * @param {?} file
                 * @return {?}
                 */
                (file) => file.relativeFolder = destinationFolderName ? destinationFolderName.concat(file.relativeFolder) : file.relativeFolder));
            }
            if (fileInfo && fileInfo.length > 0) {
                this.uploadFilesInfo(fileInfo);
            }
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    isTargetNodeFolder(event) {
        return event.detail.data.obj && event.detail.data.obj.entry.isFolder;
    }
}
UploadDragAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-drag-area',
                template: "<div [adf-file-draggable]=\"isDroppable()\" class=\"adf-upload-border\"\n     (filesDropped)=\"onFilesDropped($event)\"\n     (folderEntityDropped)=\"onFolderEntityDropped($event)\"\n     (upload-files)=\"onUploadFiles($event)\"\n     dropzone=\"\" webkitdropzone=\"*\" #droparea>\n    <ng-content></ng-content>\n</div>\n",
                host: { 'class': 'adf-upload-drag-area' },
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => UploadDragAreaComponent)) }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
UploadDragAreaComponent.ctorParameters = () => [
    { type: UploadService },
    { type: TranslationService },
    { type: NotificationService },
    { type: ContentService },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileUploadErrorPipe {
    /**
     * @param {?} translation
     */
    constructor(translation) {
        this.translation = translation;
    }
    /**
     * @param {?} errorCode
     * @return {?}
     */
    transform(errorCode) {
        return this.translation.instant(`FILE_UPLOAD.ERRORS.${errorCode || 'GENERIC'}`);
    }
}
FileUploadErrorPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfFileUploadError',
                pure: true
            },] }
];
/** @nocollapse */
FileUploadErrorPipe.ctorParameters = () => [
    { type: TranslationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class FileDraggableDirective {
    /**
     * @param {?} el
     * @param {?} ngZone
     */
    constructor(el, ngZone) {
        this.ngZone = ngZone;
        /**
         * Enables/disables drag-and-drop functionality.
         */
        this.enabled = true;
        /**
         * Emitted when one or more files are dragged and dropped onto the draggable element.
         */
        this.filesDropped = new EventEmitter();
        /**
         * Emitted when a directory is dragged and dropped onto the draggable element.
         */
        this.folderEntityDropped = new EventEmitter();
        this.cssClassName = 'adf-file-draggable__input-focus';
        this.element = el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
            this.element.addEventListener('dragover', this.onDragOver.bind(this));
            this.element.addEventListener('dragleave', this.onDragLeave.bind(this));
            this.element.addEventListener('drop', this.onDropFiles.bind(this));
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDropFiles);
    }
    /**
     * Method called when files is dropped in the drag and drop area.
     * @param {?} event DOM event.
     * @return {?}
     */
    onDropFiles(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            // Chrome, Edge, Firefox, Opera (Files + Folders)
            /** @type {?} */
            const items = event.dataTransfer.items;
            if (items) {
                /** @type {?} */
                const files = [];
                for (let i = 0; i < items.length; i++) {
                    if (items[i].webkitGetAsEntry) {
                        /** @type {?} */
                        const item = items[i].webkitGetAsEntry();
                        if (item) {
                            if (item.isFile) {
                                /** @type {?} */
                                const file = items[i].getAsFile();
                                if (file) {
                                    files.push(file);
                                }
                            }
                            else if (item.isDirectory) {
                                this.folderEntityDropped.emit(item);
                            }
                        }
                    }
                }
                if (files.length > 0) {
                    this.filesDropped.emit(files);
                }
            }
            else {
                // IE, Safari, Chrome, Edge, Firefox, Opera (Files only)
                /** @type {?} */
                const files = FileUtils.toFileArray(event.dataTransfer.files);
                this.filesDropped.emit(files);
            }
            this.element.classList.remove(this.cssClassName);
        }
    }
    /**
     * Change the style of the drag area when a file drag in.
     *
     * @param {?} event - DOM event.
     * @return {?}
     */
    onDragEnter(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    }
    /**
     * Change the style of the drag area when a file drag out.
     *
     * @param {?} event - DOM event.
     * @return {?}
     */
    onDragLeave(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.remove(this.cssClassName);
        }
    }
    /**
     * Change the style of the drag area when a file is over the drag area.
     *
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    }
    /**
     * Prevent default and stop propagation of the DOM event.
     *
     * @param {?} event
     * @return {?}
     */
    preventDefault(event) {
        event.stopPropagation();
        event.preventDefault();
    }
}
FileDraggableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-file-draggable]'
            },] }
];
/** @nocollapse */
FileDraggableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
FileDraggableDirective.propDecorators = {
    enabled: [{ type: Input, args: ['adf-file-draggable',] }],
    filesDropped: [{ type: Output }],
    folderEntityDropped: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UploadModule {
}
UploadModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    UploadVersionButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent,
                    FileUploadErrorPipe
                ],
                exports: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    UploadVersionButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent,
                    FileUploadErrorPipe
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DocumentListModule {
}
DocumentListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    UploadModule
                ],
                declarations: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    TrashcanNameColumnComponent,
                    LibraryStatusColumnComponent,
                    LibraryRoleColumnComponent,
                    LibraryNameColumnComponent,
                    NameColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent
                ],
                exports: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    TrashcanNameColumnComponent,
                    LibraryStatusColumnComponent,
                    LibraryRoleColumnComponent,
                    LibraryNameColumnComponent,
                    NameColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent
                ],
                entryComponents: [
                    TrashcanNameColumnComponent,
                    LibraryStatusColumnComponent,
                    LibraryRoleColumnComponent,
                    LibraryNameColumnComponent,
                    NameColumnComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchQueryBuilderService {
    /**
     * @param {?} appConfig
     * @param {?} alfrescoApiService
     */
    constructor(appConfig, alfrescoApiService) {
        this.appConfig = appConfig;
        this.alfrescoApiService = alfrescoApiService;
        this._userQuery = '';
        this.updated = new Subject();
        this.executed = new Subject();
        this.error = new Subject();
        this.categories = [];
        this.queryFragments = {};
        this.filterQueries = [];
        this.paging = null;
        this.sorting = [];
        this.userFacetBuckets = {};
        this.config = {
            categories: []
        };
        // TODO: to be supported in future iterations
        this.ranges = {};
        this.resetToDefaults();
    }
    /**
     * @return {?}
     */
    get userQuery() {
        return this._userQuery;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set userQuery(value) {
        value = (value || '').trim();
        this._userQuery = value ? `(${value})` : '';
    }
    /**
     * Resets the query to the defaults specified in the app config.
     * @return {?}
     */
    resetToDefaults() {
        /** @type {?} */
        const template = this.appConfig.get('search');
        if (template) {
            this.config = JSON.parse(JSON.stringify(template));
            this.categories = (this.config.categories || []).filter((/**
             * @param {?} category
             * @return {?}
             */
            (category) => category.enabled));
            this.filterQueries = this.config.filterQueries || [];
            this.userFacetBuckets = {};
            if (this.config.sorting) {
                this.sorting = this.config.sorting.defaults || [];
            }
        }
    }
    /**
     * Adds a facet bucket to a field.
     * @param {?} field The target field
     * @param {?} bucket Bucket to add
     * @return {?}
     */
    addUserFacetBucket(field, bucket) {
        if (field && field.field && bucket) {
            /** @type {?} */
            const buckets = this.userFacetBuckets[field.field] || [];
            /** @type {?} */
            const existing = buckets.find((/**
             * @param {?} facetBucket
             * @return {?}
             */
            (facetBucket) => facetBucket.label === bucket.label));
            if (!existing) {
                buckets.push(bucket);
            }
            this.userFacetBuckets[field.field] = buckets;
        }
    }
    /**
     * Gets the buckets currently added to a field
     * @param {?} field The target fields
     * @return {?} Bucket array
     */
    getUserFacetBuckets(field) {
        return this.userFacetBuckets[field] || [];
    }
    /**
     * Removes an existing bucket from a field.
     * @param {?} field The target field
     * @param {?} bucket Bucket to remove
     * @return {?}
     */
    removeUserFacetBucket(field, bucket) {
        if (field && field.field && bucket) {
            /** @type {?} */
            const buckets = this.userFacetBuckets[field.field] || [];
            this.userFacetBuckets[field.field] = buckets
                .filter((/**
             * @param {?} facetBucket
             * @return {?}
             */
            (facetBucket) => facetBucket.label !== bucket.label));
        }
    }
    /**
     * Adds a filter query to the current query.
     * @param {?} query Query string to add
     * @return {?}
     */
    addFilterQuery(query) {
        if (query) {
            /** @type {?} */
            const existing = this.filterQueries.find((/**
             * @param {?} filterQuery
             * @return {?}
             */
            (filterQuery) => filterQuery.query === query));
            if (!existing) {
                this.filterQueries.push({ query: query });
            }
        }
    }
    /**
     * Removes an existing filter query.
     * @param {?} query The query to remove
     * @return {?}
     */
    removeFilterQuery(query) {
        if (query) {
            this.filterQueries = this.filterQueries
                .filter((/**
             * @param {?} filterQuery
             * @return {?}
             */
            (filterQuery) => filterQuery.query !== query));
        }
    }
    /**
     * Gets a facet query by label.
     * @param {?} label Label of the query
     * @return {?} Facet query data
     */
    getFacetQuery(label) {
        if (label && this.hasFacetQueries) {
            /** @type {?} */
            const result = this.config.facetQueries.queries.find((/**
             * @param {?} query
             * @return {?}
             */
            (query) => query.label === label));
            if (result) {
                return Object.assign({}, result);
            }
        }
        return null;
    }
    /**
     * Gets a facet field by label.
     * @param {?} label Label of the facet field
     * @return {?} Facet field data
     */
    getFacetField(label) {
        if (label) {
            /** @type {?} */
            const fields = this.config.facetFields.fields || [];
            /** @type {?} */
            const result = fields.find((/**
             * @param {?} field
             * @return {?}
             */
            (field) => field.label === label));
            if (result) {
                result.label = this.getSupportedLabel(result.label);
                return Object.assign({}, result);
            }
        }
        return null;
    }
    /**
     * Builds the current query and triggers the `updated` event.
     * @return {?}
     */
    update() {
        /** @type {?} */
        const query = this.buildQuery();
        this.updated.next(query);
    }
    /**
     * Builds and executes the current query.
     * @return {?} Nothing
     */
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                /** @type {?} */
                const query = this.buildQuery();
                if (query) {
                    /** @type {?} */
                    const resultSetPaging = yield this.alfrescoApiService.searchApi.search(query);
                    this.executed.next(resultSetPaging);
                }
            }
            catch (error) {
                this.error.next(error);
                this.executed.next({
                    list: {
                        pagination: {
                            totalItems: 0
                        },
                        entries: []
                    }
                });
            }
        });
    }
    /**
     * Builds the current query.
     * @return {?} The finished query
     */
    buildQuery() {
        /** @type {?} */
        const query = this.getFinalQuery();
        /** @type {?} */
        const include = this.config.include || [];
        if (include.length === 0) {
            include.push('path', 'allowableOperations');
        }
        if (query) {
            /** @type {?} */
            const result = (/** @type {?} */ ({
                query: {
                    query: query,
                    language: 'afts'
                },
                include: include,
                paging: this.paging,
                fields: this.config.fields,
                filterQueries: this.filterQueries,
                facetQueries: this.facetQueries,
                facetIntervals: this.facetIntervals,
                facetFields: this.facetFields,
                sort: this.sort,
                highlight: this.highlight
            }));
            result['facetFormat'] = 'V2';
            return result;
        }
        return null;
    }
    /**
     * Gets the primary sorting definition.
     * @return {?} The primary sorting definition
     */
    getPrimarySorting() {
        if (this.sorting && this.sorting.length > 0) {
            return this.sorting[0];
        }
        return null;
    }
    /**
     * Gets all pre-configured sorting options that users can choose from.
     * @return {?} Pre-configured sorting options
     */
    getSortingOptions() {
        if (this.config && this.config.sorting) {
            return this.config.sorting.options || [];
        }
        return [];
    }
    /**
     * Gets the query group.
     * @param {?} query Target query
     * @return {?} Query group
     */
    getQueryGroup(query) {
        return query.group || this.config.facetQueries.label || 'Facet Queries';
    }
    /**
     * Checks if FacetQueries has been defined
     * @return {?} True if defined, false otherwise
     */
    get hasFacetQueries() {
        if (this.config
            && this.config.facetQueries
            && this.config.facetQueries.queries
            && this.config.facetQueries.queries.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Checks if FacetIntervals has been defined
     * @return {?} True if defined, false otherwise
     */
    get hasFacetIntervals() {
        if (this.config
            && this.config.facetIntervals
            && this.config.facetIntervals.intervals
            && this.config.facetIntervals.intervals.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    get hasFacetHighlight() {
        return this.config && this.config.highlight ? true : false;
    }
    /**
     * @protected
     * @return {?}
     */
    get sort() {
        return this.sorting.map((/**
         * @param {?} def
         * @return {?}
         */
        (def) => {
            return new RequestSortDefinitionInner({
                type: def.type,
                field: def.field,
                ascending: def.ascending
            });
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    get facetQueries() {
        if (this.hasFacetQueries) {
            return this.config.facetQueries.queries.map((/**
             * @param {?} query
             * @return {?}
             */
            (query) => {
                query.group = this.getQueryGroup(query);
                return (/** @type {?} */ (Object.assign({}, query)));
            }));
        }
        return null;
    }
    /**
     * @protected
     * @return {?}
     */
    get facetIntervals() {
        if (this.hasFacetIntervals) {
            /** @type {?} */
            const configIntervals = this.config.facetIntervals;
            return {
                intervals: configIntervals.intervals.map((/**
                 * @param {?} interval
                 * @return {?}
                 */
                (interval) => (/** @type {?} */ ({
                    label: this.getSupportedLabel(interval.label),
                    field: interval.field,
                    sets: interval.sets.map((/**
                     * @param {?} set
                     * @return {?}
                     */
                    (set) => (/** @type {?} */ ({
                        label: this.getSupportedLabel(set.label),
                        start: set.start,
                        end: set.end,
                        startInclusive: set.startInclusive,
                        endInclusive: set.endInclusive
                    }))))
                }))))
            };
        }
        return null;
    }
    /**
     * @protected
     * @return {?}
     */
    get highlight() {
        return this.hasFacetHighlight ? this.config.highlight : null;
    }
    /**
     * @protected
     * @return {?}
     */
    getFinalQuery() {
        /** @type {?} */
        let query = '';
        this.categories.forEach((/**
         * @param {?} facet
         * @return {?}
         */
        (facet) => {
            /** @type {?} */
            const customQuery = this.queryFragments[facet.id];
            if (customQuery) {
                if (query.length > 0) {
                    query += ' AND ';
                }
                query += `(${customQuery})`;
            }
        }));
        /** @type {?} */
        let result = [this.userQuery, query]
            .filter((/**
         * @param {?} entry
         * @return {?}
         */
        (entry) => entry))
            .join(' AND ');
        if (this.userFacetBuckets) {
            Object.keys(this.userFacetBuckets).forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const subQuery = (this.userFacetBuckets[key] || [])
                    .filter((/**
                 * @param {?} bucket
                 * @return {?}
                 */
                (bucket) => bucket.filterQuery))
                    .map((/**
                 * @param {?} bucket
                 * @return {?}
                 */
                (bucket) => bucket.filterQuery))
                    .join(' OR ');
                if (subQuery) {
                    if (result.length > 0) {
                        result += ' AND ';
                    }
                    result += `(${subQuery})`;
                }
            }));
        }
        return result;
    }
    /**
     * @protected
     * @return {?}
     */
    get facetFields() {
        /** @type {?} */
        const facetFields = this.config.facetFields && this.config.facetFields.fields;
        if (facetFields && facetFields.length > 0) {
            return {
                facets: facetFields.map((/**
                 * @param {?} facet
                 * @return {?}
                 */
                (facet) => (/** @type {?} */ ({
                    field: facet.field,
                    mincount: facet.mincount,
                    label: this.getSupportedLabel(facet.label),
                    limit: facet.limit,
                    offset: facet.offset,
                    prefix: facet.prefix
                }))))
            };
        }
        return null;
    }
    /**
     * Encloses a label name with double quotes if it contains whitespace characters.
     * @param {?} configLabel Original label text
     * @return {?} Label, possibly with quotes if it contains spaces
     */
    getSupportedLabel(configLabel) {
        /** @type {?} */
        const spaceInsideLabelIndex = configLabel.search(/\s/g);
        if (spaceInsideLabelIndex > -1) {
            return `"${configLabel}"`;
        }
        return configLabel;
    }
}
SearchQueryBuilderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SearchQueryBuilderService.ctorParameters = () => [
    { type: AppConfigService },
    { type: AlfrescoApiService }
];
/** @nocollapse */ SearchQueryBuilderService.ngInjectableDef = defineInjectable({ factory: function SearchQueryBuilderService_Factory() { return new SearchQueryBuilderService(inject(AppConfigService), inject(AlfrescoApiService)); }, token: SearchQueryBuilderService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchComponent {
    /**
     * @param {?} searchService
     * @param {?} _elementRef
     */
    constructor(searchService, _elementRef) {
        this.searchService = searchService;
        this._elementRef = _elementRef;
        /**
         * Function that maps an option's value to its display value in the trigger.
         */
        this.displayWith = null;
        /**
         * Maximum number of results to show in the search.
         */
        this.maxResults = 20;
        /**
         * Number of results to skip from the results pagination.
         */
        this.skipResults = 0;
        /**
         * Search term to use when executing the search. Updating this value will
         * run a new search and update the results.
         */
        this.searchTerm = '';
        /**
         * Emitted when search results have fully loaded.
         */
        this.resultLoaded = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.showPanel = false;
        this._isOpen = false;
        this.keyPressedStream = new Subject();
        this._classList = {};
        this.keyPressedStream.asObservable()
            .pipe(debounceTime(200))
            .subscribe((/**
         * @param {?} searchedWord
         * @return {?}
         */
        (searchedWord) => {
            this.loadSearchResults(searchedWord);
        }));
        searchService.dataLoaded.subscribe((/**
         * @param {?} nodePaging
         * @return {?}
         */
        (nodePaging) => this.onSearchDataLoaded(nodePaging)), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.onSearchDataError(error)));
    }
    /**
     * CSS class for display.
     * @param {?} classList
     * @return {?}
     */
    set classList(classList) {
        if (classList && classList.length) {
            classList.split(' ').forEach((/**
             * @param {?} className
             * @return {?}
             */
            (className) => this._classList[className.trim()] = true));
            this._elementRef.nativeElement.className = '';
        }
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen && this.showPanel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        this._isOpen = value;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setVisibility();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.searchTerm && changes.searchTerm.currentValue) {
            this.loadSearchResults(changes.searchTerm.currentValue);
        }
    }
    /**
     * @return {?}
     */
    resetResults() {
        this.cleanResults();
        this.setVisibility();
    }
    /**
     * @return {?}
     */
    reload() {
        this.loadSearchResults(this.searchTerm);
    }
    /**
     * @private
     * @return {?}
     */
    cleanResults() {
        if (this.results) {
            this.results = {};
        }
    }
    /**
     * @private
     * @param {?=} searchTerm
     * @return {?}
     */
    loadSearchResults(searchTerm) {
        this.resetResults();
        if (searchTerm) {
            this.searchService.search(searchTerm, this.maxResults, this.skipResults).subscribe((/**
             * @param {?} result
             * @return {?}
             */
            (result) => this.onSearchDataLoaded(result)), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => this.onSearchDataError(err)));
        }
        else {
            this.cleanResults();
        }
    }
    /**
     * @param {?} nodePaging
     * @return {?}
     */
    onSearchDataLoaded(nodePaging) {
        if (nodePaging) {
            this.results = nodePaging;
            this.resultLoaded.emit(this.results);
            this.isOpen = true;
            this.setVisibility();
        }
    }
    /**
     * @param {?} error
     * @return {?}
     */
    onSearchDataError(error) {
        if (error && error.status !== 400) {
            this.results = null;
            this.error.emit(error);
        }
    }
    /**
     * @return {?}
     */
    hidePanel() {
        if (this.isOpen) {
            this._classList['adf-search-show'] = false;
            this._classList['adf-search-hide'] = true;
            this.isOpen = false;
        }
    }
    /**
     * @return {?}
     */
    setVisibility() {
        this.showPanel = !!this.results && !!this.results.list;
        this._classList['adf-search-show'] = this.showPanel;
        this._classList['adf-search-hide'] = !this.showPanel;
    }
}
SearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search',
                template: "<div role=\"listbox\" id=\"adf-search-results-content\" [ngClass]=\"_classList\" #panel>\n    <ng-template\n        [ngTemplateOutlet]=\"template\"\n        [ngTemplateOutletContext]=\"{ $implicit: results }\">\n    </ng-template>\n</div>\n\n\n",
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false,
                exportAs: 'searchAutocomplete',
                host: {
                    'class': 'adf-search'
                },
                styles: [""]
            }] }
];
/** @nocollapse */
SearchComponent.ctorParameters = () => [
    { type: SearchService },
    { type: ElementRef }
];
SearchComponent.propDecorators = {
    panel: [{ type: ViewChild, args: ['panel',] }],
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    displayWith: [{ type: Input }],
    maxResults: [{ type: Input }],
    skipResults: [{ type: Input }],
    searchTerm: [{ type: Input }],
    classList: [{ type: Input, args: ['class',] }],
    resultLoaded: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EmptySearchResultComponent {
}
EmptySearchResultComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-empty-search-result',
                template: "<div class=\"adf-empty-search-result\">\n    <ng-content></ng-content>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchControlComponent {
    /**
     * @param {?} authService
     * @param {?} thumbnailService
     */
    constructor(authService, thumbnailService) {
        this.authService = authService;
        this.thumbnailService = thumbnailService;
        /**
         * Toggles whether to use an expanding search control. If false
         * then a regular input is used.
         */
        this.expandable = true;
        /**
         * Toggles highlighting of the search term in the results.
         */
        this.highlight = false;
        /**
         * Type of the input field to render, e.g. "search" or "text" (default).
         */
        this.inputType = 'text';
        /**
         * Toggles auto-completion of the search input field.
         */
        this.autocomplete = false;
        /**
         * Toggles "find-as-you-type" suggestions for possible matches.
         */
        this.liveSearchEnabled = true;
        /**
         * Maximum number of results to show in the live search.
         */
        this.liveSearchMaxResults = 5;
        /**
         * Emitted when the search is submitted by pressing the ENTER key.
         * The search term is provided as the value of the event.
         */
        this.submit = new EventEmitter();
        /**
         * Emitted when the search term is changed. The search term is provided
         * in the 'value' property of the returned object.  If the term is less
         * than three characters in length then it is truncated to an empty
         * string.
         */
        this.searchChange = new EventEmitter();
        /**
         * Emitted when a file item from the list of "find-as-you-type" results is selected.
         */
        this.optionClicked = new EventEmitter();
        this.searchTerm = '';
        this.noSearchResultTemplate = null;
        this.toggleSearch = new Subject();
        this.focusSubject = new Subject();
        this.toggleSearch.asObservable().pipe(debounceTime(200)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this.expandable) {
                this.subscriptAnimationState = this.subscriptAnimationState === 'inactive' ? 'active' : 'inactive';
                if (this.subscriptAnimationState === 'inactive') {
                    this.searchTerm = '';
                    this.searchAutocomplete.resetResults();
                    if (document.activeElement.id === this.searchInput.nativeElement.id) {
                        this.searchInput.nativeElement.blur();
                    }
                }
            }
        }));
    }
    /**
     * @param {?} animationDoneEvent
     * @return {?}
     */
    applySearchFocus(animationDoneEvent) {
        if (animationDoneEvent.toState === 'active') {
            this.searchInput.nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptAnimationState = this.expandable ? 'inactive' : 'no-animation';
        this.setupFocusEventHandlers();
    }
    /**
     * @return {?}
     */
    isNoSearchTemplatePresent() {
        return this.emptySearchTemplate ? true : false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.focusSubject) {
            this.focusSubject.complete();
            this.focusSubject = null;
        }
        if (this.toggleSearch) {
            this.toggleSearch.complete();
            this.toggleSearch = null;
        }
    }
    /**
     * @return {?}
     */
    isLoggedIn() {
        return this.authService.isEcmLoggedIn();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    searchSubmit(event) {
        this.submit.emit(event);
        this.toggleSearchBar();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    inputChange(event) {
        this.searchChange.emit(event);
    }
    /**
     * @return {?}
     */
    getAutoComplete() {
        return this.autocomplete ? 'on' : 'off';
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getMimeTypeIcon(node) {
        /** @type {?} */
        const mimeType = this.getMimeType(node);
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getMimeType(node) {
        /** @type {?} */
        let mimeType;
        if (node.entry.content && node.entry.content.mimeType) {
            mimeType = node.entry.content.mimeType;
        }
        if (node.entry.isFolder) {
            mimeType = 'folder';
        }
        return mimeType;
    }
    /**
     * @return {?}
     */
    isSearchBarActive() {
        return this.subscriptAnimationState === 'active' && this.liveSearchEnabled;
    }
    /**
     * @return {?}
     */
    toggleSearchBar() {
        if (this.toggleSearch) {
            this.toggleSearch.next();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    elementClicked(item) {
        if (item.entry) {
            this.optionClicked.next(item);
            this.toggleSearchBar();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onFocus($event) {
        this.focusSubject.next($event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onBlur($event) {
        this.focusSubject.next($event);
    }
    /**
     * @return {?}
     */
    activateToolbar() {
        if (!this.isSearchBarActive()) {
            this.toggleSearchBar();
        }
    }
    /**
     * @return {?}
     */
    selectFirstResult() {
        if (this.listResultElement && this.listResultElement.length > 0) {
            /** @type {?} */
            const firstElement = (/** @type {?} */ (this.listResultElement.first));
            firstElement._getHostElement().focus();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onRowArrowDown($event) {
        /** @type {?} */
        const nextElement = this.getNextElementSibling((/** @type {?} */ ($event.target)));
        if (nextElement) {
            nextElement.focus();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onRowArrowUp($event) {
        /** @type {?} */
        const previousElement = this.getPreviousElementSibling((/** @type {?} */ ($event.target)));
        if (previousElement) {
            previousElement.focus();
        }
        else {
            this.searchInput.nativeElement.focus();
            this.focusSubject.next(new FocusEvent('focus'));
        }
    }
    /**
     * @private
     * @return {?}
     */
    setupFocusEventHandlers() {
        /** @type {?} */
        const focusEvents = this.focusSubject
            .asObservable()
            .pipe(debounceTime(50), filter((/**
         * @param {?} $event
         * @return {?}
         */
        ($event) => {
            return this.isSearchBarActive() && ($event.type === 'blur' || $event.type === 'focusout');
        })));
        focusEvents.subscribe((/**
         * @return {?}
         */
        () => {
            this.toggleSearchBar();
        }));
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getNextElementSibling(node) {
        return node.nextElementSibling;
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getPreviousElementSibling(node) {
        return node.previousElementSibling;
    }
}
SearchControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-control',
                template: "<div class=\"adf-search-container\" [attr.state]=\"subscriptAnimationState\">\n    <div *ngIf=\"isLoggedIn()\" [@transitionMessages]=\"subscriptAnimationState\"\n         (@transitionMessages.done)=\"applySearchFocus($event)\">\n        <button mat-icon-button\n                *ngIf=\"expandable\"\n                id=\"adf-search-button\"\n                class=\"adf-search-button\"\n                [title]=\"'SEARCH.BUTTON.TOOLTIP' | translate\"\n                (click)=\"toggleSearchBar()\"\n                (keyup.enter)=\"toggleSearchBar()\">\n            <mat-icon [attr.aria-label]=\"'SEARCH.BUTTON.ARIA-LABEL' | translate\">search</mat-icon>\n        </button>\n        <mat-form-field class=\"adf-input-form-field-divider\">\n            <input matInput\n                   #searchInput\n                   [attr.aria-label]=\"'SEARCH.INPUT.ARIA-LABEL' | translate\"\n                   [attr.type]=\"inputType\"\n                   [autocomplete]=\"getAutoComplete()\"\n                   id=\"adf-control-input\"\n                   [(ngModel)]=\"searchTerm\"\n                   (focus)=\"activateToolbar()\"\n                   (blur)=\"onBlur($event)\"\n                   (keyup.escape)=\"toggleSearchBar()\"\n                   (keyup.arrowdown)=\"selectFirstResult()\"\n                   (ngModelChange)=\"inputChange($event)\"\n                   [searchAutocomplete]=\"auto\"\n                   (keyup.enter)=\"searchSubmit($event)\">\n        </mat-form-field>\n    </div>\n</div>\n\n<adf-search #search\n            #auto=\"searchAutocomplete\"\n            class=\"adf-search-result-autocomplete\"\n            [maxResults]=\"liveSearchMaxResults\">\n    <ng-template let-data>\n        <mat-list *ngIf=\"isSearchBarActive()\" id=\"autocomplete-search-result-list\">\n            <mat-list-item\n                *ngFor=\"let item of data?.list?.entries; let idx = index\"\n                id=\"result_option_{{idx}}\"\n                [attr.data-automation-id]=\"'autocomplete_for_' + item.entry.name\"\n                [tabindex]=\"0\"\n                (focus)=\"onFocus($event)\"\n                (blur)=\"onBlur($event)\"\n                (keyup.arrowdown)=\"onRowArrowDown($event)\"\n                (keyup.arrowup)=\"onRowArrowUp($event)\"\n                class=\"adf-search-autocomplete-item\"\n                (click)=\"elementClicked(item)\"\n                (keyup.enter)=\"elementClicked(item)\"\n                (touchend)=\"elementClicked(item)\">\n                <!-- This is a comment -->\n                <mat-icon mat-list-icon>\n                    <img [alt]=\"getMimeType(item)\" [src]=\"getMimeTypeIcon(item)\"/>\n                </mat-icon>\n                <h4 mat-line id=\"result_name_{{idx}}\"\n                    *ngIf=\"highlight; else elseBlock\"\n                    class=\"adf-search-fixed-text\"\n                    [innerHtml]=\"item.entry.name | highlight: searchTerm\">\n                    {{ item?.entry.name }}\n                </h4>\n                <ng-template #elseBlock>\n                    <h4 class=\"adf-search-fixed-text\" mat-line id=\"result_name_{{idx}}\"\n                        [innerHtml]=\"item.entry.name\"></h4>\n                </ng-template>\n                <p mat-line class=\"adf-search-fixed-text\"> {{item?.entry.createdByUser.displayName}} </p>\n            </mat-list-item>\n            <mat-list-item id=\"search_no_result\"\n                           data-automation-id=\"search_no_result_found\"\n                           *ngIf=\"data?.list?.entries.length === 0\">\n                <ng-content\n                    selector=\"adf-empty-search-result\"\n                    *ngIf=\"isNoSearchTemplatePresent() else defaultNoResult\">\n                </ng-content>\n                <ng-template #defaultNoResult>\n                    <p mat-line class=\"adf-search-fixed-text\">{{ 'SEARCH.RESULTS.NONE' | translate:{searchTerm:\n                        searchTerm} }}</p>\n                </ng-template>\n            </mat-list-item>\n        </mat-list>\n    </ng-template>\n</adf-search>\n",
                animations: [
                    trigger('transitionMessages', [
                        state('active', style({ transform: 'translateX(0%)', 'margin-left': '13px' })),
                        state('inactive', style({ transform: 'translateX(82%)' })),
                        state('no-animation', style({ transform: 'translateX(0%)', width: '100%' })),
                        transition('inactive => active', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')),
                        transition('active => inactive', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
                    ])
                ],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-control' },
                styles: [""]
            }] }
];
/** @nocollapse */
SearchControlComponent.ctorParameters = () => [
    { type: AuthenticationService },
    { type: ThumbnailService }
];
SearchControlComponent.propDecorators = {
    expandable: [{ type: Input }],
    highlight: [{ type: Input }],
    inputType: [{ type: Input }],
    autocomplete: [{ type: Input }],
    liveSearchEnabled: [{ type: Input }],
    liveSearchMaxResults: [{ type: Input }],
    submit: [{ type: Output }],
    searchChange: [{ type: Output }],
    optionClicked: [{ type: Output }],
    searchAutocomplete: [{ type: ViewChild, args: ['search',] }],
    searchInput: [{ type: ViewChild, args: ['searchInput',] }],
    listResultElement: [{ type: ViewChildren, args: [MatListItem,] }],
    emptySearchTemplate: [{ type: ContentChild, args: [EmptySearchResultComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => SearchTriggerDirective)),
    multi: true
};
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class SearchTriggerDirective {
    /**
     * @param {?} element
     * @param {?} ngZone
     * @param {?} changeDetectorRef
     * @param {?} document
     */
    constructor(element, ngZone, changeDetectorRef, document) {
        this.element = element;
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.document = document;
        this.onDestroy$ = new Subject();
        this.autocomplete = 'off';
        this._panelOpen = false;
        this.escapeEventStream = new Subject();
        this.onChange = (/**
         * @return {?}
         */
        () => { });
        this.onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
        if (this.escapeEventStream) {
            this.escapeEventStream = null;
        }
        if (this.closingActionsSubscription) {
            this.closingActionsSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this._panelOpen && this.searchPanel.showPanel;
    }
    /**
     * @return {?}
     */
    openPanel() {
        this.searchPanel.isOpen = this._panelOpen = true;
        this.closingActionsSubscription = this.subscribeToClosingActions();
    }
    /**
     * @return {?}
     */
    closePanel() {
        if (this._panelOpen) {
            this.closingActionsSubscription.unsubscribe();
            this._panelOpen = false;
            this.searchPanel.resetResults();
            this.searchPanel.hidePanel();
            this.changeDetectorRef.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    get panelClosingActions() {
        return merge(this.escapeEventStream, this.outsideClickStream);
    }
    /**
     * @private
     * @return {?}
     */
    get outsideClickStream() {
        if (!this.document) {
            return of(null);
        }
        return merge(fromEvent(this.document, 'click'), fromEvent(this.document, 'touchend')).pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /** @type {?} */
            const clickTarget = (/** @type {?} */ (event.target));
            return this._panelOpen && clickTarget !== this.element.nativeElement;
        })), takeUntil(this.onDestroy$));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        Promise.resolve(null).then((/**
         * @return {?}
         */
        () => this.setTriggerValue(value)));
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        if (keyCode === ESCAPE && this.panelOpen) {
            this.escapeEventStream.next();
            event.stopPropagation();
        }
        else if (keyCode === ENTER) {
            this.escapeEventStream.next();
            event.preventDefault();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleInput(event) {
        if (document.activeElement === event.target) {
            /** @type {?} */
            const inputValue = ((/** @type {?} */ (event.target))).value;
            this.onChange(inputValue);
            if (inputValue) {
                this.searchPanel.keyPressedStream.next(inputValue);
                this.openPanel();
            }
            else {
                this.searchPanel.resetResults();
                this.closePanel();
            }
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    isPanelOptionClicked(event) {
        /** @type {?} */
        let isPanelOption = false;
        if (event) {
            /** @type {?} */
            const clickTarget = (/** @type {?} */ (event.target));
            isPanelOption = !this.isNoResultOption(event) &&
                !!this.searchPanel.panel &&
                !!this.searchPanel.panel.nativeElement.contains(clickTarget);
        }
        return isPanelOption;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    isNoResultOption(event) {
        return this.searchPanel.results.list ? this.searchPanel.results.list.entries.length === 0 : true;
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToClosingActions() {
        /** @type {?} */
        const firstStable = this.ngZone.onStable.asObservable();
        /** @type {?} */
        const optionChanges = this.searchPanel.keyPressedStream.asObservable();
        return merge(firstStable, optionChanges)
            .pipe(switchMap((/**
         * @return {?}
         */
        () => {
            this.searchPanel.setVisibility();
            return this.panelClosingActions;
        })), takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.setValueAndClose(event)));
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setTriggerValue(value) {
        /** @type {?} */
        const toDisplay = this.searchPanel && this.searchPanel.displayWith ?
            this.searchPanel.displayWith(value) : value;
        /** @type {?} */
        const inputValue = toDisplay != null ? toDisplay : '';
        this.element.nativeElement.value = inputValue;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    setValueAndClose(event) {
        if (this.isPanelOptionClicked(event) && !event.defaultPrevented) {
            this.setTriggerValue(event.target.textContent.trim());
            this.onChange(event.target.textContent.trim());
            this.element.nativeElement.focus();
        }
        this.closePanel();
    }
}
SearchTriggerDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: `input[searchAutocomplete], textarea[searchAutocomplete]`,
                host: {
                    'role': 'combobox',
                    '[attr.autocomplete]': 'autocomplete',
                    'aria-autocomplete': 'list',
                    '[attr.aria-expanded]': 'panelOpen.toString()',
                    '(blur)': 'onTouched()',
                    '(input)': 'handleInput($event)',
                    '(keydown)': 'handleKeydown($event)'
                },
                providers: [SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR]
            },] }
];
/** @nocollapse */
SearchTriggerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
SearchTriggerDirective.propDecorators = {
    searchPanel: [{ type: Input, args: ['searchAutocomplete',] }],
    autocomplete: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
const DEFAULT_PAGE_SIZE = 5;
/**
 * @template T
 */
class SearchFilterList {
    /**
     * @param {?=} items
     * @param {?=} pageSize
     */
    constructor(items = [], pageSize) {
        this.filteredItems = [];
        this._filterText = '';
        this.items = [];
        this.pageSize = DEFAULT_PAGE_SIZE;
        this.currentPageSize = DEFAULT_PAGE_SIZE;
        this._filter = (/**
         * @return {?}
         */
        () => true);
        this.items = items;
        this.filteredItems = items;
        this.pageSize = pageSize || DEFAULT_PAGE_SIZE;
        this.currentPageSize = pageSize || DEFAULT_PAGE_SIZE;
    }
    /**
     * @return {?}
     */
    get filterText() {
        return this._filterText;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set filterText(value) {
        this._filterText = value;
        this.applyFilter();
    }
    /**
     * @return {?}
     */
    get filter() {
        return this._filter;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set filter(value) {
        this._filter = value;
        this.applyFilter();
    }
    /**
     * @private
     * @return {?}
     */
    applyFilter() {
        if (this.filter) {
            this.filteredItems = this.items.filter(this.filter);
        }
        else {
            this.filteredItems = this.items;
        }
        this.currentPageSize = this.pageSize;
    }
    /**
     * Returns visible portion of the items.
     * @return {?}
     */
    get visibleItems() {
        return this.filteredItems.slice(0, this.currentPageSize);
    }
    /**
     * Returns entire collection length including items not displayed on the page.
     * @return {?}
     */
    get length() {
        return this.items.length;
    }
    /**
     * Detects whether more items can be displayed.
     * @return {?}
     */
    get canShowMoreItems() {
        return this.filteredItems.length > this.currentPageSize;
    }
    /**
     * Detects whether less items can be displayed.
     * @return {?}
     */
    get canShowLessItems() {
        return this.currentPageSize > this.pageSize;
    }
    /**
     * Detects whether content fits single page.
     * @return {?}
     */
    get fitsPage() {
        return this.pageSize >= this.filteredItems.length;
    }
    /**
     * Display more items.
     * @return {?}
     */
    showMoreItems() {
        if (this.canShowMoreItems) {
            this.currentPageSize += this.pageSize;
        }
    }
    /**
     * Display less items.
     * @return {?}
     */
    showLessItems() {
        if (this.canShowLessItems) {
            this.currentPageSize -= this.pageSize;
        }
    }
    /**
     * Reset entire collection and page settings.
     * @return {?}
     */
    clear() {
        this.currentPageSize = this.pageSize;
        this.items = [];
        this.filteredItems = [];
        this.filterText = '';
    }
    /**
     * @param {?} item
     * @return {?}
     */
    addItem(item) {
        if (!item) {
            return;
        }
        this.items.push(item);
        this.applyFilter();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    deleteItem(item) {
        /** @type {?} */
        const removeIndex = this.items.indexOf(item);
        if (removeIndex > -1) {
            this.items.splice(removeIndex, 1);
            this.filteredItems.splice(removeIndex, 1);
        }
    }
    /**
     * @return {?}
     */
    [Symbol.iterator]() {
        /** @type {?} */
        let pointer = 0;
        /** @type {?} */
        const items = this.visibleItems;
        return {
            /**
             * @return {?}
             */
            next() {
                if (pointer < items.length) {
                    return {
                        done: false,
                        value: items[pointer++]
                    };
                }
                else {
                    return {
                        done: true,
                        value: null
                    };
                }
            }
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchFilterComponent {
    /**
     * @param {?} queryBuilder
     * @param {?} searchService
     * @param {?} translationService
     */
    constructor(queryBuilder, searchService, translationService) {
        this.queryBuilder = queryBuilder;
        this.searchService = searchService;
        this.translationService = translationService;
        this.DEFAULT_PAGE_SIZE = 5;
        this.isAlive = true;
        /**
         * All facet field items to be displayed in the component. These are updated according to the response.
         *  When a new search is performed, the already existing items are updated with the new bucket count values and
         *  the newly received items are added to the responseFacets.
         */
        this.responseFacets = null;
        this.facetQueriesPageSize = this.DEFAULT_PAGE_SIZE;
        this.facetQueriesLabel = 'Facet Queries';
        this.facetExpanded = {
            'default': false
        };
        this.selectedBuckets = [];
        if (queryBuilder.config && queryBuilder.config.facetQueries) {
            this.facetQueriesLabel = queryBuilder.config.facetQueries.label || 'Facet Queries';
            this.facetQueriesPageSize = queryBuilder.config.facetQueries.pageSize || this.DEFAULT_PAGE_SIZE;
            this.facetExpanded['query'] = queryBuilder.config.facetQueries.expanded;
        }
        if (queryBuilder.config && queryBuilder.config.facetFields) {
            this.facetExpanded['field'] = queryBuilder.config.facetFields.expanded;
        }
        if (queryBuilder.config && queryBuilder.config.facetIntervals) {
            this.facetExpanded['interval'] = queryBuilder.config.facetIntervals.expanded;
        }
        this.displayResetButton = this.queryBuilder.config && !!this.queryBuilder.config.resetButton;
        this.queryBuilder.updated.pipe(takeWhile((/**
         * @return {?}
         */
        () => this.isAlive))).subscribe((/**
         * @return {?}
         */
        () => {
            this.queryBuilder.execute();
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.queryBuilder) {
            this.queryBuilder.executed.pipe(takeWhile((/**
             * @return {?}
             */
            () => this.isAlive))).subscribe((/**
             * @param {?} resultSetPaging
             * @return {?}
             */
            (resultSetPaging) => {
                this.onDataLoaded(resultSetPaging);
                this.searchService.dataLoaded.next(resultSetPaging);
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.isAlive = false;
    }
    /**
     * @private
     * @return {?}
     */
    updateSelectedBuckets() {
        if (this.responseFacets) {
            this.selectedBuckets = [];
            for (const field of this.responseFacets) {
                if (field.buckets) {
                    this.selectedBuckets.push(...this.queryBuilder.getUserFacetBuckets(field.field)
                        .filter((/**
                     * @param {?} bucket
                     * @return {?}
                     */
                    (bucket) => bucket.checked))
                        .map((/**
                     * @param {?} bucket
                     * @return {?}
                     */
                    (bucket) => {
                        return { field, bucket };
                    })));
                }
            }
        }
        else {
            this.selectedBuckets = [];
        }
    }
    /**
     * @param {?} event
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    onToggleBucket(event, field, bucket) {
        if (event && bucket) {
            if (event.checked) {
                this.selectFacetBucket(field, bucket);
            }
            else {
                this.unselectFacetBucket(field, bucket);
            }
        }
    }
    /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    selectFacetBucket(field, bucket) {
        if (bucket) {
            bucket.checked = true;
            this.queryBuilder.addUserFacetBucket(field, bucket);
            this.updateSelectedBuckets();
            this.queryBuilder.update();
        }
    }
    /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    unselectFacetBucket(field, bucket) {
        if (bucket) {
            bucket.checked = false;
            this.queryBuilder.removeUserFacetBucket(field, bucket);
            this.updateSelectedBuckets();
            this.queryBuilder.update();
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    canResetSelectedBuckets(field) {
        if (field && field.buckets) {
            return field.buckets.items.some((/**
             * @param {?} bucket
             * @return {?}
             */
            (bucket) => bucket.checked));
        }
        return false;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    resetSelectedBuckets(field) {
        if (field && field.buckets) {
            for (const bucket of field.buckets.items) {
                bucket.checked = false;
                this.queryBuilder.removeUserFacetBucket(field, bucket);
            }
            this.updateSelectedBuckets();
            this.queryBuilder.update();
        }
    }
    /**
     * @return {?}
     */
    resetAllSelectedBuckets() {
        this.responseFacets.forEach((/**
         * @param {?} field
         * @return {?}
         */
        (field) => {
            if (field && field.buckets) {
                for (const bucket of field.buckets.items) {
                    bucket.checked = false;
                    this.queryBuilder.removeUserFacetBucket(field, bucket);
                }
                this.updateSelectedBuckets();
            }
        }));
        this.queryBuilder.update();
    }
    /**
     * @return {?}
     */
    resetAll() {
        this.resetAllSelectedBuckets();
        this.responseFacets = null;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    shouldExpand(field) {
        return this.facetExpanded[field.type] || this.facetExpanded['default'];
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onDataLoaded(data) {
        /** @type {?} */
        const context = data.list.context;
        if (context) {
            this.parseFacets(context);
        }
        else {
            this.responseFacets = null;
        }
    }
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    parseFacets(context) {
        this.parseFacetFields(context);
        this.parseFacetIntervals(context);
        this.parseFacetQueries(context);
    }
    /**
     * @private
     * @param {?} context
     * @param {?} configFacetFields
     * @param {?} itemType
     * @return {?}
     */
    parseFacetItems(context, configFacetFields, itemType) {
        configFacetFields.forEach((/**
         * @param {?} field
         * @return {?}
         */
        (field) => {
            /** @type {?} */
            const responseField = this.findFacet(context, itemType, field.label);
            /** @type {?} */
            const responseBuckets = this.getResponseBuckets(responseField, field)
                .filter(this.getFilterByMinCount(field.mincount));
            /** @type {?} */
            const alreadyExistingField = this.findResponseFacet(itemType, field.label);
            if (alreadyExistingField) {
                /** @type {?} */
                const alreadyExistingBuckets = alreadyExistingField.buckets && alreadyExistingField.buckets.items || [];
                this.updateExistingBuckets(responseField, responseBuckets, alreadyExistingField, alreadyExistingBuckets);
            }
            else if (responseField) {
                /** @type {?} */
                const bucketList = new SearchFilterList(responseBuckets, field.pageSize);
                bucketList.filter = this.getBucketFilterFunction(bucketList);
                if (!this.responseFacets) {
                    this.responseFacets = [];
                }
                this.responseFacets.push((/** @type {?} */ (Object.assign({}, field, { type: responseField.type || itemType, label: field.label, pageSize: field.pageSize | this.DEFAULT_PAGE_SIZE, currentPageSize: field.pageSize | this.DEFAULT_PAGE_SIZE, buckets: bucketList }))));
            }
        }));
    }
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    parseFacetFields(context) {
        /** @type {?} */
        const configFacetFields = this.queryBuilder.config.facetFields && this.queryBuilder.config.facetFields.fields || [];
        this.parseFacetItems(context, configFacetFields, 'field');
    }
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    parseFacetIntervals(context) {
        /** @type {?} */
        const configFacetIntervals = this.queryBuilder.config.facetIntervals && this.queryBuilder.config.facetIntervals.intervals || [];
        this.parseFacetItems(context, configFacetIntervals, 'interval');
    }
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    parseFacetQueries(context) {
        /** @type {?} */
        const configFacetQueries = this.queryBuilder.config.facetQueries && this.queryBuilder.config.facetQueries.queries || [];
        /** @type {?} */
        const configGroups = configFacetQueries.reduce((/**
         * @param {?} acc
         * @param {?} query
         * @return {?}
         */
        (acc, query) => {
            /** @type {?} */
            const group = this.queryBuilder.getQueryGroup(query);
            if (acc[group]) {
                acc[group].push(query);
            }
            else {
                acc[group] = [query];
            }
            return acc;
        }), []);
        /** @type {?} */
        const mincount = this.queryBuilder.config.facetQueries && this.queryBuilder.config.facetQueries.mincount;
        /** @type {?} */
        const mincountFilter = this.getFilterByMinCount(mincount);
        Object.keys(configGroups).forEach((/**
         * @param {?} group
         * @return {?}
         */
        (group) => {
            /** @type {?} */
            const responseField = this.findFacet(context, 'query', group);
            /** @type {?} */
            const responseBuckets = this.getResponseQueryBuckets(responseField, configGroups[group])
                .filter(mincountFilter);
            /** @type {?} */
            const alreadyExistingField = this.findResponseFacet('query', group);
            if (alreadyExistingField) {
                /** @type {?} */
                const alreadyExistingBuckets = alreadyExistingField.buckets && alreadyExistingField.buckets.items || [];
                this.updateExistingBuckets(responseField, responseBuckets, alreadyExistingField, alreadyExistingBuckets);
            }
            else if (responseField) {
                /** @type {?} */
                const bucketList = new SearchFilterList(responseBuckets, this.facetQueriesPageSize);
                bucketList.filter = this.getBucketFilterFunction(bucketList);
                if (!this.responseFacets) {
                    this.responseFacets = [];
                }
                this.responseFacets.push((/** @type {?} */ ({
                    field: group,
                    type: responseField.type || 'query',
                    label: group,
                    pageSize: this.DEFAULT_PAGE_SIZE,
                    currentPageSize: this.DEFAULT_PAGE_SIZE,
                    buckets: bucketList
                })));
            }
        }));
    }
    /**
     * @private
     * @param {?} responseField
     * @param {?} configField
     * @return {?}
     */
    getResponseBuckets(responseField, configField) {
        return ((responseField && responseField.buckets) || []).map((/**
         * @param {?} respBucket
         * @return {?}
         */
        (respBucket) => {
            respBucket['count'] = this.getCountValue(respBucket);
            respBucket.filterQuery = respBucket.filterQuery || this.getCorrespondingFilterQuery(configField, respBucket.label);
            return (/** @type {?} */ (Object.assign({}, respBucket, { checked: false, display: respBucket.display, label: respBucket.label })));
        }));
    }
    /**
     * @private
     * @param {?} responseField
     * @param {?} configGroup
     * @return {?}
     */
    getResponseQueryBuckets(responseField, configGroup) {
        return (configGroup || []).map((/**
         * @param {?} query
         * @return {?}
         */
        (query) => {
            /** @type {?} */
            const respBucket = ((responseField && responseField.buckets) || [])
                .find((/**
             * @param {?} bucket
             * @return {?}
             */
            (bucket) => bucket.label === query.label));
            respBucket['count'] = this.getCountValue(respBucket);
            return (/** @type {?} */ (Object.assign({}, respBucket, { checked: false, display: respBucket.display, label: respBucket.label })));
        }));
    }
    /**
     * @private
     * @param {?} bucket
     * @return {?}
     */
    getCountValue(bucket) {
        return (!!bucket && !!bucket.metrics && bucket.metrics[0] && bucket.metrics[0].value && bucket.metrics[0].value.count)
            || 0;
    }
    /**
     * @param {?} bucket
     * @return {?}
     */
    getBucketCountDisplay(bucket) {
        return bucket.count === null ? '' : `(${bucket.count})`;
    }
    /**
     * @private
     * @param {?} mincountInput
     * @return {?}
     */
    getFilterByMinCount(mincountInput) {
        return (/**
         * @param {?} bucket
         * @return {?}
         */
        (bucket) => {
            /** @type {?} */
            let mincount = mincountInput;
            if (mincount === undefined) {
                mincount = 1;
            }
            return bucket.count >= mincount;
        });
    }
    /**
     * @private
     * @param {?} configFacetItem
     * @param {?} bucketLabel
     * @return {?}
     */
    getCorrespondingFilterQuery(configFacetItem, bucketLabel) {
        /** @type {?} */
        let filterQuery = null;
        if (configFacetItem.field && bucketLabel) {
            if (configFacetItem.sets) {
                /** @type {?} */
                const configSet = configFacetItem.sets.find((/**
                 * @param {?} set
                 * @return {?}
                 */
                (set) => bucketLabel === set.label));
                if (configSet) {
                    filterQuery = this.buildIntervalQuery(configFacetItem.field, configSet);
                }
            }
            else {
                filterQuery = `${configFacetItem.field}:"${bucketLabel}"`;
            }
        }
        return filterQuery;
    }
    /**
     * @private
     * @param {?} fieldName
     * @param {?} interval
     * @return {?}
     */
    buildIntervalQuery(fieldName, interval) {
        /** @type {?} */
        const start = interval.start;
        /** @type {?} */
        const end = interval.end;
        /** @type {?} */
        const startLimit = (interval.startInclusive === undefined || interval.startInclusive === true) ? '[' : '<';
        /** @type {?} */
        const endLimit = (interval.endInclusive === undefined || interval.endInclusive === true) ? ']' : '>';
        return `${fieldName}:${startLimit}"${start}" TO "${end}"${endLimit}`;
    }
    /**
     * @private
     * @param {?} context
     * @param {?} itemType
     * @param {?} fieldLabel
     * @return {?}
     */
    findFacet(context, itemType, fieldLabel) {
        return (context.facets || []).find((/**
         * @param {?} response
         * @return {?}
         */
        (response) => response.type === itemType && response.label === fieldLabel)) || {};
    }
    /**
     * @private
     * @param {?} itemType
     * @param {?} fieldLabel
     * @return {?}
     */
    findResponseFacet(itemType, fieldLabel) {
        return (this.responseFacets || []).find((/**
         * @param {?} response
         * @return {?}
         */
        (response) => response.type === itemType && response.label === fieldLabel));
    }
    /**
     * @private
     * @param {?} responseField
     * @param {?} responseBuckets
     * @param {?} alreadyExistingField
     * @param {?} alreadyExistingBuckets
     * @return {?}
     */
    updateExistingBuckets(responseField, responseBuckets, alreadyExistingField, alreadyExistingBuckets) {
        /** @type {?} */
        const bucketsToDelete = [];
        alreadyExistingBuckets
            .map((/**
         * @param {?} bucket
         * @return {?}
         */
        (bucket) => {
            /** @type {?} */
            const responseBucket = ((responseField && responseField.buckets) || []).find((/**
             * @param {?} respBucket
             * @return {?}
             */
            (respBucket) => respBucket.label === bucket.label));
            if (!responseBucket) {
                bucketsToDelete.push(bucket);
            }
            bucket.count = this.getCountValue(responseBucket);
            return bucket;
        }));
        /** @type {?} */
        const hasSelection = this.selectedBuckets
            .find((/**
         * @param {?} selBuckets
         * @return {?}
         */
        (selBuckets) => alreadyExistingField.label === selBuckets.field.label && alreadyExistingField.type === selBuckets.field.type));
        if (!hasSelection && bucketsToDelete.length) {
            bucketsToDelete.forEach((/**
             * @param {?} bucket
             * @return {?}
             */
            (bucket) => {
                alreadyExistingField.buckets.deleteItem(bucket);
            }));
        }
        responseBuckets.forEach((/**
         * @param {?} respBucket
         * @return {?}
         */
        (respBucket) => {
            /** @type {?} */
            const existingBucket = alreadyExistingBuckets.find((/**
             * @param {?} oldBucket
             * @return {?}
             */
            (oldBucket) => oldBucket.label === respBucket.label));
            if (!existingBucket) {
                alreadyExistingField.buckets.addItem(respBucket);
            }
        }));
    }
    /**
     * @private
     * @param {?} bucketList
     * @return {?}
     */
    getBucketFilterFunction(bucketList) {
        return (/**
         * @param {?} bucket
         * @return {?}
         */
        (bucket) => {
            if (bucket && bucketList.filterText) {
                /** @type {?} */
                const pattern = (bucketList.filterText || '').toLowerCase();
                /** @type {?} */
                const label = (this.translationService.instant(bucket.display) || this.translationService.instant(bucket.label)).toLowerCase();
                return this.queryBuilder.config.filterWithContains ? label.indexOf(pattern) !== -1 : label.startsWith(pattern);
            }
            return true;
        });
    }
}
SearchFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-filter',
                template: "<mat-accordion multi=\"true\" displayMode=\"flat\">\n\n    <button *ngIf=\"displayResetButton && responseFacets\"\n            mat-button\n            color=\"primary\"\n            matTooltip=\"{{ 'SEARCH.FILTER.BUTTONS.RESET-ALL.TOOLTIP' | translate }}\"\n            matTooltipPosition=\"right\"\n            (click)=\"resetAll()\">\n        {{ 'SEARCH.FILTER.BUTTONS.RESET-ALL.LABEL' | translate }}\n    </button>\n    <mat-expansion-panel\n        *ngFor=\"let category of queryBuilder.categories\"\n        [attr.data-automation-id]=\"'expansion-panel-'+category.name\"\n        [(expanded)]=\"category.expanded\">\n        <mat-expansion-panel-header>\n            <mat-panel-title>\n                {{ category.name | translate }}\n            </mat-panel-title>\n        </mat-expansion-panel-header>\n        <adf-search-widget-container\n            [id]=\"category.id\"\n            [selector]=\"category.component.selector\"\n            [settings]=\"category.component.settings\">\n        </adf-search-widget-container>\n    </mat-expansion-panel>\n\n    <ng-container *ngIf=\"responseFacets\">\n        <mat-expansion-panel [attr.data-automation-id]=\"'expansion-panel-'+field.label\" *ngFor=\"let field of responseFacets\"\n                             [expanded]=\"shouldExpand(field)\">\n            <mat-expansion-panel-header>\n                <mat-panel-title>{{ field.label | translate }}</mat-panel-title>\n            </mat-expansion-panel-header>\n\n            <div class=\"adf-facet-result-filter\">\n                <mat-form-field>\n                    <input\n                        matInput\n                        placeholder=\"{{ 'SEARCH.FILTER.ACTIONS.FILTER-CATEGORY' | translate }}\"\n                        [attr.data-automation-id]=\"'facet-result-filter-'+field.label\"\n                        [(ngModel)]=\"field.buckets.filterText\">\n                    <button *ngIf=\"field.buckets.filterText\"\n                        mat-button matSuffix mat-icon-button\n                        (click)=\"field.buckets.filterText = ''\">\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </mat-form-field>\n            </div>\n\n            <div class=\"adf-checklist\">\n                <mat-checkbox\n                    *ngFor=\"let bucket of field.buckets\"\n                    [checked]=\"bucket.checked\"\n                    [attr.data-automation-id]=\"'checkbox-'+field.label+'-'+(bucket.display || bucket.label)\"\n                    (change)=\"onToggleBucket($event, field, bucket)\">\n                    <div \n                        matTooltip=\"{{ bucket.display || bucket.label | translate }} {{ getBucketCountDisplay(bucket) }}\"\n                        matTooltipPosition=\"right\"\n                        class=\"adf-facet-label\">\n                        {{ bucket.display || bucket.label | translate }} {{ getBucketCountDisplay(bucket) }}\n                    </div>\n                </mat-checkbox>\n            </div>\n\n            <div class=\"adf-facet-buttons\" *ngIf=\"field.buckets.fitsPage\">\n                <button *ngIf=\"canResetSelectedBuckets(field)\"\n                    mat-button\n                    color=\"primary\"\n                    (click)=\"resetSelectedBuckets(field)\">\n                    {{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\n                </button>\n            </div>\n\n            <div class=\"adf-facet-buttons\" *ngIf=\"!field.buckets.fitsPage\">\n                <button mat-icon-button\n                    *ngIf=\"canResetSelectedBuckets(field)\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\"\n                    (click)=\"resetSelectedBuckets(field)\">\n                    <mat-icon>clear</mat-icon>\n                </button>\n                <button mat-icon-button\n                    *ngIf=\"field.buckets.canShowLessItems\"\n                    (click)=\"field.buckets.showLessItems()\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\">\n                    <mat-icon>keyboard_arrow_up</mat-icon>\n                </button>\n                <button mat-icon-button\n                    *ngIf=\"field.buckets.canShowMoreItems\"\n                    (click)=\"field.buckets.showMoreItems()\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\">\n                    <mat-icon>keyboard_arrow_down</mat-icon>\n                </button>\n            </div>\n        </mat-expansion-panel>\n    </ng-container>\n</mat-accordion>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-filter' },
                styles: [""]
            }] }
];
/** @nocollapse */
SearchFilterComponent.ctorParameters = () => [
    { type: SearchQueryBuilderService },
    { type: SearchService },
    { type: TranslationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchTextComponent {
    constructor() {
        /**
         * The content of the text box.
         */
        this.value = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.context && this.settings && this.settings.pattern) {
            /** @type {?} */
            const pattern = new RegExp(this.settings.pattern, 'g');
            /** @type {?} */
            const match = pattern.exec(this.context.queryFragments[this.id] || '');
            if (match && match.length > 1) {
                this.value = match[1];
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.value = '';
        this.updateQuery(null);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangedHandler(event) {
        this.value = event.target.value;
        this.updateQuery(this.value);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    updateQuery(value) {
        if (this.context && this.settings && this.settings.field) {
            this.context.queryFragments[this.id] = value ? `${this.settings.field}:'${value}'` : '';
            this.context.update();
        }
    }
}
SearchTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-text',
                template: "<mat-form-field>\n    <input\n        matInput\n        [placeholder]=\"settings?.placeholder\"\n        [(ngModel)]=\"value\"\n        (change)=\"onChangedHandler($event)\">\n    <button mat-button *ngIf=\"value\" matSuffix mat-icon-button (click)=\"reset()\">\n        <mat-icon>close</mat-icon>\n    </button>\n</mat-form-field>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-text' },
                styles: [".adf-search-text .mat-form-field{width:100%}"]
            }] }
];
SearchTextComponent.propDecorators = {
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchRadioComponent {
    constructor() {
        this.pageSize = 5;
        this.options = new SearchFilterList();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.pageSize = this.settings.pageSize || 5;
            if (this.settings.options && this.settings.options.length > 0) {
                this.options = new SearchFilterList(this.settings.options, this.pageSize);
            }
        }
        /** @type {?} */
        const initialValue = this.getSelectedValue();
        if (initialValue !== null) {
            this.setValue(initialValue);
        }
    }
    /**
     * @private
     * @return {?}
     */
    getSelectedValue() {
        /** @type {?} */
        const options = this.settings['options'] || [];
        if (options && options.length > 0) {
            /** @type {?} */
            let selected = options.find((/**
             * @param {?} opt
             * @return {?}
             */
            (opt) => opt.default));
            if (!selected) {
                selected = options[0];
            }
            return selected.value;
        }
        return null;
    }
    /**
     * @private
     * @param {?} newValue
     * @return {?}
     */
    setValue(newValue) {
        this.value = newValue;
        this.context.queryFragments[this.id] = newValue;
        this.context.update();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    changeHandler(event) {
        this.setValue(event.value);
    }
}
SearchRadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-radio',
                template: "<mat-radio-group\n    [(ngModel)]=\"value\"\n    (change)=\"changeHandler($event)\">\n    <mat-radio-button [attr.data-automation-id]=\"'search-radio-'+(option.name | translate)\"\n        *ngFor=\"let option of options\"\n        [value]=\"option.value\"\n        class=\"adf-facet-filter\">\n        <div \n            matTooltip=\"{{ option.name | translate }}\"\n            matTooltipPosition=\"right\"\n            class=\"filter-label\">\n            {{ option.name | translate }}\n        </div>\n    </mat-radio-button>\n</mat-radio-group>\n\n<div class=\"adf-facet-buttons\" *ngIf=\"!options.fitsPage\">\n    <button mat-icon-button\n        *ngIf=\"options.canShowLessItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\"\n        (click)=\"options.showLessItems()\">\n        <mat-icon>keyboard_arrow_up</mat-icon>\n    </button>\n    <button mat-icon-button\n        *ngIf=\"options.canShowMoreItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\"\n        (click)=\"options.showMoreItems()\">\n        <mat-icon>keyboard_arrow_down</mat-icon>\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-radio' },
                styles: [".adf-search-radio .mat-radio-group{display:flex;flex-direction:column}.adf-search-radio .mat-radio-button{margin:5px}.adf-search-radio .adf-facet-filter .mat-radio-label-content{text-overflow:ellipsis;overflow:hidden;width:100%}.adf-search-radio .adf-facet-filter .mat-radio-label{width:100%}.adf-search-radio .adf-facet-filter .adf-filter-label{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}"]
            }] }
];
/** @nocollapse */
SearchRadioComponent.ctorParameters = () => [];
SearchRadioComponent.propDecorators = {
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchSliderComponent {
    constructor() {
        this.thumbLabel = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            if (this.settings.hasOwnProperty('min')) {
                this.min = this.settings['min'];
            }
            if (this.settings.hasOwnProperty('max')) {
                this.max = this.settings['max'];
            }
            if (this.settings.hasOwnProperty('step')) {
                this.step = this.settings['step'];
            }
            this.thumbLabel = this.settings['thumbLabel'] ? true : false;
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.value = this.min || 0;
        this.updateQuery(null);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangedHandler(event) {
        this.value = event.value;
        this.updateQuery(this.value);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    updateQuery(value) {
        if (this.id && this.context && this.settings && this.settings.field) {
            if (value === null) {
                this.context.queryFragments[this.id] = '';
            }
            else {
                this.context.queryFragments[this.id] = `${this.settings.field}:[0 TO ${value}]`;
            }
            this.context.update();
        }
    }
}
SearchSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-slider',
                template: "<mat-slider\n    [(value)]=\"value\"\n    [min]=\"min\"\n    [max]=\"max\"\n    [step]=\"step\"\n    [thumbLabel]=\"thumbLabel\"\n    (change)=\"onChangedHandler($event)\"\n    data-automation-id=\"slider-range\">\n</mat-slider>\n\n<div class=\"facet-buttons\">\n    <button mat-button color=\"primary\" (click)=\"reset()\" data-automation-id=\"slider-btn-clear\">\n        {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-slider' },
                styles: [".adf-search-slider .mat-slider{width:100%}"]
            }] }
];
SearchSliderComponent.propDecorators = {
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LiveErrorStateMatcher {
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        /** @type {?} */
        const isSubmitted = form && form.submitted;
        return !!(control && control.invalid && (control.dirty || control.touched || (!control.pristine && isSubmitted)));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchNumberRangeComponent {
    constructor() {
        this.matcher = new LiveErrorStateMatcher();
        this.format = '[{FROM} TO {TO}]';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.field = this.settings.field;
            this.format = this.settings.format || '[{FROM} TO {TO}]';
        }
        this.validators = Validators.compose([
            Validators.required,
            Validators.pattern(/^-?(0|[1-9]\d*)?$/),
            Validators.min(0)
        ]);
        this.from = new FormControl('', this.validators);
        this.to = new FormControl('', this.validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        }, this.formValidator);
    }
    /**
     * @param {?} formGroup
     * @return {?}
     */
    formValidator(formGroup) {
        return parseInt(formGroup.get('from').value, 10) < parseInt(formGroup.get('to').value, 10) ? null : { 'mismatch': true };
    }
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    apply(model, isValid) {
        if (isValid && this.id && this.context && this.field) {
            /** @type {?} */
            const map$$1 = new Map();
            map$$1.set('FROM', model.from);
            map$$1.set('TO', model.to);
            /** @type {?} */
            const value = this.formatString(this.format, map$$1);
            this.context.queryFragments[this.id] = `${this.field}:${value}`;
            this.context.update();
        }
    }
    /**
     * @private
     * @param {?} str
     * @param {?} map
     * @return {?}
     */
    formatString(str, map$$1) {
        /** @type {?} */
        let result = str;
        map$$1.forEach((/**
         * @param {?} value
         * @param {?} key
         * @return {?}
         */
        (value, key) => {
            /** @type {?} */
            const expr = new RegExp('{' + key + '}', 'gm');
            result = result.replace(expr, value);
        }));
        return result;
    }
    /**
     * @return {?}
     */
    reset() {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    }
}
SearchNumberRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-number-range',
                template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"from\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM' | translate }}\"\n            autocomplete=\"off\"\n            data-automation-id=\"number-range-from-input\">\n        <mat-error *ngIf=\"from.hasError('pattern') || from.hasError('min')\" data-automation-id=\"number-range-from-error-invalid\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"from.hasError('required')\" data-automation-id=\"number-range-from-error-required\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"to\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO' | translate }}\"\n            autocomplete=\"off\"\n            data-automation-id=\"number-range-to-input\">\n        <mat-error *ngIf=\"to.hasError('pattern') || to.hasError('min')\" data-automation-id=\"number-range-to-error-invalid\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"to.hasError('required')\" data-automation-id=\"number-range-to-error-required\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n\n    <div class=\"adf-facet-buttons\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\" data-automation-id=\"number-range-btn-clear\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\" data-automation-id=\"number-range-btn-apply\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-number-range' },
                styles: [".adf-search-number-range>form{display:inline-flex;flex-direction:column;width:100%}"]
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchCheckListComponent {
    constructor() {
        this.operator = 'OR';
        this.pageSize = 5;
        this.options = new SearchFilterList();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.operator = this.settings.operator || 'OR';
            this.pageSize = this.settings.pageSize || 5;
            if (this.settings.options && this.settings.options.length > 0) {
                this.options = new SearchFilterList(this.settings.options, this.pageSize);
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.options.items.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => {
            opt.checked = false;
        }));
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    }
    /**
     * @param {?} event
     * @param {?} option
     * @return {?}
     */
    changeHandler(event, option) {
        option.checked = event.checked;
        this.flush();
    }
    /**
     * @return {?}
     */
    flush() {
        /** @type {?} */
        const checkedValues = this.options.items
            .filter((/**
         * @param {?} option
         * @return {?}
         */
        (option) => option.checked))
            .map((/**
         * @param {?} option
         * @return {?}
         */
        (option) => option.value));
        /** @type {?} */
        const query = checkedValues.join(` ${this.operator} `);
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = query;
            this.context.update();
        }
    }
}
SearchCheckListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-check-list',
                template: "<div class=\"checklist\">\n    <mat-checkbox\n        *ngFor=\"let option of options\"\n        [checked]=\"option.checked\"\n        [attr.data-automation-id]=\"'checkbox-' + (option.name)\"\n        (change)=\"changeHandler($event, option)\"\n        class=\"adf-facet-filter\">\n        <div \n            matTooltip=\"{{ option.name | translate }}\"\n            matTooltipPosition=\"right\"\n            class=\"facet-name\">\n            {{ option.name | translate }}\n        </div>\n        \n    </mat-checkbox>\n</div>\n\n<div class=\"adf-facet-buttons\" *ngIf=\"options.fitsPage\">\n    <button mat-button color=\"primary\" (click)=\"reset()\">\n        {{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\n    </button>\n</div>\n\n<div class=\"adf-facet-buttons\" *ngIf=\"!options.fitsPage\">\n    <button mat-icon-button\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\"\n        (click)=\"reset()\">\n        <mat-icon>clear</mat-icon>\n    </button>\n    <button mat-icon-button\n        *ngIf=\"options.canShowLessItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\"\n        (click)=\"options.showLessItems()\">\n        <mat-icon>keyboard_arrow_up</mat-icon>\n    </button>\n    <button mat-icon-button\n        *ngIf=\"options.canShowMoreItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\"\n        (click)=\"options.showMoreItems()\">\n        <mat-icon>keyboard_arrow_down</mat-icon>\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-check-list' },
                styles: [".adf-search-check-list{display:flex;flex-direction:column}.adf-search-check-list .adf-facet-filter .mat-checkbox-label{text-overflow:ellipsis;overflow:hidden;width:100%}.adf-search-check-list .adf-facet-filter .mat-checkbox-layout{width:100%}.adf-search-check-list .adf-facet-filter .adf-facet-name{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}"]
            }] }
];
/** @nocollapse */
SearchCheckListComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_FORMAT_DATE = 'DD/MM/YYYY';
const ɵ0 = MOMENT_DATE_FORMATS;
class SearchDateRangeComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.matcher = new LiveErrorStateMatcher();
        this.datePickerDateFormat = DEFAULT_FORMAT_DATE;
    }
    /**
     * @return {?}
     */
    getFromValidationMessage() {
        return this.from.hasError('invalidOnChange') || this.hasParseError(this.from) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.from.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                this.from.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                    '';
    }
    /**
     * @return {?}
     */
    getToValidationMessage() {
        return this.to.hasError('invalidOnChange') || this.hasParseError(this.to) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.to.hasError('matDatepickerMin') ? 'SEARCH.FILTER.VALIDATION.NO-DAYS' :
                this.to.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                    this.to.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                        '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.datePickerDateFormat = this.settings.dateFormat || DEFAULT_FORMAT_DATE;
        }
        /** @type {?} */
        const theCustomDateAdapter = (/** @type {?} */ ((/** @type {?} */ (this.dateAdapter))));
        theCustomDateAdapter.overrideDisplayFormat = this.datePickerDateFormat;
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            this.setLocale(locale);
        }));
        /** @type {?} */
        const validators = Validators.compose([
            Validators.required
        ]);
        this.from = new FormControl('', validators);
        this.to = new FormControl('', validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        });
        this.maxDate = this.dateAdapter.today().startOf('day');
    }
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    apply(model, isValid) {
        if (isValid && this.id && this.context && this.settings && this.settings.field) {
            /** @type {?} */
            const start = moment(model.from).startOf('day').format();
            /** @type {?} */
            const end = moment(model.to).endOf('day').format();
            this.context.queryFragments[this.id] = `${this.settings.field}:['${start}' TO '${end}']`;
            this.context.update();
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    }
    /**
     * @param {?} event
     * @param {?} formControl
     * @return {?}
     */
    onChangedHandler(event, formControl) {
        /** @type {?} */
        const inputValue = event.srcElement.value;
        /** @type {?} */
        const formatDate = this.dateAdapter.parse(inputValue, this.datePickerDateFormat);
        if (formatDate && formatDate.isValid()) {
            formControl.setValue(formatDate);
        }
        else if (formatDate) {
            formControl.setErrors({
                'invalidOnChange': true
            });
        }
        else {
            formControl.setErrors({
                'required': true
            });
        }
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    setLocale(locale) {
        this.dateAdapter.setLocale(locale);
        moment.locale(locale);
    }
    /**
     * @param {?} formControl
     * @return {?}
     */
    hasParseError(formControl) {
        return formControl.hasError('matDatepickerParse') && formControl.getError('matDatepickerParse').text;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    forcePlaceholder(event) {
        event.srcElement.click();
    }
}
SearchDateRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-date-range',
                template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"from\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM-DATE' | translate }}\"\n                [matDatepicker]=\"fromDatepicker\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, from)\"\n                data-automation-id=\"date-range-from-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"fromDatepicker\" data-automation-id=\"date-range-from-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #fromDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"from.invalid\" data-automation-id=\"date-range-from-error\">\n            {{ getFromValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"to\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO-DATE' | translate }}\"\n                [matDatepicker]=\"toDatepicker\"\n                [min]=\"from.value\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, to)\"\n                data-automation-id=\"date-range-to-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"toDatepicker\" data-automation-id=\"date-range-to-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #toDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"to.invalid\" data-automation-id=\"date-range-to-error\">\n            {{ getToValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <div class=\"adf-facet-buttons adf-facet-buttons--topSpace\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\" data-automation-id=\"date-range-clear-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\" data-automation-id=\"date-range-apply-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                ],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-date-range' },
                styles: [".adf-search-date-range>form{display:inline-flex;flex-direction:column;width:100%}"]
            }] }
];
/** @nocollapse */
SearchDateRangeComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchFilterService {
    constructor() {
        /**
         * Contains string-to-type mappings for registered widgets.
         */
        this.widgets = {
            'text': SearchTextComponent,
            'radio': SearchRadioComponent,
            'slider': SearchSliderComponent,
            'number-range': SearchNumberRangeComponent,
            'check-list': SearchCheckListComponent,
            'date-range': SearchDateRangeComponent
        };
    }
}
SearchFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ SearchFilterService.ngInjectableDef = defineInjectable({ factory: function SearchFilterService_Factory() { return new SearchFilterService(); }, token: SearchFilterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchChipListComponent {
    constructor() {
        /**
         * Flag used to enable the display of a clear-all-filters button.
         */
        this.clearAll = false;
    }
}
SearchChipListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-chip-list',
                template: "<mat-chip-list>\n    <ng-container *ngIf=\"searchFilter && searchFilter.selectedBuckets.length\">\n        <mat-chip *ngIf=\"clearAll && searchFilter.selectedBuckets.length > 1\"\n                  color=\"primary\"\n                  selected\n                  matTooltip=\"{{ 'SEARCH.FILTER.BUTTONS.CLEAR-ALL.TOOLTIP' | translate }}\"\n                  matTooltipPosition=\"right\"\n                  (click)=\"searchFilter.resetAllSelectedBuckets()\">\n            {{ 'SEARCH.FILTER.BUTTONS.CLEAR-ALL.LABEL' | translate }}\n        </mat-chip>\n\n        <mat-chip\n            *ngFor=\"let selection of searchFilter.selectedBuckets\"\n            [removable]=\"true\"\n            (removed)=\"searchFilter.unselectFacetBucket(selection.field, selection.bucket)\">\n            {{ (selection.bucket.display || selection.bucket.label) | translate }}\n            <mat-icon matChipRemove>cancel</mat-icon>\n        </mat-chip>\n    </ng-container>\n</mat-chip-list>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-chip-list' }
            }] }
];
SearchChipListComponent.propDecorators = {
    searchFilter: [{ type: Input }],
    clearAll: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchSortingPickerComponent {
    /**
     * @param {?} queryBuilder
     */
    constructor(queryBuilder) {
        this.queryBuilder = queryBuilder;
        this.options = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.options = this.queryBuilder.getSortingOptions();
        /** @type {?} */
        const primary = this.queryBuilder.getPrimarySorting();
        if (primary) {
            this.value = primary.key;
            this.ascending = primary.ascending;
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    onValueChanged(key) {
        this.value = key;
        this.ascending = this.getSortingOrder();
        this.applySorting();
    }
    /**
     * @param {?} ascending
     * @return {?}
     */
    onSortingChanged(ascending) {
        this.ascending = ascending;
        this.applySorting();
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    findOptionByKey(key) {
        if (key) {
            return this.options.find((/**
             * @param {?} opt
             * @return {?}
             */
            (opt) => opt.key === key));
        }
        return null;
    }
    /**
     * @private
     * @return {?}
     */
    applySorting() {
        /** @type {?} */
        const option = this.findOptionByKey(this.value);
        if (option) {
            this.queryBuilder.sorting = [Object.assign({}, option, { ascending: this.ascending })];
            this.queryBuilder.update();
        }
    }
    /**
     * @private
     * @return {?}
     */
    getSortingOrder() {
        /** @type {?} */
        const option = this.findOptionByKey(this.value);
        if (option) {
            return option.ascending;
        }
        return this.queryBuilder.getPrimarySorting().ascending;
    }
}
SearchSortingPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-sorting-picker',
                template: "<adf-sorting-picker\n    [options]=\"options\"\n    [selected]=\"value\"\n    [ascending]=\"ascending\"\n    (valueChange)=\"onValueChanged($event)\"\n    (sortingChange)=\"onSortingChanged($event)\">\n</adf-sorting-picker>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-sorting-picker' },
                styles: [""]
            }] }
];
/** @nocollapse */
SearchSortingPickerComponent.ctorParameters = () => [
    { type: SearchQueryBuilderService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchWidgetContainerComponent {
    /**
     * @param {?} searchFilterService
     * @param {?} queryBuilder
     * @param {?} componentFactoryResolver
     */
    constructor(searchFilterService, queryBuilder, componentFactoryResolver) {
        this.searchFilterService = searchFilterService;
        this.queryBuilder = queryBuilder;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const componentType = this.searchFilterService.widgets[this.selector];
        if (componentType) {
            /** @type {?} */
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
                this.setupWidget(this.componentRef);
            }
        }
    }
    /**
     * @private
     * @param {?} ref
     * @return {?}
     */
    setupWidget(ref) {
        if (ref && ref.instance) {
            ref.instance.id = this.id;
            ref.instance.settings = Object.assign({}, this.settings);
            ref.instance.context = this.queryBuilder;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
}
SearchWidgetContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-widget-container',
                template: '<div #content></div>'
            }] }
];
/** @nocollapse */
SearchWidgetContainerComponent.ctorParameters = () => [
    { type: SearchFilterService },
    { type: SearchQueryBuilderService },
    { type: ComponentFactoryResolver }
];
SearchWidgetContainerComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] }],
    id: [{ type: Input }],
    selector: [{ type: Input }],
    settings: [{ type: Input }],
    config: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ALFRESCO_SEARCH_DIRECTIVES = [
    SearchComponent,
    SearchControlComponent,
    SearchTriggerDirective,
    EmptySearchResultComponent,
    SearchFilterComponent,
    SearchChipListComponent
];
class SearchModule {
}
SearchModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CoreModule.forChild()
                ],
                declarations: [
                    ...ALFRESCO_SEARCH_DIRECTIVES,
                    SearchWidgetContainerComponent,
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchSliderComponent,
                    SearchNumberRangeComponent,
                    SearchCheckListComponent,
                    SearchDateRangeComponent,
                    SearchSortingPickerComponent
                ],
                exports: [
                    ...ALFRESCO_SEARCH_DIRECTIVES,
                    SearchWidgetContainerComponent,
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchSliderComponent,
                    SearchNumberRangeComponent,
                    SearchCheckListComponent,
                    SearchDateRangeComponent,
                    SearchSortingPickerComponent
                ],
                entryComponents: [
                    SearchWidgetContainerComponent,
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchSliderComponent,
                    SearchNumberRangeComponent,
                    SearchCheckListComponent,
                    SearchDateRangeComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const Relations = {
    Members: 'members',
    Containers: 'containers',
};
class DropdownSitesComponent {
    /**
     * @param {?} sitesService
     * @param {?} logService
     */
    constructor(sitesService, logService) {
        this.sitesService = sitesService;
        this.logService = logService;
        /**
         * Hide the "My Files" option.
         */
        this.hideMyFiles = false;
        /**
         * A custom list of sites to be displayed by the dropdown. If no value
         * is given, the sites of the current user are displayed by default. A
         * list of objects only with properties 'title' and 'guid' is enough to
         * be able to display the dropdown.
         */
        this.siteList = null;
        /**
         * Id of the selected site
         */
        this.value = null;
        /**
         * Text or a translation key to act as a placeholder. Default value is the
         * key "DROPDOWN.PLACEHOLDER_LABEL".
         */
        this.placeholder = 'DROPDOWN.PLACEHOLDER_LABEL';
        /**
         * Emitted when the user selects a site. When the default option is selected,
         * an empty model is emitted.
         */
        this.change = new EventEmitter();
        this.loading = true;
        this.skipCount = 0;
        this.MAX_ITEMS = 50;
        this.ITEM_HEIGHT = 45;
        this.ITEM_HEIGHT_TO_WAIT_BEFORE_LOAD_NEXT = (this.ITEM_HEIGHT * (this.MAX_ITEMS / 2));
        this.selected = null;
        this.MY_FILES_VALUE = '-my-';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.siteSelect.openedChange.subscribe((/**
         * @return {?}
         */
        () => {
            if (this.siteSelect.panelOpen) {
                this.siteSelect.panel.nativeElement.addEventListener('scroll', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => this.loadAllOnScroll(event)));
            }
        }));
        if (!this.siteList) {
            this.loadSiteList();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    loadAllOnScroll(event) {
        if (this.isInfiniteScrollingEnabled() && this.isScrollInNextFetchArea(event)) {
            this.loading = true;
            this.loadSiteList();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    isScrollInNextFetchArea(event) {
        return event.target.scrollTop >= (event.target.scrollHeight - event.target.offsetHeight - this.ITEM_HEIGHT_TO_WAIT_BEFORE_LOAD_NEXT);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    selectedSite(event) {
        this.change.emit(event.value);
    }
    /**
     * @private
     * @return {?}
     */
    loadSiteList() {
        /** @type {?} */
        const extendedOptions = {
            skipCount: this.skipCount,
            maxItems: this.MAX_ITEMS
        };
        this.skipCount += this.MAX_ITEMS;
        if (this.relations) {
            extendedOptions.relations = [this.relations];
        }
        this.sitesService.getSites(extendedOptions).subscribe((/**
         * @param {?} sitePaging
         * @return {?}
         */
        (sitePaging) => {
            if (!this.siteList) {
                this.siteList = this.relations === Relations.Members ? this.filteredResultsByMember(sitePaging) : sitePaging;
                if (!this.hideMyFiles) {
                    /** @type {?} */
                    const siteEntry = new SiteEntry({
                        entry: {
                            id: '-my-',
                            guid: '-my-',
                            title: 'DROPDOWN.MY_FILES_OPTION'
                        }
                    });
                    this.siteList.list.entries.unshift(siteEntry);
                    if (!this.value) {
                        this.value = '-my-';
                    }
                }
            }
            else {
                /** @type {?} */
                const siteList = this.relations === Relations.Members ? this.filteredResultsByMember(sitePaging) : sitePaging;
                this.siteList.list.entries = this.siteList.list.entries.concat(siteList.list.entries);
                this.siteList.list.pagination = sitePaging.list.pagination;
            }
            this.selected = this.siteList.list.entries.find((/**
             * @param {?} site
             * @return {?}
             */
            (site) => site.entry.id === this.value));
            this.loading = false;
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.logService.error(error);
        }));
    }
    /**
     * @return {?}
     */
    showLoading() {
        return this.loading && (this.siteList && this.siteList.list.pagination && this.siteList.list.pagination.hasMoreItems);
    }
    /**
     * @return {?}
     */
    isInfiniteScrollingEnabled() {
        return !this.loading && (this.siteList && this.siteList.list.pagination && this.siteList.list.pagination.hasMoreItems);
    }
    /**
     * @private
     * @param {?} sites
     * @return {?}
     */
    filteredResultsByMember(sites) {
        /** @type {?} */
        const loggedUserName = this.sitesService.getEcmCurrentLoggedUserName();
        sites.list.entries = sites.list.entries.filter((/**
         * @param {?} site
         * @return {?}
         */
        (site) => this.isCurrentUserMember(site, loggedUserName)));
        return sites;
    }
    /**
     * @private
     * @param {?} site
     * @param {?} loggedUserName
     * @return {?}
     */
    isCurrentUserMember(site, loggedUserName) {
        return site.entry.visibility === 'PUBLIC' ||
            !!site.relations.members.list.entries.find((/**
             * @param {?} member
             * @return {?}
             */
            (member) => {
                return member.entry.id.toLowerCase() === loggedUserName.toLowerCase();
            }));
    }
}
DropdownSitesComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sites-dropdown',
                template: "<div id=\"site-dropdown-container\" class=\"adf-site-dropdown-container\">\n    <mat-form-field>\n        <mat-select\n            #siteSelect\n            data-automation-id=\"site-my-files-option\"\n            class=\"adf-site-dropdown-list-element\"\n            id=\"site-dropdown\"\n            placeholder=\"{{placeholder | translate}}\"\n            floatPlaceholder=\"never\"\n            [(value)]=\"selected\"\n            (selectionChange)=\"selectedSite($event)\">\n            <mat-option *ngFor=\"let site of siteList?.list.entries;\" [value]=\"site\">\n                {{ site.entry.title | translate}}\n            </mat-option>\n            <mat-option *ngIf=\"showLoading()\" disabled=\"true\" data-automation-id=\"site-loading\">\n                {{ 'ADF_DROPDOWN.LOADING' | translate}}\n            </mat-option>\n        </mat-select>\n    </mat-form-field>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-sites-dropdown' },
                styles: [".adf-sites-dropdown.adf-full-width .mat-form-field{width:100%}"]
            }] }
];
/** @nocollapse */
DropdownSitesComponent.ctorParameters = () => [
    { type: SitesService },
    { type: LogService }
];
DropdownSitesComponent.propDecorators = {
    hideMyFiles: [{ type: Input }],
    siteList: [{ type: Input }],
    value: [{ type: Input }],
    placeholder: [{ type: Input }],
    relations: [{ type: Input }],
    change: [{ type: Output }],
    siteSelect: [{ type: ViewChild, args: ['siteSelect',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SitesDropdownModule {
}
SitesDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule.forChild()
                ],
                exports: [
                    DropdownSitesComponent
                ],
                declarations: [
                    DropdownSitesComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BreadcrumbComponent {
    constructor() {
        /**
         * Active node, builds UI based on folderNode.path.elements collection.
         */
        this.folderNode = null;
        /**
         * (optional) Name of the root element of the breadcrumb. You can use
         * this property to rename "Company Home" to "Personal Files" for
         * example. You can use an i18n resource key for the property value.
         */
        this.root = null;
        /**
         * (optional) The id of the root element. You can use this property
         * to set a custom element the breadcrumb should start with.
         */
        this.rootId = null;
        this.route = [];
        /**
         * Emitted when the user clicks on a breadcrumb.
         */
        this.navigate = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get hasRoot() {
        return !!this.root;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.transform = this.transform ? this.transform : null;
        if (this.target) {
            this.target.$folderNode.subscribe((/**
             * @param {?} folderNode
             * @return {?}
             */
            (folderNode) => {
                this.folderNode = folderNode;
                this.recalculateNodes();
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.recalculateNodes();
    }
    /**
     * @protected
     * @return {?}
     */
    recalculateNodes() {
        /** @type {?} */
        const node = this.transform ? this.transform(this.folderNode) : this.folderNode;
        this.route = this.parseRoute(node);
        if (this.maxItems && this.route.length > this.maxItems) {
            this.lastNodes = this.route.slice(this.route.length - this.maxItems);
            this.previousNodes = this.route.slice(0, this.route.length - this.maxItems);
            this.previousNodes.reverse();
        }
        else {
            this.lastNodes = this.route;
            this.previousNodes = null;
        }
    }
    /**
     * @return {?}
     */
    open() {
        if (this.dropdown) {
            this.dropdown.open();
        }
    }
    /**
     * @return {?}
     */
    hasPreviousNodes() {
        return this.previousNodes ? true : false;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    parseRoute(node) {
        if (node && node.path) {
            /** @type {?} */
            const route = (/** @type {?} */ ((node.path.elements || []).slice()));
            route.push((/** @type {?} */ ({
                id: node.id,
                name: node.name,
                node: node
            })));
            /** @type {?} */
            const rootPos = this.getElementPosition(route, this.rootId);
            if (rootPos > 0) {
                route.splice(0, rootPos);
            }
            if (rootPos === -1 && this.rootId) {
                route[0].id = this.rootId;
            }
            if (this.root) {
                route[0].name = this.root;
            }
            return route;
        }
        return [];
    }
    /**
     * @private
     * @param {?} route
     * @param {?} nodeId
     * @return {?}
     */
    getElementPosition(route, nodeId) {
        /** @type {?} */
        let position = -1;
        if (route && route.length > 0 && nodeId) {
            position = route.findIndex((/**
             * @param {?} el
             * @return {?}
             */
            (el) => el.id === nodeId));
        }
        return position;
    }
    /**
     * @param {?} route
     * @param {?=} event
     * @return {?}
     */
    onRoutePathClick(route, event) {
        if (event) {
            event.preventDefault();
        }
        if (route) {
            this.navigate.emit(route);
            if (this.target) {
                this.target.navigateTo(route.id);
            }
        }
    }
}
BreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-breadcrumb',
                template: "<nav *ngIf=\"folderNode\" data-automation-id=\"breadcrumb\" class=\"adf-breadcrumb-container\" role=\"list\">\n    <button\n        *ngIf=\"hasPreviousNodes()\"\n        tabindex=\"0\"\n        class=\"adf-breadcrumb-dropdown-trigger\"\n        (click)=\"open()\">\n        <div class=\"adf-breadcrumb-dropdown-trigger-icon\">\n            <mat-icon [class.adf-isRoot]=\"!hasPreviousNodes()\">folder</mat-icon>\n            <mat-icon [class.adf-isRoot]=\"!hasPreviousNodes()\" class=\"adf-breadcrumb-dropdown-trigger-arrow\">arrow_drop_down</mat-icon>\n        </div>\n    </button>\n\n    <mat-select\n        #dropdown\n        *ngIf=\"hasPreviousNodes()\"\n        class=\"adf-breadcrumb-dropdown-path\"\n        tabindex=\"0\">\n\n        <mat-option\n            *ngFor=\"let node of previousNodes;\"\n            (click)=\"onRoutePathClick(node, $event)\"\n            class=\"adf-breadcrumb-path-option\"\n            tabindex=\"0\">\n            {{ node.name | translate }}\n        </mat-option>\n    </mat-select>\n\n    <div *ngFor=\"let item of lastNodes; let last = last\"\n        [class.adf-active]=\"last\"\n        [ngSwitch]=\"last\"\n        title=\"{{ item.name | translate }}\"\n        class=\"adf-breadcrumb-item\"\n        role=\"listitem\">\n\n        <a *ngSwitchDefault href=\"#\" [attr.data-automation-id]=\"'breadcrumb_' + item.name\"\n            class=\"adf-breadcrumb-item-anchor\"\n            (click)=\"onRoutePathClick(item, $event)\">\n            {{ item.name | translate }}\n        </a>\n\n        <div *ngSwitchCase=\"true\" class=\"adf-breadcrumb-item-current\">\n            {{ item.name | translate }}\n        </div>\n\n        <mat-icon class=\"adf-breadcrumb-item-chevron\" *ngIf=\"!last\">\n            chevron_right\n        </mat-icon>\n    </div>\n</nav>\n\n<nav *ngIf=\"!folderNode && hasRoot\" data-automation-id=\"breadcrumb\" role=\"navigation\">\n    <div class=\"adf-breadcrumb-item adf-active\" role=\"listitem\">\n        <div class=\"adf-breadcrumb-item-current\">\n            {{ root | translate }}\n        </div>\n    </div>\n</nav>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-breadcrumb'
                },
                styles: [""]
            }] }
];
BreadcrumbComponent.propDecorators = {
    folderNode: [{ type: Input }],
    root: [{ type: Input }],
    rootId: [{ type: Input }],
    target: [{ type: Input }],
    transform: [{ type: Input }],
    dropdown: [{ type: ViewChild, args: ['dropdown',] }],
    maxItems: [{ type: Input }],
    navigate: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DropdownBreadcrumbComponent extends BreadcrumbComponent {
    /**
     * Calculate the current and previous nodes from the route array
     * @protected
     * @return {?}
     */
    recalculateNodes() {
        /** @type {?} */
        const node = this.transform ? this.transform(this.folderNode) : this.folderNode;
        this.route = this.parseRoute(node);
        this.currentNode = this.route[this.route.length - 1];
        this.previousNodes = this.route.slice(0, this.route.length - 1).reverse();
    }
    /**
     * Opens the node picker menu
     * @return {?}
     */
    open() {
        if (this.dropdown) {
            this.dropdown.open();
        }
    }
    /**
     * Return if route has more than one element (means: we are not in the root directory)
     * @return {?}
     */
    hasPreviousNodes() {
        return this.previousNodes.length > 0;
    }
}
DropdownBreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-breadcrumb',
                template: "<ng-container *ngIf=\"route.length > 0\" class=\"adf-dropdown-breadcrumb-container\">\n\n    <button\n        tabindex=\"0\"\n        class=\"adf-dropdown-breadcrumb-trigger\"\n        (click)=\"open()\"\n        data-automation-id=\"dropdown-breadcrumb-trigger\">\n        <mat-icon [class.adf-isRoot]=\"!hasPreviousNodes()\">folder</mat-icon>\n    </button>\n\n    <mat-icon class=\"adf-dropdown-breadcrumb-item-chevron\">chevron_right</mat-icon>\n\n    <div class=\"adf-dropdown-breadcrumb-path\">\n        <mat-select\n            #dropdown\n            *ngIf=\"hasPreviousNodes()\"\n            tabindex=\"0\"\n            data-automation-id=\"dropdown-breadcrumb-path\">\n\n            <mat-option\n                *ngFor=\"let node of previousNodes;\"\n                (click)=\"onRoutePathClick(node, $event)\"\n                class=\"adf-dropdown-breadcrumb-path-option\"\n                tabindex=\"0\"\n                data-automation-class=\"dropdown-breadcrumb-path-option\">\n                {{ node.name | translate }}\n            </mat-option>\n        </mat-select>\n    </div>\n\n    <span\n        class=\"adf-current-folder\"\n        [class.adf-isRoot]=\"!hasPreviousNodes()\"\n        data-automation-id=\"current-folder\">{{ currentNode.name }}\n    </span>\n</ng-container>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-dropdown-breadcrumb'
                },
                styles: [""]
            }] }
];
DropdownBreadcrumbComponent.propDecorators = {
    dropdown: [{ type: ViewChild, args: ['dropdown',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BreadcrumbModule {
}
BreadcrumbModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule.forChild()
                ],
                exports: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ],
                declarations: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ConfirmDialogComponent {
    /**
     * @param {?} data
     * @param {?} sanitizer
     */
    constructor(data, sanitizer) {
        this.sanitizer = sanitizer;
        data = data || {};
        this.title = data.title || 'ADF_CONFIRM_DIALOG.CONFIRM';
        this.message = data.message || 'ADF_CONFIRM_DIALOG.MESSAGE';
        this.yesLabel = data.yesLabel || 'ADF_CONFIRM_DIALOG.YES_LABEL';
        this.thirdOptionLabel = data.thirdOptionLabel;
        this.noLabel = data.noLabel || 'ADF_CONFIRM_DIALOG.NO_LABEL';
        this.htmlContent = data.htmlContent;
    }
    /**
     * @return {?}
     */
    sanitizedHtmlContent() {
        return this.sanitizer.sanitize(SecurityContext.HTML, this.htmlContent);
    }
}
ConfirmDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-confirm-dialog',
                template: "<h1 mat-dialog-title data-automation-id=\"adf-confirm-dialog-title\">{{ title | translate }}</h1>\n<mat-dialog-content>\n    <p *ngIf=\"!htmlContent; else cutomContent\" data-automation-id=\"adf-confirm-dialog-base-message\">\n        {{ message | translate }}\n    </p>\n    <ng-template #cutomContent>\n        <span [innerHTML]=\"sanitizedHtmlContent()\" data-automation-id=\"adf-confirm-dialog-custom-content\">\n        </span>\n    </ng-template>\n</mat-dialog-content>\n<mat-dialog-actions>\n    <span class=\"adf-dialog-spacer\" data-automation-id=\"adf-confirm-dialog-spacer\"></span>\n    <button id=\"adf-confirm-accept\" mat-button color=\"primary\" data-automation-id=\"adf-confirm-dialog-confirmation\"\n        [mat-dialog-close]=\"true\">{{ yesLabel | translate }}</button>\n    <button id=\"adf-confirm-all\" mat-button *ngIf=\"thirdOptionLabel\" [mat-dialog-close]=\"thirdOptionLabel\" data-automation-id=\"adf-confirm-dialog-confirm-all\">{{ thirdOptionLabel | translate }}</button>\n    <button id=\"adf-confirm-cancel\" mat-button [mat-dialog-close]=\"false\" data-automation-id=\"adf-confirm-dialog-reject\"\n        cdkFocusInitial>{{ noLabel | translate }}</button>\n</mat-dialog-actions>\n",
                host: { 'class': 'adf-confirm-dialog' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-dialog-spacer{flex:1 1 auto}.adf-confirm-dialog .mat-dialog-actions .mat-button-wrapper{text-transform:uppercase}"]
            }] }
];
/** @nocollapse */
ConfirmDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: DomSanitizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VersionListComponent {
    /**
     * @param {?} alfrescoApi
     * @param {?} contentService
     * @param {?} dialog
     */
    constructor(alfrescoApi, contentService, dialog) {
        this.alfrescoApi = alfrescoApi;
        this.contentService = contentService;
        this.dialog = dialog;
        this.versions = [];
        this.isLoading = true;
        /**
         * Toggles showing/hiding of comments
         */
        this.showComments = true;
        /**
         * Enable/disable downloading a version of the current node.
         */
        this.allowDownload = true;
        /**
         * Toggles showing/hiding of version actions
         */
        this.showActions = true;
        /**
         * Emitted when a version is restored
         */
        this.restored = new EventEmitter();
        /**
         * Emitted when a version is deleted
         */
        this.deleted = new EventEmitter();
        this.versionsApi = this.alfrescoApi.versionsApi;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.loadVersionHistory();
    }
    /**
     * @return {?}
     */
    canUpdate() {
        return this.contentService.hasAllowableOperations(this.node, 'update') && this.versions.length > 1;
    }
    /**
     * @return {?}
     */
    canDelete() {
        return this.contentService.hasAllowableOperations(this.node, 'delete') && this.versions.length > 1;
    }
    /**
     * @param {?} versionId
     * @return {?}
     */
    restore(versionId) {
        if (this.canUpdate()) {
            this.versionsApi
                .revertVersion(this.node.id, versionId, { majorVersion: true, comment: '' })
                .then((/**
             * @return {?}
             */
            () => this.alfrescoApi.nodesApi.getNodeInfo(this.node.id, { include: ['permissions', 'path', 'isFavorite', 'allowableOperations'] })))
                .then((/**
             * @param {?} node
             * @return {?}
             */
            (node) => this.onVersionRestored(node)));
        }
    }
    /**
     * @return {?}
     */
    loadVersionHistory() {
        this.isLoading = true;
        this.versionsApi.listVersionHistory(this.node.id).then((/**
         * @param {?} versionPaging
         * @return {?}
         */
        (versionPaging) => {
            this.versions = versionPaging.list.entries;
            this.isLoading = false;
        }));
    }
    /**
     * @param {?} versionId
     * @return {?}
     */
    downloadVersion(versionId) {
        if (this.allowDownload) {
            /** @type {?} */
            const versionDownloadUrl = this.getVersionContentUrl(this.node.id, versionId, true);
            this.downloadContent(versionDownloadUrl);
        }
    }
    /**
     * @param {?} versionId
     * @return {?}
     */
    deleteVersion(versionId) {
        if (this.canUpdate()) {
            /** @type {?} */
            const dialogRef = this.dialog.open(ConfirmDialogComponent, {
                data: {
                    title: 'ADF_VERSION_LIST.CONFIRM_DELETE.TITLE',
                    message: 'ADF_VERSION_LIST.CONFIRM_DELETE.MESSAGE',
                    yesLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.YES_LABEL',
                    noLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.NO_LABEL'
                },
                minWidth: '250px'
            });
            dialogRef.afterClosed().subscribe((/**
             * @param {?} result
             * @return {?}
             */
            (result) => {
                if (result === true) {
                    this.alfrescoApi.versionsApi
                        .deleteVersion(this.node.id, versionId)
                        .then((/**
                     * @return {?}
                     */
                    () => this.onVersionDeleted(this.node)));
                }
            }));
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onVersionDeleted(node) {
        this.loadVersionHistory();
        this.deleted.emit(node);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onVersionRestored(node) {
        this.loadVersionHistory();
        this.restored.emit(node);
    }
    /**
     * @private
     * @param {?} nodeId
     * @param {?} versionId
     * @param {?=} attachment
     * @return {?}
     */
    getVersionContentUrl(nodeId, versionId, attachment) {
        /** @type {?} */
        const nodeDownloadUrl = this.alfrescoApi.contentApi.getContentUrl(nodeId, attachment);
        return nodeDownloadUrl.replace('/content', '/versions/' + versionId + '/content');
    }
    /**
     * @param {?} url
     * @return {?}
     */
    downloadContent(url) {
        if (url) {
            /** @type {?} */
            const link = document.createElement('a');
            link.style.display = 'none';
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
}
VersionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-list',
                template: "<mat-list class=\"adf-version-list\" *ngIf=\"!isLoading; else loading_template\">\n    <mat-list-item *ngFor=\"let version of versions; let idx = index\">\n        <mat-icon mat-list-icon>insert_drive_file</mat-icon>\n        <h4 mat-line class=\"adf-version-list-item-name\" [id]=\"'adf-version-list-item-name-' + version.entry.id\" >{{version.entry.name}}</h4>\n        <p mat-line>\n            <span class=\"adf-version-list-item-version\"  [id]=\"'adf-version-list-item-version-' + version.entry.id\" >{{version.entry.id}}</span> -\n            <span class=\"adf-version-list-item-date\"     [id]=\"'adf-version-list-item-date-' + version.entry.id\" >{{version.entry.modifiedAt | date}}</span>\n        </p>\n        <p mat-line [id]=\"'adf-version-list-item-comment-'+ version.entry.id\" class=\"adf-version-list-item-comment\"\n           *ngIf=\"showComments\">{{version.entry.versionComment}}</p>\n\n        <div *ngIf=\"showActions\">\n            <mat-menu [id]=\"'adf-version-list-action-menu-'+version.entry.id\"\n                      #versionMenu=\"matMenu\" yPosition=\"below\" xPosition=\"before\">\n                <button\n                    [id]=\"'adf-version-list-action-restore-'+version.entry.id\"\n                    [disabled]=\"!canUpdate()\"\n                    mat-menu-item\n                    (click)=\"restore(version.entry.id)\">\n                    {{ 'ADF_VERSION_LIST.ACTIONS.RESTORE' | translate }}\n                </button>\n                <button *ngIf=\"allowDownload\"\n                        [id]=\"'adf-version-list-action-download-'+version.entry.id\"\n                        mat-menu-item\n                        (click)=\"downloadVersion(version.entry.id)\">\n                    {{ 'ADF_VERSION_LIST.ACTIONS.DOWNLOAD' | translate }}\n                </button>\n                <button\n                    [disabled]=\"!canDelete()\"\n                    [id]=\"'adf-version-list-action-delete-'+version.entry.id\"\n                    (click)=\"deleteVersion(version.entry.id)\"\n                    mat-menu-item>\n                    {{ 'ADF_VERSION_LIST.ACTIONS.DELETE' | translate }}\n                </button>\n            </mat-menu>\n\n            <button mat-icon-button [matMenuTriggerFor]=\"versionMenu\" [id]=\"'adf-version-list-action-menu-button-'+version.entry.id\">\n                <mat-icon>more_vert</mat-icon>\n            </button>\n        </div>\n    </mat-list-item>\n</mat-list>\n\n<ng-template #loading_template>\n    <mat-progress-bar data-automation-id=\"version-history-loading-bar\" mode=\"indeterminate\"\n                      color=\"accent\"></mat-progress-bar>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-version-list'
                },
                styles: [".adf-version-list .mat-list-item-content{border-bottom:1px solid #d8d8d8}.adf-version-list-item-version{font-weight:700}.adf-version-list-item-date{opacity:.6}.adf-version-list-item-comment{opacity:.5}"]
            }] }
];
/** @nocollapse */
VersionListComponent.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: ContentService },
    { type: MatDialog }
];
VersionListComponent.propDecorators = {
    node: [{ type: Input }],
    showComments: [{ type: Input }],
    allowDownload: [{ type: Input }],
    showActions: [{ type: Input }],
    restored: [{ type: Output }],
    deleted: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VersionManagerComponent {
    /**
     * @param {?} config
     * @param {?} contentService
     * @param {?} alfrescoApiService
     */
    constructor(config, contentService, alfrescoApiService) {
        this.contentService = contentService;
        this.alfrescoApiService = alfrescoApiService;
        /**
         * Toggles showing/hiding of comments.
         */
        this.showComments = true;
        /**
         * Enable/disable downloading a version of the current node.
         */
        this.allowDownload = true;
        /**
         * Emitted when a file is uploaded successfully.
         */
        this.uploadSuccess = new EventEmitter();
        /**
         * Emitted when an error occurs during upload.
         */
        this.uploadError = new EventEmitter();
        this.uploadState = 'close';
    }
    /**
     * @param {?} node
     * @return {?}
     */
    refresh(node) {
        this.alfrescoApiService.nodeUpdated.next(node);
        this.versionListComponent.loadVersionHistory();
        this.uploadSuccess.emit(node);
        this.uploadState = 'close';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onUploadSuccess(event) {
        this.alfrescoApiService.nodeUpdated.next(event.value.entry);
        this.versionListComponent.loadVersionHistory();
        this.uploadSuccess.emit(event.value.entry);
        this.uploadState = 'close';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onUploadError(event) {
        this.uploadError.emit(event);
    }
    /**
     * @return {?}
     */
    onUploadCancel() {
        this.uploadState = 'close';
    }
    /**
     * @return {?}
     */
    toggleNewVersion() {
        this.uploadState = this.uploadState === 'open' ? 'close' : 'open';
    }
    /**
     * @return {?}
     */
    canUpdate() {
        return this.contentService.hasAllowableOperations(this.node, 'update');
    }
}
VersionManagerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-manager',
                template: "<div class=\"adf-new-version-container\">\n    <div class=\"adf-new-version-uploader-container\" id=\"adf-new-version-uploader-container\" fxLayout=\"row\" fxLayoutAlign=\"end center\" [@uploadToggle]=\"uploadState\">\n        <table class=\"adf-version-upload\" *ngIf=\"uploadState !== 'close'\">\n            <tr>\n                <td>\n                    <adf-version-upload\n                        id=\"adf-version-upload-button\"\n                        [node]=\"node\"\n                        (success)=\"onUploadSuccess($event)\"\n                        (cancel)=\"onUploadCancel()\"\n                        (error)=\"onUploadError($event)\">\n                    </adf-version-upload>\n                </td>\n            </tr>\n        </table>\n    </div>\n\n    <div class=\"adf-version-list-container\">\n        <div class=\"adf-version-list-table\">\n            <div>\n                <button mat-raised-button\n                        id=\"adf-show-version-upload-button\"\n                        (click)=\"toggleNewVersion()\" color=\"primary\"\n                        *ngIf=\"uploadState ==='close'\">{{\n                    'ADF_VERSION_LIST.ACTIONS.UPLOAD.ADD'|\n                    translate }}\n                </button>\n            </div>\n            <div>\n\n                <adf-version-list\n                    #versionList\n                    [node]=\"node\"\n                    [allowDownload]=\"allowDownload\"\n                    [showComments]=\"showComments\"\n                    (deleted)=\"refresh($event)\"\n                    (restored)=\"refresh($event)\">\n                </adf-version-list>\n            </div>\n        </div>\n    </div>\n</div>\n",
                animations: [
                    trigger('uploadToggle', [
                        state('open', style({ height: '175px', opacity: 1, visibility: 'visible' })),
                        state('close', style({ height: '0%', opacity: 0, visibility: 'hidden' })),
                        transition('open => close', [
                            style({ visibility: 'hidden' }),
                            animate('0.4s cubic-bezier(0.25, 0.8, 0.25, 1)')
                        ]),
                        transition('close => open', [
                            style({ visibility: 'visible' }),
                            animate('0.4s cubic-bezier(0.25, 0.8, 0.25, 1)')
                        ])
                    ])
                ],
                encapsulation: ViewEncapsulation.None,
                styles: ["adf-version-manager .mat-list .mat-3-line{height:auto!important;width:100%!important}adf-version-manager .mat-list-item-content{padding:16px 0!important}.adf-version-list-item-comment.mat-line{height:100%;word-break:break-all;white-space:unset!important;overflow:unset!important}.adf-button.adf-upload-new-version{box-shadow:none;width:100%;height:175px;float:left;position:relative}.adf-new-version-uploader-container{padding:16px 0;width:100%;height:0%;position:relative;float:left!important}.adf-new-version-container{height:inherit;overflow:hidden}.adf-version-list-table,.adf-version-upload-table{width:100%}.adf-version-list{width:100%!important;float:left!important}"]
            }] }
];
/** @nocollapse */
VersionManagerComponent.ctorParameters = () => [
    { type: AppConfigService },
    { type: ContentService },
    { type: AlfrescoApiService }
];
VersionManagerComponent.propDecorators = {
    node: [{ type: Input }],
    showComments: [{ type: Input }],
    allowDownload: [{ type: Input }],
    uploadSuccess: [{ type: Output }],
    uploadError: [{ type: Output }],
    versionListComponent: [{ type: ViewChild, args: ['versionList',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VersionUploadComponent {
    /**
     * @param {?} contentService
     */
    constructor(contentService) {
        this.contentService = contentService;
        this.semanticVersion = 'minor';
        this.uploadVersion = false;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.cancel = new EventEmitter();
    }
    /**
     * @return {?}
     */
    canUpload() {
        return this.contentService.hasAllowableOperations(this.node, 'update');
    }
    /**
     * @return {?}
     */
    isMajorVersion() {
        return this.semanticVersion === 'minor' ? false : true;
    }
    /**
     * @return {?}
     */
    cancelUpload() {
        this.cancel.emit();
    }
}
VersionUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-upload',
                template: "<div class=\"adf-new-version-max-width\">\n    <mat-radio-group class=\"adf-new-version-radio-group\" [(ngModel)]=\"semanticVersion\">\n        <mat-radio-button class=\"adf-new-version-radio-button\" id=\"adf-new-version-minor\"[value]=\"'minor'\">{{\n            'ADF_VERSION_LIST.ACTIONS.UPLOAD.MINOR' |\n            translate }}\n        </mat-radio-button>\n        <mat-radio-button class=\"adf-new-version-radio-button\" id=\"adf-new-version-major\" [value]=\"'major'\">{{\n            'ADF_VERSION_LIST.ACTIONS.UPLOAD.MAJOR' |\n            translate }}\n        </mat-radio-button>\n    </mat-radio-group>\n    <mat-form-field class=\"adf-new-version-max-width\">\n                    <textarea matInput [(ngModel)]=\"comment\" class=\"adf-new-version-text-area\" id=\"adf-new-version-text-area\"\n                              placeholder=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.COMMENT' | translate }}\"></textarea>\n    </mat-form-field>\n\n</div>\n<div class=\"adf-version-upload-buttons\">\n    <adf-upload-version-button\n        data-automation-id=\"adf-new-version-file-upload\"\n        staticTitle=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TITLE' | translate }}\"\n        [node]=\"node\"\n        [disabled]=\"!canUpload()\"\n        [rootFolderId]=\"node.parentId\"\n        tooltip=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TOOLTIP' | translate }}\"\n        [comment]=\"comment\"\n        [versioning]=\"true\"\n        [majorVersion]=\"isMajorVersion()\"\n        (success)=\"success.emit($event)\"\n        (error)=\"error.emit($event)\">\n    </adf-upload-version-button>\n    <button mat-raised-button (click)=\"cancelUpload()\" id=\"adf-new-version-cancel\"  >{{\n        'ADF_VERSION_LIST.ACTIONS.UPLOAD.CANCEL'| translate }}\n    </button>\n</div>\n\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-version-upload' },
                styles: [".adf-new-version-radio-group{display:inline-flex;flex-direction:column}.adf-new-version-radio-button{margin:5px}.adf-version-upload-buttons{display:flex;float:right;justify-content:space-between;width:100%}.adf-new-version-max-width{width:100%;float:right}.adf-new-version-text-area{resize:none!important}"]
            }] }
];
/** @nocollapse */
VersionUploadComponent.ctorParameters = () => [
    { type: ContentService }
];
VersionUploadComponent.propDecorators = {
    node: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    cancel: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VersionManagerModule {
}
VersionManagerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule.forChild(),
                    UploadModule,
                    FormsModule
                ],
                exports: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent,
                    FormsModule
                ],
                declarations: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NameLocationCellComponent {
    constructor() {
        this.name = '';
        this.path = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.row) {
            this.name = this.row.getValue('name');
            /** @type {?} */
            const fullPath = this.row.getValue('path');
            if (fullPath) {
                this.path = fullPath.name || '';
            }
        }
    }
}
NameLocationCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-name-location-cell',
                template: `
        <div class="adf-name-location-cell-name adf-datatable-cell-value">{{ name }}</div>
        <div class="adf-name-location-cell-location adf-datatable-cell-value" [title]="path">{{ path }}</div>
    `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-name-location-cell adf-datatable-content-cell' },
                styles: [""]
            }] }
];
NameLocationCellComponent.propDecorators = {
    row: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal service used by ContentNodeSelector component.
 */
class ContentNodeSelectorService {
    /**
     * @param {?} searchService
     */
    constructor(searchService) {
        this.searchService = searchService;
    }
    /**
     * Performs a search for content node selection
     *
     * @param {?} searchTerm    The term to search for
     * @param {?=} rootNodeId    The root is to start the search from
     * @param {?=} skipCount     From where to start the loading
     * @param {?=} maxItems      How many items to load
     * @param {?=} extraNodeIds
     * @return {?}
     */
    search(searchTerm, rootNodeId = null, skipCount = 0, maxItems = 25, extraNodeIds) {
        /** @type {?} */
        let extraParentFiltering = '';
        if (extraNodeIds && extraNodeIds.length) {
            extraNodeIds
                .filter((/**
             * @param {?} id
             * @return {?}
             */
            (id) => id !== rootNodeId))
                .forEach((/**
             * @param {?} extraId
             * @return {?}
             */
            (extraId) => {
                extraParentFiltering += ` OR ANCESTOR:'workspace://SpacesStore/${extraId}'`;
            }));
        }
        /** @type {?} */
        const parentFiltering = rootNodeId ? [{ query: `ANCESTOR:'workspace://SpacesStore/${rootNodeId}'${extraParentFiltering}` }] : [];
        /** @type {?} */
        const defaultSearchNode = {
            query: {
                query: `${searchTerm}* OR name:${searchTerm}*`
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: maxItems,
                skipCount: skipCount
            },
            filterQueries: [
                { query: "TYPE:'cm:folder'" },
                { query: 'NOT cm:creator:System' },
                ...parentFiltering
            ],
            scope: {
                locations: ['nodes']
            }
        };
        return this.searchService.searchByQueryBody(defaultSearchNode);
    }
}
ContentNodeSelectorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ContentNodeSelectorService.ctorParameters = () => [
    { type: SearchService }
];
/** @nocollapse */ ContentNodeSelectorService.ngInjectableDef = defineInjectable({ factory: function ContentNodeSelectorService_Factory() { return new ContentNodeSelectorService(inject(SearchService)); }, token: ContentNodeSelectorService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultValidation = (/**
 * @return {?}
 */
() => true);
class ContentNodeSelectorPanelComponent {
    /**
     * @param {?} contentNodeSelectorService
     * @param {?} customResourcesService
     * @param {?} userPreferencesService
     */
    constructor(contentNodeSelectorService, customResourcesService, userPreferencesService) {
        this.contentNodeSelectorService = contentNodeSelectorService;
        this.customResourcesService = customResourcesService;
        this.userPreferencesService = userPreferencesService;
        this.DEFAULT_PAGINATION = new Pagination({
            maxItems: 25,
            skipCount: 0,
            totalItems: 0,
            hasMoreItems: false
        });
        /**
         * Node ID of the folder currently listed.
         */
        this.currentFolderId = null;
        /**
         * Hide the "My Files" option added to the site list by default.
         * See the [Sites Dropdown component](sites-dropdown.component.md)
         * for more information.
         */
        this.dropdownHideMyFiles = false;
        /**
         * Custom site for site dropdown. This is the same as the `siteList`.
         * property of the Sites Dropdown component (see its doc page
         * for more information).
         */
        this.dropdownSiteList = null;
        this._rowFilter = defaultValidation;
        this._excludeSiteContent = [];
        /**
         * Custom image resolver function. See the
         * [Image Resolver Model](image-resolver.model.md) page
         * for more information.
         */
        this.imageResolver = null;
        /**
         * Number of items shown per page in the list.
         */
        this.pageSize = this.DEFAULT_PAGINATION.maxItems;
        /**
         * Function used to decide if the selected node has permission to be selected.
         * Default value is a function that always returns true.
         */
        this.isSelectionValid = defaultValidation;
        /**
         * Emitted when the user has chosen an item.
         */
        this.select = new EventEmitter();
        this.nodePaging = null;
        this.searchTerm = '';
        this.showingSearchResults = false;
        this.loadingSearchResults = false;
        this.inDialog = false;
        this._chosenNode = null;
        this.folderIdToShow = null;
        this.breadcrumbFolderTitle = null;
        this.pagination = this.DEFAULT_PAGINATION;
        this.infiniteScroll = false;
        this.debounceSearch = 200;
        this.searchInput = new FormControl();
        this.searchInput.valueChanges
            .pipe(debounceTime(this.debounceSearch))
            .subscribe((/**
         * @param {?} searchValue
         * @return {?}
         */
        (searchValue) => {
            this.search(searchValue);
        }));
        this.userPreferencesService.select(UserPreferenceValues.PaginationSize).subscribe((/**
         * @param {?} pagSize
         * @return {?}
         */
        (pagSize) => {
            this.pageSize = pagSize;
        }));
    }
    /**
     * Custom row filter function. See the
     * [Row Filter Model](row-filter.model.md) page
     * for more information.
     * @param {?} rowFilter
     * @return {?}
     */
    set rowFilter(rowFilter) {
        this.createRowFilter(rowFilter);
    }
    /**
     * @return {?}
     */
    get rowFilter() {
        return this._rowFilter;
    }
    /**
     * Custom list of site content componentIds.
     * Used to filter out the corresponding items from the displayed nodes
     * @param {?} excludeSiteContent
     * @return {?}
     */
    set excludeSiteContent(excludeSiteContent) {
        this._excludeSiteContent = excludeSiteContent;
        this.createRowFilter(this._rowFilter);
    }
    /**
     * @return {?}
     */
    get excludeSiteContent() {
        return this._excludeSiteContent;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set chosenNode(value) {
        this._chosenNode = value;
        /** @type {?} */
        let valuesArray = null;
        if (value) {
            valuesArray = [value];
        }
        this.select.next(valuesArray);
    }
    /**
     * @return {?}
     */
    get chosenNode() {
        return this._chosenNode;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.target = this.documentList;
        this.folderIdToShow = this.currentFolderId;
        this.breadcrumbTransform = this.breadcrumbTransform ? this.breadcrumbTransform : null;
        this.isSelectionValid = this.isSelectionValid ? this.isSelectionValid : defaultValidation;
    }
    /**
     * @private
     * @param {?=} filter
     * @return {?}
     */
    createRowFilter(filter$$1) {
        if (!filter$$1) {
            filter$$1 = (/**
             * @return {?}
             */
            () => true);
        }
        this._rowFilter = (/**
         * @param {?} value
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        (value, index, array) => {
            return filter$$1(value, index, array) &&
                !this.isExcludedSiteContent(value);
        });
    }
    /**
     * @private
     * @param {?} row
     * @return {?}
     */
    isExcludedSiteContent(row) {
        /** @type {?} */
        const entry = row.node.entry;
        if (this._excludeSiteContent && this._excludeSiteContent.length &&
            entry &&
            entry.properties &&
            entry.properties['st:componentId']) {
            /** @type {?} */
            const excludedItem = this._excludeSiteContent.find((/**
             * @param {?} id
             * @return {?}
             */
            (id) => entry.properties['st:componentId'] === id));
            return !!excludedItem;
        }
        return false;
    }
    /**
     * Updates the site attribute and starts a new search
     *
     * @param {?} chosenSite SiteEntry to search within
     * @return {?}
     */
    siteChanged(chosenSite) {
        this.siteId = chosenSite.entry.guid;
        this.setTitleIfCustomSite(chosenSite);
        this.updateResults();
    }
    /**
     * Updates the searchTerm attribute and starts a new search
     *
     * @param {?} searchTerm string value to search against
     * @return {?}
     */
    search(searchTerm) {
        this.searchTerm = searchTerm;
        this.updateResults();
    }
    /**
     * Returns the actually selected|entered folder node or null in case of searching for the breadcrumb
     * @return {?}
     */
    get breadcrumbFolderNode() {
        /** @type {?} */
        let folderNode;
        if (this.showingSearchResults && this.chosenNode) {
            folderNode = this.chosenNode;
        }
        else {
            folderNode = this.documentList.folderNode;
        }
        return folderNode;
    }
    /**
     * Clear the search input and reset to last folder node in which search was performed
     * @return {?}
     */
    clear() {
        this.clearSearch();
        this.folderIdToShow = this.siteId || this.currentFolderId;
    }
    /**
     * Clear the search input and search related data
     * @return {?}
     */
    clearSearch() {
        this.searchTerm = '';
        this.nodePaging = null;
        this.pagination.maxItems = this.pageSize;
        this.chosenNode = null;
        this.showingSearchResults = false;
    }
    /**
     * Update the result list depending on the criteria
     * @private
     * @return {?}
     */
    updateResults() {
        this.target = this.searchTerm.length > 0 ? null : this.documentList;
        if (this.searchTerm.length === 0) {
            this.clear();
        }
        else {
            this.startNewSearch();
        }
    }
    /**
     * Load the first page of a new search result
     * @private
     * @return {?}
     */
    startNewSearch() {
        this.nodePaging = null;
        this.pagination.maxItems = this.pageSize;
        if (this.target) {
            this.infinitePaginationComponent.reset();
        }
        this.chosenNode = null;
        this.folderIdToShow = null;
        this.querySearch();
    }
    /**
     * Perform the call to searchService with the proper parameters
     * @private
     * @return {?}
     */
    querySearch() {
        this.loadingSearchResults = true;
        if (this.customResourcesService.hasCorrespondingNodeIds(this.siteId)) {
            this.customResourcesService.getCorrespondingNodeIds(this.siteId)
                .subscribe((/**
             * @param {?} nodeIds
             * @return {?}
             */
            (nodeIds) => {
                this.contentNodeSelectorService.search(this.searchTerm, this.siteId, this.pagination.skipCount, this.pagination.maxItems, nodeIds)
                    .subscribe(this.showSearchResults.bind(this));
            }), (/**
             * @return {?}
             */
            () => {
                this.showSearchResults({ list: { entries: [] } });
            }));
        }
        else {
            this.contentNodeSelectorService.search(this.searchTerm, this.siteId, this.pagination.skipCount, this.pagination.maxItems)
                .subscribe(this.showSearchResults.bind(this));
        }
    }
    /**
     * Show the results of the search
     *
     * @private
     * @param {?} nodePaging
     * @return {?}
     */
    showSearchResults(nodePaging) {
        this.showingSearchResults = true;
        this.loadingSearchResults = false;
        this.nodePaging = nodePaging;
    }
    /**
     * Sets showingSearchResults state to be able to differentiate between search results or folder results
     * @return {?}
     */
    onFolderChange() {
        this.showingSearchResults = false;
        this.infiniteScroll = false;
        this.clearSearch();
    }
    /**
     * Attempts to set the currently loaded node
     * @return {?}
     */
    onFolderLoaded() {
        if (!this.showingSearchResults) {
            this.attemptNodeSelection(this.documentList.folderNode);
        }
    }
    /**
     * Returns whether breadcrumb has to be shown or not
     * @return {?}
     */
    showBreadcrumbs() {
        return !this.showingSearchResults || this.chosenNode;
    }
    /**
     * Loads the next batch of search results
     *
     * @param {?} pagination
     * @return {?}
     */
    getNextPageOfSearch(pagination) {
        this.infiniteScroll = true;
        this.pagination = pagination;
        if (this.searchTerm.length > 0) {
            this.querySearch();
        }
    }
    /**
     * Selects node as chosen if it has the right permission, clears the selection otherwise
     *
     * @private
     * @param {?} entry
     * @return {?}
     */
    attemptNodeSelection(entry) {
        if (entry && this.isSelectionValid(entry)) {
            this.chosenNode = entry;
        }
        else {
            this.resetChosenNode();
        }
    }
    /**
     * Clears the chosen node
     * @return {?}
     */
    resetChosenNode() {
        this.chosenNode = null;
    }
    /**
     * Invoked when user selects a node
     *
     * @param {?} event CustomEvent for node-select
     * @return {?}
     */
    onNodeSelect(event) {
        this.attemptNodeSelection(event.detail.node.entry);
    }
    /**
     * @param {?} site
     * @return {?}
     */
    setTitleIfCustomSite(site) {
        if (this.customResourcesService.isCustomSource(site.entry.guid)) {
            this.breadcrumbFolderTitle = site.entry.title;
        }
        else {
            this.breadcrumbFolderTitle = null;
        }
    }
}
ContentNodeSelectorPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-node-selector-panel',
                template: "<div class=\"adf-content-node-selector-content\" (node-select)=\"onNodeSelect($event)\">\n    <mat-form-field floatPlaceholder=\"never\" class=\"adf-content-node-selector-content-input\">\n        <input matInput\n            id=\"searchInput\"\n            [formControl]=\"searchInput\"\n            type=\"text\"\n            placeholder=\"{{'NODE_SELECTOR.SEARCH' | translate}}\"\n            [value]=\"searchTerm\"\n            data-automation-id=\"content-node-selector-search-input\">\n\n        <mat-icon *ngIf=\"searchTerm.length > 0\"\n            matSuffix (click)=\"clear()\"\n            class=\"adf-content-node-selector-content-input-icon\"\n            data-automation-id=\"content-node-selector-search-clear\">clear\n        </mat-icon>\n\n        <mat-icon *ngIf=\"searchTerm.length === 0\"\n            matSuffix\n            class=\"adf-content-node-selector-content-input-icon\"\n            data-automation-id=\"content-node-selector-search-icon\">search\n        </mat-icon>\n\n    </mat-form-field>\n\n    <adf-sites-dropdown\n        class=\"full-width\"\n        (change)=\"siteChanged($event)\"\n        [placeholder]=\"'NODE_SELECTOR.SELECT_LOCATION'\"\n        [hideMyFiles]=\"dropdownHideMyFiles\"\n        [siteList]=\"dropdownSiteList\"\n        data-automation-id=\"content-node-selector-sites-combo\">\n    </adf-sites-dropdown>\n\n    <adf-toolbar>\n        <adf-toolbar-title>\n            <ng-container *ngIf=\"!showBreadcrumbs()\">\n                <span class=\"adf-search-results-label\">{{ 'NODE_SELECTOR.SEARCH_RESULTS' | translate }}</span>\n            </ng-container>\n            <adf-dropdown-breadcrumb *ngIf=\"showBreadcrumbs()\"\n                class=\"adf-content-node-selector-content-breadcrumb\"\n                (navigate)=\"clearSearch()\"\n                [target]=\"documentList\"\n                [transform]=\"breadcrumbTransform\"\n                [folderNode]=\"breadcrumbFolderNode\"\n                [root]=\"breadcrumbFolderTitle\"\n                data-automation-id=\"content-node-selector-content-breadcrumb\">\n            </adf-dropdown-breadcrumb>\n        </adf-toolbar-title>\n    </adf-toolbar>\n\n    <div\n        class=\"adf-content-node-selector-content-list\"\n        [class.adf-content-node-selector-content-list-searchLayout]=\"showingSearchResults\"\n        data-automation-id=\"content-node-selector-content-list\">\n        <adf-document-list\n            #documentList\n            [adf-highlight]=\"searchTerm\"\n            adf-highlight-selector=\".adf-name-location-cell-name\"\n            [showHeader]=\"false\"\n            [node]=\"nodePaging\"\n            [maxItems]=\"pageSize\"\n            [rowFilter]=\"_rowFilter\"\n            [imageResolver]=\"imageResolver\"\n            [currentFolderId]=\"folderIdToShow\"\n            selectionMode=\"single\"\n            [contextMenuActions]=\"false\"\n            [contentActions]=\"false\"\n            [allowDropFiles]=\"false\"\n            [sorting]=\"'server'\"\n            [where]=\"where\"\n            (folderChange)=\"onFolderChange()\"\n            (ready)=\"onFolderLoaded()\"\n            data-automation-id=\"content-node-selector-document-list\">\n\n            <adf-custom-empty-content-template>\n                <div>{{ 'NODE_SELECTOR.NO_RESULTS' | translate }}</div>\n            </adf-custom-empty-content-template>\n\n            <data-columns>\n                <data-column key=\"$thumbnail\" type=\"image\"></data-column>\n                <data-column key=\"name\" type=\"text\" class=\"adf-full-width adf-ellipsis-cell\">\n                    <ng-template let-context>\n                        <adf-name-location-cell [row]=\"context.row\"></adf-name-location-cell>\n                    </ng-template>\n                </data-column>\n                <data-column key=\"modifiedAt\" type=\"date\" format=\"timeAgo\" class=\"adf-content-selector-modified-cell\"></data-column>\n                <data-column key=\"createdByUser.displayName\" type=\"text\" class=\"adf-content-selector-modifier-cell\"></data-column>\n                <data-column key=\"visibility\" type=\"text\" class=\"adf-content-selector-visibility-cell\"></data-column>\n            </data-columns>\n\n        </adf-document-list>\n\n        <adf-infinite-pagination\n            [target]=\"target\"\n            [loading]=\"loadingSearchResults\"\n            (loadMore)=\"getNextPageOfSearch($event)\"\n            data-automation-id=\"content-node-selector-search-pagination\">\n            {{ 'ADF-DOCUMENT-LIST.LAYOUT.LOAD_MORE' | translate }}\n        </adf-infinite-pagination>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-content-node-selector-panel' },
                styles: [""]
            }] }
];
/** @nocollapse */
ContentNodeSelectorPanelComponent.ctorParameters = () => [
    { type: ContentNodeSelectorService },
    { type: CustomResourcesService },
    { type: UserPreferencesService }
];
ContentNodeSelectorPanelComponent.propDecorators = {
    currentFolderId: [{ type: Input }],
    dropdownHideMyFiles: [{ type: Input }],
    dropdownSiteList: [{ type: Input }],
    where: [{ type: Input }],
    rowFilter: [{ type: Input }],
    excludeSiteContent: [{ type: Input }],
    imageResolver: [{ type: Input }],
    pageSize: [{ type: Input }],
    isSelectionValid: [{ type: Input }],
    breadcrumbTransform: [{ type: Input }],
    select: [{ type: Output }],
    documentList: [{ type: ViewChild, args: ['documentList',] }],
    highlighter: [{ type: ViewChild, args: [HighlightDirective,] }],
    infinitePaginationComponent: [{ type: ViewChild, args: [InfinitePaginationComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentNodeSelectorModule {
}
ContentNodeSelectorModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule.forChild(),
                    CommonModule,
                    MaterialModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    DocumentListModule
                ],
                exports: [
                    ContentNodeSelectorPanelComponent,
                    NameLocationCellComponent,
                    ContentNodeSelectorComponent
                ],
                entryComponents: [
                    ContentNodeSelectorPanelComponent,
                    ContentNodeSelectorComponent
                ],
                declarations: [
                    ContentNodeSelectorPanelComponent,
                    NameLocationCellComponent,
                    ContentNodeSelectorComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
const I18N_ERRORS_PATH = 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS';
/**
 * @param {?} __0
 * @return {?}
 */
function forbidSpecialCharacters({ value }) {
    /** @type {?} */
    const specialCharacters = /([\*\"\<\>\\\/\?\:\|])/;
    /** @type {?} */
    const isValid = !specialCharacters.test(value);
    return (isValid) ? null : {
        message: `${I18N_ERRORS_PATH}.SPECIAL_CHARACTERS`
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function forbidEndingDot({ value }) {
    /** @type {?} */
    const isValid = ((value || '').trim().split('').pop() !== '.');
    return isValid ? null : {
        message: `${I18N_ERRORS_PATH}.ENDING_DOT`
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function forbidOnlySpaces({ value }) {
    /** @type {?} */
    const isValid = !!((value || '')).trim();
    return isValid ? null : {
        message: `${I18N_ERRORS_PATH}.ONLY_SPACES`
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FolderDialogComponent {
    /**
     * @param {?} formBuilder
     * @param {?} dialog
     * @param {?} nodesApi
     * @param {?} translation
     * @param {?} data
     */
    constructor(formBuilder, dialog, nodesApi, translation, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.nodesApi = nodesApi;
        this.translation = translation;
        this.data = data;
        this.folder = null;
        /**
         * Emitted when the edit/create folder give error for example a folder with same name already exist
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the edit/create folder is successfully created/modified
         */
        this.success = new EventEmitter();
        this.editTitle = 'CORE.FOLDER_DIALOG.EDIT_FOLDER_TITLE';
        this.createTitle = 'CORE.FOLDER_DIALOG.CREATE_FOLDER_TITLE';
        this.nodeType = 'cm:folder';
        if (data) {
            this.editTitle = data.editTitle || this.editTitle;
            this.createTitle = data.createTitle || this.createTitle;
            this.nodeType = data.nodeType || this.nodeType;
        }
    }
    /**
     * @return {?}
     */
    get editing() {
        return !!this.data.folder;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const { folder } = this.data;
        /** @type {?} */
        let name = '';
        /** @type {?} */
        let description = '';
        if (folder) {
            const { properties } = folder;
            name = folder.name || '';
            description = properties ? properties['cm:description'] : '';
        }
        /** @type {?} */
        const validators = {
            name: [
                Validators.required,
                forbidSpecialCharacters,
                forbidEndingDot,
                forbidOnlySpaces
            ]
        };
        this.form = this.formBuilder.group({
            name: [name, validators.name],
            description: [description]
        });
    }
    /**
     * @return {?}
     */
    get name() {
        const { name } = this.form.value;
        return (name || '').trim();
    }
    /**
     * @return {?}
     */
    get description() {
        const { description } = this.form.value;
        return (description || '').trim();
    }
    /**
     * @private
     * @return {?}
     */
    get properties() {
        const { name: title, description } = this;
        return {
            'cm:title': title,
            'cm:description': description
        };
    }
    /**
     * @private
     * @return {?}
     */
    create() {
        const { name, properties, nodeType, nodesApi, data: { parentNodeId } } = this;
        return nodesApi.createFolder(parentNodeId, { name, properties, nodeType });
    }
    /**
     * @private
     * @return {?}
     */
    edit() {
        const { name, properties, nodesApi, data: { folder: { id: nodeId } } } = this;
        return nodesApi.updateNode(nodeId, { name, properties });
    }
    /**
     * @return {?}
     */
    submit() {
        const { form, dialog, editing } = this;
        if (!form.valid) {
            return;
        }
        (editing ? this.edit() : this.create())
            .subscribe((/**
         * @param {?} folder
         * @return {?}
         */
        (folder) => {
            this.success.emit(folder);
            dialog.close(folder);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.handleError(error)));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        /** @type {?} */
        let errorMessage = 'CORE.MESSAGES.ERRORS.GENERIC';
        try {
            const { error: { statusCode } } = JSON.parse(error.message);
            if (statusCode === 409) {
                errorMessage = 'CORE.MESSAGES.ERRORS.EXISTENT_FOLDER';
            }
        }
        catch (err) { /* Do nothing, keep the original message */ }
        this.error.emit(this.translation.instant(errorMessage));
        return error;
    }
}
FolderDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-folder-dialog',
                template: "<h2 mat-dialog-title>\n    {{ (editing ? editTitle : createTitle) | translate }}\n</h2>\n\n<mat-dialog-content>\n    <form [formGroup]=\"form\" (submit)=\"submit()\">\n        <mat-form-field class=\"adf-full-width\">\n            <input\n                id=\"adf-folder-name-input\"\n                placeholder=\"{{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.LABEL' | translate }}\"\n                matInput\n                required\n                [formControl]=\"form.controls['name']\"/>\n\n            <mat-hint *ngIf=\"form.controls['name'].dirty\">\n                <span *ngIf=\"form.controls['name'].errors?.required\">\n                    {{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS.REQUIRED' | translate }}\n                </span>\n\n                <span *ngIf=\"!form.controls['name'].errors?.required && form.controls['name'].errors?.message\">\n                    {{ form.controls['name'].errors?.message | translate }}\n                </span>\n            </mat-hint>\n        </mat-form-field>\n\n        <br />\n        <br />\n\n        <mat-form-field class=\"adf-full-width\">\n            <textarea\n                id=\"adf-folder-description-input\"\n                matInput\n                placeholder=\"{{ 'CORE.FOLDER_DIALOG.FOLDER_DESCRIPTION.LABEL' | translate }}\"\n                rows=\"4\"\n                [formControl]=\"form.controls['description']\"></textarea>\n        </mat-form-field>\n    </form>\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button\n        mat-button\n        id=\"adf-folder-cancel-button\"\n        mat-dialog-close>\n        {{ 'CORE.FOLDER_DIALOG.CANCEL_BUTTON.LABEL' | translate }}\n    </button>\n\n    <button class=\"adf-dialog-action-button\"\n            id=\"adf-folder-create-button\"\n            mat-button\n            (click)=\"submit()\"\n            [disabled]=\"!form.valid\">\n        {{\n        (editing\n        ? 'CORE.FOLDER_DIALOG.UPDATE_BUTTON.LABEL'\n        : 'CORE.FOLDER_DIALOG.CREATE_BUTTON.LABEL'\n        ) | translate\n        }}\n    </button>\n</mat-dialog-actions>\n",
                styles: [".adf-fill-remaining-space{flex:1 1 auto}.adf-full-width,.adf-lock-file-name .mat-checkbox-layout{width:100%}.adf-lock-file-name .mat-checkbox-label{text-overflow:ellipsis;overflow:hidden}.adf-lock-file-name .mat-checkbox-inner-container{margin:auto 8px auto 0}"]
            }] }
];
/** @nocollapse */
FolderDialogComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialogRef },
    { type: NodesApiService },
    { type: TranslationService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
FolderDialogComponent.propDecorators = {
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LibraryDialogComponent {
    /**
     * @param {?} alfrescoApiService
     * @param {?} formBuilder
     * @param {?} dialog
     */
    constructor(alfrescoApiService, formBuilder, dialog) {
        this.alfrescoApiService = alfrescoApiService;
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the new library is created successfully. The
         * event parameter is a SiteEntry object with the details of the
         * newly-created library.
         */
        this.success = new EventEmitter();
        this.onDestroy$ = new Subject();
        this.createTitle = 'LIBRARY.DIALOG.CREATE_TITLE';
        this.libraryTitleExists = false;
        this.visibilityOptions = [
            { value: 'PUBLIC', label: 'LIBRARY.VISIBILITY.PUBLIC', disabled: false },
            { value: 'PRIVATE', label: 'LIBRARY.VISIBILITY.PRIVATE', disabled: false },
            {
                value: 'MODERATED',
                label: 'LIBRARY.VISIBILITY.MODERATED',
                disabled: false
            }
        ];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const validators = {
            id: [
                Validators.required,
                Validators.maxLength(72),
                this.forbidSpecialCharacters
            ],
            title: [
                Validators.required,
                this.forbidOnlySpaces,
                Validators.minLength(2),
                Validators.maxLength(256)
            ],
            description: [Validators.maxLength(512)]
        };
        this.form = this.formBuilder.group({
            title: [null, validators.title],
            id: [null, validators.id, this.createSiteIdValidator()],
            description: ['', validators.description]
        });
        this.visibilityOption = this.visibilityOptions[0].value;
        this.form.controls['title'].valueChanges
            .pipe(debounceTime(300), mergeMap((/**
         * @param {?} title
         * @return {?}
         */
        (title) => this.checkLibraryNameExists(title)), (/**
         * @param {?} title
         * @return {?}
         */
        (title) => title)), takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} title
         * @return {?}
         */
        (title) => {
            if (!this.form.controls['id'].dirty && this.canGenerateId(title)) {
                this.form.patchValue({ id: this.sanitize(title.trim()) });
                this.form.controls['id'].markAsTouched();
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    /**
     * @return {?}
     */
    get title() {
        const { title } = this.form.value;
        return (title || '').trim();
    }
    /**
     * @return {?}
     */
    get id() {
        const { id } = this.form.value;
        return (id || '').trim();
    }
    /**
     * @return {?}
     */
    get description() {
        const { description } = this.form.value;
        return (description || '').trim();
    }
    /**
     * @return {?}
     */
    get visibility() {
        return this.visibilityOption || '';
    }
    /**
     * @return {?}
     */
    submit() {
        const { form, dialog } = this;
        if (!form.valid) {
            return;
        }
        this.create().subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.success.emit(node);
            dialog.close(node);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.handleError(error)));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    visibilityChangeHandler(event) {
        this.visibilityOption = event.value;
    }
    /**
     * @private
     * @return {?}
     */
    create() {
        const { title, id, description, visibility } = this;
        /** @type {?} */
        const siteBody = (/** @type {?} */ ({
            id,
            title,
            description,
            visibility
        }));
        return from(this.alfrescoApiService.sitesApi.createSite(siteBody));
    }
    /**
     * @private
     * @param {?} input
     * @return {?}
     */
    sanitize(input) {
        return input.replace(/[\s\s]+/g, '-').replace(/[^A-Za-z0-9-]/g, '');
    }
    /**
     * @private
     * @param {?} title
     * @return {?}
     */
    canGenerateId(title) {
        return Boolean(title.replace(/[^A-Za-z0-9-]/g, '').length);
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        const { error: { statusCode } } = JSON.parse(error.message);
        if (statusCode === 409) {
            this.form.controls['id'].setErrors({
                message: 'LIBRARY.ERRORS.CONFLICT'
            });
        }
        return error;
    }
    /**
     * @private
     * @param {?} libraryTitle
     * @return {?}
     */
    checkLibraryNameExists(libraryTitle) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            let entries = [];
            try {
                entries = (yield this.findLibraryByTitle(libraryTitle)).list.entries;
            }
            catch (_a) {
                entries = [];
            }
            if (entries.length) {
                this.libraryTitleExists = entries[0].entry.title.toLowerCase() === libraryTitle.toLowerCase();
            }
            else {
                this.libraryTitleExists = false;
            }
        });
    }
    /**
     * @private
     * @param {?} libraryTitle
     * @return {?}
     */
    findLibraryByTitle(libraryTitle) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.alfrescoApiService
                .getInstance()
                .core.queriesApi.findSites(libraryTitle, {
                maxItems: 1,
                fields: ['title']
            });
        });
    }
    /**
     * @private
     * @param {?} __0
     * @return {?}
     */
    forbidSpecialCharacters({ value }) {
        if (value === null || value.length === 0) {
            return null;
        }
        /** @type {?} */
        const validCharacters = /[^A-Za-z0-9-]/;
        /** @type {?} */
        const isValid = !validCharacters.test(value);
        return isValid
            ? null
            : {
                message: 'LIBRARY.ERRORS.ILLEGAL_CHARACTERS'
            };
    }
    /**
     * @private
     * @param {?} __0
     * @return {?}
     */
    forbidOnlySpaces({ value }) {
        if (value === null || value.length === 0) {
            return null;
        }
        /** @type {?} */
        const isValid = !!(value || '').trim();
        return isValid
            ? null
            : {
                message: 'LIBRARY.ERRORS.ONLY_SPACES'
            };
    }
    /**
     * @private
     * @return {?}
     */
    createSiteIdValidator() {
        /** @type {?} */
        let timer;
        return (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            if (timer) {
                clearTimeout(timer);
            }
            return new Promise((/**
             * @param {?} resolve
             * @return {?}
             */
            (resolve) => {
                timer = setTimeout((/**
                 * @return {?}
                 */
                () => {
                    return from(this.alfrescoApiService.sitesApi.getSite(control.value)).subscribe((/**
                     * @return {?}
                     */
                    () => resolve({ message: 'LIBRARY.ERRORS.EXISTENT_SITE' })), (/**
                     * @return {?}
                     */
                    () => resolve(null)));
                }), 300);
            }));
        });
    }
}
LibraryDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-library-dialog',
                template: "<h2 mat-dialog-title>{{ createTitle | translate }}</h2>\n\n<mat-dialog-content>\n  <form novalidate [formGroup]=\"form\" (submit)=\"submit()\">\n    <mat-form-field>\n      <input\n        placeholder=\"{{ 'LIBRARY.DIALOG.FORM.NAME' | translate }}\"\n        required\n        matInput\n        autofocus\n        formControlName=\"title\"\n        autocomplete=\"off\"\n      />\n\n      <mat-hint *ngIf=\"libraryTitleExists\">{{\n        'LIBRARY.HINTS.SITE_TITLE_EXISTS' | translate\n      }}</mat-hint>\n      <mat-error *ngIf=\"form.controls['title'].hasError('maxlength')\">\n        {{ 'LIBRARY.ERRORS.TITLE_TOO_LONG' | translate }}\n      </mat-error>\n\n      <mat-error *ngIf=\"form.controls['title'].hasError('minlength')\">\n        {{ 'LIBRARY.ERRORS.TITLE_TOO_SHORT' | translate }}\n      </mat-error>\n\n      <mat-error *ngIf=\"form.controls['title'].errors?.message\">\n        {{ form.controls['title'].errors?.message | translate }}\n      </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n      <input\n        required\n        placeholder=\"{{ 'LIBRARY.DIALOG.FORM.SITE_ID' | translate }}\"\n        matInput\n        formControlName=\"id\"\n        autocomplete=\"off\"\n      />\n\n      <mat-error *ngIf=\"form.controls['id'].errors?.message\">\n        {{ form.controls['id'].errors?.message | translate }}\n      </mat-error>\n\n      <mat-error *ngIf=\"form.controls['id'].hasError('maxlength')\">\n        {{ 'LIBRARY.ERRORS.ID_TOO_LONG' | translate }}\n      </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n      <textarea\n        matInput\n        placeholder=\"{{ 'LIBRARY.DIALOG.FORM.DESCRIPTION' | translate }}\"\n        rows=\"3\"\n        formControlName=\"description\"\n      ></textarea>\n\n      <mat-error *ngIf=\"form.controls['description'].hasError('maxlength')\">\n        {{ 'LIBRARY.ERRORS.DESCRIPTION_TOO_LONG' | translate }}\n      </mat-error>\n    </mat-form-field>\n\n    <mat-radio-group\n      [ngModelOptions]=\"{ standalone: true }\"\n      [(ngModel)]=\"visibilityOption\"\n      (change)=\"visibilityChangeHandler($event)\"\n    >\n      <mat-radio-button\n        color=\"primary\"\n        [disabled]=\"option.disabled\"\n        *ngFor=\"let option of visibilityOptions\"\n        [attr.data-automation-id]=\"option.value\"\n        [value]=\"option.value\"\n        [checked]=\"visibilityOption.value === option.value\"\n      >\n        {{ option.label | translate }}\n      </mat-radio-button>\n    </mat-radio-group>\n  </form>\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-action-buttons\">\n  <button mat-button mat-dialog-close data-automation-id=\"cancel-library-id\">\n    {{ 'LIBRARY.DIALOG.CANCEL' | translate }}\n  </button>\n\n  <button\n    color=\"primary\"\n    mat-button\n    (click)=\"submit()\"\n    [disabled]=\"!form.valid\"\n    data-automation-id=\"create-library-id\"\n  >\n    {{ 'LIBRARY.DIALOG.CREATE' | translate }}\n  </button>\n</mat-dialog-actions>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-library-dialog' },
                styles: [".adf-library-dialog .mat-radio-group{display:flex;flex-direction:column;margin:0 0 20px}.adf-library-dialog .mat-radio-group .mat-radio-button{margin:10px 0}.adf-library-dialog .mat-form-field{width:100%}.adf-library-dialog mat-form-field{padding-top:20px}.adf-library-dialog .adf-action-buttons{display:flex;flex-direction:row;justify-content:flex-end}.adf-library-dialog .adf-action-buttons .mat-button{text-transform:uppercase}"]
            }] }
];
/** @nocollapse */
LibraryDialogComponent.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: FormBuilder },
    { type: MatDialogRef }
];
LibraryDialogComponent.propDecorators = {
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DialogModule {
}
DialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule.forChild(),
                    FormsModule,
                    ReactiveFormsModule,
                    MatMomentDatetimeModule,
                    MatDatetimepickerModule
                ],
                declarations: [
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ConfirmDialogComponent,
                    LibraryDialogComponent
                ],
                exports: [
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ConfirmDialogComponent,
                    LibraryDialogComponent
                ],
                entryComponents: [
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ConfirmDialogComponent,
                    LibraryDialogComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_FOLDER_PARENT_ID = '-my-';
class FolderCreateDirective {
    /**
     * @param {?} dialogRef
     * @param {?} content
     */
    constructor(dialogRef, content) {
        this.dialogRef = dialogRef;
        this.content = content;
        /**
         * Parent folder where the new folder will be located after creation.
         */
        this.parentNodeId = DEFAULT_FOLDER_PARENT_ID;
        /**
         * Title of folder creation dialog.
         */
        this.title = null;
        /**
         * Type of node to create.
         */
        this.nodeType = 'cm:folder';
        /**
         * Emitted when an error occurs (eg, a folder with same name already exists).
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the folder is created successfully.
         */
        this.success = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        this.openDialog();
    }
    /**
     * @private
     * @return {?}
     */
    get dialogConfig() {
        const { DIALOG_WIDTH: width } = FolderCreateDirective;
        const { parentNodeId, title: createTitle, nodeType } = this;
        return {
            data: { parentNodeId, createTitle, nodeType },
            width: `${width}px`
        };
    }
    /**
     * @private
     * @return {?}
     */
    openDialog() {
        const { dialogRef, dialogConfig, content } = this;
        /** @type {?} */
        const dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
        }));
        dialogInstance.componentInstance.success.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.success.emit(node);
        }));
        dialogInstance.afterClosed().subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (node) {
                content.folderCreate.next(node);
            }
        }));
    }
}
FolderCreateDirective.DIALOG_WIDTH = 400;
FolderCreateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-create-folder]'
            },] }
];
/** @nocollapse */
FolderCreateDirective.ctorParameters = () => [
    { type: MatDialog },
    { type: ContentService }
];
FolderCreateDirective.propDecorators = {
    parentNodeId: [{ type: Input, args: ['adf-create-folder',] }],
    title: [{ type: Input }],
    nodeType: [{ type: Input }],
    error: [{ type: Output }],
    success: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FolderEditDirective {
    /**
     * @param {?} dialogRef
     * @param {?} elementRef
     * @param {?} content
     */
    constructor(dialogRef, elementRef, content) {
        this.dialogRef = dialogRef;
        this.elementRef = elementRef;
        this.content = content;
        /**
         * Emitted when an error occurs (eg, a folder with same name already exists).
         */
        this.error = new EventEmitter();
        /**
         * Title of folder edit dialog.
         */
        this.title = null;
        /**
         * Emitted when the folder has been edited successfully.
         */
        this.success = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        if (this.folder) {
            this.openDialog();
        }
    }
    /**
     * @private
     * @return {?}
     */
    get dialogConfig() {
        const { DIALOG_WIDTH: width } = FolderEditDirective;
        const { folder } = this;
        return {
            data: {
                folder,
                editTitle: this.title
            },
            width: `${width}px`
        };
    }
    /**
     * @private
     * @return {?}
     */
    openDialog() {
        const { dialogRef, dialogConfig, content } = this;
        /** @type {?} */
        const dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
        }));
        dialogInstance.componentInstance.success.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.success.emit(node);
        }));
        dialogInstance.afterClosed().subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (node) {
                content.folderEdit.next(node);
            }
        }));
    }
}
FolderEditDirective.DIALOG_WIDTH = 400;
FolderEditDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-edit-folder]'
            },] }
];
/** @nocollapse */
FolderEditDirective.ctorParameters = () => [
    { type: MatDialog },
    { type: ElementRef },
    { type: ContentService }
];
FolderEditDirective.propDecorators = {
    folder: [{ type: Input, args: ['adf-edit-folder',] }],
    error: [{ type: Output }],
    title: [{ type: Input }],
    success: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FolderDirectiveModule {
}
FolderDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    FolderCreateDirective,
                    FolderEditDirective
                ],
                exports: [
                    FolderCreateDirective,
                    FolderEditDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentMetadataCardComponent {
    /**
     * @param {?} contentService
     */
    constructor(contentService) {
        this.contentService = contentService;
        /**
         * (optional) This flag displays/hides empty metadata
         * fields.
         */
        this.displayEmpty = false;
        /**
         * (optional) This flag displays desired aspect when open for the first time
         * fields.
         */
        this.displayAspect = null;
        /**
         * (optional) This flag sets the metadata in read only mode
         * preventing changes.
         */
        this.readOnly = false;
        /**
         * (optional) This flag allows the component to display more
         * than one accordion at a time.
         */
        this.multi = false;
        this._displayDefaultProperties = true;
        this.editable = false;
    }
    /**
     * (optional) This flag displays/hides the metadata
     * properties.
     * @param {?} value
     * @return {?}
     */
    set displayDefaultProperties(value) {
        this._displayDefaultProperties = value;
        this.onDisplayDefaultPropertiesChange();
    }
    /**
     * @return {?}
     */
    get displayDefaultProperties() {
        return this._displayDefaultProperties;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.displayAspect && changes.displayAspect.currentValue) {
            this.expanded = true;
        }
    }
    /**
     * @return {?}
     */
    onDisplayDefaultPropertiesChange() {
        this.expanded = !this._displayDefaultProperties;
    }
    /**
     * @return {?}
     */
    toggleEdit() {
        this.editable = !this.editable;
    }
    /**
     * @return {?}
     */
    toggleExpanded() {
        this.expanded = !this.expanded;
    }
    /**
     * @return {?}
     */
    hasAllowableOperations() {
        return this.contentService.hasAllowableOperations(this.node, AllowableOperationsEnum.UPDATE);
    }
}
ContentMetadataCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-metadata-card',
                template: "<mat-card *ngIf=\"node\">\n    <mat-card-content>\n        <adf-content-metadata\n            [displayDefaultProperties]=\"displayDefaultProperties\"\n            [expanded]=\"expanded\"\n            [node]=\"node\"\n            [displayEmpty]=\"displayEmpty\"\n            [editable]=\"editable\"\n            [multi]=\"multi\"\n            [displayAspect]=\"displayAspect\"\n            [preset]=\"preset\">\n        </adf-content-metadata>\n    </mat-card-content>\n    <mat-card-footer class=\"adf-content-metadata-card-footer\" fxLayout=\"row\" fxLayoutAlign=\"space-between stretch\">\n        <div>\n            <button *ngIf=\"!readOnly && hasAllowableOperations()\"\n                mat-icon-button\n                (click)=\"toggleEdit()\"\n                [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                data-automation-id=\"meta-data-card-toggle-edit\">\n                <mat-icon>mode_edit</mat-icon>\n            </button>\n        </div>\n        <button *ngIf=\"displayDefaultProperties\" mat-button (click)=\"toggleExpanded()\" data-automation-id=\"meta-data-card-toggle-expand\">\n            <ng-container *ngIf=\"expanded\">\n                <span data-automation-id=\"meta-data-card-toggle-expand-label\">{{ 'ADF_VIEWER.SIDEBAR.METADATA.MORE_INFORMATION' | translate }}</span>\n                <mat-icon>keyboard_arrow_down</mat-icon>\n            </ng-container>\n            <ng-container *ngIf=\"!expanded\">\n                <span data-automation-id=\"meta-data-card-toggle-expand-label\">{{ 'ADF_VIEWER.SIDEBAR.METADATA.LESS_INFORMATION' | translate }}</span>\n                <mat-icon>keyboard_arrow_up</mat-icon>\n            </ng-container>\n        </button>\n    </mat-card-footer>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-content-metadata-card' },
                styles: [""]
            }] }
];
/** @nocollapse */
ContentMetadataCardComponent.ctorParameters = () => [
    { type: ContentService }
];
ContentMetadataCardComponent.propDecorators = {
    node: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    displayAspect: [{ type: Input }],
    preset: [{ type: Input }],
    readOnly: [{ type: Input }],
    multi: [{ type: Input }],
    displayDefaultProperties: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BasicPropertiesService {
    /**
     * @param {?} fileSizePipe
     */
    constructor(fileSizePipe) {
        this.fileSizePipe = fileSizePipe;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getProperties(node) {
        /** @type {?} */
        const sizeInBytes = node.content ? node.content.sizeInBytes : '';
        /** @type {?} */
        const mimeTypeName = node.content ? node.content.mimeTypeName : '';
        /** @type {?} */
        const author = node.properties ? node.properties['cm:author'] : '';
        /** @type {?} */
        const description = node.properties ? node.properties['cm:description'] : '';
        /** @type {?} */
        const title = node.properties ? node.properties['cm:title'] : '';
        return [
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.NAME',
                value: node.name,
                key: 'name',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.TITLE',
                value: title,
                key: 'properties.cm:title',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.CREATOR',
                value: node.createdByUser.displayName,
                key: 'createdByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.CREATED_DATE',
                value: node.createdAt,
                key: 'createdAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.SIZE',
                value: sizeInBytes,
                key: 'content.sizeInBytes',
                pipes: [{ pipe: this.fileSizePipe }],
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIER',
                value: node.modifiedByUser.displayName,
                key: 'modifiedByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIED_DATE',
                value: node.modifiedAt,
                key: 'modifiedAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MIMETYPE',
                value: mimeTypeName,
                key: 'content.mimeTypeName',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.AUTHOR',
                value: author,
                key: 'properties.cm:author',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.DESCRIPTION',
                value: description,
                key: 'properties.cm:description',
                multiline: true,
                editable: true
            })
        ];
    }
}
BasicPropertiesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
BasicPropertiesService.ctorParameters = () => [
    { type: FileSizePipe }
];
/** @nocollapse */ BasicPropertiesService.ngInjectableDef = defineInjectable({ factory: function BasicPropertiesService_Factory() { return new BasicPropertiesService(inject(FileSizePipe)); }, token: BasicPropertiesService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const D_TEXT = 'd:text';
/** @type {?} */
const D_MLTEXT = 'd:mltext';
/** @type {?} */
const D_DATE = 'd:date';
/** @type {?} */
const D_DATETIME = 'd:datetime';
/** @type {?} */
const D_INT = 'd:int';
/** @type {?} */
const D_LONG = 'd:long';
/** @type {?} */
const D_FLOAT = 'd:float';
/** @type {?} */
const D_DOUBLE = 'd:double';
/** @type {?} */
const D_BOOLEAN = 'd:boolean';
class PropertyGroupTranslatorService {
    /**
     * @param {?} logService
     * @param {?} multiValuePipe
     * @param {?} appConfig
     */
    constructor(logService, multiValuePipe, appConfig) {
        this.logService = logService;
        this.multiValuePipe = multiValuePipe;
        this.appConfig = appConfig;
        this.valueSeparator = this.appConfig.get('content-metadata.multi-value-pipe-separator');
    }
    /**
     * @param {?} propertyGroups
     * @param {?} propertyValues
     * @return {?}
     */
    translateToCardViewGroups(propertyGroups, propertyValues) {
        return propertyGroups.map((/**
         * @param {?} propertyGroup
         * @return {?}
         */
        (propertyGroup) => {
            /** @type {?} */
            const translatedPropertyGroup = Object.assign({}, propertyGroup);
            translatedPropertyGroup.properties = this.translateArray(propertyGroup.properties, propertyValues);
            return translatedPropertyGroup;
        }));
    }
    /**
     * @private
     * @param {?} properties
     * @param {?} propertyValues
     * @return {?}
     */
    translateArray(properties, propertyValues) {
        return properties.map((/**
         * @param {?} property
         * @return {?}
         */
        (property) => {
            return this.translate(property, propertyValues);
        }));
    }
    /**
     * @private
     * @param {?} property
     * @param {?} propertyValues
     * @return {?}
     */
    translate(property, propertyValues) {
        /** @type {?} */
        let propertyValue;
        if (propertyValues && propertyValues[property.name]) {
            propertyValue = propertyValues[property.name];
        }
        this.checkECMTypeValidity(property.dataType);
        /** @type {?} */
        const prefix = 'properties.';
        /** @type {?} */
        const propertyDefinition = {
            label: property.title || property.name,
            value: propertyValue,
            key: `${prefix}${property.name}`,
            default: property.defaultValue,
            editable: true
        };
        /** @type {?} */
        let cardViewItemProperty;
        switch (property.dataType) {
            case D_MLTEXT:
                cardViewItemProperty = new CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multiline: true
                }));
                break;
            case D_INT:
            case D_LONG:
                cardViewItemProperty = new CardViewIntItemModel(propertyDefinition);
                break;
            case D_FLOAT:
            case D_DOUBLE:
                cardViewItemProperty = new CardViewFloatItemModel(propertyDefinition);
                break;
            case D_DATE:
                cardViewItemProperty = new CardViewDateItemModel(propertyDefinition);
                break;
            case D_DATETIME:
                cardViewItemProperty = new CardViewDatetimeItemModel(propertyDefinition);
                break;
            case D_BOOLEAN:
                cardViewItemProperty = new CardViewBoolItemModel(propertyDefinition);
                break;
            case D_TEXT:
            default:
                cardViewItemProperty = new CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multivalued: property.multiValued,
                    multiline: property.multiValued,
                    pipes: [{ pipe: this.multiValuePipe, params: [this.valueSeparator] }]
                }));
        }
        return cardViewItemProperty;
    }
    /**
     * @private
     * @param {?} ecmPropertyType
     * @return {?}
     */
    checkECMTypeValidity(ecmPropertyType) {
        if (PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES.indexOf(ecmPropertyType) === -1) {
            this.logService.error(`Unknown type for mapping: ${ecmPropertyType}`);
        }
    }
}
PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES = [D_TEXT, D_MLTEXT, D_DATE, D_DATETIME, D_INT, D_LONG, D_FLOAT, D_DOUBLE, D_BOOLEAN];
PropertyGroupTranslatorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PropertyGroupTranslatorService.ctorParameters = () => [
    { type: LogService },
    { type: MultiValuePipe },
    { type: AppConfigService }
];
/** @nocollapse */ PropertyGroupTranslatorService.ngInjectableDef = defineInjectable({ factory: function PropertyGroupTranslatorService_Factory() { return new PropertyGroupTranslatorService(inject(LogService), inject(MultiValuePipe), inject(AppConfigService)); }, token: PropertyGroupTranslatorService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
const emptyGroup = {
    properties: {}
};
/**
 * @param {?} object
 * @return {?}
 */
function convertObjectToArray(object) {
    return Object.keys(object).map((/**
     * @param {?} key
     * @return {?}
     */
    (key) => object[key]));
}
/**
 * @param {?} propertyGroups
 * @param {?} groupName
 * @return {?}
 */
function getGroup(propertyGroups, groupName) {
    return propertyGroups[groupName];
}
/**
 * @param {?} propertyGroups
 * @param {?} groupName
 * @param {?} propertyName
 * @return {?}
 */
function getProperty(propertyGroups, groupName, propertyName) {
    /** @type {?} */
    const groupDefinition = getGroup(propertyGroups, groupName) || emptyGroup;
    /** @type {?} */
    let propertyDefinitions;
    if (propertyName === '*') {
        propertyDefinitions = convertObjectToArray(groupDefinition.properties);
    }
    else {
        propertyDefinitions = groupDefinition.properties[propertyName];
    }
    return propertyDefinitions;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AspectOrientedConfigService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    isGroupAllowed(groupName) {
        if (this.isIncludeAllEnabled()) {
            return true;
        }
        /** @type {?} */
        const groupNames = Object.keys(this.config);
        return groupNames.indexOf(groupName) !== -1;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    reorganiseByConfig(propertyGroups) {
        /** @type {?} */
        const aspects = this.config;
        /** @type {?} */
        const aspectNames = Object.keys(aspects);
        return aspectNames
            .reduce((/**
         * @param {?} groupAccumulator
         * @param {?} aspectName
         * @return {?}
         */
        (groupAccumulator, aspectName) => {
            /** @type {?} */
            const newGroup = this.getOrganisedPropertyGroup(propertyGroups, aspectName);
            return groupAccumulator.concat(newGroup);
        }), [])
            .filter((/**
         * @param {?} organisedPropertyGroup
         * @return {?}
         */
        (organisedPropertyGroup) => organisedPropertyGroup.properties.length > 0));
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    appendAllPreset(propertyGroups) {
        /** @type {?} */
        const groups = Object.keys(propertyGroups)
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        (groupName) => {
            /** @type {?} */
            const propertyGroup = propertyGroups[groupName];
            /** @type {?} */
            const properties = propertyGroup.properties;
            return Object.assign({}, propertyGroup, {
                properties: Object.keys(properties).map((/**
                 * @param {?} propertyName
                 * @return {?}
                 */
                (propertyName) => properties[propertyName]))
            });
        }));
        return groups;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    filterExcludedPreset(propertyGroups) {
        if (this.config.exclude) {
            return propertyGroups.filter((/**
             * @param {?} preset
             * @return {?}
             */
            (preset) => {
                return !this.config.exclude.includes(preset.name);
            }));
        }
        return propertyGroups;
    }
    /**
     * @return {?}
     */
    isIncludeAllEnabled() {
        return this.config.includeAll;
    }
    /**
     * @private
     * @param {?} propertyGroups
     * @param {?} aspectName
     * @return {?}
     */
    getOrganisedPropertyGroup(propertyGroups, aspectName) {
        /** @type {?} */
        const group = getGroup(propertyGroups, aspectName);
        /** @type {?} */
        let newGroup = [];
        if (group) {
            /** @type {?} */
            const aspectProperties = this.config[aspectName];
            /** @type {?} */
            let properties;
            if (aspectProperties === '*') {
                properties = getProperty(propertyGroups, aspectName, aspectProperties);
            }
            else {
                properties = ((/** @type {?} */ (aspectProperties)))
                    .map((/**
                 * @param {?} propertyName
                 * @return {?}
                 */
                (propertyName) => getProperty(propertyGroups, aspectName, propertyName)))
                    .filter((/**
                 * @param {?} props
                 * @return {?}
                 */
                (props) => props !== undefined));
            }
            newGroup = [{ title: group.title, properties }];
        }
        return newGroup;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IndifferentConfigService {
    /**
     * @param {?} config
     */
    constructor(config) { }
    /**
     * @param {?} groupName
     * @return {?}
     */
    isGroupAllowed(groupName) {
        return true;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    reorganiseByConfig(propertyGroups) {
        return Object.keys(propertyGroups)
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        (groupName) => {
            /** @type {?} */
            const propertyGroup = propertyGroups[groupName];
            /** @type {?} */
            const properties = propertyGroup.properties;
            return Object.assign({}, propertyGroup, {
                properties: Object.keys(properties).map((/**
                 * @param {?} propertyName
                 * @return {?}
                 */
                (propertyName) => properties[propertyName]))
            });
        }));
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    filterExcludedPreset(propertyGroups) {
        return propertyGroups;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    appendAllPreset(propertyGroups) {
        return [];
    }
    /**
     * @return {?}
     */
    isIncludeAllEnabled() {
        return true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayoutOrientedConfigService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    isGroupAllowed(groupName) {
        if (this.isIncludeAllEnabled()) {
            return true;
        }
        return this.getMatchingGroups(groupName).length > 0;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    reorganiseByConfig(propertyGroups) {
        /** @type {?} */
        const layoutBlocks = this.config.filter((/**
         * @param {?} itemsGroup
         * @return {?}
         */
        (itemsGroup) => itemsGroup.items));
        /** @type {?} */
        const organisedPropertyGroup = layoutBlocks.map((/**
         * @param {?} layoutBlock
         * @return {?}
         */
        (layoutBlock) => {
            /** @type {?} */
            const flattenedItems = this.flattenItems(layoutBlock.items);
            /** @type {?} */
            const properties = flattenedItems.reduce((/**
             * @param {?} props
             * @param {?} explodedItem
             * @return {?}
             */
            (props, explodedItem) => {
                /** @type {?} */
                const property = getProperty(propertyGroups, explodedItem.groupName, explodedItem.propertyName) || [];
                return props.concat(property);
            }), []);
            return {
                title: layoutBlock.title,
                properties
            };
        }));
        return organisedPropertyGroup;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    appendAllPreset(propertyGroups) {
        return Object.keys(propertyGroups)
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        (groupName) => {
            /** @type {?} */
            const propertyGroup = propertyGroups[groupName];
            /** @type {?} */
            const properties = propertyGroup.properties;
            return Object.assign({}, propertyGroup, {
                properties: Object.keys(properties).map((/**
                 * @param {?} propertyName
                 * @return {?}
                 */
                (propertyName) => properties[propertyName]))
            });
        }));
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    filterExcludedPreset(propertyGroups) {
        /** @type {?} */
        let excludedConfig = this.config
            .map((/**
         * @param {?} config
         * @return {?}
         */
        (config) => config.exclude))
            .find((/**
         * @param {?} exclude
         * @return {?}
         */
        (exclude) => exclude !== undefined));
        if (excludedConfig === undefined) {
            excludedConfig = [];
        }
        else if (typeof excludedConfig === 'string') {
            excludedConfig = [excludedConfig];
        }
        return propertyGroups.filter((/**
         * @param {?} props
         * @return {?}
         */
        (props) => {
            return !excludedConfig.includes(props.name);
        }));
    }
    /**
     * @return {?}
     */
    isIncludeAllEnabled() {
        /** @type {?} */
        const includeAllProperty = this.config
            .map((/**
         * @param {?} config
         * @return {?}
         */
        (config) => config.includeAll))
            .find((/**
         * @param {?} includeAll
         * @return {?}
         */
        (includeAll) => includeAll !== undefined));
        return includeAllProperty !== undefined ? includeAllProperty : false;
    }
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    flattenItems(items) {
        return items.reduce((/**
         * @param {?} accumulator
         * @param {?} item
         * @return {?}
         */
        (accumulator, item) => {
            /** @type {?} */
            const properties = Array.isArray(item.properties) ? item.properties : [item.properties];
            /** @type {?} */
            const flattenedProperties = properties.map((/**
             * @param {?} propertyName
             * @return {?}
             */
            (propertyName) => {
                return {
                    groupName: item.aspect || item.type,
                    propertyName
                };
            }));
            return accumulator.concat(flattenedProperties);
        }), []);
    }
    /**
     * @private
     * @param {?} groupName
     * @return {?}
     */
    getMatchingGroups(groupName) {
        return this.config
            .map((/**
         * @param {?} layoutBlock
         * @return {?}
         */
        (layoutBlock) => layoutBlock.items))
            .reduce((/**
         * @param {?} accumulator
         * @param {?} items
         * @return {?}
         */
        (accumulator, items) => accumulator.concat(items)), [])
            .filter((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.aspect === groupName || item.type === groupName));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentMetadataConfigFactory {
    /**
     * @param {?} appConfigService
     * @param {?} logService
     */
    constructor(appConfigService, logService) {
        this.appConfigService = appConfigService;
        this.logService = logService;
    }
    /**
     * @param {?=} presetName
     * @return {?}
     */
    get(presetName = 'default') {
        /** @type {?} */
        let presetConfig;
        try {
            presetConfig = this.appConfigService.config['content-metadata'].presets[presetName];
        }
        catch (_a) {
            if (presetName !== ContentMetadataConfigFactory.DEFAULT_PRESET_NAME) {
                this.logService.error(`No content-metadata preset for: ${presetName}`);
            }
            presetConfig = ContentMetadataConfigFactory.INDIFFERENT_PRESET;
        }
        return this.createConfig(presetConfig);
    }
    /**
     * @private
     * @param {?} presetConfig
     * @return {?}
     */
    createConfig(presetConfig) {
        /** @type {?} */
        let config;
        if (this.isLayoutOrientedPreset(presetConfig)) {
            config = new LayoutOrientedConfigService((/** @type {?} */ (presetConfig)));
        }
        else if (this.isAspectOrientedPreset(presetConfig)) {
            config = new AspectOrientedConfigService((/** @type {?} */ (presetConfig)));
        }
        else {
            config = new IndifferentConfigService((/** @type {?} */ (presetConfig)));
        }
        Object.freeze(config);
        return config;
    }
    /**
     * @private
     * @param {?} presetConfig
     * @return {?}
     */
    isAspectOrientedPreset(presetConfig) {
        return this.isObject(presetConfig);
    }
    /**
     * @private
     * @param {?} presetConfig
     * @return {?}
     */
    isLayoutOrientedPreset(presetConfig) {
        return Array.isArray(presetConfig);
    }
    /**
     * @private
     * @param {?} x
     * @return {?}
     */
    isObject(x) {
        return x != null && typeof x === 'object';
    }
}
ContentMetadataConfigFactory.INDIFFERENT_PRESET = '*';
ContentMetadataConfigFactory.DEFAULT_PRESET_NAME = 'default';
ContentMetadataConfigFactory.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ContentMetadataConfigFactory.ctorParameters = () => [
    { type: AppConfigService },
    { type: LogService }
];
/** @nocollapse */ ContentMetadataConfigFactory.ngInjectableDef = defineInjectable({ factory: function ContentMetadataConfigFactory_Factory() { return new ContentMetadataConfigFactory(inject(AppConfigService), inject(LogService)); }, token: ContentMetadataConfigFactory, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PropertyDescriptorsService {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    /**
     * @param {?} groupNames
     * @return {?}
     */
    load(groupNames) {
        /** @type {?} */
        const groupFetchStreams = groupNames
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        (groupName) => groupName.replace(':', '_')))
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        (groupName) => defer((/**
         * @return {?}
         */
        () => this.alfrescoApiService.classesApi.getClass(groupName)))));
        return forkJoin(groupFetchStreams).pipe(map(this.convertToObject));
    }
    /**
     * @private
     * @param {?} propertyGroupsArray
     * @return {?}
     */
    convertToObject(propertyGroupsArray) {
        return propertyGroupsArray.reduce((/**
         * @param {?} propertyGroups
         * @param {?} propertyGroup
         * @return {?}
         */
        (propertyGroups, propertyGroup) => {
            return Object.assign({}, propertyGroups, {
                [propertyGroup.name]: propertyGroup
            });
        }), {});
    }
}
PropertyDescriptorsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PropertyDescriptorsService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ PropertyDescriptorsService.ngInjectableDef = defineInjectable({ factory: function PropertyDescriptorsService_Factory() { return new PropertyDescriptorsService(inject(AlfrescoApiService)); }, token: PropertyDescriptorsService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentMetadataService {
    /**
     * @param {?} basicPropertiesService
     * @param {?} contentMetadataConfigFactory
     * @param {?} propertyGroupTranslatorService
     * @param {?} propertyDescriptorsService
     */
    constructor(basicPropertiesService, contentMetadataConfigFactory, propertyGroupTranslatorService, propertyDescriptorsService) {
        this.basicPropertiesService = basicPropertiesService;
        this.contentMetadataConfigFactory = contentMetadataConfigFactory;
        this.propertyGroupTranslatorService = propertyGroupTranslatorService;
        this.propertyDescriptorsService = propertyDescriptorsService;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getBasicProperties(node) {
        return of(this.basicPropertiesService.getProperties(node));
    }
    /**
     * @param {?} node
     * @param {?=} presetName
     * @return {?}
     */
    getGroupedProperties(node, presetName = 'default') {
        /** @type {?} */
        let groupedProperties = of([]);
        if (node.aspectNames) {
            /** @type {?} */
            const contentMetadataConfig = this.contentMetadataConfigFactory.get(presetName);
            /** @type {?} */
            const groupNames = node.aspectNames
                .concat(node.nodeType)
                .filter((/**
             * @param {?} groupName
             * @return {?}
             */
            (groupName) => contentMetadataConfig.isGroupAllowed(groupName)));
            if (groupNames.length > 0) {
                groupedProperties = this.propertyDescriptorsService.load(groupNames).pipe(switchMap((/**
                 * @param {?} groups
                 * @return {?}
                 */
                (groups) => iif((/**
                 * @return {?}
                 */
                () => contentMetadataConfig.isIncludeAllEnabled()), of(contentMetadataConfig.appendAllPreset(groups).concat(contentMetadataConfig.reorganiseByConfig(groups))), of(contentMetadataConfig.reorganiseByConfig(groups))))), map((/**
                 * @param {?} groups
                 * @return {?}
                 */
                (groups) => contentMetadataConfig.filterExcludedPreset(groups))), map((/**
                 * @param {?} groups
                 * @return {?}
                 */
                (groups) => this.filterEmptyPreset(groups))), map((/**
                 * @param {?} groups
                 * @return {?}
                 */
                (groups) => this.setTitleToNameIfNotSet(groups))), map((/**
                 * @param {?} groups
                 * @return {?}
                 */
                (groups) => this.propertyGroupTranslatorService.translateToCardViewGroups(groups, node.properties))));
            }
        }
        return groupedProperties;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    setTitleToNameIfNotSet(propertyGroups) {
        propertyGroups.map((/**
         * @param {?} propertyGroup
         * @return {?}
         */
        (propertyGroup) => {
            propertyGroup.title = propertyGroup.title || propertyGroup.name;
        }));
        return propertyGroups;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    filterEmptyPreset(propertyGroups) {
        return propertyGroups.filter((/**
         * @param {?} props
         * @return {?}
         */
        (props) => props.properties.length));
    }
}
ContentMetadataService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ContentMetadataService.ctorParameters = () => [
    { type: BasicPropertiesService },
    { type: ContentMetadataConfigFactory },
    { type: PropertyGroupTranslatorService },
    { type: PropertyDescriptorsService }
];
/** @nocollapse */ ContentMetadataService.ngInjectableDef = defineInjectable({ factory: function ContentMetadataService_Factory() { return new ContentMetadataService(inject(BasicPropertiesService), inject(ContentMetadataConfigFactory), inject(PropertyGroupTranslatorService), inject(PropertyDescriptorsService)); }, token: ContentMetadataService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentMetadataComponent {
    /**
     * @param {?} contentMetadataService
     * @param {?} cardViewUpdateService
     * @param {?} nodesApiService
     * @param {?} logService
     * @param {?} alfrescoApiService
     */
    constructor(contentMetadataService, cardViewUpdateService, nodesApiService, logService, alfrescoApiService) {
        this.contentMetadataService = contentMetadataService;
        this.cardViewUpdateService = cardViewUpdateService;
        this.nodesApiService = nodesApiService;
        this.logService = logService;
        this.alfrescoApiService = alfrescoApiService;
        /**
         * Toggles whether the edit button should be shown
         */
        this.editable = false;
        /**
         * Toggles whether to display empty values in the card view
         */
        this.displayEmpty = false;
        /**
         * Toggles between expanded (ie, full information) and collapsed
         * (ie, reduced information) in the display
         */
        this.expanded = false;
        /**
         * The multi parameter of the underlying material expansion panel, set to true to allow multi accordion to be expanded at the same time
         */
        this.multi = false;
        /**
         * Toggles whether the metadata properties should be shown
         */
        this.displayDefaultProperties = true;
        /**
         * (Optional) shows the given aspect in the expanded  card
         */
        this.displayAspect = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.disposableNodeUpdate = this.cardViewUpdateService.itemUpdated$
            .pipe(switchMap(this.saveNode.bind(this)))
            .subscribe((/**
         * @param {?} updatedNode
         * @return {?}
         */
        (updatedNode) => {
            Object.assign(this.node, updatedNode);
            this.alfrescoApiService.nodeUpdated.next(this.node);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.logService.error(error)));
        this.loadProperties(this.node);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.node && !changes.node.firstChange) {
            this.loadProperties(changes.node.currentValue);
        }
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    loadProperties(node) {
        if (node) {
            this.basicProperties$ = this.contentMetadataService.getBasicProperties(node);
            this.groupedProperties$ = this.contentMetadataService.getGroupedProperties(node, this.preset);
        }
    }
    /**
     * @private
     * @param {?} __0
     * @return {?}
     */
    saveNode({ changed: nodeBody }) {
        return this.nodesApiService.updateNode(this.node.id, nodeBody);
    }
    /**
     * @param {?} group
     * @return {?}
     */
    showGroup(group) {
        /** @type {?} */
        const properties = group.properties.filter((/**
         * @param {?} property
         * @return {?}
         */
        (property) => {
            return !!property.displayValue;
        }));
        return properties.length;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.disposableNodeUpdate.unsubscribe();
    }
    /**
     * @param {?} group
     * @return {?}
     */
    canExpandTheCard(group) {
        return group.title === this.displayAspect;
    }
    /**
     * @return {?}
     */
    canExpandProperties() {
        return !this.expanded || this.displayAspect === 'Properties';
    }
}
ContentMetadataComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-metadata',
                template: "<div class=\"adf-metadata-properties\">\n    <mat-accordion displayMode=\"flat\" [multi]=\"multi\">\n        <mat-expansion-panel\n            *ngIf=\"displayDefaultProperties\"\n            [expanded]=\"canExpandProperties()\"\n            [hideToggle]=\"canExpandProperties()\"\n            [attr.data-automation-id]=\"'adf-metadata-group-properties'\" >\n            <mat-expansion-panel-header>\n                <mat-panel-title>\n                    {{ 'CORE.METADATA.BASIC.HEADER' | translate }}\n                </mat-panel-title>\n            </mat-expansion-panel-header>\n\n            <adf-card-view\n                [properties]=\"basicProperties$ | async\"\n                [editable]=\"editable\"\n                [displayEmpty]=\"displayEmpty\">\n            </adf-card-view>\n        </mat-expansion-panel>\n\n        <ng-container *ngIf=\"expanded\">\n            <ng-container *ngIf=\"groupedProperties$ | async; else loading; let groupedProperties\">\n                <div *ngFor=\"let group of groupedProperties; let first = first;\" class=\"adf-metadata-grouped-properties-container\">\n                    <mat-expansion-panel *ngIf=\"showGroup(group) || editable\"\n                    [attr.data-automation-id]=\"'adf-metadata-group-' + group.title\"\n                    [expanded]=\"canExpandTheCard(group) || !displayDefaultProperties && first\">\n                        <mat-expansion-panel-header>\n                            <mat-panel-title>\n                                {{ group.title | translate }}\n                            </mat-panel-title>\n                        </mat-expansion-panel-header>\n\n                        <adf-card-view\n                            [properties]=\"group.properties\"\n                            [editable]=\"editable\"\n                            [displayEmpty]=\"displayEmpty\">\n                        </adf-card-view>\n                    </mat-expansion-panel>\n\n                </div>\n            </ng-container>\n            <ng-template #loading>\n                <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n            </ng-template>\n        </ng-container>\n    </mat-accordion>\n</div>\n",
                host: { 'class': 'adf-content-metadata' },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
ContentMetadataComponent.ctorParameters = () => [
    { type: ContentMetadataService },
    { type: CardViewUpdateService },
    { type: NodesApiService },
    { type: LogService },
    { type: AlfrescoApiService }
];
ContentMetadataComponent.propDecorators = {
    node: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    expanded: [{ type: Input }],
    multi: [{ type: Input }],
    preset: [{ type: Input }],
    displayDefaultProperties: [{ type: Input }],
    displayAspect: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentMetadataModule {
}
ContentMetadataModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FlexLayoutModule,
                    CoreModule.forChild()
                ],
                exports: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ],
                declarations: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PermissionDisplayModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.isInherited = false;
        if (obj) {
            this.authorityId = obj.authorityId;
            this.name = obj.name;
            this.accessStatus = obj.accessStatus;
            this.isInherited = obj.isInherited !== null && obj.isInherited !== undefined ? obj.isInherited : false;
            this.icon = obj.icon ? obj.icon : 'vpn_key';
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodePermissionService {
    /**
     * @param {?} apiService
     * @param {?} searchApiService
     * @param {?} nodeService
     * @param {?} translation
     */
    constructor(apiService, searchApiService, nodeService, translation) {
        this.apiService = apiService;
        this.searchApiService = searchApiService;
        this.nodeService = nodeService;
        this.translation = translation;
    }
    /**
     * Gets a list of roles for the current node.
     * @param {?} node The target node
     * @return {?} Array of strings representing the roles
     */
    getNodeRoles(node) {
        /** @type {?} */
        const retrieveSiteQueryBody = this.buildRetrieveSiteQueryBody(node.path.elements);
        return this.searchApiService.searchByQueryBody(retrieveSiteQueryBody)
            .pipe(switchMap((/**
         * @param {?} siteNodeList
         * @return {?}
         */
        (siteNodeList) => {
            if (siteNodeList.list.entries.length > 0) {
                /** @type {?} */
                const siteName = siteNodeList.list.entries[0].entry.name;
                return this.getGroupMembersBySiteName(siteName);
            }
            else {
                return of(node.permissions.settable);
            }
        })));
    }
    /**
     * Updates the permission role for a node.
     * @param {?} node Target node
     * @param {?} updatedPermissionRole Permission role to update or add
     * @return {?} Node with updated permission
     */
    updatePermissionRole(node, updatedPermissionRole) {
        /** @type {?} */
        const permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        const index = node.permissions.locallySet.map((/**
         * @param {?} permission
         * @return {?}
         */
        (permission) => permission.authorityId)).indexOf(updatedPermissionRole.authorityId);
        permissionBody.permissions.locallySet = permissionBody.permissions.locallySet.concat(node.permissions.locallySet);
        if (index !== -1) {
            permissionBody.permissions.locallySet[index] = updatedPermissionRole;
        }
        else {
            permissionBody.permissions.locallySet.push(updatedPermissionRole);
        }
        return this.nodeService.updateNode(node.id, permissionBody);
    }
    /**
     * Update permissions for a node.
     * @param {?} nodeId ID of the target node
     * @param {?} permissionList New permission settings
     * @return {?} Node with updated permissions
     */
    updateNodePermissions(nodeId, permissionList) {
        return this.nodeService.getNode(nodeId).pipe(switchMap((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            return this.getNodeRoles(node).pipe(switchMap((/**
             * @param {?} nodeRoles
             * @return {?}
             */
            (nodeRoles) => of({ node, nodeRoles }))));
        })), switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ node, nodeRoles }) => this.updateLocallySetPermissions(node, permissionList, nodeRoles))));
    }
    /**
     * Updates the locally set permissions for a node.
     * @param {?} node ID of the target node
     * @param {?} nodes Permission settings
     * @param {?} nodeRole Permission role
     * @return {?} Node with updated permissions
     */
    updateLocallySetPermissions(node, nodes, nodeRole) {
        /** @type {?} */
        const permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        const permissionList = this.transformNodeToPermissionElement(nodes, nodeRole[0]);
        /** @type {?} */
        const duplicatedPermissions = this.getDuplicatedPermissions(node.permissions.locallySet, permissionList);
        if (duplicatedPermissions.length > 0) {
            /** @type {?} */
            const list = duplicatedPermissions.map((/**
             * @param {?} permission
             * @return {?}
             */
            (permission) => 'authority -> ' + permission.authorityId + ' / role -> ' + permission.name)).join(', ');
            /** @type {?} */
            const duplicatePermissionMessage = this.translation.instant('PERMISSION_MANAGER.ERROR.DUPLICATE-PERMISSION', { list });
            return throwError(duplicatePermissionMessage);
        }
        permissionBody.permissions.locallySet = node.permissions.locallySet ? node.permissions.locallySet.concat(permissionList) : permissionList;
        return this.nodeService.updateNode(node.id, permissionBody);
    }
    /**
     * @private
     * @param {?} nodeLocallySet
     * @param {?} permissionListAdded
     * @return {?}
     */
    getDuplicatedPermissions(nodeLocallySet, permissionListAdded) {
        /** @type {?} */
        const duplicatePermissions = [];
        if (nodeLocallySet) {
            permissionListAdded.forEach((/**
             * @param {?} permission
             * @return {?}
             */
            (permission) => {
                /** @type {?} */
                const duplicate = nodeLocallySet.find((/**
                 * @param {?} localPermission
                 * @return {?}
                 */
                (localPermission) => this.isEqualPermission(localPermission, permission)));
                if (duplicate) {
                    duplicatePermissions.push(duplicate);
                }
            }));
        }
        return duplicatePermissions;
    }
    /**
     * @private
     * @param {?} oldPermission
     * @param {?} newPermission
     * @return {?}
     */
    isEqualPermission(oldPermission, newPermission) {
        return oldPermission.accessStatus === newPermission.accessStatus &&
            oldPermission.authorityId === newPermission.authorityId &&
            oldPermission.name === newPermission.name;
    }
    /**
     * @private
     * @param {?} nodes
     * @param {?} nodeRole
     * @return {?}
     */
    transformNodeToPermissionElement(nodes, nodeRole) {
        return nodes.map((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            /** @type {?} */
            const newPermissionElement = (/** @type {?} */ ({
                'authorityId': node.entry.properties['cm:authorityName'] ?
                    node.entry.properties['cm:authorityName'] :
                    node.entry.properties['cm:userName'],
                'name': nodeRole,
                'accessStatus': 'ALLOWED'
            }));
            return newPermissionElement;
        }));
    }
    /**
     * Removes a permission setting from a node.
     * @param {?} node ID of the target node
     * @param {?} permissionToRemove Permission setting to remove
     * @return {?} Node with modified permissions
     */
    removePermission(node, permissionToRemove) {
        /** @type {?} */
        const permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        const index = node.permissions.locallySet.map((/**
         * @param {?} permission
         * @return {?}
         */
        (permission) => permission.authorityId)).indexOf(permissionToRemove.authorityId);
        if (index !== -1) {
            node.permissions.locallySet.splice(index, 1);
            permissionBody.permissions.locallySet = node.permissions.locallySet;
            return this.nodeService.updateNode(node.id, permissionBody);
        }
    }
    /**
     * @private
     * @param {?} siteName
     * @return {?}
     */
    getGroupMembersBySiteName(siteName) {
        /** @type {?} */
        const groupName = 'GROUP_site_' + siteName;
        return this.getGroupMemberByGroupName(groupName)
            .pipe(map((/**
         * @param {?} groupMemberPaging
         * @return {?}
         */
        (groupMemberPaging) => {
            /** @type {?} */
            const displayResult = [];
            groupMemberPaging.list.entries.forEach((/**
             * @param {?} member
             * @return {?}
             */
            (member) => {
                displayResult.push(this.formattedRoleName(member.entry.displayName, 'site_' + siteName));
            }));
            return displayResult;
        })));
    }
    /**
     * Gets all members related to a group name.
     * @param {?} groupName Name of group to look for members
     * @param {?=} opts Extra options supported by JS-API
     * @return {?} List of members
     */
    getGroupMemberByGroupName(groupName, opts) {
        return from(this.apiService.groupsApi.getGroupMembers(groupName, opts));
    }
    /**
     * @private
     * @param {?} displayName
     * @param {?} siteName
     * @return {?}
     */
    formattedRoleName(displayName, siteName) {
        return displayName.replace(siteName + '_', '');
    }
    /**
     * @private
     * @param {?} nodePath
     * @return {?}
     */
    buildRetrieveSiteQueryBody(nodePath) {
        /** @type {?} */
        const pathNames = nodePath.map((/**
         * @param {?} node
         * @return {?}
         */
        (node) => 'name: "' + node.name + '"'));
        /** @type {?} */
        const buildedPathNames = pathNames.join(' OR ');
        return {
            'query': {
                'query': buildedPathNames
            },
            'paging': {
                'maxItems': 100,
                'skipCount': 0
            },
            'include': ['aspectNames', 'properties'],
            'filterQueries': [
                {
                    'query': "TYPE:'st:site'"
                }
            ]
        };
    }
}
NodePermissionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NodePermissionService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: SearchService },
    { type: NodesApiService },
    { type: TranslationService }
];
/** @nocollapse */ NodePermissionService.ngInjectableDef = defineInjectable({ factory: function NodePermissionService_Factory() { return new NodePermissionService(inject(AlfrescoApiService), inject(SearchService), inject(NodesApiService), inject(TranslationService)); }, token: NodePermissionService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PermissionListComponent {
    /**
     * @param {?} nodeService
     * @param {?} nodePermissionService
     */
    constructor(nodeService, nodePermissionService) {
        this.nodeService = nodeService;
        this.nodePermissionService = nodePermissionService;
        /**
         * ID of the node whose permissions you want to show.
         */
        this.nodeId = '';
        /**
         * Emitted when the permission is updated.
         */
        this.update = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.fetchNodePermissions();
    }
    /**
     * @return {?}
     */
    reload() {
        this.fetchNodePermissions();
    }
    /**
     * @private
     * @return {?}
     */
    fetchNodePermissions() {
        this.nodeService.getNode(this.nodeId).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.actualNode = node;
            this.permissionList = this.getPermissionList(node);
            this.nodePermissionService.getNodeRoles(node).subscribe((/**
             * @param {?} settableList
             * @return {?}
             */
            (settableList) => {
                this.settableRoles = settableList;
            }));
        }));
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    getPermissionList(node) {
        /** @type {?} */
        const allPermissions = [];
        if (node.permissions.locallySet) {
            node.permissions.locallySet.map((/**
             * @param {?} permissionElement
             * @return {?}
             */
            (permissionElement) => {
                /** @type {?} */
                const permission = new PermissionDisplayModel(permissionElement);
                allPermissions.push(permission);
            }));
        }
        if (node.permissions.inherited) {
            node.permissions.inherited.map((/**
             * @param {?} permissionElement
             * @return {?}
             */
            (permissionElement) => {
                /** @type {?} */
                const permissionInherited = new PermissionDisplayModel(permissionElement);
                permissionInherited.isInherited = true;
                allPermissions.push(permissionInherited);
            }));
        }
        return allPermissions;
    }
    /**
     * @param {?} event
     * @param {?} permissionRow
     * @return {?}
     */
    saveNewRole(event, permissionRow) {
        /** @type {?} */
        const updatedPermissionRole = this.buildUpdatedPermission(event.value, permissionRow);
        this.nodePermissionService.updatePermissionRole(this.actualNode, updatedPermissionRole)
            .subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.update.emit(updatedPermissionRole);
        }));
    }
    /**
     * @private
     * @param {?} newRole
     * @param {?} permissionRow
     * @return {?}
     */
    buildUpdatedPermission(newRole, permissionRow) {
        /** @type {?} */
        const permissionRole = {};
        permissionRole.accessStatus = permissionRow.accessStatus;
        permissionRole.name = newRole;
        permissionRole.authorityId = permissionRow.authorityId;
        return permissionRole;
    }
    /**
     * @param {?} permissionRow
     * @return {?}
     */
    removePermission(permissionRow) {
        this.nodePermissionService.removePermission(this.actualNode, permissionRow).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.update.emit(node);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.error.emit(error)));
    }
}
PermissionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-permission-list',
                template: "<div id=\"adf-permission-display-container\" class=\"adf-display-permission-container\">\n\n    <div *ngIf=\"!permissionList || !permissionList.length\" id=\"adf-no-permissions-template\">\n        <div #ref>\n            <ng-content select=\"adf-no-permission-template\"></ng-content>\n        </div>\n\n        <p *ngIf=\"ref.children.length == 0\">\n            {{ 'PERMISSION_MANAGER.PERMISSION_DISPLAY.NO_PERMISSIONS' | translate }}\n        </p>\n    </div>\n\n    <adf-datatable [rows]=\"permissionList\" class=\"adf-datatable-permission\" *ngIf=\"permissionList && permissionList.length\">\n        <data-columns>\n            <data-column [class] = \"'adf-key-icon'\" key=\"icon\" type=\"icon\" [sortable]=\"false\">\n            </data-column>\n            <data-column [class]= \"'adf-authorityId-label adf-ellipsis-cell adf-expand-cell-2'\" title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.AUTHORITY_ID' | translate}}\" key=\"authorityId\"></data-column>\n            <data-column [class]=\"'adf-ellipsis-cell adf-expand-cell-1'\" title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.ROLE' | translate}}\" key=\"name\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-form-field *ngIf=\"!entry.row.getValue('isInherited') else show_only_label\">\n                        <mat-select id=\"adf-select-role-permission\"\n                                    [placeholder]=\"entry.data.getValue(entry.row, entry.col)\"\n                                    value=\"{{entry.data.getValue(entry.row, entry.col)}}\"\n                                    (selectionChange)=\"saveNewRole($event, entry.row.obj)\">\n                          <mat-option *ngFor=\"let role of settableRoles\" [value]=\"role\">\n                            {{ role }}\n                          </mat-option>\n                        </mat-select>\n                      </mat-form-field>\n                      <ng-template #show_only_label>\n                          <span>{{entry.data.getValue(entry.row, entry.col)}}</span>\n                      </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column [class]=\"'adf-permission-label'\" title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}\" key=\"isInherited\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-chip-list>\n                        <mat-chip [class]=\"'mat-chip mat-primary mat-standard-chip mat-chip-selected adf-inherited-label '\"\n                                  *ngIf=\"!!entry.data.getValue(entry.row, entry.col) else locally_set_chip\"\n                                id=\"adf-permission-inherited-label\"\n                                color=\"primary\" selected=\"true\">{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}</mat-chip>\n                    </mat-chip-list>\n                    <ng-template #locally_set_chip>\n                            <mat-chip-list [class] = \"'adf-locallyset-label'\">\n                                    <mat-chip id=\"adf-permission-locallyset-label\"\n                                              color=\"accent\" selected=\"true\">\n                                              {{'PERMISSION_MANAGER.PERMISSION_DISPLAY.LOCALLY_SET' | translate}}\n                                    </mat-chip>\n                            </mat-chip-list>\n                    </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column [class]=\"'adf-delete-permission'\" key=\"delete\">\n            <ng-template let-entry=\"$implicit\">\n                <button *ngIf=\"!entry.row.getValue('isInherited')\" mat-icon-button color=\"primary\" (click)=\"removePermission(entry.row.obj)\" data-automation-id=\"adf-delete-permission-button\">\n                    <mat-icon>highlight_off</mat-icon>\n                </button>\n            </ng-template>\n        </data-column>\n        </data-columns>\n    </adf-datatable>\n</div>\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
PermissionListComponent.ctorParameters = () => [
    { type: NodesApiService },
    { type: NodePermissionService }
];
PermissionListComponent.propDecorators = {
    nodeId: [{ type: Input }],
    update: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NoPermissionTemplateComponent {
}
NoPermissionTemplateComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-no-permission-template',
                template: '<ng-content></ng-content>'
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InheritPermissionDirective {
    /**
     * @param {?} nodeService
     * @param {?} contentService
     */
    constructor(nodeService, contentService) {
        this.nodeService = nodeService;
        this.contentService = contentService;
        /**
         * Emitted when the node is updated.
         */
        this.updated = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onInheritPermissionClicked() {
        this.nodeService.getNode(this.nodeId).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (this.contentService.hasAllowableOperations(node, AllowableOperationsEnum.UPDATEPERMISSIONS)) {
                /** @type {?} */
                const nodeBody = { permissions: { isInheritanceEnabled: !node.permissions.isInheritanceEnabled } };
                this.nodeService.updateNode(this.nodeId, nodeBody, { include: ['permissions'] }).subscribe((/**
                 * @param {?} nodeUpdated
                 * @return {?}
                 */
                (nodeUpdated) => {
                    this.updated.emit(nodeUpdated);
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                (error) => this.error.emit(error)));
            }
            else {
                this.error.emit('PERMISSION_MANAGER.ERROR.NOT-ALLOWED');
            }
        }));
    }
}
InheritPermissionDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[adf-inherit-permission], mat-button-toggle[adf-inherit-permission]',
                host: {
                    'role': 'button',
                    '(click)': 'onInheritPermissionClicked()'
                }
            },] }
];
/** @nocollapse */
InheritPermissionDirective.ctorParameters = () => [
    { type: NodesApiService },
    { type: ContentService }
];
InheritPermissionDirective.propDecorators = {
    nodeId: [{ type: Input }],
    updated: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AddPermissionComponent {
    /**
     * @param {?} nodePermissionService
     * @param {?} nodeApiService
     * @param {?} contentService
     */
    constructor(nodePermissionService, nodeApiService, contentService) {
        this.nodePermissionService = nodePermissionService;
        this.nodeApiService = nodeApiService;
        this.contentService = contentService;
        /**
         * Emitted when the node is updated successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs during the update.
         */
        this.error = new EventEmitter();
        this.selectedItems = [];
        this.nodeApiService.getNode(this.nodeId).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => this.currentNode = node));
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    onSelect(selection) {
        this.selectedItems = selection;
    }
    /**
     * @return {?}
     */
    isAddEnabled() {
        return this.contentService.hasAllowableOperations(this.currentNode, AllowableOperationsEnum.UPDATEPERMISSIONS) &&
            this.selectedItems.length !== 0;
    }
    /**
     * @return {?}
     */
    applySelection() {
        if (this.contentService.hasAllowableOperations(this.currentNode, AllowableOperationsEnum.UPDATEPERMISSIONS)) {
            this.nodePermissionService.updateNodePermissions(this.nodeId, this.selectedItems)
                .subscribe((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                this.success.emit(node);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                this.error.emit(error);
            }));
        }
    }
}
AddPermissionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-add-permission',
                template: "<adf-add-permission-panel\n    (select)=\"onSelect($event)\">\n</adf-add-permission-panel>\n<div id=\"adf-add-permission-actions\">\n   <button mat-button\n          id=\"adf-add-permission-action-button\"\n          class=\"adf-permission-action\"\n          [disabled]=\"!isAddEnabled()\"\n          (click)=\"applySelection()\">\n     {{'PERMISSION_MANAGER.ADD-PERMISSION.ADD-ACTION' | translate}}\n    </button>\n</div>\n\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
AddPermissionComponent.ctorParameters = () => [
    { type: NodePermissionService },
    { type: NodesApiService },
    { type: ContentService }
];
AddPermissionComponent.propDecorators = {
    nodeId: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AddPermissionDialogComponent {
    /**
     * @param {?} data
     */
    constructor(data) {
        this.data = data;
        this.currentSelection = [];
    }
    /**
     * @param {?} items
     * @return {?}
     */
    onSelect(items) {
        this.currentSelection = items;
    }
    /**
     * @return {?}
     */
    onAddClicked() {
        this.data.confirm.next(this.currentSelection);
        this.data.confirm.complete();
    }
}
AddPermissionDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-add-permission-dialog',
                template: "<h2 mat-dialog-title id=\"add-permission-dialog-title\">\n    {{(data?.title ? data?.title : 'PERMISSION_MANAGER.ADD-PERMISSION.BASE-DIALOG-TITLE') | translate}}\n</h2>\n<mat-dialog-content>\n    <adf-add-permission-panel\n        (select)=\"onSelect($event)\">\n    </adf-add-permission-panel>\n</mat-dialog-content>\n<mat-dialog-actions>\n    <button mat-button mat-dialog-close id=\"add-permission-dialog-close-button\">{{'PERMISSION_MANAGER.ADD-PERMISSION.CLOSE-ACTION' | translate}}</button>\n    <button mat-button id=\"add-permission-dialog-confirm-button\" [mat-dialog-close]=\"true\"\n            class=\"adf-choose-action\"\n            [disabled]=\"currentSelection?.length === 0\"\n            (click)=\"onAddClicked()\">{{'PERMISSION_MANAGER.ADD-PERMISSION.ADD-ACTION' | translate}}</button>\n</mat-dialog-actions>\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
AddPermissionDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
AddPermissionDialogComponent.propDecorators = {
    addPermissionComponent: [{ type: ViewChild, args: ['addPermission',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodePermissionDialogService {
    /**
     * @param {?} dialog
     * @param {?} nodePermissionService
     * @param {?} contentService
     */
    constructor(dialog, nodePermissionService, contentService) {
        this.dialog = dialog;
        this.nodePermissionService = nodePermissionService;
        this.contentService = contentService;
    }
    /**
     * Opens a dialog to add permissions to a node.
     * @param {?} node ID of the target node
     * @param {?=} title Dialog title
     * @return {?} Node with updated permissions
     */
    openAddPermissionDialog(node, title) {
        if (this.contentService.hasAllowableOperations(node, AllowableOperationsEnum.UPDATEPERMISSIONS)) {
            /** @type {?} */
            const confirm = new Subject();
            confirm.subscribe({
                complete: this.close.bind(this)
            });
            /** @type {?} */
            const data = {
                nodeId: node.id,
                title: title,
                confirm: confirm
            };
            this.openDialog(data, 'adf-add-permission-dialog', '630px');
            return confirm;
        }
        else {
            /** @type {?} */
            const errors = new Error(JSON.stringify({ error: { statusCode: 403 } }));
            errors.message = 'PERMISSION_MANAGER.ERROR.NOT-ALLOWED';
            return throwError(errors);
        }
    }
    /**
     * @private
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    openDialog(data, currentPanelClass, chosenWidth) {
        this.dialog.open(AddPermissionDialogComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
    }
    /**
     * Closes the currently-open dialog.
     * @return {?}
     */
    close() {
        this.dialog.closeAll();
    }
    /**
     * Opens a dialog to update permissions for a node.
     * @param {?=} nodeId ID of the target node
     * @param {?=} title Dialog title
     * @return {?} Node with updated permissions
     */
    updateNodePermissionByDialog(nodeId, title) {
        return this.contentService.getNode(nodeId, { include: ['allowableOperations'] })
            .pipe(switchMap((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            return this.openAddPermissionDialog(node.entry, title)
                .pipe(switchMap((/**
             * @param {?} selection
             * @return {?}
             */
            (selection) => {
                return this.nodePermissionService.updateNodePermissions(nodeId, selection);
            })));
        })));
    }
}
NodePermissionDialogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NodePermissionDialogService.ctorParameters = () => [
    { type: MatDialog },
    { type: NodePermissionService },
    { type: ContentService }
];
/** @nocollapse */ NodePermissionDialogService.ngInjectableDef = defineInjectable({ factory: function NodePermissionDialogService_Factory() { return new NodePermissionDialogService(inject(MatDialog$1), inject(NodePermissionService), inject(ContentService)); }, token: NodePermissionDialogService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SearchPermissionConfigurationService {
    constructor() {
    }
    /**
     * @param {?} searchTerm
     * @param {?} maxResults
     * @param {?} skipCount
     * @return {?}
     */
    generateQueryBody(searchTerm, maxResults, skipCount) {
        /** @type {?} */
        const defaultQueryBody = {
            query: {
                query: searchTerm ? `authorityName:*${searchTerm}* OR userName:*${searchTerm}*` : searchTerm
            },
            include: ['properties', 'aspectNames'],
            paging: {
                maxItems: maxResults,
                skipCount: skipCount
            },
            filterQueries: [
                /*tslint:disable-next-line */
                { query: "TYPE:'cm:authority'" }
            ]
        };
        return defaultQueryBody;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AddPermissionPanelComponent {
    constructor() {
        /**
         * Emitted when a permission list item is selected.
         */
        this.select = new EventEmitter();
        this.searchInput = new FormControl();
        this.searchedWord = '';
        this.debounceSearch = 200;
        this.selectedItems = [];
        this.EVERYONE = new NodeEntry({ entry: { properties: { 'cm:authorityName': 'GROUP_EVERYONE' } } });
        this.searchInput.valueChanges
            .pipe(debounceTime(this.debounceSearch))
            .subscribe((/**
         * @param {?} searchValue
         * @return {?}
         */
        (searchValue) => {
            this.searchedWord = searchValue;
            if (!searchValue) {
                this.search.resetResults();
            }
        }));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    elementClicked(item) {
        if (this.isAlreadySelected(item)) {
            this.selectedItems.splice(this.selectedItems.indexOf(item), 1);
        }
        else {
            this.selectedItems.push(item);
        }
        this.select.emit(this.selectedItems);
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    isAlreadySelected(item) {
        return this.selectedItems.indexOf(item) >= 0;
    }
    /**
     * @return {?}
     */
    clearSearch() {
        this.searchedWord = '';
        this.selectedItems.splice(0, this.selectedItems.length);
        this.search.resetResults();
    }
}
AddPermissionPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-add-permission-panel',
                template: "<mat-form-field floatPlaceholder=\"never\" class=\"adf-permission-search-input\">\n    <input matInput\n        id=\"searchInput\"\n        [formControl]=\"searchInput\"\n        type=\"text\"\n        placeholder=\"{{'PERMISSION_MANAGER.ADD-PERMISSION.SEARCH' | translate}}\"\n        [value]=\"searchedWord\">\n\n    <mat-icon *ngIf=\"searchedWord?.length > 0\"\n        class=\"adf-permission-search-icon\"\n        data-automation-id=\"adf-permission-clear-input\"\n        id=\"adf-permission-clear-input\"\n        matSuffix (click)=\"clearSearch()\">clear\n    </mat-icon>\n\n    <mat-icon *ngIf=\"searchedWord?.length === 0\"\n        class=\"adf-permission-search-icon\"\n        data-automation-id=\"adf-permission-search-icon\"\n        matSuffix>search\n    </mat-icon>\n</mat-form-field>\n\n<div *ngIf=\"searchedWord?.length === 0\" id=\"adf-add-permission-type-search\">\n    <span class=\"adf-permission-start-message\">{{'PERMISSION_MANAGER.ADD-PERMISSION.TYPE-MESSAGE' | translate}}</span>\n</div>\n\n<adf-search #search [searchTerm]=\"searchedWord\"\n        id=\"adf-add-permission-authority-results\"\n        class=\"adf-permission-result-list\"\n        [class.adf-permission-result-list-search]=\"searchedWord.length === 0\">\n<ng-template let-data>\n    <mat-selection-list class=\"adf-permission-result-list-elements\">\n        <mat-list-option\n            id=\"adf-add-permission-group-everyone\"\n            class=\"adf-list-option-item\"\n            (click)=\"elementClicked(EVERYONE)\">\n            <mat-icon mat-list-icon id=\"add-group-icon\">\n                group_add\n            </mat-icon>\n            <p>\n                {{'PERMISSION_MANAGER.ADD-PERMISSION.EVERYONE' | translate}}\n            </p>\n        </mat-list-option>\n\n        <mat-list-option *ngFor=\"let item of data?.list?.entries; let idx = index\"\n                            (click)=\"elementClicked(item)\"\n                            class=\"adf-list-option-item\"\n                            id=\"result_option_{{idx}}\">\n            <mat-icon mat-list-icon id=\"add-group-icon\"\n                      *ngIf=\"item?.entry?.nodeType === 'cm:authorityContainer' else show_person_icon\">\n                      group_add\n            </mat-icon>\n            <ng-template #show_person_icon>\n                <mat-icon id=\"add-person-icon\" mat-list-icon>person_add</mat-icon>\n            </ng-template>\n            <p>\n             {{item.entry?.properties['cm:authorityName']?\n                                    item.entry?.properties['cm:authorityName'] :\n                                    item.entry?.properties['cm:firstName']}}</p>\n        </mat-list-option>\n    </mat-selection-list>\n</ng-template>\n</adf-search>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    { provide: SearchConfigurationService, useClass: SearchPermissionConfigurationService },
                    SearchService
                ],
                styles: [""]
            }] }
];
/** @nocollapse */
AddPermissionPanelComponent.ctorParameters = () => [];
AddPermissionPanelComponent.propDecorators = {
    search: [{ type: ViewChild, args: ['search',] }],
    select: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PermissionManagerModule {
}
PermissionManagerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    SearchModule
                ],
                declarations: [
                    PermissionListComponent,
                    NoPermissionTemplateComponent,
                    AddPermissionPanelComponent,
                    InheritPermissionDirective,
                    AddPermissionComponent,
                    AddPermissionDialogComponent
                ],
                entryComponents: [
                    AddPermissionPanelComponent,
                    AddPermissionComponent,
                    AddPermissionDialogComponent
                ],
                exports: [
                    PermissionListComponent,
                    NoPermissionTemplateComponent,
                    AddPermissionPanelComponent,
                    InheritPermissionDirective,
                    AddPermissionComponent,
                    AddPermissionDialogComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShareDialogComponent {
    /**
     * @param {?} sharedLinksApiService
     * @param {?} dialogRef
     * @param {?} dialog
     * @param {?} nodesApiService
     * @param {?} contentService
     * @param {?} renditionService
     * @param {?} data
     */
    constructor(sharedLinksApiService, dialogRef, dialog, nodesApiService, contentService, renditionService, data) {
        this.sharedLinksApiService = sharedLinksApiService;
        this.dialogRef = dialogRef;
        this.dialog = dialog;
        this.nodesApiService = nodesApiService;
        this.contentService = contentService;
        this.renditionService = renditionService;
        this.data = data;
        this.subscriptions = [];
        this.minDate = moment$1().add(1, 'd');
        this.isFileShared = false;
        this.isDisabled = false;
        this.form = new FormGroup({
            'sharedUrl': new FormControl(''),
            'time': new FormControl({ value: '', disabled: false })
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.canUpdate) {
            this.form.controls['time'].disable();
        }
        this.subscriptions.push(this.form.valueChanges
            .pipe(skip(1), tap((/**
         * @param {?} updates
         * @return {?}
         */
        (updates) => {
            this.updateNode(updates);
        })))
            .subscribe((/**
         * @param {?} updates
         * @return {?}
         */
        (updates) => this.updateEntryExpiryDate(updates))));
        if (this.data.node && this.data.node.entry) {
            this.fileName = this.data.node.entry.name;
            this.baseShareUrl = this.data.baseShareUrl;
            /** @type {?} */
            const properties = this.data.node.entry.properties;
            if (properties && !properties['qshare:sharedId']) {
                this.createSharedLinks(this.data.node.entry.id);
            }
            else {
                this.sharedId = properties['qshare:sharedId'];
                this.isFileShared = true;
                this.updateForm();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => subscription.unsubscribe));
    }
    /**
     * @return {?}
     */
    removeShare() {
        this.deleteSharedLink(this.sharedId);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSlideShareChange(event) {
        if (event.checked) {
            this.createSharedLinks(this.data.node.entry.id);
        }
        else {
            this.openConfirmationDialog();
        }
    }
    /**
     * @return {?}
     */
    get canUpdate() {
        return this.contentService.hasAllowableOperations(this.data.node.entry, 'update');
    }
    /**
     * @private
     * @return {?}
     */
    openConfirmationDialog() {
        this.isFileShared = false;
        this.dialog
            .open(ConfirmDialogComponent, {
            data: {
                title: 'SHARE.CONFIRMATION.DIALOG-TITLE',
                message: 'SHARE.CONFIRMATION.MESSAGE',
                yesLabel: 'SHARE.CONFIRMATION.REMOVE',
                noLabel: 'SHARE.CONFIRMATION.CANCEL'
            },
            minWidth: '250px',
            closeOnNavigation: true
        })
            .beforeClose().subscribe((/**
         * @param {?} deleteSharedLink
         * @return {?}
         */
        (deleteSharedLink) => {
            if (deleteSharedLink) {
                this.deleteSharedLink(this.sharedId);
            }
            else {
                this.isFileShared = true;
            }
        }));
    }
    /**
     * @private
     * @param {?} nodeId
     * @return {?}
     */
    createSharedLinks(nodeId) {
        this.isDisabled = true;
        this.sharedLinksApiService.createSharedLinks(nodeId)
            .subscribe((/**
         * @param {?} sharedLink
         * @return {?}
         */
        (sharedLink) => {
            if (sharedLink.entry) {
                this.sharedId = sharedLink.entry.id;
                this.data.node.entry.properties['qshare:sharedId'] = this.sharedId;
                this.isDisabled = false;
                this.isFileShared = true;
                this.renditionService.generateRenditionForNode(this.data.node.entry.id).subscribe((/**
                 * @return {?}
                 */
                () => { }));
                this.updateForm();
            }
        }), (/**
         * @return {?}
         */
        () => {
            this.isDisabled = false;
            this.isFileShared = false;
        }));
    }
    /**
     * @private
     * @param {?} sharedId
     * @return {?}
     */
    deleteSharedLink(sharedId) {
        this.isDisabled = true;
        this.sharedLinksApiService.deleteSharedLink(sharedId).subscribe((/**
         * @return {?}
         */
        () => {
            this.data.node.entry.properties['qshare:sharedId'] = null;
            this.data.node.entry.properties['qshare:expiryDate'] = null;
            this.dialogRef.close(false);
        }), (/**
         * @return {?}
         */
        () => {
            this.isDisabled = false;
            this.isFileShared = false;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    updateForm() {
        const { entry } = this.data.node;
        /** @type {?} */
        const expiryDate = entry.properties['qshare:expiryDate'];
        this.form.setValue({
            'sharedUrl': `${this.baseShareUrl}${this.sharedId}`,
            'time': expiryDate ? expiryDate : null
        });
    }
    /**
     * @private
     * @param {?} updates
     * @return {?}
     */
    updateNode(updates) {
        return this.nodesApiService.updateNode(this.data.node.entry.id, {
            properties: {
                'qshare:expiryDate': updates.time ? updates.time.utc().format() : null
            }
        });
    }
    /**
     * @private
     * @param {?} updates
     * @return {?}
     */
    updateEntryExpiryDate(updates) {
        const { properties } = this.data.node.entry;
        properties['qshare:expiryDate'] = updates.time
            ? updates.time.local()
            : null;
    }
}
ShareDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-share-dialog',
                template: "<div class=\"adf-share-link__dialog-content\">\n    <h1 data-automation-id=\"adf-share-dialog-title\"\n        class=\"adf-share-link__title\">\n        {{ 'SHARE.DIALOG-TITLE' | translate }} {{ fileName }}\n    </h1>\n\n    <mat-dialog-content>\n        <p class=\"adf-share-link__info\">{{ 'SHARE.DESCRIPTION' | translate }}</p>\n\n        <div class=\"adf-share-link--row\">\n            <h1 class=\"adf-share-link__label\">{{ 'SHARE.TITLE' | translate }}</h1>\n\n            <mat-slide-toggle\n                color=\"primary\"\n                data-automation-id=\"adf-share-toggle\"\n                [checked]=\"isFileShared\"\n                [disabled]=\"!canUpdate || isDisabled\"\n                (change)=\"onSlideShareChange($event)\">\n            </mat-slide-toggle>\n        </div>\n\n        <form [formGroup]=\"form\">\n            <mat-form-field class=\"adf-full-width\">\n                <input #sharedLinkInput\n                    data-automation-id=\"adf-share-link\"\n                    class=\"adf-share-link__input\"\n                    matInput\n                    cdkFocusInitial\n                    placeholder=\"{{ 'SHARE.PUBLIC-LINK' | translate }}\"\n                    formControlName=\"sharedUrl\"\n                    readonly=\"readonly\">\n                    <mat-icon class=\"adf-input-action\" matSuffix\n                          [clipboard-notification]=\"'SHARE.CLIPBOARD-MESSAGE' | translate\"\n                          [adf-clipboard] [target]=\"sharedLinkInput\">\n                        link\n                    </mat-icon>\n            </mat-form-field>\n\n            <h1 class=\"adf-share-link__label\">{{ 'SHARE.EXPIRES' | translate }}</h1>\n            <mat-form-field class=\"adf-full-width\">\n                <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\n                <mat-datetimepicker #datetimePicker type=\"datetime\" openOnFocus=\"true\" timeInterval=\"1\"></mat-datetimepicker>\n                <input class=\"adf-share-link__input\"\n                    matInput\n                    [min]=\"minDate\"\n                    formControlName=\"time\"\n                    [matDatetimepicker]=\"datetimePicker\">\n            </mat-form-field>\n        </form>\n    </mat-dialog-content>\n\n    <div mat-dialog-actions>\n        <button\n            data-automation-id=\"adf-share-dialog-close\"\n            mat-button color=\"primary\" mat-dialog-close>\n            {{ 'SHARE.CLOSE' | translate }}\n        </button>\n    </div>\n</div>\n",
                host: { 'class': 'adf-share-dialog' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-share-link-dialog .adf-share-link__dialog-content{display:flex;flex-direction:column}.adf-share-link-dialog .adf-share-link__label{letter-spacing:-.4px;line-height:2;font-weight:400;font-style:normal;font-stretch:normal;font-size:16px;opacity:.87;flex:1 1 auto}.adf-share-link-dialog .adf-share-link__title{letter-spacing:-.4px;line-height:2;font-weight:400;font-style:normal;font-stretch:normal;font-size:16px;opacity:.87}.adf-share-link-dialog .adf-share-link__info{letter-spacing:-.4px;line-height:2;font-weight:400;font-style:normal;font-stretch:normal;opacity:.87;opacity:.54;font-size:13px}.adf-share-link-dialog .adf-share-link--row{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center}.adf-share-link-dialog .adf-share-link__input{opacity:.54}.adf-share-link-dialog .adf-input-action{cursor:pointer}.adf-share-link-dialog .adf-full-width{width:100%}.adf-share-link-dialog .mat-form-field-infix{border-top:unset}.adf-share-link-dialog .mat-dialog-actions{justify-content:flex-end}.adf-share-link-dialog .mat-dialog-actions>button{text-transform:uppercase}.adf-share-link-dialog .mat-form-field-flex{align-items:center}"]
            }] }
];
/** @nocollapse */
ShareDialogComponent.ctorParameters = () => [
    { type: SharedLinksApiService },
    { type: MatDialogRef },
    { type: MatDialog },
    { type: NodesApiService },
    { type: ContentService },
    { type: RenditionsService },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
ShareDialogComponent.propDecorators = {
    sharedLinkInput: [{ type: ViewChild, args: ['sharedLinkInput',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NodeSharedDirective {
    /**
     * @param {?} dialog
     * @param {?} zone
     */
    constructor(dialog, zone) {
        this.dialog = dialog;
        this.zone = zone;
        this.isFile = false;
        this.isShared = false;
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.node) {
            this.shareNode(this.node);
        }
    }
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    shareNode(nodeEntry) {
        if (nodeEntry && nodeEntry.entry && nodeEntry.entry.isFile) {
            this.dialog.open(ShareDialogComponent, {
                width: '600px',
                panelClass: 'adf-share-link-dialog',
                data: {
                    node: nodeEntry,
                    baseShareUrl: this.baseShareUrl
                }
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.zone.onStable.subscribe((/**
         * @return {?}
         */
        () => {
            if (this.node && this.node.entry) {
                this.isFile = this.node.entry.isFile;
                this.isShared = this.node.entry.properties['qshare:sharedId'];
            }
        }));
    }
}
NodeSharedDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-share]',
                exportAs: 'adfShare'
            },] }
];
/** @nocollapse */
NodeSharedDirective.ctorParameters = () => [
    { type: MatDialog },
    { type: NgZone }
];
NodeSharedDirective.propDecorators = {
    node: [{ type: Input, args: ['adf-share',] }],
    baseShareUrl: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentNodeShareModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ContentNodeShareModule
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: ContentNodeShareModule
        };
    }
}
ContentNodeShareModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    ShareDialogComponent,
                    NodeSharedDirective
                ],
                exports: [
                    ShareDialogComponent,
                    NodeSharedDirective
                ],
                entryComponents: [
                    ShareDialogComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeBaseNode {
    /**
     * @param {?} nodeEntry
     * @param {?=} level
     * @param {?=} expandable
     */
    constructor(nodeEntry, level, expandable) {
        this.expandable = true;
        this.name = nodeEntry.entry.name;
        this.nodeId = nodeEntry.entry.id;
        this.level = level ? level : 0;
        this.expandable = expandable ? expandable : true;
        this.node = nodeEntry ? new NodeEntry(nodeEntry) : undefined;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeViewService {
    /**
     * @param {?} nodeApi
     */
    constructor(nodeApi) {
        this.nodeApi = nodeApi;
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    getTreeNodes(nodeId) {
        return this.nodeApi.getNodeChildren(nodeId)
            .pipe(map((/**
         * @param {?} nodePage
         * @return {?}
         */
        (nodePage) => {
            return nodePage.list.entries.filter((/**
             * @param {?} node
             * @return {?}
             */
            (node) => node.entry.isFolder ? node : null));
        })), map((/**
         * @param {?} nodes
         * @return {?}
         */
        (nodes) => nodes.map((/**
         * @param {?} node
         * @return {?}
         */
        (node) => new TreeBaseNode(node))))));
    }
}
TreeViewService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TreeViewService.ctorParameters = () => [
    { type: NodesApiService }
];
/** @nocollapse */ TreeViewService.ngInjectableDef = defineInjectable({ factory: function TreeViewService_Factory() { return new TreeViewService(inject(NodesApiService)); }, token: TreeViewService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeViewDataSource {
    /**
     * @param {?} treeControl
     * @param {?} treeViewService
     */
    constructor(treeControl, treeViewService) {
        this.treeControl = treeControl;
        this.treeViewService = treeViewService;
        this.dataChange = new BehaviorSubject([]);
        this.childrenSubscription = null;
        this.changeSubscription = null;
        this.dataChange.subscribe((/**
         * @param {?} treeNodes
         * @return {?}
         */
        (treeNodes) => this.treeNodes = treeNodes));
    }
    /**
     * @return {?}
     */
    get data() {
        return this.treeNodes;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this.treeControl.dataNodes = value;
        this.dataChange.next(value);
    }
    /**
     * @param {?} collectionViewer
     * @return {?}
     */
    connect(collectionViewer) {
        this.changeSubscription = this.treeControl.expansionModel.onChange.subscribe((/**
         * @param {?} change
         * @return {?}
         */
        (change) => {
            if (((/** @type {?} */ (change))).added &&
                ((/** @type {?} */ (change))).added.length > 0) {
                this.expandTreeNodes((/** @type {?} */ (change)));
            }
            else if (((/** @type {?} */ (change))).removed) {
                this.reduceTreeNodes((/** @type {?} */ (change)));
            }
        }));
        return merge(collectionViewer.viewChange, this.dataChange).pipe(map((/**
         * @return {?}
         */
        () => this.data)));
    }
    /**
     * @return {?}
     */
    disconnect() {
        if (this.childrenSubscription) {
            this.childrenSubscription.unsubscribe();
        }
        if (this.changeSubscription) {
            this.changeSubscription.unsubscribe();
        }
    }
    /**
     * @private
     * @param {?} change
     * @return {?}
     */
    expandTreeNodes(change) {
        change.added.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => this.expandNode(node)));
    }
    /**
     * @private
     * @param {?} change
     * @return {?}
     */
    reduceTreeNodes(change) {
        change.removed.slice().reverse().forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => this.toggleNode(node)));
    }
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    expandNode(node) {
        this.childrenSubscription = this.treeViewService.getTreeNodes(node.nodeId)
            .subscribe((/**
         * @param {?} children
         * @return {?}
         */
        (children) => {
            /** @type {?} */
            const index = this.data.indexOf(node);
            if (!children || index < 0) {
                node.expandable = false;
                return;
            }
            /** @type {?} */
            const nodes = children.map((/**
             * @param {?} actualNode
             * @return {?}
             */
            (actualNode) => {
                actualNode.level = node.level + 1;
                return actualNode;
            }));
            this.data.splice(index + 1, 0, ...nodes);
            this.dataChange.next(this.data);
        }));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    toggleNode(node) {
        /** @type {?} */
        const index = this.data.indexOf(node);
        /** @type {?} */
        let count = 0;
        for (let i = index + 1; i < this.data.length
            && this.data[i].level > node.level; i++, count++) { }
        this.data.splice(index + 1, count);
        this.dataChange.next(this.data);
    }
}
TreeViewDataSource.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TreeViewDataSource.ctorParameters = () => [
    { type: FlatTreeControl },
    { type: TreeViewService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeViewComponent {
    /**
     * @param {?} treeViewService
     */
    constructor(treeViewService) {
        this.treeViewService = treeViewService;
        /**
         * Emitted when a node in the tree view is clicked.
         */
        this.nodeClicked = new EventEmitter();
        /**
         * Emitted when an invalid node id is given.
         */
        this.error = new EventEmitter();
        this.getLevel = (/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.level);
        this.isExpandable = (/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.expandable);
        this.hasChild = (/**
         * @param {?} level
         * @param {?} nodeData
         * @return {?}
         */
        (level, nodeData) => nodeData.expandable);
        this.treeControl = new FlatTreeControl(this.getLevel, this.isExpandable);
        this.dataSource = new TreeViewDataSource(this.treeControl, this.treeViewService);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['nodeId'] && changes['nodeId'].currentValue &&
            changes['nodeId'].currentValue !== changes['nodeId'].previousValue) {
            this.loadTreeNode();
        }
        else {
            this.dataSource.data = [];
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeClicked(node) {
        this.nodeClicked.emit(node);
    }
    /**
     * @private
     * @return {?}
     */
    loadTreeNode() {
        this.treeViewService.getTreeNodes(this.nodeId)
            .subscribe((/**
         * @param {?} treeNode
         * @return {?}
         */
        (treeNode) => {
            this.dataSource.data = treeNode;
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.error.emit(error)));
    }
}
TreeViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tree-view-list',
                template: "<mat-tree class=\"adf-tree-view-main\" [dataSource]=\"dataSource\"\n          [treeControl]=\"treeControl\" *ngIf=\"nodeId; else missingNodeId\">\n    <mat-tree-node class=\"adf-tree-view-node\"\n        *matTreeNodeDef=\"let treeNode\" id=\"{{treeNode.name + '-tree-node'}}\"\n        matTreeNodePadding [matTreeNodePaddingIndent]=\"15\">\n        {{treeNode.name}}\n    </mat-tree-node>\n    <mat-tree-node class=\"adf-tree-view-node\"\n        id=\"{{treeNode.name + '-tree-child-node'}}\" *matTreeNodeDef=\"let treeNode; when: hasChild\"\n        matTreeNodePadding [matTreeNodePaddingIndent]=\"15\">\n        <button id=\"{{'button-'+treeNode.name}}\" (click)=\"onNodeClicked(treeNode.node)\"\n                mat-icon-button [attr.aria-label]=\"'toggle ' + treeNode.filename\" matTreeNodeToggle>\n            <mat-icon class=\"adf-tree-view-icon\">\n                {{treeControl.isExpanded(treeNode) ? 'folder_open' : 'folder'}}\n            </mat-icon>\n        </button>\n        {{treeNode.name}}\n    </mat-tree-node>\n</mat-tree>\n<ng-template #missingNodeId>\n    <div id=\"adf-tree-view-missing-node\">\n        {{'ADF-TREE-VIEW.MISSING-ID' | translate}}\n    </div>\n</ng-template>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
TreeViewComponent.ctorParameters = () => [
    { type: TreeViewService }
];
TreeViewComponent.propDecorators = {
    nodeId: [{ type: Input }],
    nodeClicked: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeViewModule {
}
TreeViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule.forChild()
                ],
                declarations: [
                    TreeViewComponent
                ],
                exports: [
                    TreeViewComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentModuleLazy {
}
ContentModuleLazy.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    SocialModule,
                    TagModule,
                    CommonModule,
                    WebScriptModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DialogModule,
                    SearchModule,
                    DocumentListModule,
                    UploadModule,
                    MaterialModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentNodeShareModule,
                    ContentMetadataModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule,
                    TreeViewModule
                ],
                exports: [
                    SocialModule,
                    TagModule,
                    WebScriptModule,
                    DocumentListModule,
                    UploadModule,
                    SearchModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentNodeShareModule,
                    ContentMetadataModule,
                    DialogModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule,
                    TreeViewModule
                ]
            },] }
];
const ɵ0$2 = {
    name: 'adf-content-services',
    source: 'assets/adf-content-services'
};
class ContentModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ContentModule,
            providers: [
                {
                    provide: TRANSLATION_PROVIDER,
                    multi: true,
                    useValue: {
                        name: 'adf-content-services',
                        source: 'assets/adf-content-services'
                    }
                }
            ]
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: ContentModuleLazy
        };
    }
}
ContentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    SocialModule,
                    TagModule,
                    CommonModule,
                    WebScriptModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DialogModule,
                    SearchModule,
                    DocumentListModule,
                    UploadModule,
                    MaterialModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentNodeShareModule,
                    ContentMetadataModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule,
                    TreeViewModule
                ],
                providers: [
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: ɵ0$2
                    }
                ],
                exports: [
                    SocialModule,
                    TagModule,
                    WebScriptModule,
                    DocumentListModule,
                    UploadModule,
                    SearchModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentNodeShareModule,
                    ContentMetadataModule,
                    DialogModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule,
                    TreeViewModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ContentDirectiveModule, RatingComponent, LikeComponent, RatingService, SocialModule, TagActionsComponent, TagListComponent, TagNodeListComponent, TagService, TagModule, WebscriptComponent, WebScriptModule, DocumentListComponent, NodeEntityEvent, NodeEntryEvent, ContentColumnComponent, ContentColumnListComponent, ContentActionComponent, ContentActionListComponent, LibraryNameColumnComponent, LibraryRoleColumnComponent, LibraryStatusColumnComponent, NameColumnComponent, TrashcanNameColumnComponent, ShareDataTableAdapter, ShareDataRow, FolderActionsService, DocumentActionsService, DocumentListService, NodeActionsService, CustomResourcesService, ContentActionModel, ContentActionTarget, DocumentActionModel, FolderActionModel, NodePaging, NodePagingList, NodeMinimalEntry, Pagination$1 as Pagination, NodeMinimal, UserInfo, ContentInfo, PathInfoEntity, PathElementEntity, PermissionModel, PermissionStyleModel, DocumentListModule, UploadButtonComponent, UploadVersionButtonComponent, FileUploadingDialogComponent, UploadDragAreaComponent, FileUploadingListComponent, FileUploadingListRowComponent, UploadFilesEvent, FileDraggableDirective, FileUploadErrorPipe, UploadBase, UploadModule, SearchQueryBuilderService, SearchComponent, SearchControlComponent, SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR, SearchTriggerDirective, EmptySearchResultComponent, SearchFilterComponent, SearchFilterService, SearchChipListComponent, SearchSortingPickerComponent, ALFRESCO_SEARCH_DIRECTIVES, SearchModule, Relations, DropdownSitesComponent, SitesDropdownModule, BreadcrumbComponent, DropdownBreadcrumbComponent, BreadcrumbModule, VersionListComponent, VersionManagerComponent, VersionUploadComponent, VersionManagerModule, NameLocationCellComponent, ContentNodeSelectorPanelComponent, ContentNodeSelectorComponent, ContentNodeSelectorService, ContentNodeDialogService, ContentNodeSelectorModule, FolderDialogComponent, NodeLockDialogComponent, ConfirmDialogComponent, DialogModule, LibraryDialogComponent, forbidSpecialCharacters, forbidEndingDot, forbidOnlySpaces, FolderCreateDirective, FolderEditDirective, FolderDirectiveModule, ContentMetadataCardComponent, BasicPropertiesService, ContentMetadataService, PropertyDescriptorsService, PropertyGroupTranslatorService, ContentMetadataConfigFactory, IndifferentConfigService, LayoutOrientedConfigService, AspectOrientedConfigService, ContentMetadataModule, PermissionListComponent, NoPermissionTemplateComponent, InheritPermissionDirective, PermissionDisplayModel, NodePermissionDialogService, NodePermissionService, AddPermissionPanelComponent, AddPermissionComponent, AddPermissionDialogComponent, PermissionManagerModule, ShareDialogComponent, NodeSharedDirective, ContentNodeShareModule, TreeViewModule, TreeViewComponent, TreeViewDataSource, TreeBaseNode, TreeViewService, ContentModuleLazy, ContentModule, ContentMetadataComponent as ɵk, NodeLockDirective as ɵc, MaterialModule as ɵb, modules as ɵa, SearchPermissionConfigurationService as ɵl, SearchCheckListComponent as ɵi, SearchDateRangeComponent as ɵj, SearchNumberRangeComponent as ɵh, SearchRadioComponent as ɵf, SearchSliderComponent as ɵg, SearchTextComponent as ɵe, SearchWidgetContainerComponent as ɵd };

//# sourceMappingURL=adf-content-services.js.map