import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { DomSanitizer } from '@angular/platform-browser';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { MatDatetimepickerModule } from '@mat-datetimepicker/core';
import { MatMomentDatetimeModule } from '@mat-datetimepicker/moment';
import { FlexLayoutModule } from '@angular/flex-layout';
import { MatDialog as MatDialog$1 } from '@angular/material/dialog';
import moment$1 from 'moment-es6';
import { MatButtonModule, MatChipsModule, MatDialogModule, MatIconModule, MatCardModule, MatInputModule, MatListModule, MatMenuModule, MatOptionModule, MatProgressBarModule, MatProgressSpinnerModule, MatRippleModule, MatExpansionModule, MatSelectModule, MatCheckboxModule, MatDatepickerModule, MatSlideToggleModule, MatRadioModule, MatSliderModule, MatTreeModule, MAT_DIALOG_DATA, MatDialogRef, MatDialog, MatListItem } from '@angular/material';
import { TranslateModule } from '@ngx-translate/core';
import { __assign, __awaiter, __generator, __spread, __extends, __values, __read } from 'tslib';
import { Observable, from, of, throwError, forkJoin, Subject, BehaviorSubject, merge, fromEvent, defer, iif } from 'rxjs';
import { FlatTreeControl } from '@angular/cdk/tree';
import { SearchRequest, SiteMemberPaging, NodeBodyLock, RatingBody, TagBody, Pagination, Site, RequestSortDefinitionInner, SiteEntry, NodeEntry } from '@alfresco/js-api';
import { catchError, map, switchMap, debounceTime, filter, takeUntil, takeWhile, mergeMap, tap, skip } from 'rxjs/operators';
import { CommonModule, DOCUMENT } from '@angular/common';
import { NgModule, Injectable, Directive, ElementRef, Renderer2, HostListener, Input, Component, ViewEncapsulation, Inject, EventEmitter, Output, ViewChild, NgZone, SecurityContext, Optional, ChangeDetectionStrategy, Pipe, ComponentFactoryResolver, ViewContainerRef, defineInjectable, inject, ContentChild, TemplateRef, forwardRef, ChangeDetectorRef, ViewChildren } from '@angular/core';
import { FormBuilder, FormsModule, ReactiveFormsModule, NG_VALUE_ACCESSOR, FormControl, Validators, FormGroup } from '@angular/forms';
import { AlfrescoApiService, LogService, CoreModule, ObjectDataTableAdapter, TranslationService, ContentService, SearchService, AuthenticationService, ThumbnailService, FileUploadStatus, UploadService, FileModel, FileUtils, ObjectUtils, DataSorting, NodesApiService, AllowableOperationsEnum, MOMENT_DATE_FORMATS, UserPreferenceValues, MomentDateAdapter, UserPreferencesService, CardViewUpdateService, SitesService, AppConfigService, TRANSLATION_PROVIDER, CardViewTextItemModel, CardViewDateItemModel, FileSizePipe, CardViewIntItemModel, CardViewFloatItemModel, CardViewDatetimeItemModel, CardViewBoolItemModel, MultiValuePipe, HighlightDirective, InfinitePaginationComponent, SharedLinksApiService, RenditionsService, SearchConfigurationService, EXTENDIBLE_COMPONENT, NotificationService, DisplayMode, ObjectDataColumn, LockService, DataColumnListComponent, CustomLoadingContentTemplateDirective, CustomNoPermissionTemplateDirective, CustomEmptyContentTemplateDirective, BaseEvent, NodeDownloadDirective } from '@alfresco/adf-core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function modules() {
    return [
        MatButtonModule,
        MatChipsModule,
        MatDialogModule,
        MatIconModule,
        MatCardModule,
        MatInputModule,
        MatListModule,
        MatProgressSpinnerModule,
        MatProgressBarModule,
        MatRippleModule,
        MatMenuModule,
        MatOptionModule,
        MatExpansionModule,
        MatSelectModule,
        MatCheckboxModule,
        MatDatepickerModule,
        MatSlideToggleModule,
        MatRadioModule,
        MatSliderModule,
        MatTreeModule
    ];
}
var MaterialModule = /** @class */ (function () {
    function MaterialModule() {
    }
    MaterialModule.decorators = [
        { type: NgModule, args: [{
                    imports: modules(),
                    exports: modules()
                },] }
    ];
    return MaterialModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DocumentLoaderNode = /** @class */ (function () {
    function DocumentLoaderNode(currentNode, children) {
        this.currentNode = currentNode;
        this.children = children;
    }
    return DocumentLoaderNode;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CustomResourcesService = /** @class */ (function () {
    function CustomResourcesService(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.CREATE_PERMISSION = 'create';
    }
    /**
     * Gets files recently accessed by a user.
     * @param personId ID of the user
     * @param pagination Specifies how to paginate the results
     * @param filters Specifies additional filters to apply (joined with **AND**)
     * @returns List of nodes for the recently used files
     */
    /**
     * Gets files recently accessed by a user.
     * @param {?} personId ID of the user
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} filters Specifies additional filters to apply (joined with **AND**)
     * @return {?} List of nodes for the recently used files
     */
    CustomResourcesService.prototype.getRecentFiles = /**
     * Gets files recently accessed by a user.
     * @param {?} personId ID of the user
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} filters Specifies additional filters to apply (joined with **AND**)
     * @return {?} List of nodes for the recently used files
     */
    function (personId, pagination, filters) {
        var _this = this;
        /** @type {?} */
        var defaultFilter = [
            'TYPE:"content"',
            '-PNAME:"0/wiki"',
            '-TYPE:"app:filelink"',
            '-TYPE:"cm:thumbnail"',
            '-TYPE:"cm:failedThumbnail"',
            '-TYPE:"cm:rating"',
            '-TYPE:"dl:dataList"',
            '-TYPE:"dl:todoList"',
            '-TYPE:"dl:issue"',
            '-TYPE:"dl:contact"',
            '-TYPE:"dl:eventAgenda"',
            '-TYPE:"dl:event"',
            '-TYPE:"dl:task"',
            '-TYPE:"dl:simpletask"',
            '-TYPE:"dl:meetingAgenda"',
            '-TYPE:"dl:location"',
            '-TYPE:"fm:topic"',
            '-TYPE:"fm:post"',
            '-TYPE:"ia:calendarEvent"',
            '-TYPE:"lnk:link"'
        ];
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            _this.apiService.peopleApi.getPerson(personId)
                .then((/**
             * @param {?} person
             * @return {?}
             */
            function (person) {
                /** @type {?} */
                var username = person.entry.id;
                /** @type {?} */
                var filterQueries = [
                    { query: "cm:modified:[NOW/DAY-30DAYS TO NOW/DAY+1DAY]" },
                    { query: "cm:modifier:" + username + " OR cm:creator:" + username },
                    { query: defaultFilter.join(' AND ') }
                ];
                if (filters && filters.length > 0) {
                    filterQueries.push({
                        query: filters.join()
                    });
                }
                /** @type {?} */
                var query = new SearchRequest({
                    query: {
                        query: '*',
                        language: 'afts'
                    },
                    filterQueries: filterQueries,
                    include: ['path', 'properties', 'allowableOperations'],
                    sort: [{
                            type: 'FIELD',
                            field: 'cm:modified',
                            ascending: false
                        }],
                    paging: {
                        maxItems: pagination.maxItems,
                        skipCount: pagination.skipCount
                    }
                });
                return _this.apiService.searchApi.search(query)
                    .then((/**
                 * @param {?} searchResult
                 * @return {?}
                 */
                function (searchResult) {
                    observer.next(searchResult);
                    observer.complete();
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    observer.error(err);
                    observer.complete();
                }));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                observer.error(err);
                observer.complete();
            }));
        })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Gets favorite files for the current user.
     * @param pagination Specifies how to paginate the results
     * @param includeFields List of data field names to include in the results
     * @returns List of favorite files
     */
    /**
     * Gets favorite files for the current user.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of favorite files
     */
    CustomResourcesService.prototype.loadFavorites = /**
     * Gets favorite files for the current user.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of favorite files
     */
    function (pagination, includeFields) {
        var _this = this;
        if (includeFields === void 0) { includeFields = []; }
        /** @type {?} */
        var includeFieldsRequest = this.getIncludesFields(includeFields);
        /** @type {?} */
        var options = {
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: includeFieldsRequest
        };
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            _this.apiService.favoritesApi.getFavorites('-me-', options)
                .then((/**
             * @param {?} result
             * @return {?}
             */
            function (result) {
                /** @type {?} */
                var page = {
                    list: {
                        entries: result.list.entries
                            .map((/**
                         * @param {?} __0
                         * @return {?}
                         */
                        function (_a) {
                            var target = _a.entry.target;
                            return ({
                                entry: target.file || target.folder
                            });
                        }))
                            .map((/**
                         * @param {?} __0
                         * @return {?}
                         */
                        function (_a) {
                            var entry = _a.entry;
                            entry.properties = {
                                'cm:title': entry.title,
                                'cm:description': entry.description
                            };
                            return { entry: entry };
                        })),
                        pagination: result.list.pagination
                    }
                };
                observer.next(page);
                observer.complete();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                observer.error(err);
                observer.complete();
            }));
        })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Gets sites that the current user is a member of.
     * @param pagination Specifies how to paginate the results
     * @returns List of sites
     */
    /**
     * Gets sites that the current user is a member of.
     * @param {?} pagination Specifies how to paginate the results
     * @return {?} List of sites
     */
    CustomResourcesService.prototype.loadMemberSites = /**
     * Gets sites that the current user is a member of.
     * @param {?} pagination Specifies how to paginate the results
     * @return {?} List of sites
     */
    function (pagination) {
        var _this = this;
        /** @type {?} */
        var options = {
            include: ['properties'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            _this.apiService.peopleApi.listSiteMembershipsForPerson('-me-', options)
                .then((/**
             * @param {?} result
             * @return {?}
             */
            function (result) {
                /** @type {?} */
                var page = new SiteMemberPaging({
                    list: {
                        entries: result.list.entries
                            .map((/**
                         * @param {?} __0
                         * @return {?}
                         */
                        function (_a) {
                            var site = _a.entry.site;
                            site.allowableOperations = site.allowableOperations ? site.allowableOperations : [_this.CREATE_PERMISSION];
                            site.name = site.name || site.title;
                            return {
                                entry: site
                            };
                        })),
                        pagination: result.list.pagination
                    }
                });
                observer.next(page);
                observer.complete();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                observer.error(err);
                observer.complete();
            }));
        })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Gets all sites in the repository.
     * @param pagination Specifies how to paginate the results
     * @returns List of sites
     */
    /**
     * Gets all sites in the repository.
     * @param {?} pagination Specifies how to paginate the results
     * @return {?} List of sites
     */
    CustomResourcesService.prototype.loadSites = /**
     * Gets all sites in the repository.
     * @param {?} pagination Specifies how to paginate the results
     * @return {?} List of sites
     */
    function (pagination) {
        var _this = this;
        /** @type {?} */
        var options = {
            include: ['properties', 'aspectNames'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            _this.apiService.sitesApi.getSites(options)
                .then((/**
             * @param {?} page
             * @return {?}
             */
            function (page) {
                page.list.entries.map((/**
                 * @param {?} __0
                 * @return {?}
                 */
                function (_a) {
                    var entry = _a.entry;
                    entry.name = entry.name || entry.title;
                    return { entry: entry };
                }));
                observer.next(page);
                observer.complete();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                observer.error(err);
                observer.complete();
            }));
        })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Gets all items currently in the trash.
     * @param pagination Specifies how to paginate the results
     * @param includeFields List of data field names to include in the results
     * @returns List of deleted items
     */
    /**
     * Gets all items currently in the trash.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of deleted items
     */
    CustomResourcesService.prototype.loadTrashcan = /**
     * Gets all items currently in the trash.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of deleted items
     */
    function (pagination, includeFields) {
        var _this = this;
        if (includeFields === void 0) { includeFields = []; }
        /** @type {?} */
        var includeFieldsRequest = this.getIncludesFields(includeFields);
        /** @type {?} */
        var options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return from(this.apiService.nodesApi.getDeletedNodes(options))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Gets shared links for the current user.
     * @param pagination Specifies how to paginate the results
     * @param includeFields List of data field names to include in the results
     * @returns List of shared links
     */
    /**
     * Gets shared links for the current user.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of shared links
     */
    CustomResourcesService.prototype.loadSharedLinks = /**
     * Gets shared links for the current user.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of shared links
     */
    function (pagination, includeFields) {
        var _this = this;
        if (includeFields === void 0) { includeFields = []; }
        /** @type {?} */
        var includeFieldsRequest = this.getIncludesFields(includeFields);
        /** @type {?} */
        var options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return from(this.apiService.sharedLinksApi.findSharedLinks(options))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Is the folder ID one of the well-known aliases?
     * @param folderId Folder ID name to check
     * @returns True if the ID is a well-known name, false otherwise
     */
    /**
     * Is the folder ID one of the well-known aliases?
     * @param {?} folderId Folder ID name to check
     * @return {?} True if the ID is a well-known name, false otherwise
     */
    CustomResourcesService.prototype.isCustomSource = /**
     * Is the folder ID one of the well-known aliases?
     * @param {?} folderId Folder ID name to check
     * @return {?} True if the ID is a well-known name, false otherwise
     */
    function (folderId) {
        /** @type {?} */
        var isCustomSources = false;
        /** @type {?} */
        var sources = ['-trashcan-', '-sharedlinks-', '-sites-', '-mysites-', '-favorites-', '-recent-'];
        if (sources.indexOf(folderId) > -1) {
            isCustomSources = true;
        }
        return isCustomSources;
    };
    /**
     * Is the folder ID a "-my", "-root-", or "-shared-" alias?
     * @param folderId Folder ID name to check
     * @returns True if the ID is one of the supported sources, false otherwise
     */
    /**
     * Is the folder ID a "-my", "-root-", or "-shared-" alias?
     * @param {?} folderId Folder ID name to check
     * @return {?} True if the ID is one of the supported sources, false otherwise
     */
    CustomResourcesService.prototype.isSupportedSource = /**
     * Is the folder ID a "-my", "-root-", or "-shared-" alias?
     * @param {?} folderId Folder ID name to check
     * @return {?} True if the ID is one of the supported sources, false otherwise
     */
    function (folderId) {
        /** @type {?} */
        var isSupportedSources = false;
        /** @type {?} */
        var sources = ['-my-', '-root-', '-shared-'];
        if (sources.indexOf(folderId) > -1) {
            isSupportedSources = true;
        }
        return isSupportedSources;
    };
    /**
     * Gets a folder's contents.
     * @param nodeId ID of the target folder node
     * @param pagination Specifies how to paginate the results
     * @param includeFields List of data field names to include in the results
     * @returns List of items contained in the folder
     */
    /**
     * Gets a folder's contents.
     * @param {?} nodeId ID of the target folder node
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of items contained in the folder
     */
    CustomResourcesService.prototype.loadFolderByNodeId = /**
     * Gets a folder's contents.
     * @param {?} nodeId ID of the target folder node
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of items contained in the folder
     */
    function (nodeId, pagination, includeFields) {
        if (includeFields === void 0) { includeFields = []; }
        if (nodeId === '-trashcan-') {
            return this.loadTrashcan(pagination, includeFields);
        }
        else if (nodeId === '-sharedlinks-') {
            return this.loadSharedLinks(pagination, includeFields);
        }
        else if (nodeId === '-sites-') {
            return this.loadSites(pagination);
        }
        else if (nodeId === '-mysites-') {
            return this.loadMemberSites(pagination);
        }
        else if (nodeId === '-favorites-') {
            return this.loadFavorites(pagination, includeFields);
        }
        else if (nodeId === '-recent-') {
            return this.getRecentFiles('-me-', pagination);
        }
    };
    // TODO: remove it from here
    /**
     * Gets the contents of one of the well-known aliases in the form of node ID strings.
     * @param nodeId ID of the target folder node
     * @param pagination Specifies how to paginate the results
     * @returns List of node IDs
     */
    // TODO: remove it from here
    /**
     * Gets the contents of one of the well-known aliases in the form of node ID strings.
     * @param {?} nodeId ID of the target folder node
     * @param {?=} pagination Specifies how to paginate the results
     * @return {?} List of node IDs
     */
    CustomResourcesService.prototype.getCorrespondingNodeIds = 
    // TODO: remove it from here
    /**
     * Gets the contents of one of the well-known aliases in the form of node ID strings.
     * @param {?} nodeId ID of the target folder node
     * @param {?=} pagination Specifies how to paginate the results
     * @return {?} List of node IDs
     */
    function (nodeId, pagination) {
        var _this = this;
        if (pagination === void 0) { pagination = {}; }
        if (this.isCustomSource(nodeId)) {
            return this.loadFolderByNodeId(nodeId, pagination)
                .pipe(map((/**
             * @param {?} result
             * @return {?}
             */
            function (result) {
                return result.list.entries.map((/**
                 * @param {?} node
                 * @return {?}
                 */
                function (node) { return _this.getIdFromEntry(node, nodeId); }));
            })));
        }
        else if (nodeId) {
            // cases when nodeId is '-my-', '-root-' or '-shared-'
            return from(this.apiService.nodesApi.getNode(nodeId)
                .then((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return [node.entry.id]; })));
        }
        return of([]);
    };
    /**
     * Chooses the correct ID for a node entry.
     * @param node Node object
     * @param nodeId ID of the node object
     * @returns ID value
     */
    /**
     * Chooses the correct ID for a node entry.
     * @param {?} node Node object
     * @param {?} nodeId ID of the node object
     * @return {?} ID value
     */
    CustomResourcesService.prototype.getIdFromEntry = /**
     * Chooses the correct ID for a node entry.
     * @param {?} node Node object
     * @param {?} nodeId ID of the node object
     * @return {?} ID value
     */
    function (node, nodeId) {
        if (nodeId === '-sharedlinks-') {
            return node.entry.nodeId;
        }
        else if (nodeId === '-sites-' || nodeId === '-mysites-') {
            return node.entry.guid;
        }
        else if (nodeId === '-favorites-') {
            return node.entry.targetGuid;
        }
        else {
            return node.entry.id;
        }
    };
    /**
     * Does the well-known alias have a corresponding node ID?
     * @param nodeId Node to check
     * @returns True if the alias has a corresponding node ID, false otherwise
     */
    /**
     * Does the well-known alias have a corresponding node ID?
     * @param {?} nodeId Node to check
     * @return {?} True if the alias has a corresponding node ID, false otherwise
     */
    CustomResourcesService.prototype.hasCorrespondingNodeIds = /**
     * Does the well-known alias have a corresponding node ID?
     * @param {?} nodeId Node to check
     * @return {?} True if the alias has a corresponding node ID, false otherwise
     */
    function (nodeId) {
        return this.isCustomSource(nodeId) || this.isSupportedSource(nodeId);
    };
    /**
     * @private
     * @param {?} includeFields
     * @return {?}
     */
    CustomResourcesService.prototype.getIncludesFields = /**
     * @private
     * @param {?} includeFields
     * @return {?}
     */
    function (includeFields) {
        return __spread(['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames'], includeFields).filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        function (element, index, array) { return index === array.indexOf(element); }));
    };
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    CustomResourcesService.prototype.handleError = /**
     * @private
     * @param {?} error
     * @return {?}
     */
    function (error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    };
    CustomResourcesService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    CustomResourcesService.ctorParameters = function () { return [
        { type: AlfrescoApiService },
        { type: LogService }
    ]; };
    /** @nocollapse */ CustomResourcesService.ngInjectableDef = defineInjectable({ factory: function CustomResourcesService_Factory() { return new CustomResourcesService(inject(AlfrescoApiService), inject(LogService)); }, token: CustomResourcesService, providedIn: "root" });
    return CustomResourcesService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DocumentListService = /** @class */ (function () {
    function DocumentListService(contentService, apiService, logService, customResourcesService) {
        this.contentService = contentService;
        this.apiService = apiService;
        this.logService = logService;
        this.customResourcesService = customResourcesService;
    }
    /**
     * Deletes a node.
     * @param nodeId ID of the node to delete
     * @returns Empty response when the operation is complete
     */
    /**
     * Deletes a node.
     * @param {?} nodeId ID of the node to delete
     * @return {?} Empty response when the operation is complete
     */
    DocumentListService.prototype.deleteNode = /**
     * Deletes a node.
     * @param {?} nodeId ID of the node to delete
     * @return {?} Empty response when the operation is complete
     */
    function (nodeId) {
        return from(this.apiService.getInstance().nodes.deleteNode(nodeId));
    };
    /**
     * Copy a node to destination node
     *
     * @param nodeId The id of the node to be copied
     * @param targetParentId The id of the folder where the node will be copied
     * @returns NodeEntry for the copied node
     */
    /**
     * Copy a node to destination node
     *
     * @param {?} nodeId The id of the node to be copied
     * @param {?} targetParentId The id of the folder where the node will be copied
     * @return {?} NodeEntry for the copied node
     */
    DocumentListService.prototype.copyNode = /**
     * Copy a node to destination node
     *
     * @param {?} nodeId The id of the node to be copied
     * @param {?} targetParentId The id of the folder where the node will be copied
     * @return {?} NodeEntry for the copied node
     */
    function (nodeId, targetParentId) {
        var _this = this;
        return from(this.apiService.getInstance().nodes.copyNode(nodeId, { targetParentId: targetParentId })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Moves a node to destination node.
     *
     * @param nodeId The id of the node to be moved
     * @param targetParentId The id of the folder where the node will be moved
     * @returns NodeEntry for the moved node
     */
    /**
     * Moves a node to destination node.
     *
     * @param {?} nodeId The id of the node to be moved
     * @param {?} targetParentId The id of the folder where the node will be moved
     * @return {?} NodeEntry for the moved node
     */
    DocumentListService.prototype.moveNode = /**
     * Moves a node to destination node.
     *
     * @param {?} nodeId The id of the node to be moved
     * @param {?} targetParentId The id of the folder where the node will be moved
     * @return {?} NodeEntry for the moved node
     */
    function (nodeId, targetParentId) {
        var _this = this;
        return from(this.apiService.getInstance().nodes.moveNode(nodeId, { targetParentId: targetParentId })).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Gets the folder node with the specified relative name path below the root node.
     * @param folder Path to folder.
     * @param opts Options.
     * @param includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @returns Details of the folder
     */
    /**
     * Gets the folder node with the specified relative name path below the root node.
     * @param {?} folder Path to folder.
     * @param {?=} opts Options.
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    DocumentListService.prototype.getFolder = /**
     * Gets the folder node with the specified relative name path below the root node.
     * @param {?} folder Path to folder.
     * @param {?=} opts Options.
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    function (folder, opts, includeFields) {
        var _this = this;
        if (includeFields === void 0) { includeFields = []; }
        /** @type {?} */
        var rootNodeId = DocumentListService.ROOT_ID;
        if (opts && opts.rootFolderId) {
            rootNodeId = opts.rootFolderId;
        }
        /** @type {?} */
        var includeFieldsRequest = __spread(['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames'], includeFields).filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        function (element, index, array) { return index === array.indexOf(element); }));
        /** @type {?} */
        var params = {
            includeSource: true,
            include: includeFieldsRequest
        };
        if (folder) {
            params.relativePath = folder;
        }
        if (opts) {
            if (opts.maxItems) {
                params.maxItems = opts.maxItems;
            }
            if (opts.skipCount) {
                params.skipCount = opts.skipCount;
            }
            if (opts.where) {
                params.where = opts.where;
            }
        }
        return from(this.apiService.getInstance().nodes.getNodeChildren(rootNodeId, params)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Gets a node via its node ID.
     * @param nodeId ID of the target node
     * @param includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @returns Details of the folder
     */
    /**
     * Gets a node via its node ID.
     * @param {?} nodeId ID of the target node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    DocumentListService.prototype.getNode = /**
     * Gets a node via its node ID.
     * @param {?} nodeId ID of the target node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    function (nodeId, includeFields) {
        if (includeFields === void 0) { includeFields = []; }
        /** @type {?} */
        var includeFieldsRequest = __spread(['path', 'properties', 'allowableOperations', 'permissions'], includeFields).filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        function (element, index, array) { return index === array.indexOf(element); }));
        /** @type {?} */
        var opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return this.contentService.getNode(nodeId, opts);
    };
    /**
     * Gets a folder node via its node ID.
     * @param nodeId ID of the folder node
     * @param includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @returns Details of the folder
     */
    /**
     * Gets a folder node via its node ID.
     * @param {?} nodeId ID of the folder node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    DocumentListService.prototype.getFolderNode = /**
     * Gets a folder node via its node ID.
     * @param {?} nodeId ID of the folder node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    function (nodeId, includeFields) {
        var _this = this;
        if (includeFields === void 0) { includeFields = []; }
        /** @type {?} */
        var includeFieldsRequest = __spread(['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames'], includeFields).filter((/**
         * @param {?} element
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        function (element, index, array) { return index === array.indexOf(element); }));
        /** @type {?} */
        var opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return from(this.apiService.getInstance().nodes.getNode(nodeId, opts)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * @param {?} nodeId
     * @return {?}
     */
    DocumentListService.prototype.isCustomSourceService = /**
     * @param {?} nodeId
     * @return {?}
     */
    function (nodeId) {
        return this.customResourcesService.isCustomSource(nodeId);
    };
    /**
     * @param {?} nodeId
     * @param {?} pagination
     * @param {?} includeFields
     * @param {?=} where
     * @return {?}
     */
    DocumentListService.prototype.loadFolderByNodeId = /**
     * @param {?} nodeId
     * @param {?} pagination
     * @param {?} includeFields
     * @param {?=} where
     * @return {?}
     */
    function (nodeId, pagination, includeFields, where) {
        if (this.customResourcesService.isCustomSource(nodeId)) {
            return this.customResourcesService.loadFolderByNodeId(nodeId, pagination, includeFields).pipe(map((/**
             * @param {?} result
             * @return {?}
             */
            function (result) { return new DocumentLoaderNode(null, result); })));
        }
        else {
            return this.retrieveDocumentNode(nodeId, pagination, includeFields, where);
        }
    };
    /**
     * @private
     * @param {?} nodeId
     * @param {?} pagination
     * @param {?} includeFields
     * @param {?=} where
     * @return {?}
     */
    DocumentListService.prototype.retrieveDocumentNode = /**
     * @private
     * @param {?} nodeId
     * @param {?} pagination
     * @param {?} includeFields
     * @param {?=} where
     * @return {?}
     */
    function (nodeId, pagination, includeFields, where) {
        return forkJoin(this.getFolderNode(nodeId, includeFields), this.getFolder(null, {
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount,
            rootFolderId: nodeId,
            where: where
        }, includeFields)).pipe(map((/**
         * @param {?} results
         * @return {?}
         */
        function (results) { return new DocumentLoaderNode(results[0], results[1]); })));
    };
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    DocumentListService.prototype.handleError = /**
     * @private
     * @param {?} error
     * @return {?}
     */
    function (error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    };
    DocumentListService.ROOT_ID = '-root-';
    DocumentListService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    DocumentListService.ctorParameters = function () { return [
        { type: ContentService },
        { type: AlfrescoApiService },
        { type: LogService },
        { type: CustomResourcesService }
    ]; };
    /** @nocollapse */ DocumentListService.ngInjectableDef = defineInjectable({ factory: function DocumentListService_Factory() { return new DocumentListService(inject(ContentService), inject(AlfrescoApiService), inject(LogService), inject(CustomResourcesService)); }, token: DocumentListService, providedIn: "root" });
    return DocumentListService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentNodeSelectorComponent = /** @class */ (function () {
    function ContentNodeSelectorComponent(data) {
        this.data = data;
        this.buttonActionName = data.actionName ? "NODE_SELECTOR." + data.actionName.toUpperCase() : 'NODE_SELECTOR.CHOOSE';
    }
    /**
     * @return {?}
     */
    ContentNodeSelectorComponent.prototype.close = /**
     * @return {?}
     */
    function () {
        this.data.select.complete();
    };
    /**
     * @param {?} nodeList
     * @return {?}
     */
    ContentNodeSelectorComponent.prototype.onSelect = /**
     * @param {?} nodeList
     * @return {?}
     */
    function (nodeList) {
        this.chosenNode = nodeList;
    };
    /**
     * @return {?}
     */
    ContentNodeSelectorComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.data.select.next(this.chosenNode);
        this.data.select.complete();
    };
    ContentNodeSelectorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-content-node-selector',
                    template: "<header\n    mat-dialog-title\n    data-automation-id=\"content-node-selector-title\">{{data?.title}}\n</header>\n\n<mat-dialog-content>\n    <adf-content-node-selector-panel\n        [currentFolderId]=\"data?.currentFolderId\"\n        [dropdownHideMyFiles]=\"data?.dropdownHideMyFiles\"\n        [dropdownSiteList]=\"data?.dropdownSiteList\"\n        [rowFilter]=\"data?.rowFilter\"\n        [imageResolver]=\"data?.imageResolver\"\n        [isSelectionValid]=\"data?.isSelectionValid\"\n        [breadcrumbTransform]=\"data?.breadcrumbTransform\"\n        [excludeSiteContent]=\"data?.excludeSiteContent\"\n        [where]=\"data?.where\"\n        (select)=\"onSelect($event)\">\n    </adf-content-node-selector-panel>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n    <button\n        mat-button\n        (click)=\"close()\"\n        data-automation-id=\"content-node-selector-actions-cancel\">{{ 'NODE_SELECTOR.CANCEL' | translate }}\n    </button>\n\n    <button mat-button\n        [disabled]=\"!chosenNode\"\n        class=\"adf-choose-action\"\n        (click)=\"onClick()\"\n        data-automation-id=\"content-node-selector-actions-choose\">{{ buttonActionName | translate }}\n    </button>\n</mat-dialog-actions>\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    ContentNodeSelectorComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
    ]; };
    return ContentNodeSelectorComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NodeLockDialogComponent = /** @class */ (function () {
    function NodeLockDialogComponent(formBuilder, dialog, alfrescoApi, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.alfrescoApi = alfrescoApi;
        this.data = data;
        this.node = null;
    }
    /**
     * @return {?}
     */
    NodeLockDialogComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var node = this.data.node;
        this.nodeName = node.name;
        this.form = this.formBuilder.group({
            isLocked: node.isLocked || false,
            allowOwner: node.properties['cm:lockType'] === 'WRITE_LOCK',
            isTimeLock: !!node.properties['cm:expiryDate'],
            time: !!node.properties['cm:expiryDate'] ? moment$1(node.properties['cm:expiryDate']) : moment$1()
        });
    };
    Object.defineProperty(NodeLockDialogComponent.prototype, "lockTimeInSeconds", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            if (this.form.value.isTimeLock) {
                /** @type {?} */
                var duration = moment$1.duration(moment$1(this.form.value.time).diff(moment$1()));
                return duration.asSeconds();
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeLockDialogComponent.prototype, "nodeBodyLock", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return new NodeBodyLock({
                'timeToExpire': this.lockTimeInSeconds,
                'type': this.form.value.allowOwner ? 'ALLOW_OWNER_CHANGES' : 'FULL',
                'lifetime': 'PERSISTENT'
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    NodeLockDialogComponent.prototype.toggleLock = /**
     * @private
     * @return {?}
     */
    function () {
        var _a = this, nodesApi = _a.alfrescoApi.nodesApi, node = _a.data.node;
        if (this.form.value.isLocked) {
            return nodesApi.lockNode(node.id, this.nodeBodyLock);
        }
        return nodesApi.unlockNode(node.id);
    };
    /**
     * @return {?}
     */
    NodeLockDialogComponent.prototype.submit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.toggleLock()
            .then((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            _this.data.node.isLocked = _this.form.value.isLocked;
            _this.dialog.close(node.entry);
        }))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return _this.data.onError(error); }));
    };
    NodeLockDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-node-lock',
                    template: "<h2 mat-dialog-title>\n    {{ 'CORE.FILE_DIALOG.FILE_LOCK' | translate }}\n</h2>\n\n<mat-dialog-content>\n    <br />\n    <form [formGroup]=\"form\" (submit)=\"submit()\">\n        <mat-checkbox  data-automation-id=\"adf-lock-node-checkbox\" class=\"adf-lock-file-name\" [formControl]=\"form.controls['isLocked']\" ngDefaultControl>\n            {{ 'CORE.FILE_DIALOG.FILE_LOCK_CHECKBOX' | translate }} <strong>\"{{ nodeName }}\"</strong>\n        </mat-checkbox>\n\n        <br />\n\n        <div *ngIf=\"form.value.isLocked\">\n            <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['allowOwner']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.ALLOW_OTHERS_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['isTimeLock']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.TIME_LOCK_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-form-field *ngIf=\"form.value.isTimeLock\">\n                <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\n                <mat-datetimepicker #datetimePicker type=\"datetime\" openOnFocus=\"true\" timeInterval=\"1\"></mat-datetimepicker>\n                <input matInput [formControl]=\"form.controls['time']\" [matDatetimepicker]=\"datetimePicker\" required autocomplete=\"false\">\n            </mat-form-field>\n        </div>\n    </form>\n    <br />\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button mat-button mat-dialog-close data-automation-id=\"lock-dialog-btn-cancel\">\n        {{ 'CORE.FILE_DIALOG.CANCEL_BUTTON.LABEL' | translate }}\n    </button>\n\n    <button class=\"adf-dialog-action-button\" mat-button (click)=\"submit()\">\n        {{ 'CORE.FILE_DIALOG.SAVE_BUTTON.LABEL' | translate }}\n    </button>\n</mat-dialog-actions>\n",
                    styles: [".adf-fill-remaining-space{flex:1 1 auto}.adf-full-width,.adf-lock-file-name .mat-checkbox-layout{width:100%}.adf-lock-file-name .mat-checkbox-label{text-overflow:ellipsis;overflow:hidden}.adf-lock-file-name .mat-checkbox-inner-container{margin:auto 8px auto 0}"]
                }] }
    ];
    /** @nocollapse */
    NodeLockDialogComponent.ctorParameters = function () { return [
        { type: FormBuilder },
        { type: MatDialogRef },
        { type: AlfrescoApiService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] }] }
    ]; };
    return NodeLockDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentNodeDialogService = /** @class */ (function () {
    function ContentNodeDialogService(dialog, contentService, documentListService, siteService, translation, thumbnailService) {
        this.dialog = dialog;
        this.contentService = contentService;
        this.documentListService = documentListService;
        this.siteService = siteService;
        this.translation = translation;
        this.thumbnailService = thumbnailService;
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * Opens a file browser at a chosen folder location.
     * @param folderNodeId ID of the folder to use
     * @returns Information about the selected file(s)
     */
    /**
     * Opens a file browser at a chosen folder location.
     * @param {?} folderNodeId ID of the folder to use
     * @return {?} Information about the selected file(s)
     */
    ContentNodeDialogService.prototype.openFileBrowseDialogByFolderId = /**
     * Opens a file browser at a chosen folder location.
     * @param {?} folderNodeId ID of the folder to use
     * @return {?} Information about the selected file(s)
     */
    function (folderNodeId) {
        var _this = this;
        return this.documentListService.getFolderNode(folderNodeId).pipe(switchMap((/**
         * @param {?} nodeEntry
         * @return {?}
         */
        function (nodeEntry) {
            return _this.openUploadFileDialog('Choose', nodeEntry.entry);
        })));
    };
    /**
     * Opens a lock node dialog.
     * @param contentEntry Node to lock
     * @returns Error/status message (if any)
     */
    /**
     * Opens a lock node dialog.
     * @param {?} contentEntry Node to lock
     * @return {?} Error/status message (if any)
     */
    ContentNodeDialogService.prototype.openLockNodeDialog = /**
     * Opens a lock node dialog.
     * @param {?} contentEntry Node to lock
     * @return {?} Error/status message (if any)
     */
    function (contentEntry) {
        var _this = this;
        /** @type {?} */
        var observable = new Subject();
        if (this.contentService.hasAllowableOperations(contentEntry, AllowableOperationsEnum.LOCK)) {
            this.dialog.open(NodeLockDialogComponent, {
                data: {
                    node: contentEntry,
                    onError: (/**
                     * @param {?} error
                     * @return {?}
                     */
                    function (error) {
                        _this.error.emit(error);
                        observable.error(error);
                    })
                },
                width: '400px'
            });
        }
        else {
            observable.error('OPERATION.FAIL.NODE.NO_PERMISSION');
        }
        return observable;
    };
    /**
     * Opens a file browser at a chosen site location.
     * @returns Information about the selected file(s)
     */
    /**
     * Opens a file browser at a chosen site location.
     * @return {?} Information about the selected file(s)
     */
    ContentNodeDialogService.prototype.openFileBrowseDialogBySite = /**
     * Opens a file browser at a chosen site location.
     * @return {?} Information about the selected file(s)
     */
    function () {
        var _this = this;
        return this.siteService.getSites().pipe(switchMap((/**
         * @param {?} response
         * @return {?}
         */
        function (response) {
            return _this.openFileBrowseDialogByFolderId(response.list.entries[0].entry.guid);
        })));
    };
    /**
     * Opens a folder browser at a chosen site location.
     * @returns Information about the selected folder(s)
     */
    /**
     * Opens a folder browser at a chosen site location.
     * @return {?} Information about the selected folder(s)
     */
    ContentNodeDialogService.prototype.openFolderBrowseDialogBySite = /**
     * Opens a folder browser at a chosen site location.
     * @return {?} Information about the selected folder(s)
     */
    function () {
        return this.openFolderBrowseDialogByFolderId('-my-');
    };
    /**
     * Opens a folder browser at a chosen folder location.
     * @param folderNodeId ID of the folder to use
     * @returns Information about the selected folder(s)
     */
    /**
     * Opens a folder browser at a chosen folder location.
     * @param {?} folderNodeId ID of the folder to use
     * @return {?} Information about the selected folder(s)
     */
    ContentNodeDialogService.prototype.openFolderBrowseDialogByFolderId = /**
     * Opens a folder browser at a chosen folder location.
     * @param {?} folderNodeId ID of the folder to use
     * @return {?} Information about the selected folder(s)
     */
    function (folderNodeId) {
        var _this = this;
        return this.documentListService.getFolderNode(folderNodeId).pipe(switchMap((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return _this.openUploadFolderDialog('Choose', node.entry);
        })));
    };
    /**
     * Opens a dialog to copy or move an item to a new location.
     * @param action Name of the action (eg, "Copy" or "Move") to show in the title
     * @param contentEntry Item to be copied or moved
     * @param permission Permission for the operation
     * @param excludeSiteContent The site content that should be filtered out
     * @returns Information about files that were copied/moved
     */
    /**
     * Opens a dialog to copy or move an item to a new location.
     * @param {?} action Name of the action (eg, "Copy" or "Move") to show in the title
     * @param {?} contentEntry Item to be copied or moved
     * @param {?=} permission Permission for the operation
     * @param {?=} excludeSiteContent The site content that should be filtered out
     * @return {?} Information about files that were copied/moved
     */
    ContentNodeDialogService.prototype.openCopyMoveDialog = /**
     * Opens a dialog to copy or move an item to a new location.
     * @param {?} action Name of the action (eg, "Copy" or "Move") to show in the title
     * @param {?} contentEntry Item to be copied or moved
     * @param {?=} permission Permission for the operation
     * @param {?=} excludeSiteContent The site content that should be filtered out
     * @return {?} Information about files that were copied/moved
     */
    function (action, contentEntry, permission, excludeSiteContent) {
        if (this.contentService.hasAllowableOperations(contentEntry, permission)) {
            /** @type {?} */
            var select = new Subject();
            select.subscribe({
                complete: this.close.bind(this)
            });
            /** @type {?} */
            var title = this.getTitleTranslation(action, contentEntry.name);
            /** @type {?} */
            var data = {
                title: title,
                actionName: action,
                currentFolderId: contentEntry.parentId,
                imageResolver: this.imageResolver.bind(this),
                where: '(isFolder=true)',
                isSelectionValid: this.isCopyMoveSelectionValid.bind(this),
                excludeSiteContent: excludeSiteContent || ContentNodeDialogService.nonDocumentSiteContent,
                select: select
            };
            this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
            return select;
        }
        else {
            /** @type {?} */
            var errors = new Error(JSON.stringify({ error: { statusCode: 403 } }));
            return throwError(errors);
        }
    };
    /**
     * Gets the translation of the dialog title.
     * @param action Name of the action to display in the dialog title
     * @param name Name of the item on which the action is being performed
     * @returns Translated version of the title
     */
    /**
     * Gets the translation of the dialog title.
     * @param {?} action Name of the action to display in the dialog title
     * @param {?} name Name of the item on which the action is being performed
     * @return {?} Translated version of the title
     */
    ContentNodeDialogService.prototype.getTitleTranslation = /**
     * Gets the translation of the dialog title.
     * @param {?} action Name of the action to display in the dialog title
     * @param {?} name Name of the item on which the action is being performed
     * @return {?} Translated version of the title
     */
    function (action, name) {
        return this.translation.instant("NODE_SELECTOR." + action.toUpperCase() + "_ITEM", { name: name });
    };
    /**
     * Opens a dialog to choose folders to upload.
     * @param action Name of the action to show in the title
     * @param contentEntry  Item to upload
     * @returns Information about the chosen folder(s)
     */
    /**
     * Opens a dialog to choose folders to upload.
     * @param {?} action Name of the action to show in the title
     * @param {?} contentEntry  Item to upload
     * @return {?} Information about the chosen folder(s)
     */
    ContentNodeDialogService.prototype.openUploadFolderDialog = /**
     * Opens a dialog to choose folders to upload.
     * @param {?} action Name of the action to show in the title
     * @param {?} contentEntry  Item to upload
     * @return {?} Information about the chosen folder(s)
     */
    function (action, contentEntry) {
        /** @type {?} */
        var select = new Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        /** @type {?} */
        var data = {
            title: action + " '" + contentEntry.name + "' to ...",
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.hasAllowableOperationsOnNodeFolder.bind(this),
            where: '(isFolder=true)',
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    };
    /**
     * Opens a dialog to choose a file to upload.
     * @param action Name of the action to show in the title
     * @param contentEntry Item to upload
     * @returns Information about the chosen file(s)
     */
    /**
     * Opens a dialog to choose a file to upload.
     * @param {?} action Name of the action to show in the title
     * @param {?} contentEntry Item to upload
     * @return {?} Information about the chosen file(s)
     */
    ContentNodeDialogService.prototype.openUploadFileDialog = /**
     * Opens a dialog to choose a file to upload.
     * @param {?} action Name of the action to show in the title
     * @param {?} contentEntry Item to upload
     * @return {?} Information about the chosen file(s)
     */
    function (action, contentEntry) {
        /** @type {?} */
        var select = new Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        /** @type {?} */
        var data = {
            title: action + " '" + contentEntry.name + "' to ...",
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.isNodeFile.bind(this),
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    };
    /**
     * @private
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    ContentNodeDialogService.prototype.openContentNodeDialog = /**
     * @private
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    function (data, currentPanelClass, chosenWidth) {
        this.dialog.open(ContentNodeSelectorComponent, { data: data, panelClass: currentPanelClass, width: chosenWidth });
    };
    /**
     * @private
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    ContentNodeDialogService.prototype.imageResolver = /**
     * @private
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    function (row, col) {
        /** @type {?} */
        var entry = row.node.entry;
        if (!this.contentService.hasAllowableOperations(entry, 'create')) {
            return this.thumbnailService.getMimeTypeIcon('disable/folder');
        }
        return null;
    };
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    ContentNodeDialogService.prototype.isNodeFile = /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    function (entry) {
        return entry.isFile;
    };
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    ContentNodeDialogService.prototype.hasAllowableOperationsOnNodeFolder = /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    function (entry) {
        return this.isNodeFolder(entry) && this.contentService.hasAllowableOperations(entry, 'create');
    };
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    ContentNodeDialogService.prototype.isNodeFolder = /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    function (entry) {
        return entry.isFolder;
    };
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    ContentNodeDialogService.prototype.isCopyMoveSelectionValid = /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    function (entry) {
        return this.hasEntityCreatePermission(entry) && !this.isSite(entry);
    };
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    ContentNodeDialogService.prototype.hasEntityCreatePermission = /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    function (entry) {
        return this.contentService.hasAllowableOperations(entry, 'create');
    };
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    ContentNodeDialogService.prototype.isSite = /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    function (entry) {
        return !!entry.guid || entry.nodeType === 'st:site' || entry.nodeType === 'st:sites';
    };
    /** Closes the currently open dialog. */
    /**
     * Closes the currently open dialog.
     * @return {?}
     */
    ContentNodeDialogService.prototype.close = /**
     * Closes the currently open dialog.
     * @return {?}
     */
    function () {
        this.dialog.closeAll();
    };
    ContentNodeDialogService.nonDocumentSiteContent = [
        'blog',
        'calendar',
        'dataLists',
        'discussions',
        'links',
        'wiki'
    ];
    ContentNodeDialogService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ContentNodeDialogService.ctorParameters = function () { return [
        { type: MatDialog },
        { type: ContentService },
        { type: DocumentListService },
        { type: SitesService },
        { type: TranslationService },
        { type: ThumbnailService }
    ]; };
    ContentNodeDialogService.propDecorators = {
        error: [{ type: Output }]
    };
    /** @nocollapse */ ContentNodeDialogService.ngInjectableDef = defineInjectable({ factory: function ContentNodeDialogService_Factory() { return new ContentNodeDialogService(inject(MatDialog$1), inject(ContentService), inject(DocumentListService), inject(SitesService), inject(TranslationService), inject(ThumbnailService)); }, token: ContentNodeDialogService, providedIn: "root" });
    return ContentNodeDialogService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NodeLockDirective = /** @class */ (function () {
    function NodeLockDirective(element, renderer, contentService, contentNodeDialogService) {
        this.element = element;
        this.renderer = renderer;
        this.contentService = contentService;
        this.contentNodeDialogService = contentNodeDialogService;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    NodeLockDirective.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.contentNodeDialogService.openLockNodeDialog(this.node);
    };
    /**
     * @return {?}
     */
    NodeLockDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var hasAllowableOperations = this.contentService.hasAllowableOperations(this.node, AllowableOperationsEnum.LOCK);
        this.renderer.setProperty(this.element.nativeElement, 'disabled', !hasAllowableOperations);
    };
    NodeLockDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[adf-node-lock]'
                },] }
    ];
    /** @nocollapse */
    NodeLockDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: ContentService },
        { type: ContentNodeDialogService }
    ]; };
    NodeLockDirective.propDecorators = {
        node: [{ type: Input, args: ['adf-node-lock',] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return NodeLockDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentDirectiveModule = /** @class */ (function () {
    function ContentDirectiveModule() {
    }
    ContentDirectiveModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule
                    ],
                    declarations: [
                        NodeLockDirective
                    ],
                    exports: [
                        NodeLockDirective
                    ]
                },] }
    ];
    return ContentDirectiveModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RatingService = /** @class */ (function () {
    function RatingService(apiService) {
        this.apiService = apiService;
    }
    /**
     * Gets the current user's rating for a node.
     * @param nodeId Node to get the rating from
     * @param ratingType Type of rating (can be "likes" or "fiveStar")
     * @returns The rating value
     */
    /**
     * Gets the current user's rating for a node.
     * @param {?} nodeId Node to get the rating from
     * @param {?} ratingType Type of rating (can be "likes" or "fiveStar")
     * @return {?} The rating value
     */
    RatingService.prototype.getRating = /**
     * Gets the current user's rating for a node.
     * @param {?} nodeId Node to get the rating from
     * @param {?} ratingType Type of rating (can be "likes" or "fiveStar")
     * @return {?} The rating value
     */
    function (nodeId, ratingType) {
        return from(this.apiService.getInstance().core.ratingsApi.getRating(nodeId, ratingType))
            .pipe(catchError(this.handleError));
    };
    /**
     * Adds the current user's rating for a node.
     * @param nodeId Target node for the rating
     * @param ratingType Type of rating (can be "likes" or "fiveStar")
     * @param vote Rating value (boolean for "likes", numeric 0..5 for "fiveStar")
     * @returns Details about the rating, including the new value
     */
    /**
     * Adds the current user's rating for a node.
     * @param {?} nodeId Target node for the rating
     * @param {?} ratingType Type of rating (can be "likes" or "fiveStar")
     * @param {?} vote Rating value (boolean for "likes", numeric 0..5 for "fiveStar")
     * @return {?} Details about the rating, including the new value
     */
    RatingService.prototype.postRating = /**
     * Adds the current user's rating for a node.
     * @param {?} nodeId Target node for the rating
     * @param {?} ratingType Type of rating (can be "likes" or "fiveStar")
     * @param {?} vote Rating value (boolean for "likes", numeric 0..5 for "fiveStar")
     * @return {?} Details about the rating, including the new value
     */
    function (nodeId, ratingType, vote) {
        /** @type {?} */
        var ratingBody = new RatingBody({
            'id': ratingType,
            'myRating': vote
        });
        return from(this.apiService.getInstance().core.ratingsApi.rate(nodeId, ratingBody))
            .pipe(catchError(this.handleError));
    };
    /**
     * Removes the current user's rating for a node.
     * @param nodeId Target node
     * @param ratingType Type of rating to remove (can be "likes" or "fiveStar")
     * @returns Null response indicating that the operation is complete
     */
    /**
     * Removes the current user's rating for a node.
     * @param {?} nodeId Target node
     * @param {?} ratingType Type of rating to remove (can be "likes" or "fiveStar")
     * @return {?} Null response indicating that the operation is complete
     */
    RatingService.prototype.deleteRating = /**
     * Removes the current user's rating for a node.
     * @param {?} nodeId Target node
     * @param {?} ratingType Type of rating to remove (can be "likes" or "fiveStar")
     * @return {?} Null response indicating that the operation is complete
     */
    function (nodeId, ratingType) {
        return from(this.apiService.getInstance().core.ratingsApi.removeRating(nodeId, ratingType))
            .pipe(catchError(this.handleError));
    };
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    RatingService.prototype.handleError = /**
     * @private
     * @param {?} error
     * @return {?}
     */
    function (error) {
        console.error(error);
        return throwError(error || 'Server error');
    };
    RatingService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    RatingService.ctorParameters = function () { return [
        { type: AlfrescoApiService }
    ]; };
    /** @nocollapse */ RatingService.ngInjectableDef = defineInjectable({ factory: function RatingService_Factory() { return new RatingService(inject(AlfrescoApiService)); }, token: RatingService, providedIn: "root" });
    return RatingService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RatingComponent = /** @class */ (function () {
    function RatingComponent(ratingService) {
        this.ratingService = ratingService;
        this.average = 0;
        this.ratingType = 'fiveStar';
        /**
         * Emitted when the "vote" gets changed.
         */
        this.changeVote = new EventEmitter();
        this.stars = [];
    }
    /**
     * @return {?}
     */
    RatingComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var ratingObserver = this.ratingService.getRating(this.nodeId, this.ratingType);
        ratingObserver.subscribe((/**
         * @param {?} ratingEntry
         * @return {?}
         */
        function (ratingEntry) {
            if (ratingEntry.entry.aggregate) {
                _this.average = ratingEntry.entry.aggregate.average;
                _this.calculateStars();
            }
        }));
        return ratingObserver;
    };
    /**
     * @return {?}
     */
    RatingComponent.prototype.calculateStars = /**
     * @return {?}
     */
    function () {
        this.stars = [];
        for (var i = 0; i < 5; i++) {
            if (i < this.average) {
                this.stars.push({ fill: true });
            }
            else {
                this.stars.push({ fill: false });
            }
        }
        this.changeVote.emit(this.average);
    };
    /**
     * @param {?} vote
     * @return {?}
     */
    RatingComponent.prototype.updateVote = /**
     * @param {?} vote
     * @return {?}
     */
    function (vote) {
        var _this = this;
        this.ratingService.postRating(this.nodeId, this.ratingType, vote).subscribe((/**
         * @param {?} ratingEntry
         * @return {?}
         */
        function (ratingEntry) {
            if (ratingEntry.entry.aggregate) {
                if (_this.average !== ratingEntry.entry.aggregate.average) {
                    _this.average = ratingEntry.entry.aggregate.average;
                    _this.calculateStars();
                }
            }
        }));
    };
    RatingComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-rating',
                    template: "<mat-list id=\"adf-rating-container\" class=\"adf-rating-container\">\n    <mat-list-item class=\"adf-rating-star\" *ngFor=\"let currentRate of stars; let idx = index\">\n            <span id=\"adf-rate-{{idx}}\">\n                <mat-icon id=\"adf-grey-star-{{idx}}\" *ngIf=\"currentRate.fill\" class=\"adf-colored-star\"\n                         (click)=\"updateVote(idx + 1)\">star_rate\n                </mat-icon>\n                <mat-icon id=\"adf-colored-star-{{idx}}\" *ngIf=\"!currentRate.fill\" class=\"adf-grey-star\"\n                         (click)=\"updateVote(idx + 1)\">star_border\n                </mat-icon>\n            </span>\n    </mat-list-item>\n</mat-list>\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [".adf-rating-container{overflow:hidden;width:100%}.adf-rating-container .adf-rating-star{float:left;transition:.3s;padding:1px;cursor:pointer;width:25px!important}.adf-rating-container .adf-rating-star .mat-list-item-content{padding:0 2px!important}.adf-rating-container .adf-colored-star{color:#ffe944}.adf-rating-container .adf-grey-star{color:grey}.adf-rating-container .adf-stars-container{padding:0!important;margin:0!important;display:inline-block}.adf-rating-container .adf-rating-star:hover{-webkit-transform:rotate(13deg) scale(1.2);transform:rotate(13deg) scale(1.2)}"]
                }] }
    ];
    /** @nocollapse */
    RatingComponent.ctorParameters = function () { return [
        { type: RatingService }
    ]; };
    RatingComponent.propDecorators = {
        nodeId: [{ type: Input }],
        changeVote: [{ type: Output }]
    };
    return RatingComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LikeComponent = /** @class */ (function () {
    function LikeComponent(ratingService) {
        this.ratingService = ratingService;
        /**
         * Emitted when the "vote" gets changed.
         */
        this.changeVote = new EventEmitter();
        this.likesCounter = 0;
        this.ratingType = 'likes';
        this.isLike = false;
    }
    /**
     * @return {?}
     */
    LikeComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.clean();
        this.ratingService.getRating(this.nodeId, this.ratingType).subscribe((/**
         * @param {?} ratingEntry
         * @return {?}
         */
        function (ratingEntry) {
            if (ratingEntry.entry.aggregate) {
                _this.likesCounter = ratingEntry.entry.aggregate.numberOfRatings;
                if (ratingEntry.entry.ratedAt) {
                    _this.isLike = true;
                }
            }
        }));
    };
    /**
     * @return {?}
     */
    LikeComponent.prototype.likeClick = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isLike) {
            this.ratingService.deleteRating(this.nodeId, this.ratingType).subscribe((/**
             * @return {?}
             */
            function () {
                _this.likesCounter -= 1;
                _this.isLike = false;
                _this.changeVote.emit(_this.likesCounter);
            }));
        }
        else {
            this.ratingService.postRating(this.nodeId, this.ratingType, true).subscribe((/**
             * @param {?} ratingEntry
             * @return {?}
             */
            function (ratingEntry) {
                _this.likesCounter = ratingEntry.entry.aggregate.numberOfRatings;
                _this.isLike = true;
                _this.changeVote.emit(_this.likesCounter);
            }));
        }
    };
    /**
     * @return {?}
     */
    LikeComponent.prototype.clean = /**
     * @return {?}
     */
    function () {
        this.isLike = false;
        this.likesCounter = 0;
    };
    LikeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-like',
                    template: "<div id=\"adf-like-container\" class=\"adf-like-container\">\n    <div class=\"adf-like\">\n        <span id=\"adf-like-{{nodeId}}\" [ngClass]=\"{'adf-like-select': isLike ,'adf-like-grey': !isLike  }\"\n              (click)=\"likeClick()\">\n            <mat-icon>thumb_up</mat-icon>\n        </span>\n    </div>\n    <div id=\"adf-like-counter\" class=\"adf-like-counter\">{{likesCounter}}</div>\n    <div class=\"adf-left\" *ngIf=\"likesCounter<=1\">Like</div>\n    <div class=\"adf-left\" *ngIf=\"likesCounter>1\">Likes</div>\n</div>\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [".adf-like-container{overflow:hidden;width:100%}.adf-like-container .adf-like{padding:5px;cursor:pointer;float:left;margin:5px 0 5px 5px}.adf-like-container .adf-like-select{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-grey,.adf-like-container .adf-like-select:hover{cursor:pointer;color:grey}.adf-like-container .adf-like-grey:hover{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-counter{float:left;padding:13px 0 0}.adf-like-container .adf-left{float:left;padding:13px 0 0 4px}"]
                }] }
    ];
    /** @nocollapse */
    LikeComponent.ctorParameters = function () { return [
        { type: RatingService }
    ]; };
    LikeComponent.propDecorators = {
        nodeId: [{ type: Input }],
        changeVote: [{ type: Output }]
    };
    return LikeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SocialModule = /** @class */ (function () {
    function SocialModule() {
    }
    SocialModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule
                    ],
                    exports: [
                        RatingComponent,
                        LikeComponent
                    ],
                    declarations: [
                        RatingComponent,
                        LikeComponent
                    ]
                },] }
    ];
    return SocialModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TagService = /** @class */ (function () {
    function TagService(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        /**
         * Emitted when tag information is updated.
         */
        this.refresh = new EventEmitter();
    }
    /**
     * Gets a list of tags added to a node.
     * @param nodeId ID of the target node
     * @returns TagPaging object (defined in JS-API) containing the tags
     */
    /**
     * Gets a list of tags added to a node.
     * @param {?} nodeId ID of the target node
     * @return {?} TagPaging object (defined in JS-API) containing the tags
     */
    TagService.prototype.getTagsByNodeId = /**
     * Gets a list of tags added to a node.
     * @param {?} nodeId ID of the target node
     * @return {?} TagPaging object (defined in JS-API) containing the tags
     */
    function (nodeId) {
        var _this = this;
        return from(this.apiService.getInstance().core.tagsApi.getNodeTags(nodeId)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Gets a list of all the tags already defined in the repository.
     * @param opts Options supported by JS-API
     * @returns TagPaging object (defined in JS-API) containing the tags
     */
    /**
     * Gets a list of all the tags already defined in the repository.
     * @param {?=} opts Options supported by JS-API
     * @return {?} TagPaging object (defined in JS-API) containing the tags
     */
    TagService.prototype.getAllTheTags = /**
     * Gets a list of all the tags already defined in the repository.
     * @param {?=} opts Options supported by JS-API
     * @return {?} TagPaging object (defined in JS-API) containing the tags
     */
    function (opts) {
        var _this = this;
        return from(this.apiService.getInstance().core.tagsApi.getTags(opts))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) { return _this.handleError(err); })));
    };
    /**
     * Adds a tag to a node.
     * @param nodeId ID of the target node
     * @param tagName Name of the tag to add
     * @returns TagEntry object (defined in JS-API) with details of the new tag
     */
    /**
     * Adds a tag to a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tagName Name of the tag to add
     * @return {?} TagEntry object (defined in JS-API) with details of the new tag
     */
    TagService.prototype.addTag = /**
     * Adds a tag to a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tagName Name of the tag to add
     * @return {?} TagEntry object (defined in JS-API) with details of the new tag
     */
    function (nodeId, tagName) {
        var _this = this;
        /** @type {?} */
        var tagBody = new TagBody();
        tagBody.tag = tagName;
        /** @type {?} */
        var observableAdd = from(this.apiService.getInstance().core.tagsApi.addTag(nodeId, tagBody));
        observableAdd.subscribe((/**
         * @param {?} tagEntry
         * @return {?}
         */
        function (tagEntry) {
            _this.refresh.emit(tagEntry);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            _this.handleError(err);
        }));
        return observableAdd;
    };
    /**
     * Removes a tag from a node.
     * @param nodeId ID of the target node
     * @param tag Name of the tag to remove
     * @returns Null object when the operation completes
     */
    /**
     * Removes a tag from a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tag Name of the tag to remove
     * @return {?} Null object when the operation completes
     */
    TagService.prototype.removeTag = /**
     * Removes a tag from a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tag Name of the tag to remove
     * @return {?} Null object when the operation completes
     */
    function (nodeId, tag) {
        var _this = this;
        /** @type {?} */
        var observableRemove = from(this.apiService.getInstance().core.tagsApi.removeTag(nodeId, tag));
        observableRemove.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            _this.refresh.emit(data);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            _this.handleError(err);
        }));
        return observableRemove;
    };
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    TagService.prototype.handleError = /**
     * @private
     * @param {?} error
     * @return {?}
     */
    function (error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    };
    TagService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    TagService.ctorParameters = function () { return [
        { type: AlfrescoApiService },
        { type: LogService }
    ]; };
    TagService.propDecorators = {
        refresh: [{ type: Output }]
    };
    /** @nocollapse */ TagService.ngInjectableDef = defineInjectable({ factory: function TagService_Factory() { return new TagService(inject(AlfrescoApiService), inject(LogService)); }, token: TagService, providedIn: "root" });
    return TagService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * This component, provide a list of the tags relative a node with actions button to add or remove new tag
 */
var TagActionsComponent = /** @class */ (function () {
    function TagActionsComponent(tagService, translateService) {
        this.tagService = tagService;
        this.translateService = translateService;
        /**
         * Emitted when a tag is added successfully.
         */
        this.successAdd = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when an action is chosen.
         */
        this.result = new EventEmitter();
        this.disableAddTag = true;
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    TagActionsComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.tagService.refresh.subscribe((/**
         * @return {?}
         */
        function () {
            _this.refreshTag();
        })));
    };
    /**
     * @return {?}
     */
    TagActionsComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        return this.refreshTag();
    };
    /**
     * @return {?}
     */
    TagActionsComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        function (subscription) { return subscription.unsubscribe(); }));
        this.subscriptions = [];
    };
    /**
     * @return {?}
     */
    TagActionsComponent.prototype.refreshTag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe((/**
             * @param {?} tagPaging
             * @return {?}
             */
            function (tagPaging) {
                _this.tagsEntries = tagPaging.list.entries;
                _this.disableAddTag = false;
                _this.result.emit(_this.tagsEntries);
            }), (/**
             * @return {?}
             */
            function () {
                _this.tagsEntries = null;
                _this.disableAddTag = true;
                _this.result.emit(_this.tagsEntries);
            }));
        }
    };
    /**
     * @return {?}
     */
    TagActionsComponent.prototype.addTag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.searchTag(this.newTagName)) {
            this.translateService.get('TAG.MESSAGES.EXIST').subscribe((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                _this.errorMsg = error;
            }));
            this.error.emit(this.errorMsg);
        }
        else {
            this.tagService.addTag(this.nodeId, this.newTagName).subscribe((/**
             * @return {?}
             */
            function () {
                _this.newTagName = '';
                _this.successAdd.emit(_this.nodeId);
            }));
        }
    };
    /**
     * @param {?} searchTagName
     * @return {?}
     */
    TagActionsComponent.prototype.searchTag = /**
     * @param {?} searchTagName
     * @return {?}
     */
    function (searchTagName) {
        if (this.tagsEntries) {
            return this.tagsEntries.find((/**
             * @param {?} currentTag
             * @return {?}
             */
            function (currentTag) {
                return (searchTagName === currentTag.entry.tag);
            }));
        }
    };
    /**
     * @return {?}
     */
    TagActionsComponent.prototype.cleanErrorMsg = /**
     * @return {?}
     */
    function () {
        this.errorMsg = '';
    };
    /**
     * @param {?} tag
     * @return {?}
     */
    TagActionsComponent.prototype.removeTag = /**
     * @param {?} tag
     * @return {?}
     */
    function (tag) {
        this.tagService.removeTag(this.nodeId, tag);
    };
    TagActionsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-tag-node-actions-list',
                    template: "<mat-list>\n    <mat-list-item *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <div class=\"adf-tag-actions-container\" id=\"tag_delete_{{currentEntry.entry.tag}}\" (click)=\"removeTag(currentEntry.entry.id)\">\n            <div class=\"adf-tag-actions-delete-text\" id=\"tag_name_{{currentEntry.entry.tag}}\">\n                {{currentEntry.entry.tag}}\n            </div>\n            <mat-icon class=\"adf-tag-actions-delete-icon\">delete</mat-icon>\n        </div>\n    </mat-list-item>\n</mat-list>\n<table class=\"adf-full-width\" cellspacing=\"0\">\n    <tr>\n        <td>\n            <mat-form-field class=\"adf-full-width\">\n                <input matInput placeholder=\"{{'TAG.LABEL.NEWTAG' | translate }}\"\n                       type=\"text\"\n                       (keypress)=\"cleanErrorMsg()\"\n                       [(ngModel)]=\"newTagName\"\n                       id=\"new-tag-text\"/>\n                <mat-hint data-automation-id=\"errorMessage\" *ngIf=\"error\" [ngStyle]=\"{'color': 'red'}\" align=\"start\">{{errorMsg}}</mat-hint>\n            </mat-form-field>\n        </td>\n        <td>\n            <button class=\"adf-full-width\" color=\"primary\" id=\"add-tag\" (click)=\"addTag()\" [disabled]=\"disableAddTag\"\n                    mat-raised-button>\n                {{'TAG.BUTTON.ADD' | translate }}\n            </button>\n        </td>\n    </tr>\n</table>\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [".adf-full-width{width:100%}.adf-tag-actions-delete-icon{float:right;cursor:pointer}.adf-tag-actions-delete-text{font-size:16px;float:left}.adf-tag-actions-container{padding:8px 0;height:20px}"]
                }] }
    ];
    /** @nocollapse */
    TagActionsComponent.ctorParameters = function () { return [
        { type: TagService },
        { type: TranslationService }
    ]; };
    TagActionsComponent.propDecorators = {
        nodeId: [{ type: Input }],
        successAdd: [{ type: Output }],
        error: [{ type: Output }],
        result: [{ type: Output }]
    };
    return TagActionsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This component provide a list of all the tag inside the ECM
 */
var TagListComponent = /** @class */ (function () {
    /**
     * Constructor
     * @param tagService
     */
    function TagListComponent(tagService) {
        var _this = this;
        this.tagService = tagService;
        /**
         * Emitted when a tag is selected.
         */
        this.result = new EventEmitter();
        /**
         * Array of tags that are displayed
         */
        this.tagsEntries = [];
        /**
         * Number of items per iteration
         */
        this.size = 10;
        this.isLoading = false;
        this.isSizeMinimum = true;
        this.defaultPagination = {
            skipCount: 0,
            maxItems: this.size,
            hasMoreItems: false
        };
        this.pagination = this.defaultPagination;
        this.tagService.refresh.subscribe((/**
         * @return {?}
         */
        function () {
            _this.tagsEntries = [];
            _this.refreshTag(_this.defaultPagination);
        }));
    }
    /**
     * @return {?}
     */
    TagListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        return this.refreshTag(this.defaultPagination);
    };
    /**
     * @param {?=} opts
     * @return {?}
     */
    TagListComponent.prototype.refreshTag = /**
     * @param {?=} opts
     * @return {?}
     */
    function (opts) {
        var _this = this;
        this.tagService.getAllTheTags(opts).subscribe((/**
         * @param {?} tags
         * @return {?}
         */
        function (tags) {
            _this.tagsEntries = _this.tagsEntries.concat(tags.list.entries);
            _this.pagination = tags.list.pagination;
            _this.result.emit(_this.tagsEntries);
            _this.isLoading = false;
        }));
    };
    /**
     * @return {?}
     */
    TagListComponent.prototype.loadMoreTags = /**
     * @return {?}
     */
    function () {
        if (this.pagination.hasMoreItems) {
            this.isLoading = true;
            this.isSizeMinimum = false;
            this.refreshTag({
                skipCount: this.pagination.skipCount + this.pagination.count,
                maxItems: this.size
            });
        }
    };
    /**
     * @return {?}
     */
    TagListComponent.prototype.loadLessTags = /**
     * @return {?}
     */
    function () {
        this.isSizeMinimum = false;
        this.tagsEntries = this.tagsEntries.slice(0, this.tagsEntries.length - this.pagination.count);
        this.pagination.skipCount = this.pagination.skipCount - this.pagination.count;
        this.pagination.hasMoreItems = true;
        if (this.tagsEntries.length <= this.size) {
            this.isSizeMinimum = true;
        }
    };
    TagListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-tag-list',
                    template: "<mat-chip-list class=\"adf-tag-chips-list\">\n    <div class=\"adf-list-tag\" *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <mat-chip class=\"adf-primary-background-color\">\n            <span id=\"tag_name_{{idx}}\">{{currentEntry.entry.tag}}</span>\n        </mat-chip>\n    </div>\n</mat-chip-list>\n\n<div class=\"adf-tag-list-controls\">\n    <button\n        *ngIf=\"!isSizeMinimum\"\n        [disabled]=\"isLoading\"\n        data-automation-id=\"show-fewer-tags\"\n        mat-icon-button\n        (click)=\"loadLessTags()\">\n        <mat-icon>keyboard_arrow_up</mat-icon>\n    </button>\n    <button\n        *ngIf=\"pagination.hasMoreItems\"\n        [disabled]=\"isLoading\"\n        data-automation-id=\"show-more-tags\"\n        mat-icon-button\n        (click)=\"loadMoreTags()\">\n        <mat-icon>keyboard_arrow_down</mat-icon>\n    </button>\n</div>\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [".adf-tag-chips-list,.adf-tag-chips-list div{display:flex;flex-direction:column}.adf-list-tag{display:block;font-size:16px}.adf-tag-list-controls{margin-top:30px;display:flex;justify-content:center}"]
                }] }
    ];
    /** @nocollapse */
    TagListComponent.ctorParameters = function () { return [
        { type: TagService }
    ]; };
    TagListComponent.propDecorators = {
        result: [{ type: Output }]
    };
    return TagListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * This component, ShowNodeTag a list of the tag on relative a node
 */
var TagNodeListComponent = /** @class */ (function () {
    /**
     * Constructor
     * @param tagService
     */
    function TagNodeListComponent(tagService) {
        var _this = this;
        this.tagService = tagService;
        /**
         * Show delete button
         */
        this.showDelete = true;
        /**
         * Emitted when a tag is selected.
         */
        this.results = new EventEmitter();
        this.tagService.refresh.subscribe((/**
         * @return {?}
         */
        function () {
            _this.refreshTag();
        }));
    }
    /**
     * @return {?}
     */
    TagNodeListComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        return this.refreshTag();
    };
    /**
     * @return {?}
     */
    TagNodeListComponent.prototype.refreshTag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe((/**
             * @param {?} tagPaging
             * @return {?}
             */
            function (tagPaging) {
                _this.tagsEntries = tagPaging.list.entries;
                _this.results.emit(_this.tagsEntries);
            }));
        }
    };
    /**
     * @param {?} tag
     * @return {?}
     */
    TagNodeListComponent.prototype.removeTag = /**
     * @param {?} tag
     * @return {?}
     */
    function (tag) {
        var _this = this;
        this.tagService.removeTag(this.nodeId, tag).subscribe((/**
         * @return {?}
         */
        function () {
            _this.refreshTag();
        }));
    };
    TagNodeListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-tag-node-list',
                    template: "<mat-chip-list>\n    <mat-chip class=\"adf-tag-chips adf-primary-background-color\"\n              *ngFor=\"let currentEntry of tagsEntries; let idx = index\" (removed)=\"removeTag(currentEntry.entry.id)\">\n        <span id=\"tag_name_{{idx}}\">{{currentEntry.entry.tag}}</span>\n        <mat-icon *ngIf=\"showDelete\" id=\"tag_chips_delete_{{currentEntry.entry.tag}}\"\n                  class=\"adf-tag-chips-delete-icon adf-primary-contrast-text-color\" matChipRemove>cancel\n        </mat-icon>\n    </mat-chip>\n</mat-chip-list>\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [".adf-tag-chips-delete{overflow:visible;cursor:pointer;height:17px;width:20px;float:right;border:0;background:0 0;padding:0;margin:-1px 0 0 10px}.adf-tag-chips-delete-icon{font-size:20px;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:20px;width:20px}"]
                }] }
    ];
    /** @nocollapse */
    TagNodeListComponent.ctorParameters = function () { return [
        { type: TagService }
    ]; };
    TagNodeListComponent.propDecorators = {
        nodeId: [{ type: Input }],
        showDelete: [{ type: Input }],
        results: [{ type: Output }]
    };
    return TagNodeListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TagModule = /** @class */ (function () {
    function TagModule() {
    }
    TagModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule,
                        FormsModule,
                        ReactiveFormsModule,
                        CoreModule.forChild()
                    ],
                    exports: [
                        TagActionsComponent,
                        TagListComponent,
                        TagNodeListComponent
                    ],
                    declarations: [
                        TagActionsComponent,
                        TagListComponent,
                        TagNodeListComponent
                    ]
                },] }
    ];
    return TagModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * <adf-webscript-get [scriptPath]="string"
 *                         [scriptArgs]="Object"
 *                         [contextRoot]="string"
 *                         [servicePath]="string"
 *                         [contentType]="JSON|HTML|DATATABLE"
 *                         (success)="customMethod($event)>
 * </adf-webscript-get>
 *
 * This component, provide a get webscript viewer
 *
 * \@InputParam {string} scriptPath path to Web Script (as defined by Web Script)
 * \@InputParam {Object} scriptArgs arguments to pass to Web Script
 * \@InputParam {string} contextRoot path where application is deployed default value 'alfresco'
 * \@InputParam {string} servicePath path where Web Script service is mapped default value 'service'
 * \@InputParam {string} contentType JSON | HTML | DATATABLE | TEXT
 *
 * \@Output - success - The event is emitted when the data are received
 *
 */
var WebscriptComponent = /** @class */ (function () {
    function WebscriptComponent(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        /**
         * Toggles whether to show or hide the data.
         */
        this.showData = true;
        /**
         * Path where the application is deployed
         */
        this.contextRoot = 'alfresco';
        /**
         * Path that the webscript service is mapped to.
         */
        this.servicePath = 'service';
        /**
         * Content type to interpret the data received from the webscript.
         * Can be "JSON" , "HTML" , "DATATABLE" or "TEXT"
         */
        this.contentType = 'TEXT';
        /**
         * Emitted when the operation succeeds. You can get the plain data from
         * the webscript through the **success** event parameter and use it as you
         * need in your application.
         */
        this.success = new EventEmitter();
        this.data = undefined;
        this.showError = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    WebscriptComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        if (this.showData) {
            this.clean();
        }
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        function (resolve, reject) {
            _this.apiService.getInstance().webScript.executeWebScript('GET', _this.scriptPath, _this.scriptArgs, _this.contextRoot, _this.servicePath).then((/**
             * @param {?} webScriptData
             * @return {?}
             */
            function (webScriptData) {
                _this.data = webScriptData;
                if (_this.showData) {
                    if (_this.contentType === 'DATATABLE') {
                        _this.data = _this.showDataAsDataTable(webScriptData);
                    }
                }
                _this.success.emit(_this.data);
                resolve();
            }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                _this.logService.log('Error' + error);
                reject();
            }));
        }));
    };
    /**
     * show the data in a ng2-alfresco-datatable
     *
     * @param data
     *
     * @returns the data as datatable
     */
    /**
     * show the data in a ng2-alfresco-datatable
     *
     * @param {?} data
     *
     * @return {?} the data as datatable
     */
    WebscriptComponent.prototype.showDataAsDataTable = /**
     * show the data in a ng2-alfresco-datatable
     *
     * @param {?} data
     *
     * @return {?} the data as datatable
     */
    function (data) {
        /** @type {?} */
        var datatableData = null;
        try {
            if (!data.schema) {
                data.schema = ObjectDataTableAdapter.generateSchema(data.data);
            }
            if (data.schema && data.schema.length > 0) {
                this.data = new ObjectDataTableAdapter(data.data, data.schema);
            }
        }
        catch (error) {
            this.logService.error('error during the cast as datatable');
        }
        return datatableData;
    };
    /**
     * @return {?}
     */
    WebscriptComponent.prototype.clean = /**
     * @return {?}
     */
    function () {
        this.data = undefined;
    };
    /**
     * @return {?}
     */
    WebscriptComponent.prototype.isDataTableContent = /**
     * @return {?}
     */
    function () {
        return this.contentType === 'DATATABLE';
    };
    WebscriptComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-webscript-get',
                    template: "<div *ngIf=\"showData\">\n    <div *ngIf=\"contentType === 'JSON'\" id=\"webscript-data-JSON\">{{data | json}}</div>\n    <div *ngIf=\"contentType === 'HTML'\" id=\"webscript-data-HTML\" [innerHTML]=\"data\"></div>\n    <div *ngIf=\"contentType === 'TEXT'\" id=\"webscript-data-TEXT\">{{data}}</div>\n    <div *ngIf=\"isDataTableContent()\">\n        <adf-datatable id=\"webscript-datatable-wrapper\" [data]=\"data\"></adf-datatable>\n        <div>\n            <div *ngIf=\"showError\" id=\"error\">{{'WEBSCRIPT.ERROR' | translate: {\n                data: data,\n                contentType: contentType\n                }\n                }}\n            </div>\n        </div>\n    </div>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    WebscriptComponent.ctorParameters = function () { return [
        { type: AlfrescoApiService },
        { type: LogService }
    ]; };
    WebscriptComponent.propDecorators = {
        scriptPath: [{ type: Input }],
        scriptArgs: [{ type: Input }],
        showData: [{ type: Input }],
        contextRoot: [{ type: Input }],
        servicePath: [{ type: Input }],
        contentType: [{ type: Input }],
        success: [{ type: Output }]
    };
    return WebscriptComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WebScriptModule = /** @class */ (function () {
    function WebScriptModule() {
    }
    WebScriptModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule,
                        CoreModule.forChild()
                    ],
                    exports: [
                        WebscriptComponent
                    ],
                    declarations: [
                        WebscriptComponent
                    ]
                },] }
    ];
    return WebScriptModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ShareDataRow = /** @class */ (function () {
    function ShareDataRow(obj, contentService, permissionsStyle, thumbnailService) {
        this.obj = obj;
        this.contentService = contentService;
        this.permissionsStyle = permissionsStyle;
        this.thumbnailService = thumbnailService;
        this.cache = {};
        this.isSelected = false;
        this.cssClass = '';
        if (!obj) {
            throw new Error(ShareDataRow.ERR_OBJECT_NOT_FOUND);
        }
        this.isDropTarget = this.isFolderAndHasPermissionToUpload(obj);
        if (permissionsStyle) {
            this.cssClass = this.getPermissionClass(obj);
        }
    }
    Object.defineProperty(ShareDataRow.prototype, "node", {
        get: /**
         * @return {?}
         */
        function () {
            return this.obj;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.obj = value;
            this.cache = {};
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} nodeEntity
     * @return {?}
     */
    ShareDataRow.prototype.getPermissionClass = /**
     * @param {?} nodeEntity
     * @return {?}
     */
    function (nodeEntity) {
        var _this = this;
        /** @type {?} */
        var permissionsClasses = '';
        this.permissionsStyle.forEach((/**
         * @param {?} currentPermissionsStyle
         * @return {?}
         */
        function (currentPermissionsStyle) {
            if (_this.applyPermissionStyleToFolder(nodeEntity.entry, currentPermissionsStyle) || _this.applyPermissionStyleToFile(nodeEntity.entry, currentPermissionsStyle)) {
                if (_this.contentService.hasAllowableOperations(nodeEntity.entry, currentPermissionsStyle.permission)) {
                    permissionsClasses += " " + currentPermissionsStyle.css;
                }
            }
        }));
        return permissionsClasses;
    };
    /**
     * @private
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    ShareDataRow.prototype.applyPermissionStyleToFile = /**
     * @private
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    function (node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFile && node.isFile);
    };
    /**
     * @private
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    ShareDataRow.prototype.applyPermissionStyleToFolder = /**
     * @private
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    function (node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFolder && node.isFolder);
    };
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    ShareDataRow.prototype.isFolderAndHasPermissionToUpload = /**
     * @param {?} nodeEntry
     * @return {?}
     */
    function (nodeEntry) {
        return this.isFolder(nodeEntry) && this.contentService.hasAllowableOperations(nodeEntry.entry, 'create');
    };
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    ShareDataRow.prototype.isFolder = /**
     * @param {?} nodeEntry
     * @return {?}
     */
    function (nodeEntry) {
        return nodeEntry.entry && nodeEntry.entry.isFolder;
    };
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    ShareDataRow.prototype.cacheValue = /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (key, value) {
        this.cache[key] = value;
        return value;
    };
    /**
     * @param {?} key
     * @return {?}
     */
    ShareDataRow.prototype.getValue = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        if (this.cache[key] !== undefined) {
            return this.cache[key];
        }
        return ObjectUtils.getValue(this.obj.entry, key);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ShareDataRow.prototype.imageErrorResolver = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.obj.entry.content) {
            return this.thumbnailService.getMimeTypeIcon(this.obj.entry.content.mimeType);
        }
    };
    /**
     * @param {?} key
     * @return {?}
     */
    ShareDataRow.prototype.hasValue = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.getValue(key) !== undefined;
    };
    ShareDataRow.ERR_OBJECT_NOT_FOUND = 'Object source not found';
    return ShareDataRow;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ShareDataTableAdapter = /** @class */ (function () {
    function ShareDataTableAdapter(thumbnailService, contentService, schema, sorting, sortingMode) {
        if (schema === void 0) { schema = []; }
        if (sortingMode === void 0) { sortingMode = 'client'; }
        this.thumbnailService = thumbnailService;
        this.contentService = contentService;
        this.ERR_ROW_NOT_FOUND = 'Row not found';
        this.ERR_COL_NOT_FOUND = 'Column not found';
        this.thumbnails = false;
        this.rows = [];
        this.columns = schema || [];
        this.sorting = sorting;
        this.sortingMode = sortingMode;
    }
    Object.defineProperty(ShareDataTableAdapter.prototype, "sortingMode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sortingMode;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = (value || 'client').toLowerCase();
            if (newValue !== 'client' && newValue !== 'server') {
                newValue = 'client';
            }
            this._sortingMode = newValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ShareDataTableAdapter.prototype.getRows = /**
     * @return {?}
     */
    function () {
        return this.rows;
    };
    // TODO: disable this api
    // TODO: disable this api
    /**
     * @param {?} rows
     * @return {?}
     */
    ShareDataTableAdapter.prototype.setRows = 
    // TODO: disable this api
    /**
     * @param {?} rows
     * @return {?}
     */
    function (rows) {
        this.rows = rows || [];
        this.sort();
    };
    /**
     * @return {?}
     */
    ShareDataTableAdapter.prototype.getColumns = /**
     * @return {?}
     */
    function () {
        return this.columns;
    };
    /**
     * @param {?} columns
     * @return {?}
     */
    ShareDataTableAdapter.prototype.setColumns = /**
     * @param {?} columns
     * @return {?}
     */
    function (columns) {
        this.columns = columns || [];
    };
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    ShareDataTableAdapter.prototype.getValue = /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    function (row, col) {
        if (!row) {
            throw new Error(this.ERR_ROW_NOT_FOUND);
        }
        if (!col) {
            throw new Error(this.ERR_COL_NOT_FOUND);
        }
        /** @type {?} */
        var dataRow = (/** @type {?} */ (row));
        /** @type {?} */
        var value = row.getValue(col.key);
        if (dataRow.cache[col.key] !== undefined) {
            return dataRow.cache[col.key];
        }
        if (col.key === '$thumbnail') {
            if (this.imageResolver) {
                /** @type {?} */
                var resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
            /** @type {?} */
            var node = ((/** @type {?} */ (row))).node;
            if (node.entry.isFolder) {
                return this.getFolderIcon(node);
            }
            if (node.entry.isFile) {
                if (this.thumbnails) {
                    return this.thumbnailService.getDocumentThumbnailUrl(node);
                }
            }
            if (node.entry.content) {
                /** @type {?} */
                var mimeType = node.entry.content.mimeType;
                if (mimeType) {
                    return this.thumbnailService.getMimeTypeIcon(mimeType);
                }
            }
            return this.thumbnailService.getDefaultMimeTypeIcon();
        }
        if (col.type === 'image') {
            if (this.imageResolver) {
                /** @type {?} */
                var resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
        }
        return dataRow.cacheValue(col.key, value);
    };
    /**
     * @return {?}
     */
    ShareDataTableAdapter.prototype.getSorting = /**
     * @return {?}
     */
    function () {
        return this.sorting;
    };
    /**
     * @param {?} sorting
     * @return {?}
     */
    ShareDataTableAdapter.prototype.setSorting = /**
     * @param {?} sorting
     * @return {?}
     */
    function (sorting) {
        this.sorting = sorting;
        this.sortRows(this.rows, this.sorting);
    };
    /**
     * @param {?=} key
     * @param {?=} direction
     * @return {?}
     */
    ShareDataTableAdapter.prototype.sort = /**
     * @param {?=} key
     * @param {?=} direction
     * @return {?}
     */
    function (key, direction) {
        /** @type {?} */
        var sorting = this.sorting || new DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    ShareDataTableAdapter.prototype.setFilter = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        this.filter = filter$$1;
    };
    /**
     * @param {?} resolver
     * @return {?}
     */
    ShareDataTableAdapter.prototype.setImageResolver = /**
     * @param {?} resolver
     * @return {?}
     */
    function (resolver) {
        this.imageResolver = resolver;
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    ShareDataTableAdapter.prototype.getFolderIcon = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (this.isSmartFolder(node)) {
            return this.thumbnailService.getMimeTypeIcon('smartFolder');
        }
        else if (this.isRuleFolder(node)) {
            return this.thumbnailService.getMimeTypeIcon('ruleFolder');
        }
        else if (this.isALinkFolder(node)) {
            return this.thumbnailService.getMimeTypeIcon('linkFolder');
        }
        else {
            return this.thumbnailService.getMimeTypeIcon('folder');
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    ShareDataTableAdapter.prototype.isSmartFolder = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var nodeAspects = this.getNodeAspectNames(node);
        return nodeAspects.indexOf('smf:customConfigSmartFolder') > -1 ||
            (nodeAspects.indexOf('smf:systemConfigSmartFolder') > -1);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    ShareDataTableAdapter.prototype.isRuleFolder = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var nodeAspects = this.getNodeAspectNames(node);
        return nodeAspects.indexOf('rule:rules') > -1 ||
            (nodeAspects.indexOf('rule:rules') > -1);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    ShareDataTableAdapter.prototype.isALinkFolder = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var nodeType = node.entry ? node.entry.nodeType : node.nodeType;
        return nodeType === 'app:folderlink';
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    ShareDataTableAdapter.prototype.getNodeAspectNames = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.entry && node.entry.aspectNames ? node.entry.aspectNames : node.aspectNames ? node.aspectNames : [];
    };
    /**
     * @private
     * @param {?} rows
     * @param {?} sorting
     * @return {?}
     */
    ShareDataTableAdapter.prototype.sortRows = /**
     * @private
     * @param {?} rows
     * @param {?} sorting
     * @return {?}
     */
    function (rows, sorting) {
        if (this.sortingMode === 'server') {
            return;
        }
        /** @type {?} */
        var options = {};
        if (sorting && sorting.key && rows && rows.length > 0) {
            if (sorting.key.includes('sizeInBytes') || sorting.key === 'name') {
                options.numeric = true;
            }
            rows.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function (a, b) {
                if (a.node.entry.isFolder !== b.node.entry.isFolder) {
                    return a.node.entry.isFolder ? -1 : 1;
                }
                /** @type {?} */
                var left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                /** @type {?} */
                var right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right, undefined, options)
                    : right.localeCompare(left, undefined, options);
            }));
        }
    };
    /**
     * @param {?} nodePaging
     * @param {?=} merge
     * @return {?}
     */
    ShareDataTableAdapter.prototype.loadPage = /**
     * @param {?} nodePaging
     * @param {?=} merge
     * @return {?}
     */
    function (nodePaging, merge$$1) {
        var _this = this;
        if (merge$$1 === void 0) { merge$$1 = false; }
        /** @type {?} */
        var shareDataRows = [];
        if (nodePaging && nodePaging.list) {
            /** @type {?} */
            var nodeEntries = nodePaging.list.entries;
            if (nodeEntries && nodeEntries.length > 0) {
                shareDataRows = nodeEntries.map((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) { return new ShareDataRow(item, _this.contentService, _this.permissionsStyle, _this.thumbnailService); }));
                if (this.filter) {
                    shareDataRows = shareDataRows.filter(this.filter);
                }
                if (this.sortingMode !== 'server') {
                    // Sort by first sortable or just first column
                    if (this.columns && this.columns.length > 0) {
                        /** @type {?} */
                        var sorting = this.getSorting();
                        if (sorting) {
                            this.sortRows(shareDataRows, sorting);
                        }
                        else {
                            /** @type {?} */
                            var sortable = this.columns.filter((/**
                             * @param {?} c
                             * @return {?}
                             */
                            function (c) { return c.sortable; }));
                            if (sortable.length > 0) {
                                this.sort(sortable[0].key, 'asc');
                            }
                            else {
                                this.sort(this.columns[0].key, 'asc');
                            }
                        }
                    }
                }
            }
        }
        if (merge$$1) {
            /** @type {?} */
            var listPrunedDuplicate = shareDataRows.filter((/**
             * @param {?} elementToFilter
             * @return {?}
             */
            function (elementToFilter) {
                /** @type {?} */
                var isPresent = _this.rows.find((/**
                 * @param {?} currentRow
                 * @return {?}
                 */
                function (currentRow) {
                    return currentRow.obj.entry.id === elementToFilter.obj.entry.id;
                }));
                return !isPresent;
            }));
            this.rows = this.rows.concat(listPrunedDuplicate);
        }
        else {
            this.rows = shareDataRows;
        }
    };
    return ShareDataTableAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
var presetsDefaultModel = {
    '-trashcan-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'archivedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'archivedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_BY',
            sortable: true
        }
    ],
    '-sites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-mysites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-favorites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ],
    '-recent-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        }
    ],
    '-sharedlinks-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        },
        {
            key: 'sharedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SHARED_BY',
            sortable: true
        }
    ],
    'default': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ContentActionModel = /** @class */ (function () {
    function ContentActionModel(obj) {
        this.disableWithNoPermission = false;
        this.disabled = false;
        this.visible = true;
        if (obj) {
            this.icon = obj.icon;
            this.title = obj.title;
            this.handler = obj.handler;
            this.execute = obj.execute;
            this.target = obj.target;
            this.permission = obj.permission;
            this.disableWithNoPermission = obj.disableWithNoPermission;
            if (obj.hasOwnProperty('disabled')) {
                this.disabled = obj.disabled;
            }
            if (obj.hasOwnProperty('visible')) {
                this.visible = obj.visible;
            }
        }
    }
    return ContentActionModel;
}());
/** @enum {string} */
var ContentActionTarget = {
    Document: 'document',
    Folder: 'folder',
    All: 'all',
};
var DocumentActionModel = /** @class */ (function (_super) {
    __extends(DocumentActionModel, _super);
    function DocumentActionModel(json) {
        var _this = _super.call(this, json) || this;
        _this.target = 'document';
        return _this;
    }
    return DocumentActionModel;
}(ContentActionModel));
var FolderActionModel = /** @class */ (function (_super) {
    __extends(FolderActionModel, _super);
    function FolderActionModel(json) {
        var _this = _super.call(this, json) || this;
        _this.target = 'folder';
        return _this;
    }
    return FolderActionModel;
}(ContentActionModel));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NodeEntityEvent = /** @class */ (function (_super) {
    __extends(NodeEntityEvent, _super);
    function NodeEntityEvent(nodeEntry) {
        var _this = _super.call(this) || this;
        _this.value = nodeEntry;
        return _this;
    }
    return NodeEntityEvent;
}(BaseEvent));
var NodeEntryEvent = /** @class */ (function (_super) {
    __extends(NodeEntryEvent, _super);
    function NodeEntryEvent(node) {
        var _this = _super.call(this) || this;
        _this.value = node;
        return _this;
    }
    return NodeEntryEvent;
}(BaseEvent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DocumentListComponent = /** @class */ (function () {
    function DocumentListComponent(documentListService, ngZone, elementRef, appConfig, userPreferencesService, contentService, thumbnailService, alfrescoApiService, lockService) {
        var _this = this;
        this.documentListService = documentListService;
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.appConfig = appConfig;
        this.userPreferencesService = userPreferencesService;
        this.contentService = contentService;
        this.thumbnailService = thumbnailService;
        this.alfrescoApiService = alfrescoApiService;
        this.lockService = lockService;
        this.DEFAULT_PAGINATION = new Pagination({
            hasMoreItems: false,
            skipCount: 0,
            maxItems: 25,
            totalItems: 0
        });
        /**
         * Change the display mode of the table. Can be "list" or "gallery".
         */
        this.display = DisplayMode.List;
        /**
         * Define a set of CSS styles to apply depending on the permission
         * of the user on that node. See the Permission Style model
         * page for further details and examples.
         */
        this.permissionsStyle = [];
        /**
         * The default route for all the location-based columns (if declared).
         */
        this.locationFormat = '/';
        /**
         * Toggles navigation to folder content or file preview
         */
        this.navigate = true;
        /**
         * Toggles the header
         */
        this.showHeader = true;
        /**
         * User interaction for folder navigation or file preview.
         * Valid values are "click" and "dblclick". Default value: "dblclick"
         */
        this.navigationMode = DocumentListComponent.DOUBLE_CLICK_NAVIGATION; // click|dblclick
        // click|dblclick
        /**
         * Show document thumbnails rather than icons
         */
        this.thumbnails = false;
        /**
         * Row selection mode. Can be null, `single` or `multiple`. For `multiple` mode,
         * you can use Cmd (macOS) or Ctrl (Win) modifier key to toggle selection for multiple rows.
         */
        this.selectionMode = 'single'; // null|single|multiple
        // null|single|multiple
        /**
         * Toggles multiselect mode
         */
        this.multiselect = false;
        /**
         * Toggles content actions for each row
         */
        this.contentActions = false;
        /**
         * Position of the content actions dropdown menu. Can be set to "left" or "right".
         */
        this.contentActionsPosition = 'right'; // left|right
        // left|right
        /**
         * Toggles context menus for each row
         */
        this.contextMenuActions = false;
        /**
         * Custom image for empty folder. Default value: './assets/images/empty_doc_lib.svg'
         */
        this.emptyFolderImageUrl = './assets/images/empty_doc_lib.svg';
        /**
         * When true, this enables you to drop files directly into subfolders shown
         * as items in the list. When false, the dropped file will be added to the
         * current folder (ie, the one containing all the items shown in the list).
         * See the Upload directive for further details about how the file drop is
         * handled.
         */
        this.allowDropFiles = false;
        /**
         * Defines default sorting. The format is an array of 2 strings `[key, direction]`
         * i.e. `['name', 'desc']` or `['name', 'asc']`. Set this value only if you want to
         * override the default sorting detected by the component based on columns.
         */
        this.sorting = ['name', 'asc'];
        /**
         * Defines sorting mode. Can be either `client` (items in the list
         * are sorted client-side) or `server` (the ordering supplied by the
         * server is used without further client-side sorting).
         * Note that the `server` option *does not* request the server to sort the data
         * before delivering it.
         */
        this.sortingMode = 'client';
        /**
         * Toggles the loading state and animated spinners for the component. Used in
         * combination with `navigate=false` to perform custom navigation and loading
         * state indication.
         */
        this.loading = false;
        /**
         * @hidden
         */
        this._rowFilter = null;
        /**
         * Custom function to choose image file paths to show. See the
         * [Image Resolver Model](image-resolver.model.md) page for
         * more information.
         */
        this.imageResolver = null;
        /**
         * Toggles the sticky header mode.
         */
        this.stickyHeader = false;
        this._currentFolderId = null;
        /**
         * The Document list will show all the nodes contained in the NodePaging entity
         */
        this.node = null;
        /**
         * Default value is stored in the user preference settings. Use this only if you are not using pagination.
         */
        this.maxItems = this.DEFAULT_PAGINATION.maxItems;
        /**
         * Emitted when the user clicks a list node
         */
        this.nodeClick = new EventEmitter();
        /**
         * Emitted when the user double-clicks a list node
         */
        this.nodeDblClick = new EventEmitter();
        /**
         * Emitted when the current display folder changes
         */
        this.folderChange = new EventEmitter();
        /**
         * Emitted when the user acts upon files with either single or double click
         * (depends on `navigation-mode`). Useful for integration with the
         * Viewer component.
         */
        this.preview = new EventEmitter();
        /**
         * Emitted when the Document List has loaded all items and is ready for use
         */
        this.ready = new EventEmitter();
        /**
         * Emitted when the API fails to get the Document List data
         */
        this.error = new EventEmitter();
        this.actions = [];
        this.contextActionHandler = new Subject();
        this.noPermission = false;
        this.selection = new Array();
        this.$folderNode = new Subject();
        this._pagination = this.DEFAULT_PAGINATION;
        this.pagination = new BehaviorSubject(this.DEFAULT_PAGINATION);
        this.layoutPresets = {};
        this.subscriptions = [];
        this.rowMenuCache = {};
        this.userPreferencesService.select(UserPreferenceValues.PaginationSize).subscribe((/**
         * @param {?} pagSize
         * @return {?}
         */
        function (pagSize) {
            _this.maxItems = _this._pagination.maxItems = pagSize;
        }));
    }
    Object.defineProperty(DocumentListComponent.prototype, "rowFilter", {
        get: /**
         * @return {?}
         */
        function () {
            return this._rowFilter;
        },
        /**
         * Custom function to choose whether to show or hide rows.
         * See the [Row Filter Model](row-filter.model.md) page for
         * more information.
         */
        set: /**
         * Custom function to choose whether to show or hide rows.
         * See the [Row Filter Model](row-filter.model.md) page for
         * more information.
         * @param {?} rowFilter
         * @return {?}
         */
        function (rowFilter) {
            this._rowFilter = rowFilter;
            if (this.data) {
                this.data.setFilter(this._rowFilter);
                if (this._currentFolderId) {
                    this.reload();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentListComponent.prototype, "currentFolderId", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currentFolderId;
        },
        /** The ID of the folder node to display or a reserved string alias for special sources */
        set: /**
         * The ID of the folder node to display or a reserved string alias for special sources
         * @param {?} currentFolderId
         * @return {?}
         */
        function (currentFolderId) {
            if (this._currentFolderId !== currentFolderId) {
                this._currentFolderId = currentFolderId;
                if (this.data) {
                    this.data.loadPage(null, false);
                    this.resetNewFolderPagination();
                }
                if (this._currentFolderId) {
                    this.loadFolder();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.getContextActions = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        if (node && node.entry) {
            /** @type {?} */
            var actions = this.getNodeActions(node);
            if (actions && actions.length > 0) {
                return actions.map((/**
                 * @param {?} currentAction
                 * @return {?}
                 */
                function (currentAction) {
                    return {
                        model: currentAction,
                        node: node,
                        subject: _this.contextActionHandler
                    };
                }));
            }
        }
        return null;
    };
    Object.defineProperty(DocumentListComponent.prototype, "hasCustomLayout", {
        get: /**
         * @return {?}
         */
        function () {
            return this.columnList && this.columnList.columns && this.columnList.columns.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    DocumentListComponent.prototype.getDefaultSorting = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var defaultSorting;
        if (this.sorting) {
            var _a = __read(this.sorting, 2), key = _a[0], direction = _a[1];
            defaultSorting = new DataSorting(key, direction);
        }
        return defaultSorting;
    };
    /**
     * @private
     * @param {?=} name
     * @return {?}
     */
    DocumentListComponent.prototype.getLayoutPreset = /**
     * @private
     * @param {?=} name
     * @return {?}
     */
    function (name) {
        if (name === void 0) { name = 'default'; }
        return (this.layoutPresets[name] || this.layoutPresets['default']).map((/**
         * @param {?} col
         * @return {?}
         */
        function (col) { return new ObjectDataColumn(col); }));
    };
    /**
     * @return {?}
     */
    DocumentListComponent.prototype.isMobile = /**
     * @return {?}
     */
    function () {
        return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    };
    /**
     * @return {?}
     */
    DocumentListComponent.prototype.isEmpty = /**
     * @return {?}
     */
    function () {
        return !this.data || this.data.getRows().length === 0;
    };
    /**
     * @return {?}
     */
    DocumentListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.rowMenuCache = {};
        this.loadLayoutPresets();
        this.data = new ShareDataTableAdapter(this.thumbnailService, this.contentService, null, this.getDefaultSorting(), this.sortingMode);
        this.data.thumbnails = this.thumbnails;
        this.data.permissionsStyle = this.permissionsStyle;
        if (this._rowFilter) {
            this.data.setFilter(this._rowFilter);
        }
        if (this.imageResolver) {
            this.data.setImageResolver(this.imageResolver);
        }
        this.subscriptions.push(this.contextActionHandler.subscribe((/**
         * @param {?} val
         * @return {?}
         */
        function (val) { return _this.contextActionCallback(val); })));
        this.enforceSingleClickNavigationForMobile();
    };
    /**
     * @return {?}
     */
    DocumentListComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.columnList) {
            this.subscriptions.push(this.columnList.columns.changes.subscribe((/**
             * @return {?}
             */
            function () {
                _this.setTableSchema();
            })));
        }
        this.setTableSchema();
    };
    /**
     * @private
     * @return {?}
     */
    DocumentListComponent.prototype.setTableSchema = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var schema = [];
        if (this.hasCustomLayout) {
            schema = this.columnList.columns.map((/**
             * @param {?} c
             * @return {?}
             */
            function (c) { return (/** @type {?} */ (c)); }));
        }
        if (!this.data) {
            this.data = new ShareDataTableAdapter(this.thumbnailService, this.contentService, schema, this.getDefaultSorting(), this.sortingMode);
        }
        else if (schema && schema.length > 0) {
            this.data.setColumns(schema);
        }
        /** @type {?} */
        var columns = this.data.getColumns();
        if (!columns || columns.length === 0) {
            this.setupDefaultColumns(this._currentFolderId);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    DocumentListComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.resetSelection();
        if (this.data) {
            this.data.thumbnails = this.thumbnails;
        }
        if (changes.sortingMode && !changes.sortingMode.firstChange && this.data) {
            this.data.sortingMode = changes.sortingMode.currentValue;
        }
        if (changes.sorting && !changes.sorting.firstChange && this.data) {
            /** @type {?} */
            var newValue = changes.sorting.currentValue;
            if (newValue && newValue.length > 0) {
                var _a = __read(newValue, 2), key = _a[0], direction = _a[1];
                this.data.setSorting(new DataSorting(key, direction));
            }
        }
        if (this.data) {
            if (changes.node && changes.node.currentValue) {
                /** @type {?} */
                var merge$$1 = this._pagination ? this._pagination.merge : false;
                this.data.loadPage(changes.node.currentValue, merge$$1);
                this.onDataReady(changes.node.currentValue);
            }
            else if (changes.imageResolver) {
                this.data.setImageResolver(changes.imageResolver.currentValue);
            }
        }
    };
    /**
     * @return {?}
     */
    DocumentListComponent.prototype.reload = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.ngZone.run((/**
         * @return {?}
         */
        function () {
            _this.resetSelection();
            if (_this.node) {
                _this.data.loadPage(_this.node, _this._pagination.merge);
                _this.onDataReady(_this.node);
            }
            else {
                _this.loadFolder();
            }
        }));
    };
    /**
     * @param {?} action
     * @return {?}
     */
    DocumentListComponent.prototype.contextActionCallback = /**
     * @param {?} action
     * @return {?}
     */
    function (action) {
        if (action) {
            this.executeContentAction(action.node, action.model);
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.getNodeActions = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        if (node && node.entry) {
            /** @type {?} */
            var target_1 = null;
            if (node.entry.isFile) {
                target_1 = 'document';
            }
            else if (node.entry.isFolder) {
                target_1 = 'folder';
            }
            if (target_1) {
                /** @type {?} */
                var actions = this.rowMenuCache[node.entry.id];
                if (actions) {
                    actions.forEach((/**
                     * @param {?} action
                     * @return {?}
                     */
                    function (action) {
                        _this.refreshAction(action, node);
                    }));
                    return actions;
                }
                /** @type {?} */
                var actionsByTarget = this.actions
                    .filter((/**
                 * @param {?} entry
                 * @return {?}
                 */
                function (entry) {
                    /** @type {?} */
                    var isVisible = (typeof entry.visible === 'function')
                        ? entry.visible(node)
                        : entry.visible;
                    return isVisible && entry.target.toLowerCase() === target_1;
                }))
                    .map((/**
                 * @param {?} action
                 * @return {?}
                 */
                function (action) { return new ContentActionModel(action); }));
                actionsByTarget.forEach((/**
                 * @param {?} action
                 * @return {?}
                 */
                function (action) {
                    _this.refreshAction(action, node);
                }));
                this.rowMenuCache[node.entry.id] = actionsByTarget;
                return actionsByTarget;
            }
        }
        return [];
    };
    /**
     * @private
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.refreshAction = /**
     * @private
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    function (action, node) {
        action.disabled = this.isActionDisabled(action, node);
        action.visible = this.isActionVisible(action, node);
    };
    /**
     * @private
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.isActionVisible = /**
     * @private
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    function (action, node) {
        if (typeof action.visible === 'function') {
            return action.visible(node);
        }
        return action.visible;
    };
    /**
     * @private
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.isActionDisabled = /**
     * @private
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    function (action, node) {
        if (typeof action.disabled === 'function') {
            return action.disabled(node);
        }
        if ((action.permission &&
            action.disableWithNoPermission &&
            !this.contentService.hasAllowableOperations(node.entry, action.permission)) ||
            this.lockService.isLocked(node.entry)) {
            return true;
        }
        else {
            return action.disabled;
        }
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    DocumentListComponent.prototype.onShowContextMenu = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (e && this.contextMenuActions) {
            e.preventDefault();
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.navigateTo = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (typeof node === 'string') {
            this.resetNewFolderPagination();
            this._currentFolderId = node;
            this.folderChange.emit(new NodeEntryEvent((/** @type {?} */ ({ id: node }))));
            this.reload();
            return true;
        }
        else {
            if (this.canNavigateFolder(node)) {
                this.resetNewFolderPagination();
                this._currentFolderId = this.getNodeFolderDestinationId(node);
                this.folderChange.emit(new NodeEntryEvent((/** @type {?} */ ({ id: this._currentFolderId }))));
                this.reload();
                return true;
            }
        }
        return false;
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.getNodeFolderDestinationId = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return this.isLinkFolder(node) ? node.properties['cm:destination'] : node.id;
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.isLinkFolder = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.nodeType === 'app:folderlink' && node.properties &&
            node.properties['cm:destination'];
    };
    /**
     * @param {?} nodeId
     * @return {?}
     */
    DocumentListComponent.prototype.updateCustomSourceData = /**
     * @param {?} nodeId
     * @return {?}
     */
    function (nodeId) {
        this._currentFolderId = nodeId;
    };
    /**
     * Invoked when executing content action for a document or folder.
     * @param node Node to be the context of the execution.
     * @param action Action to be executed against the context.
     */
    /**
     * Invoked when executing content action for a document or folder.
     * @param {?} node Node to be the context of the execution.
     * @param {?} action Action to be executed against the context.
     * @return {?}
     */
    DocumentListComponent.prototype.executeContentAction = /**
     * Invoked when executing content action for a document or folder.
     * @param {?} node Node to be the context of the execution.
     * @param {?} action Action to be executed against the context.
     * @return {?}
     */
    function (node, action) {
        if (node && node.entry && action) {
            /** @type {?} */
            var handlerSub = void 0;
            if (typeof action.handler === 'function') {
                handlerSub = action.handler(node, this, action.permission);
            }
            else {
                handlerSub = of(true);
            }
            if (typeof action.execute === 'function' && handlerSub) {
                handlerSub.subscribe((/**
                 * @return {?}
                 */
                function () {
                    action.execute(node);
                }));
            }
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    DocumentListComponent.prototype.setLoadingState = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        if (value) {
            clearTimeout(this.loadingTimeout);
            this.loadingTimeout = setTimeout((/**
             * @return {?}
             */
            function () {
                _this.loading = true;
            }), 1000);
        }
        else {
            clearTimeout(this.loadingTimeout);
            this.loading = false;
        }
    };
    /**
     * @return {?}
     */
    DocumentListComponent.prototype.loadFolder = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._pagination.merge) {
            this.setLoadingState(true);
        }
        if (!this.hasCustomLayout) {
            this.setupDefaultColumns(this._currentFolderId);
        }
        if (this.documentListService.isCustomSourceService(this._currentFolderId)) {
            this.updateCustomSourceData(this._currentFolderId);
        }
        this.documentListService.loadFolderByNodeId(this._currentFolderId, this._pagination, this.includeFields, this.where)
            .subscribe((/**
         * @param {?} documentNode
         * @return {?}
         */
        function (documentNode) {
            if (documentNode.currentNode) {
                _this.folderNode = documentNode.currentNode.entry;
                _this.$folderNode.next(documentNode.currentNode.entry);
            }
            _this.onPageLoaded(documentNode.children);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            _this.handleError(err);
        }));
    };
    /**
     * @return {?}
     */
    DocumentListComponent.prototype.resetSelection = /**
     * @return {?}
     */
    function () {
        this.dataTable.resetSelection();
        this.selection = [];
        this.noPermission = false;
    };
    /**
     * @param {?} nodePaging
     * @return {?}
     */
    DocumentListComponent.prototype.onPageLoaded = /**
     * @param {?} nodePaging
     * @return {?}
     */
    function (nodePaging) {
        if (nodePaging) {
            this.data.loadPage(nodePaging, this._pagination.merge);
            this.setLoadingState(false);
            this.onDataReady(nodePaging);
        }
    };
    /**
     * Creates a set of predefined columns.
     */
    /**
     * Creates a set of predefined columns.
     * @param {?=} preset
     * @return {?}
     */
    DocumentListComponent.prototype.setupDefaultColumns = /**
     * Creates a set of predefined columns.
     * @param {?=} preset
     * @return {?}
     */
    function (preset) {
        if (preset === void 0) { preset = 'default'; }
        if (this.data) {
            /** @type {?} */
            var columns = this.getLayoutPreset(preset);
            this.data.setColumns(columns);
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.onPreviewFile = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (node) {
            this.preview.emit(new NodeEntityEvent(node));
        }
    };
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    DocumentListComponent.prototype.onNodeClick = /**
     * @param {?} nodeEntry
     * @return {?}
     */
    function (nodeEntry) {
        /** @type {?} */
        var domEvent = new CustomEvent('node-click', {
            detail: {
                sender: this,
                node: nodeEntry
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        /** @type {?} */
        var event = new NodeEntityEvent(nodeEntry);
        this.nodeClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.SINGLE_CLICK_NAVIGATION) {
                this.executeActionClick(nodeEntry);
            }
        }
    };
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    DocumentListComponent.prototype.onNodeDblClick = /**
     * @param {?} nodeEntry
     * @return {?}
     */
    function (nodeEntry) {
        /** @type {?} */
        var domEvent = new CustomEvent('node-dblclick', {
            detail: {
                sender: this,
                node: nodeEntry
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        /** @type {?} */
        var event = new NodeEntityEvent(nodeEntry);
        this.nodeDblClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.DOUBLE_CLICK_NAVIGATION) {
                this.executeActionClick(nodeEntry);
            }
        }
    };
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    DocumentListComponent.prototype.executeActionClick = /**
     * @param {?} nodeEntry
     * @return {?}
     */
    function (nodeEntry) {
        var _this = this;
        if (nodeEntry && nodeEntry.entry) {
            if (nodeEntry.entry.isFile) {
                this.onPreviewFile(nodeEntry);
            }
            if (nodeEntry.entry.isFolder) {
                this.navigateTo(nodeEntry.entry);
            }
            if (nodeEntry.entry['guid']) {
                /** @type {?} */
                var options = {
                    include: this.includeFields
                };
                this.alfrescoApiService.nodesApi.getNode(nodeEntry.entry['guid'], options)
                    .then((/**
                 * @param {?} node
                 * @return {?}
                 */
                function (node) {
                    _this.navigateTo(node.entry);
                }));
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DocumentListComponent.prototype.onNodeSelect = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.selection = event.selection.map((/**
         * @param {?} entry
         * @return {?}
         */
        function (entry) { return entry.node; }));
        /** @type {?} */
        var domEvent = new CustomEvent('node-select', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DocumentListComponent.prototype.onNodeUnselect = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.selection = event.selection.map((/**
         * @param {?} entry
         * @return {?}
         */
        function (entry) { return entry.node; }));
        /** @type {?} */
        var domEvent = new CustomEvent('node-unselect', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DocumentListComponent.prototype.onShowRowContextMenu = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.contextMenuActions) {
            /** @type {?} */
            var args = event.value;
            /** @type {?} */
            var node = ((/** @type {?} */ (args.row))).node;
            if (node) {
                args.actions = this.getContextActions(node) || [];
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DocumentListComponent.prototype.onShowRowActionsMenu = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.contentActions) {
            /** @type {?} */
            var args = event.value;
            /** @type {?} */
            var node = ((/** @type {?} */ (args.row))).node;
            if (node) {
                args.actions = this.getNodeActions(node) || [];
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DocumentListComponent.prototype.onExecuteRowAction = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.contentActions) {
            /** @type {?} */
            var args = event.value;
            /** @type {?} */
            var node = ((/** @type {?} */ (args.row))).node;
            /** @type {?} */
            var action = ((/** @type {?} */ (args.action)));
            this.executeContentAction(node, action);
        }
    };
    /**
     * @private
     * @return {?}
     */
    DocumentListComponent.prototype.enforceSingleClickNavigationForMobile = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.isMobile()) {
            this.navigationMode = DocumentListComponent.SINGLE_CLICK_NAVIGATION;
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DocumentListComponent.prototype.canNavigateFolder = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var canNavigateFolder = false;
        if (node && node.isFolder) {
            canNavigateFolder = true;
        }
        return canNavigateFolder;
    };
    /**
     * @private
     * @return {?}
     */
    DocumentListComponent.prototype.loadLayoutPresets = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var externalSettings = this.appConfig.get('document-list.presets', null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, presetsDefaultModel, externalSettings);
        }
        else {
            this.layoutPresets = presetsDefaultModel;
        }
    };
    /**
     * @private
     * @param {?} nodePaging
     * @return {?}
     */
    DocumentListComponent.prototype.onDataReady = /**
     * @private
     * @param {?} nodePaging
     * @return {?}
     */
    function (nodePaging) {
        this.ready.emit(nodePaging);
        this.pagination.next(nodePaging.list.pagination);
    };
    /**
     * @param {?} requestPaginationModel
     * @return {?}
     */
    DocumentListComponent.prototype.updatePagination = /**
     * @param {?} requestPaginationModel
     * @return {?}
     */
    function (requestPaginationModel) {
        this._pagination.maxItems = requestPaginationModel.maxItems;
        this._pagination.merge = requestPaginationModel.merge;
        this._pagination.skipCount = requestPaginationModel.skipCount;
        this.reload();
    };
    /**
     * @private
     * @return {?}
     */
    DocumentListComponent.prototype.resetNewFolderPagination = /**
     * @private
     * @return {?}
     */
    function () {
        this._pagination.skipCount = 0;
        this._pagination.maxItems = this.maxItems;
    };
    /**
     * @return {?}
     */
    DocumentListComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach((/**
         * @param {?} s
         * @return {?}
         */
        function (s) { return s.unsubscribe(); }));
        this.subscriptions = [];
    };
    /**
     * @private
     * @param {?} err
     * @return {?}
     */
    DocumentListComponent.prototype.handleError = /**
     * @private
     * @param {?} err
     * @return {?}
     */
    function (err) {
        if (err.message) {
            try {
                if (JSON.parse(err.message).error.statusCode === 403) {
                    this.setLoadingState(false);
                    this.noPermission = true;
                }
            }
            catch (error) {
            }
        }
        this.error.emit(err);
    };
    DocumentListComponent.SINGLE_CLICK_NAVIGATION = 'click';
    DocumentListComponent.DOUBLE_CLICK_NAVIGATION = 'dblclick';
    DocumentListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-document-list',
                    template: "<adf-datatable\n    #dataTable\n    [selectionMode]=\"selectionMode\"\n    [data]=\"data\"\n    [actions]=\"contentActions\"\n    [actionsPosition]=\"contentActionsPosition\"\n    [multiselect]=\"multiselect\"\n    [allowDropFiles]=\"allowDropFiles\"\n    [contextMenu]=\"contextMenuActions\"\n    [rowStyle]=\"rowStyle\"\n    [rowStyleClass]=\"rowStyleClass\"\n    [loading]=\"loading\"\n    [display]=\"display\"\n    [noPermission]=\"noPermission\"\n    [showHeader]=\"!isEmpty() && showHeader\"\n    [rowMenuCacheEnabled]=\"false\"\n    [stickyHeader]=\"stickyHeader\"\n    (showRowContextMenu)=\"onShowRowContextMenu($event)\"\n    (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n    (executeRowAction)=\"onExecuteRowAction($event)\"\n    (rowClick)=\"onNodeClick($event.value?.node)\"\n    (rowDblClick)=\"onNodeDblClick($event.value?.node)\"\n    (row-select)=\"onNodeSelect($event.detail)\"\n    (row-unselect)=\"onNodeUnselect($event.detail)\"\n    [class.adf-datatable-gallery-thumbnails]=\"data.thumbnails\">\n\n    <adf-no-content-template>\n        <ng-template>\n            <adf-empty-list *ngIf=\"!customNoContentTemplate\">\n                <div class=\"adf-empty-list_template adf-empty-folder\">\n                    <div class=\"adf-empty-folder-this-space-is-empty\">{{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}}</div>\n                    <div fxHide.lt-md=\"true\" class=\"adf-empty-folder-drag-drop\">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.TITLE' | translate }}</div>\n                    <div fxHide.lt-md=\"true\" class=\"adf-empty-folder-any-files-here-to-add\">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.SUBTITLE' | translate }}</div>\n                    <img [alt]=\"'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.TITLE' | translate\" class=\"adf-empty-folder-image\" [src]=\"emptyFolderImageUrl\">\n                </div>\n            </adf-empty-list>\n            <ng-content select=\"adf-custom-empty-content-template, empty-folder-content\"></ng-content>\n        </ng-template>\n    </adf-no-content-template>\n\n    <adf-no-permission-template>\n        <ng-template>\n            <div class=\"adf-no-permission__template\" *ngIf=\"!customNoPermissionsTemplate\">\n                <mat-icon>ic_error</mat-icon>\n                <p class=\"adf-no-permission__template--text\">{{ 'ADF-DOCUMENT-LIST.NO_PERMISSION' | translate }}</p>\n            </div>\n            <ng-content select=\"adf-custom-no-permission-template, no-permission-content\"></ng-content>\n        </ng-template>\n    </adf-no-permission-template>\n\n    <adf-loading-content-template>\n        <ng-template>\n            <div class=\"adf-document-list-loading-container\" *ngIf=\"!customLoadingContent\">\n                <mat-progress-spinner\n                    id=\"adf-document-list-loading\"\n                    class=\"adf-document-list-loading-margin\"\n                    [color]=\"'primary'\"\n                    [mode]=\"'indeterminate'\">\n                </mat-progress-spinner>\n            </div>\n            <ng-content select=\"adf-custom-loading-content-template\"></ng-content>\n        </ng-template>\n    </adf-loading-content-template>\n\n</adf-datatable>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: '.adf-document-list' },
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    DocumentListComponent.ctorParameters = function () { return [
        { type: DocumentListService },
        { type: NgZone },
        { type: ElementRef },
        { type: AppConfigService },
        { type: UserPreferencesService },
        { type: ContentService },
        { type: ThumbnailService },
        { type: AlfrescoApiService },
        { type: LockService }
    ]; };
    DocumentListComponent.propDecorators = {
        columnList: [{ type: ContentChild, args: [DataColumnListComponent,] }],
        customLoadingContent: [{ type: ContentChild, args: [CustomLoadingContentTemplateDirective,] }],
        customNoPermissionsTemplate: [{ type: ContentChild, args: [CustomNoPermissionTemplateDirective,] }],
        customNoContentTemplate: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
        includeFields: [{ type: Input }],
        where: [{ type: Input }],
        display: [{ type: Input }],
        permissionsStyle: [{ type: Input }],
        locationFormat: [{ type: Input }],
        navigate: [{ type: Input }],
        showHeader: [{ type: Input }],
        navigationMode: [{ type: Input }],
        thumbnails: [{ type: Input }],
        selectionMode: [{ type: Input }],
        multiselect: [{ type: Input }],
        contentActions: [{ type: Input }],
        contentActionsPosition: [{ type: Input }],
        contextMenuActions: [{ type: Input }],
        emptyFolderImageUrl: [{ type: Input }],
        allowDropFiles: [{ type: Input }],
        sorting: [{ type: Input }],
        sortingMode: [{ type: Input }],
        rowStyle: [{ type: Input }],
        rowStyleClass: [{ type: Input }],
        loading: [{ type: Input }],
        _rowFilter: [{ type: Input }],
        rowFilter: [{ type: Input }],
        imageResolver: [{ type: Input }],
        stickyHeader: [{ type: Input }],
        currentFolderId: [{ type: Input }],
        node: [{ type: Input }],
        maxItems: [{ type: Input }],
        nodeClick: [{ type: Output }],
        nodeDblClick: [{ type: Output }],
        folderChange: [{ type: Output }],
        preview: [{ type: Output }],
        ready: [{ type: Output }],
        error: [{ type: Output }],
        dataTable: [{ type: ViewChild, args: ['dataTable',] }],
        onShowContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }]
    };
    return DocumentListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentColumnListComponent = /** @class */ (function () {
    function ContentColumnListComponent(documentList, logService) {
        this.documentList = documentList;
        this.logService = logService;
        this.logService.log('ContentColumnListComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnListComponent instead.');
    }
    /**
     * Registers column model within the parent document list component.
     * @param column Column definition model to register.
     */
    /**
     * Registers column model within the parent document list component.
     * @param {?} column Column definition model to register.
     * @return {?}
     */
    ContentColumnListComponent.prototype.registerColumn = /**
     * Registers column model within the parent document list component.
     * @param {?} column Column definition model to register.
     * @return {?}
     */
    function (column) {
        if (this.documentList && column) {
            /** @type {?} */
            var columns = this.documentList.data.getColumns();
            columns.push(column);
            return true;
        }
        return false;
    };
    ContentColumnListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'content-columns',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    ContentColumnListComponent.ctorParameters = function () { return [
        { type: DocumentListComponent },
        { type: LogService }
    ]; };
    return ContentColumnListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentColumnComponent = /** @class */ (function () {
    function ContentColumnComponent(list, logService) {
        this.list = list;
        this.logService = logService;
        this.type = 'text';
        this.sortable = false;
        this.title = '';
        this.logService.log('ContentColumnComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnComponent instead.');
    }
    /**
     * @return {?}
     */
    ContentColumnComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    };
    /**
     * @return {?}
     */
    ContentColumnComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.register();
    };
    /**
     * @return {?}
     */
    ContentColumnComponent.prototype.register = /**
     * @return {?}
     */
    function () {
        if (this.list) {
            return this.list.registerColumn(this);
        }
        return false;
    };
    ContentColumnComponent.decorators = [
        { type: Component, args: [{
                    selector: 'content-column',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    ContentColumnComponent.ctorParameters = function () { return [
        { type: ContentColumnListComponent },
        { type: LogService }
    ]; };
    ContentColumnComponent.propDecorators = {
        key: [{ type: Input }],
        type: [{ type: Input }],
        format: [{ type: Input }],
        sortable: [{ type: Input }],
        title: [{ type: Input }],
        template: [{ type: ContentChild, args: [TemplateRef,] }],
        srTitle: [{ type: Input, args: ['sr-title',] }],
        cssClass: [{ type: Input, args: ['class',] }]
    };
    return ContentColumnComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PermissionModel = /** @class */ (function () {
    function PermissionModel(obj) {
        if (obj) {
            this.type = obj.type || null;
            this.action = obj.action || null;
            this.permission = obj.permission || null;
        }
    }
    return PermissionModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NodeActionsService = /** @class */ (function () {
    function NodeActionsService(contentDialogService, dialogRef, content, documentListService, apiService, dialog) {
        this.contentDialogService = contentDialogService;
        this.dialogRef = dialogRef;
        this.content = content;
        this.documentListService = documentListService;
        this.apiService = apiService;
        this.dialog = dialog;
        this.error = new EventEmitter();
    }
    /**
     * @param {?} node
     * @return {?}
     */
    NodeActionsService.prototype.downloadNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        new NodeDownloadDirective(this.apiService, this.dialog)
            .downloadNode(node);
    };
    /**
     * Copy content node
     *
     * @param contentEntry node to copy
     * @param permission permission which is needed to apply the action
     */
    /**
     * Copy content node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    NodeActionsService.prototype.copyContent = /**
     * Copy content node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    function (contentEntry, permission) {
        return this.doFileOperation('copy', 'content', contentEntry, permission);
    };
    /**
     * Copy folder node
     *
     * @param contentEntry node to copy
     * @param permission permission which is needed to apply the action
     */
    /**
     * Copy folder node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    NodeActionsService.prototype.copyFolder = /**
     * Copy folder node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    function (contentEntry, permission) {
        return this.doFileOperation('copy', 'folder', contentEntry, permission);
    };
    /**
     * Move content node
     *
     * @param contentEntry node to move
     * @param permission permission which is needed to apply the action
     */
    /**
     * Move content node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    NodeActionsService.prototype.moveContent = /**
     * Move content node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    function (contentEntry, permission) {
        return this.doFileOperation('move', 'content', contentEntry, permission);
    };
    /**
     * Move folder node
     *
     * @param contentEntry node to move
     * @param permission permission which is needed to apply the action
     */
    /**
     * Move folder node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    NodeActionsService.prototype.moveFolder = /**
     * Move folder node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    function (contentEntry, permission) {
        return this.doFileOperation('move', 'folder', contentEntry, permission);
    };
    /**
     * General method for performing the given operation (copy|move)
     *
     * @param action the action to perform (copy|move)
     * @param type type of the content (content|folder)
     * @param contentEntry the contentEntry which has to have the action performed on
     * @param permission permission which is needed to apply the action
     */
    /**
     * General method for performing the given operation (copy|move)
     *
     * @private
     * @param {?} action the action to perform (copy|move)
     * @param {?} type type of the content (content|folder)
     * @param {?} contentEntry the contentEntry which has to have the action performed on
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    NodeActionsService.prototype.doFileOperation = /**
     * General method for performing the given operation (copy|move)
     *
     * @private
     * @param {?} action the action to perform (copy|move)
     * @param {?} type type of the content (content|folder)
     * @param {?} contentEntry the contentEntry which has to have the action performed on
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    function (action, type, contentEntry, permission) {
        var _this = this;
        /** @type {?} */
        var observable = new Subject();
        this.contentDialogService
            .openCopyMoveDialog(action, contentEntry, permission)
            .subscribe((/**
         * @param {?} selections
         * @return {?}
         */
        function (selections) {
            /** @type {?} */
            var selection = selections[0];
            _this.documentListService[action + "Node"].call(_this.documentListService, contentEntry.id, selection.id)
                .subscribe(observable.next.bind(observable, "OPERATION.SUCCESS." + type.toUpperCase() + "." + action.toUpperCase()), observable.error.bind(observable));
        }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            observable.error(error);
            return observable;
        }));
        return observable;
    };
    NodeActionsService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NodeActionsService.ctorParameters = function () { return [
        { type: ContentNodeDialogService },
        { type: MatDialog },
        { type: ContentService },
        { type: DocumentListService },
        { type: AlfrescoApiService },
        { type: MatDialog }
    ]; };
    NodeActionsService.propDecorators = {
        error: [{ type: Output }]
    };
    /** @nocollapse */ NodeActionsService.ngInjectableDef = defineInjectable({ factory: function NodeActionsService_Factory() { return new NodeActionsService(inject(ContentNodeDialogService), inject(MatDialog$1), inject(ContentService), inject(DocumentListService), inject(AlfrescoApiService), inject(MatDialog$1)); }, token: NodeActionsService, providedIn: "root" });
    return NodeActionsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DocumentActionsService = /** @class */ (function () {
    function DocumentActionsService(nodeActionsService, contentNodeDialogService, translation, documentListService, contentService) {
        this.nodeActionsService = nodeActionsService;
        this.contentNodeDialogService = contentNodeDialogService;
        this.translation = translation;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.permissionEvent = new Subject();
        this.error = new Subject();
        this.success = new Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    /**
     * Gets the handler for an action.
     * @param key Identifier of the action
     * @returns The handler for the action
     */
    /**
     * Gets the handler for an action.
     * @param {?} key Identifier of the action
     * @return {?} The handler for the action
     */
    DocumentActionsService.prototype.getHandler = /**
     * Gets the handler for an action.
     * @param {?} key Identifier of the action
     * @return {?} The handler for the action
     */
    function (key) {
        if (key) {
            /** @type {?} */
            var lKey = key.toLowerCase();
            return this.handlers[lKey] || null;
        }
        return null;
    };
    /**
     * Sets a new handler for an action.
     * @param key Identifier of the action
     * @param handler Handler for the action
     * @returns False if the key was an empty/null string, true otherwise
     */
    /**
     * Sets a new handler for an action.
     * @param {?} key Identifier of the action
     * @param {?} handler Handler for the action
     * @return {?} False if the key was an empty/null string, true otherwise
     */
    DocumentActionsService.prototype.setHandler = /**
     * Sets a new handler for an action.
     * @param {?} key Identifier of the action
     * @param {?} handler Handler for the action
     * @return {?} False if the key was an empty/null string, true otherwise
     */
    function (key, handler) {
        if (key) {
            /** @type {?} */
            var lKey = key.toLowerCase();
            this.handlers[lKey] = handler;
            return true;
        }
        return false;
    };
    /**
     * Checks if actions can be executed for an item.
     * @param nodeEntry Item to receive an action
     * @returns True if the action can be executed on this item, false otherwise
     */
    /**
     * Checks if actions can be executed for an item.
     * @param {?} nodeEntry Item to receive an action
     * @return {?} True if the action can be executed on this item, false otherwise
     */
    DocumentActionsService.prototype.canExecuteAction = /**
     * Checks if actions can be executed for an item.
     * @param {?} nodeEntry Item to receive an action
     * @return {?} True if the action can be executed on this item, false otherwise
     */
    function (nodeEntry) {
        return this.documentListService && nodeEntry && nodeEntry.entry.isFile === true;
    };
    /**
     * @private
     * @return {?}
     */
    DocumentActionsService.prototype.setupActionHandlers = /**
     * @private
     * @return {?}
     */
    function () {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
        this.handlers['lock'] = this.lockNode.bind(this);
    };
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    DocumentActionsService.prototype.lockNode = /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (node, target, permission) {
        return this.contentNodeDialogService.openLockNodeDialog(node.entry);
    };
    /**
     * @private
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    DocumentActionsService.prototype.downloadNode = /**
     * @private
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (obj, target, permission) {
        this.nodeActionsService.downloadNode(obj);
    };
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    DocumentActionsService.prototype.copyNode = /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (node, target, permission) {
        /** @type {?} */
        var actionObservable = this.nodeActionsService.copyContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'copy', target, permission);
        return actionObservable;
    };
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    DocumentActionsService.prototype.moveNode = /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (node, target, permission) {
        /** @type {?} */
        var actionObservable = this.nodeActionsService.moveContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'move', target, permission);
        return actionObservable;
    };
    /**
     * @private
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    DocumentActionsService.prototype.prepareHandlers = /**
     * @private
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (actionObservable, type, action, target, permission) {
        var _this = this;
        actionObservable.subscribe((/**
         * @param {?} fileOperationMessage
         * @return {?}
         */
        function (fileOperationMessage) {
            _this.success.next(fileOperationMessage);
        }), this.error.next.bind(this.error));
    };
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    DocumentActionsService.prototype.deleteNode = /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (node, target, permission) {
        var _this = this;
        /** @type {?} */
        var handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasAllowableOperations(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe((/**
                 * @return {?}
                 */
                function () {
                    /** @type {?} */
                    var message = _this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    _this.success.next(message);
                }), (/**
                 * @return {?}
                 */
                function () {
                    /** @type {?} */
                    var message = _this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    _this.error.next(message);
                }));
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({
                    type: 'content',
                    action: 'delete',
                    permission: permission
                }));
                return throwError(new Error('No permission to delete'));
            }
        }
    };
    DocumentActionsService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    DocumentActionsService.ctorParameters = function () { return [
        { type: NodeActionsService },
        { type: ContentNodeDialogService },
        { type: TranslationService },
        { type: DocumentListService },
        { type: ContentService }
    ]; };
    /** @nocollapse */ DocumentActionsService.ngInjectableDef = defineInjectable({ factory: function DocumentActionsService_Factory() { return new DocumentActionsService(inject(NodeActionsService), inject(ContentNodeDialogService), inject(TranslationService), inject(DocumentListService), inject(ContentService)); }, token: DocumentActionsService, providedIn: "root" });
    return DocumentActionsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FolderActionsService = /** @class */ (function () {
    function FolderActionsService(nodeActionsService, documentListService, contentService, translation) {
        this.nodeActionsService = nodeActionsService;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.translation = translation;
        this.permissionEvent = new Subject();
        this.error = new Subject();
        this.success = new Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    /**
     * Gets the handler function for an action.
     * @param key Identifier for the action
     * @returns The handler function
     */
    /**
     * Gets the handler function for an action.
     * @param {?} key Identifier for the action
     * @return {?} The handler function
     */
    FolderActionsService.prototype.getHandler = /**
     * Gets the handler function for an action.
     * @param {?} key Identifier for the action
     * @return {?} The handler function
     */
    function (key) {
        if (key) {
            /** @type {?} */
            var lKey = key.toLowerCase();
            return this.handlers[lKey] || null;
        }
        return null;
    };
    /**
     * Sets a new handler function for an action.
     * @param key Identifier for the action
     * @param handler The new handler function
     * @returns True if the key was a valid action identifier, false otherwise
     */
    /**
     * Sets a new handler function for an action.
     * @param {?} key Identifier for the action
     * @param {?} handler The new handler function
     * @return {?} True if the key was a valid action identifier, false otherwise
     */
    FolderActionsService.prototype.setHandler = /**
     * Sets a new handler function for an action.
     * @param {?} key Identifier for the action
     * @param {?} handler The new handler function
     * @return {?} True if the key was a valid action identifier, false otherwise
     */
    function (key, handler) {
        if (key) {
            /** @type {?} */
            var lKey = key.toLowerCase();
            this.handlers[lKey] = handler;
            return true;
        }
        return false;
    };
    /**
     * Checks if an action is available for a particular item.
     * @param nodeEntry Item to check
     * @returns True if the action is available, false otherwise
     */
    /**
     * Checks if an action is available for a particular item.
     * @param {?} nodeEntry Item to check
     * @return {?} True if the action is available, false otherwise
     */
    FolderActionsService.prototype.canExecuteAction = /**
     * Checks if an action is available for a particular item.
     * @param {?} nodeEntry Item to check
     * @return {?} True if the action is available, false otherwise
     */
    function (nodeEntry) {
        return this.documentListService && nodeEntry && nodeEntry.entry.isFolder === true;
    };
    /**
     * @private
     * @return {?}
     */
    FolderActionsService.prototype.setupActionHandlers = /**
     * @private
     * @return {?}
     */
    function () {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
    };
    /**
     * @private
     * @param {?} nodeEntry
     * @return {?}
     */
    FolderActionsService.prototype.downloadNode = /**
     * @private
     * @param {?} nodeEntry
     * @return {?}
     */
    function (nodeEntry) {
        this.nodeActionsService.downloadNode(nodeEntry);
    };
    /**
     * @private
     * @param {?} nodeEntry
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    FolderActionsService.prototype.copyNode = /**
     * @private
     * @param {?} nodeEntry
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (nodeEntry, target, permission) {
        /** @type {?} */
        var actionObservable = this.nodeActionsService.copyFolder(nodeEntry.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'copy', target, permission);
        return actionObservable;
    };
    /**
     * @private
     * @param {?} nodeEntry
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    FolderActionsService.prototype.moveNode = /**
     * @private
     * @param {?} nodeEntry
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (nodeEntry, target, permission) {
        /** @type {?} */
        var actionObservable = this.nodeActionsService.moveFolder(nodeEntry.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'move', target, permission);
        return actionObservable;
    };
    /**
     * @private
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    FolderActionsService.prototype.prepareHandlers = /**
     * @private
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (actionObservable, type, action, target, permission) {
        var _this = this;
        actionObservable.subscribe((/**
         * @param {?} fileOperationMessage
         * @return {?}
         */
        function (fileOperationMessage) {
            if (target && typeof target.reload === 'function') {
                target.reload();
            }
            _this.success.next(fileOperationMessage);
        }), this.error.next.bind(this.error));
    };
    /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    FolderActionsService.prototype.deleteNode = /**
     * @private
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    function (node, target, permission) {
        var _this = this;
        /** @type {?} */
        var handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasAllowableOperations(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe((/**
                 * @return {?}
                 */
                function () {
                    if (target && typeof target.reload === 'function') {
                        target.reload();
                    }
                    /** @type {?} */
                    var message = _this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    _this.success.next(message);
                }), (/**
                 * @return {?}
                 */
                function () {
                    /** @type {?} */
                    var message = _this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    _this.error.next(message);
                }));
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({ type: 'folder', action: 'delete', permission: permission }));
                return throwError(new Error('No permission to delete'));
            }
        }
    };
    FolderActionsService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    FolderActionsService.ctorParameters = function () { return [
        { type: NodeActionsService },
        { type: DocumentListService },
        { type: ContentService },
        { type: TranslationService }
    ]; };
    /** @nocollapse */ FolderActionsService.ngInjectableDef = defineInjectable({ factory: function FolderActionsService_Factory() { return new FolderActionsService(inject(NodeActionsService), inject(DocumentListService), inject(ContentService), inject(TranslationService)); }, token: FolderActionsService, providedIn: "root" });
    return FolderActionsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentActionListComponent = /** @class */ (function () {
    function ContentActionListComponent(documentList) {
        this.documentList = documentList;
    }
    /**
     * Registers action handler within the parent document list component.
     * @param action Action model to register.
     */
    /**
     * Registers action handler within the parent document list component.
     * @param {?} action Action model to register.
     * @return {?}
     */
    ContentActionListComponent.prototype.registerAction = /**
     * Registers action handler within the parent document list component.
     * @param {?} action Action model to register.
     * @return {?}
     */
    function (action) {
        if (this.documentList && action) {
            this.documentList.actions.push(action);
            return true;
        }
        return false;
    };
    /**
     * @param {?} action
     * @return {?}
     */
    ContentActionListComponent.prototype.unregisterAction = /**
     * @param {?} action
     * @return {?}
     */
    function (action) {
        if (this.documentList && action) {
            /** @type {?} */
            var idx = this.documentList.actions.indexOf(action);
            if (idx >= 0) {
                this.documentList.actions.splice(idx, 1);
                return true;
            }
        }
        return false;
    };
    ContentActionListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'content-actions',
                    template: ''
                }] }
    ];
    /** @nocollapse */
    ContentActionListComponent.ctorParameters = function () { return [
        { type: DocumentListComponent }
    ]; };
    return ContentActionListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentActionComponent = /** @class */ (function () {
    function ContentActionComponent(list, documentActions, folderActions) {
        this.list = list;
        this.documentActions = documentActions;
        this.folderActions = folderActions;
        /**
         * The title of the action as shown in the menu.
         */
        this.title = 'Action';
        /**
         * Visibility state (see examples).
         */
        this.visible = true;
        /**
         * Type of item that the action applies to. Can be "document" or "folder"
         */
        this.target = ContentActionTarget.All;
        /**
         * Is the menu item disabled?
         */
        this.disabled = false;
        /**
         * Emitted when the user selects the action from the menu.
         */
        this.execute = new EventEmitter();
        /**
         * Emitted when a permission error occurs
         */
        this.permissionEvent = new EventEmitter();
        /**
         * Emitted when an error occurs during the action.
         * Applies to copy and move actions.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the action succeeds with the success string message.
         * Applies to copy, move and delete actions.
         */
        this.success = new EventEmitter();
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    ContentActionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.target === ContentActionTarget.All) {
            this.folderActionModel = this.generateAction(ContentActionTarget.Folder);
            this.documentActionModel = this.generateAction(ContentActionTarget.Document);
        }
        else {
            this.documentActionModel = this.generateAction(this.target);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ContentActionComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.visible && !changes.visible.firstChange) {
            if (this.documentActionModel) {
                this.documentActionModel.visible = changes.visible.currentValue;
            }
            if (this.folderActionModel) {
                this.folderActionModel.visible = changes.visible.currentValue;
            }
        }
        if (changes.disabled && !changes.disabled.firstChange) {
            if (this.documentActionModel) {
                this.documentActionModel.disabled = changes.disabled.currentValue;
            }
            if (this.folderActionModel) {
                this.folderActionModel.disabled = changes.disabled.currentValue;
            }
        }
    };
    /**
     * @return {?}
     */
    ContentActionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        function (subscription) { return subscription.unsubscribe(); }));
        this.subscriptions = [];
        if (this.documentActionModel) {
            this.unregister(this.documentActionModel);
            this.documentActionModel = null;
        }
        if (this.folderActionModel) {
            this.unregister(this.folderActionModel);
            this.folderActionModel = null;
        }
    };
    /**
     * @param {?} model
     * @return {?}
     */
    ContentActionComponent.prototype.register = /**
     * @param {?} model
     * @return {?}
     */
    function (model) {
        if (this.list) {
            return this.list.registerAction(model);
        }
        return false;
    };
    /**
     * @param {?} model
     * @return {?}
     */
    ContentActionComponent.prototype.unregister = /**
     * @param {?} model
     * @return {?}
     */
    function (model) {
        if (this.list) {
            return this.list.unregisterAction(model);
        }
        return false;
    };
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    ContentActionComponent.prototype.generateAction = /**
     * @private
     * @param {?} target
     * @return {?}
     */
    function (target) {
        var _this = this;
        /** @type {?} */
        var model = new ContentActionModel({
            title: this.title,
            icon: this.icon,
            permission: this.permission,
            disableWithNoPermission: this.disableWithNoPermission,
            target: target,
            disabled: this.disabled,
            visible: this.visible
        });
        if (this.handler) {
            model.handler = this.getSystemHandler(target, this.handler);
        }
        if (this.execute) {
            model.execute = (/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                _this.execute.emit({ value: value });
            });
        }
        this.register(model);
        return model;
    };
    /**
     * @param {?} target
     * @param {?} name
     * @return {?}
     */
    ContentActionComponent.prototype.getSystemHandler = /**
     * @param {?} target
     * @param {?} name
     * @return {?}
     */
    function (target, name) {
        var _this = this;
        if (target) {
            target = target.toLowerCase();
            if (target === ContentActionTarget.Document) {
                if (this.documentActions) {
                    this.subscriptions.push(this.documentActions.permissionEvent.subscribe((/**
                     * @param {?} permission
                     * @return {?}
                     */
                    function (permission) {
                        _this.permissionEvent.emit(permission);
                    })), this.documentActions.error.subscribe((/**
                     * @param {?} errors
                     * @return {?}
                     */
                    function (errors) {
                        _this.error.emit(errors);
                    })), this.documentActions.success.subscribe((/**
                     * @param {?} message
                     * @return {?}
                     */
                    function (message) {
                        _this.success.emit(message);
                    })));
                    return this.documentActions.getHandler(name);
                }
                return null;
            }
            if (target === ContentActionTarget.Folder) {
                if (this.folderActions) {
                    this.subscriptions.push(this.folderActions.permissionEvent.subscribe((/**
                     * @param {?} permission
                     * @return {?}
                     */
                    function (permission) {
                        _this.permissionEvent.emit(permission);
                    })), this.folderActions.error.subscribe((/**
                     * @param {?} errors
                     * @return {?}
                     */
                    function (errors) {
                        _this.error.emit(errors);
                    })), this.folderActions.success.subscribe((/**
                     * @param {?} message
                     * @return {?}
                     */
                    function (message) {
                        _this.success.emit(message);
                    })));
                    return this.folderActions.getHandler(name);
                }
                return null;
            }
        }
        return null;
    };
    ContentActionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'content-action',
                    template: '',
                    providers: [
                        DocumentActionsService,
                        FolderActionsService
                    ]
                }] }
    ];
    /** @nocollapse */
    ContentActionComponent.ctorParameters = function () { return [
        { type: ContentActionListComponent },
        { type: DocumentActionsService },
        { type: FolderActionsService }
    ]; };
    ContentActionComponent.propDecorators = {
        title: [{ type: Input }],
        icon: [{ type: Input }],
        visible: [{ type: Input }],
        handler: [{ type: Input }],
        target: [{ type: Input }],
        permission: [{ type: Input }],
        disableWithNoPermission: [{ type: Input }],
        disabled: [{ type: Input }],
        execute: [{ type: Output }],
        permissionEvent: [{ type: Output }],
        error: [{ type: Output }],
        success: [{ type: Output }]
    };
    return ContentActionComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LibraryNameColumnComponent = /** @class */ (function () {
    function LibraryNameColumnComponent(element, alfrescoApiService) {
        this.element = element;
        this.alfrescoApiService = alfrescoApiService;
        this.displayTooltip$ = new BehaviorSubject('');
        this.displayText$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    LibraryNameColumnComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.updateValue();
        this.sub = this.alfrescoApiService.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var row = _this.context.row;
            if (row) {
                var entry = row.node.entry;
                if (entry === node) {
                    row.node = { entry: entry };
                    _this.updateValue();
                }
            }
        }));
    };
    /**
     * @protected
     * @return {?}
     */
    LibraryNameColumnComponent.prototype.updateValue = /**
     * @protected
     * @return {?}
     */
    function () {
        this.node = this.context.row.node;
        /** @type {?} */
        var rows = this.context.data.rows || [];
        if (this.node && this.node.entry) {
            this.displayText$.next(this.makeLibraryTitle((/** @type {?} */ (this.node.entry)), rows));
            this.displayTooltip$.next(this.makeLibraryTooltip(this.node.entry));
        }
    };
    /**
     * @return {?}
     */
    LibraryNameColumnComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.element.nativeElement.dispatchEvent(new CustomEvent('name-click', {
            bubbles: true,
            detail: {
                node: this.node
            }
        }));
    };
    /**
     * @param {?} library
     * @return {?}
     */
    LibraryNameColumnComponent.prototype.makeLibraryTooltip = /**
     * @param {?} library
     * @return {?}
     */
    function (library) {
        var description = library.description, title = library.title;
        return description || title || '';
    };
    /**
     * @param {?} library
     * @param {?} rows
     * @return {?}
     */
    LibraryNameColumnComponent.prototype.makeLibraryTitle = /**
     * @param {?} library
     * @param {?} rows
     * @return {?}
     */
    function (library, rows) {
        /** @type {?} */
        var entries = rows.map((/**
         * @param {?} row
         * @return {?}
         */
        function (row) { return row.node.entry; }));
        var title = library.title, id = library.id;
        /** @type {?} */
        var isDuplicate = false;
        if (entries) {
            isDuplicate = entries.some((/**
             * @param {?} entry
             * @return {?}
             */
            function (entry) {
                return entry.id !== id && entry.title === title;
            }));
        }
        return isDuplicate ? title + " (" + id + ")" : "" + title;
    };
    /**
     * @return {?}
     */
    LibraryNameColumnComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    };
    LibraryNameColumnComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-library-name-column',
                    template: "\n        <span class=\"adf-datatable-cell-value\" title=\"{{ displayTooltip$ | async }}\" (click)=\"onClick()\">\n            {{ displayText$ | async }}\n        </span>\n    ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        class: 'adf-datatable-content-cell adf-datatable-link adf-library-name-column'
                    }
                }] }
    ];
    /** @nocollapse */
    LibraryNameColumnComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: AlfrescoApiService }
    ]; };
    LibraryNameColumnComponent.propDecorators = {
        context: [{ type: Input }]
    };
    return LibraryNameColumnComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LibraryRoleColumnComponent = /** @class */ (function () {
    function LibraryRoleColumnComponent(api) {
        this.api = api;
        this.displayText$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    LibraryRoleColumnComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.updateValue();
        this.sub = this.api.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var row = _this.context.row;
            if (row) {
                var entry = row.node.entry;
                if (entry === node) {
                    row.node = { entry: entry };
                    _this.updateValue();
                }
            }
        }));
    };
    /**
     * @protected
     * @return {?}
     */
    LibraryRoleColumnComponent.prototype.updateValue = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var node = this.context.row.node;
        if (node && node.entry) {
            /** @type {?} */
            var role = node.entry.role;
            switch (role) {
                case Site.RoleEnum.SiteManager:
                    this.displayText$.next('LIBRARY.ROLE.MANAGER');
                    break;
                case Site.RoleEnum.SiteCollaborator:
                    this.displayText$.next('LIBRARY.ROLE.COLLABORATOR');
                    break;
                case Site.RoleEnum.SiteContributor:
                    this.displayText$.next('LIBRARY.ROLE.CONTRIBUTOR');
                    break;
                case Site.RoleEnum.SiteConsumer:
                    this.displayText$.next('LIBRARY.ROLE.CONSUMER');
                    break;
                default:
                    this.displayText$.next('');
                    break;
            }
        }
    };
    /**
     * @return {?}
     */
    LibraryRoleColumnComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    };
    LibraryRoleColumnComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-library-role-column',
                    template: "\n        <span class=\"adf-datatable-cell-value\" title=\"{{ (displayText$ | async) | translate }}\">\n            {{ (displayText$ | async) | translate }}\n        </span>\n    ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-library-role-column adf-datatable-content-cell' }
                }] }
    ];
    /** @nocollapse */
    LibraryRoleColumnComponent.ctorParameters = function () { return [
        { type: AlfrescoApiService }
    ]; };
    LibraryRoleColumnComponent.propDecorators = {
        context: [{ type: Input }]
    };
    return LibraryRoleColumnComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LibraryStatusColumnComponent = /** @class */ (function () {
    function LibraryStatusColumnComponent(api) {
        this.api = api;
        this.displayText$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    LibraryStatusColumnComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.updateValue();
        this.sub = this.api.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var row = _this.context.row;
            if (row) {
                var entry = row.node.entry;
                if (entry === node) {
                    row.node = { entry: entry };
                    _this.updateValue();
                }
            }
        }));
    };
    /**
     * @protected
     * @return {?}
     */
    LibraryStatusColumnComponent.prototype.updateValue = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var node = this.context.row.node;
        if (node && node.entry) {
            /** @type {?} */
            var visibility = node.entry.visibility;
            switch (visibility) {
                case Site.VisibilityEnum.PUBLIC:
                    this.displayText$.next('LIBRARY.VISIBILITY.PUBLIC');
                    break;
                case Site.VisibilityEnum.PRIVATE:
                    this.displayText$.next('LIBRARY.VISIBILITY.PRIVATE');
                    break;
                case Site.VisibilityEnum.MODERATED:
                    this.displayText$.next('LIBRARY.VISIBILITY.MODERATED');
                    break;
                default:
                    this.displayText$.next('UNKNOWN');
                    break;
            }
        }
    };
    /**
     * @return {?}
     */
    LibraryStatusColumnComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    };
    LibraryStatusColumnComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-library-status-column',
                    template: "\n        <span class=\"adf-datatable-cell-value\" title=\"{{ (displayText$ | async) | translate }}\">\n            {{ (displayText$ | async) | translate }}\n        </span>\n    ",
                    host: { class: 'adf-library-status-column adf-datatable-content-cell' }
                }] }
    ];
    /** @nocollapse */
    LibraryStatusColumnComponent.ctorParameters = function () { return [
        { type: AlfrescoApiService }
    ]; };
    LibraryStatusColumnComponent.propDecorators = {
        context: [{ type: Input }]
    };
    return LibraryStatusColumnComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NameColumnComponent = /** @class */ (function () {
    function NameColumnComponent(element, alfrescoApiService) {
        this.element = element;
        this.alfrescoApiService = alfrescoApiService;
        this.displayText$ = new BehaviorSubject('');
    }
    /**
     * @return {?}
     */
    NameColumnComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.updateValue();
        this.sub = this.alfrescoApiService.nodeUpdated.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var row = _this.context.row;
            if (row) {
                var entry = row.node.entry;
                if (entry === node) {
                    row.node = { entry: entry };
                    _this.updateValue();
                }
            }
        }));
    };
    /**
     * @protected
     * @return {?}
     */
    NameColumnComponent.prototype.updateValue = /**
     * @protected
     * @return {?}
     */
    function () {
        this.node = this.context.row.node;
        if (this.node && this.node.entry) {
            this.displayText$.next(this.node.entry.name || this.node.entry.id);
        }
    };
    /**
     * @return {?}
     */
    NameColumnComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.element.nativeElement.dispatchEvent(new CustomEvent('name-click', {
            bubbles: true,
            detail: {
                node: this.node
            }
        }));
    };
    /**
     * @return {?}
     */
    NameColumnComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.sub) {
            this.sub.unsubscribe();
            this.sub = null;
        }
    };
    NameColumnComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-name-column',
                    template: "\n        <span class=\"adf-datatable-cell-value\" title=\"{{ node | adfNodeNameTooltip }}\" (click)=\"onClick()\">\n            {{ displayText$ | async }}\n        </span>\n    ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-datatable-content-cell adf-datatable-link adf-name-column' }
                }] }
    ];
    /** @nocollapse */
    NameColumnComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: AlfrescoApiService }
    ]; };
    NameColumnComponent.propDecorators = {
        context: [{ type: Input }]
    };
    return NameColumnComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TrashcanNameColumnComponent = /** @class */ (function () {
    function TrashcanNameColumnComponent() {
        this.isLibrary = false;
    }
    /**
     * @return {?}
     */
    TrashcanNameColumnComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.node = this.context.row.node;
        /** @type {?} */
        var rows = this.context.data.rows || [];
        if (this.node && this.node.entry) {
            this.isLibrary = this.node.entry.nodeType === 'st:site';
            if (this.isLibrary) {
                var properties = this.node.entry.properties;
                this.displayText = this.makeLibraryTitle(this.node.entry, rows);
                this.displayTooltip =
                    properties['cm:description'] || properties['cm:title'];
            }
            else {
                this.displayText = this.node.entry.name || this.node.entry.id;
            }
        }
    };
    /**
     * @param {?} library
     * @param {?} rows
     * @return {?}
     */
    TrashcanNameColumnComponent.prototype.makeLibraryTitle = /**
     * @param {?} library
     * @param {?} rows
     * @return {?}
     */
    function (library, rows) {
        /** @type {?} */
        var entries = rows.map((/**
         * @param {?} r
         * @return {?}
         */
        function (r) { return r.node.entry; }));
        var id = library.id;
        /** @type {?} */
        var title = library.properties['cm:title'];
        /** @type {?} */
        var isDuplicate = false;
        if (entries) {
            isDuplicate = entries.some((/**
             * @param {?} entry
             * @return {?}
             */
            function (entry) {
                return entry.id !== id && entry.properties['cm:title'] === title;
            }));
        }
        return isDuplicate
            ? library.properties['cm:title'] + " (" + library.name + ")"
            : "" + library.properties['cm:title'];
    };
    TrashcanNameColumnComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-trashcan-name-column',
                    template: "\n    <ng-container *ngIf=\"!isLibrary\">\n      <span class=\"adf-datatable-cell-value\" title=\"{{ node | adfNodeNameTooltip }}\">{{ displayText }}</span>\n    </ng-container>\n    <ng-container *ngIf=\"isLibrary\">\n      <span class=\"adf-datatable-cell-value\" title=\"{{ displayTooltip }}\">{{ displayText }}</span>\n    </ng-container>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-datatable-content-cell adf-trashcan-name-column' }
                }] }
    ];
    TrashcanNameColumnComponent.propDecorators = {
        context: [{ type: Input }]
    };
    return TrashcanNameColumnComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// note: contains only limited subset of available fields
var NodePaging = /** @class */ (function () {
    function NodePaging() {
    }
    return NodePaging;
}());
var NodePagingList = /** @class */ (function () {
    function NodePagingList() {
    }
    return NodePagingList;
}());
var NodeMinimalEntry = /** @class */ (function () {
    function NodeMinimalEntry() {
    }
    return NodeMinimalEntry;
}());
var Pagination$1 = /** @class */ (function () {
    function Pagination$$1() {
    }
    return Pagination$$1;
}());
var NodeMinimal = /** @class */ (function () {
    function NodeMinimal() {
        this.properties = {};
    }
    return NodeMinimal;
}());
var UserInfo = /** @class */ (function () {
    function UserInfo() {
    }
    return UserInfo;
}());
var ContentInfo = /** @class */ (function () {
    function ContentInfo() {
    }
    return ContentInfo;
}());
var PathInfoEntity = /** @class */ (function () {
    function PathInfoEntity() {
    }
    return PathInfoEntity;
}());
var PathElementEntity = /** @class */ (function () {
    function PathElementEntity() {
    }
    return PathElementEntity;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PermissionStyleModel = /** @class */ (function () {
    function PermissionStyleModel(css, permission, isFile, isFolder) {
        if (isFile === void 0) { isFile = true; }
        if (isFolder === void 0) { isFolder = true; }
        this.isFolder = true;
        this.isFile = true;
        this.css = css;
        this.permission = permission;
        this.isFile = isFile;
        this.isFolder = isFolder;
    }
    return PermissionStyleModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FileUploadingListComponent = /** @class */ (function () {
    function FileUploadingListComponent(uploadService, nodesApi, translateService) {
        this.uploadService = uploadService;
        this.nodesApi = nodesApi;
        this.translateService = translateService;
        this.FileUploadStatus = FileUploadStatus;
        this.files = [];
        /**
         * Emitted when a file in the list has an error.
         */
        this.error = new EventEmitter();
    }
    /**
     * Cancel file upload
     *
     * @param file File model to cancel upload for.
     *
     * @memberOf FileUploadingListComponent
     */
    /**
     * Cancel file upload
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to cancel upload for.
     *
     * @return {?}
     */
    FileUploadingListComponent.prototype.cancelFile = /**
     * Cancel file upload
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to cancel upload for.
     *
     * @return {?}
     */
    function (file) {
        this.uploadService.cancelUpload(file);
    };
    /**
     * Remove uploaded file
     *
     * @param file File model to remove upload for.
     *
     * @memberOf FileUploadingListComponent
     */
    /**
     * Remove uploaded file
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to remove upload for.
     *
     * @return {?}
     */
    FileUploadingListComponent.prototype.removeFile = /**
     * Remove uploaded file
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to remove upload for.
     *
     * @return {?}
     */
    function (file) {
        var _this = this;
        this.deleteNode(file).subscribe((/**
         * @return {?}
         */
        function () {
            if (file.status === FileUploadStatus.Error) {
                _this.notifyError(file);
            }
            _this.cancelNodeVersionInstances(file);
            _this.uploadService.cancelUpload(file);
        }));
    };
    /**
     * Call the appropriate method for each file, depending on state
     */
    /**
     * Call the appropriate method for each file, depending on state
     * @return {?}
     */
    FileUploadingListComponent.prototype.cancelAllFiles = /**
     * Call the appropriate method for each file, depending on state
     * @return {?}
     */
    function () {
        var _this = this;
        this.getUploadingFiles().forEach((/**
         * @param {?} file
         * @return {?}
         */
        function (file) {
            return _this.uploadService.cancelUpload(file);
        }));
        /** @type {?} */
        var deletedFiles = this.files
            .filter((/**
         * @param {?} file
         * @return {?}
         */
        function (file) { return file.status === FileUploadStatus.Complete; }))
            .map((/**
         * @param {?} file
         * @return {?}
         */
        function (file) { return _this.deleteNode(file); }));
        forkJoin.apply(void 0, __spread(deletedFiles)).subscribe((/**
         * @param {?} files
         * @return {?}
         */
        function (files) {
            var _a;
            /** @type {?} */
            var errors = files.filter((/**
             * @param {?} file
             * @return {?}
             */
            function (file) { return file.status === FileUploadStatus.Error; }));
            if (errors.length) {
                _this.notifyError.apply(_this, __spread(errors));
            }
            (_a = _this.uploadService).cancelUpload.apply(_a, __spread(files));
        }));
    };
    /**
     * Checks if all the files are uploaded false if there is at least one file in Progress | Starting | Pending
     */
    /**
     * Checks if all the files are uploaded false if there is at least one file in Progress | Starting | Pending
     * @return {?}
     */
    FileUploadingListComponent.prototype.isUploadCompleted = /**
     * Checks if all the files are uploaded false if there is at least one file in Progress | Starting | Pending
     * @return {?}
     */
    function () {
        return (!this.isUploadCancelled() &&
            Boolean(this.files.length) &&
            !this.files.some((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var status = _a.status;
                return status === FileUploadStatus.Starting ||
                    status === FileUploadStatus.Progress ||
                    status === FileUploadStatus.Pending;
            })));
    };
    /**
     * Check if all the files are Cancelled | Aborted | Error. false if there is at least one file in uploading states
     */
    /**
     * Check if all the files are Cancelled | Aborted | Error. false if there is at least one file in uploading states
     * @return {?}
     */
    FileUploadingListComponent.prototype.isUploadCancelled = /**
     * Check if all the files are Cancelled | Aborted | Error. false if there is at least one file in uploading states
     * @return {?}
     */
    function () {
        return (!!this.files.length &&
            this.files.every((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var status = _a.status;
                return status === FileUploadStatus.Aborted ||
                    status === FileUploadStatus.Cancelled ||
                    status === FileUploadStatus.Deleted;
            })));
    };
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    FileUploadingListComponent.prototype.deleteNode = /**
     * @private
     * @param {?} file
     * @return {?}
     */
    function (file) {
        var id = file.data.entry.id;
        return this.nodesApi.deleteNode(id, { permanent: true }).pipe(map((/**
         * @return {?}
         */
        function () {
            file.status = FileUploadStatus.Deleted;
            return file;
        })), catchError((/**
         * @return {?}
         */
        function () {
            file.status = FileUploadStatus.Error;
            return of(file);
        })));
    };
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    FileUploadingListComponent.prototype.cancelNodeVersionInstances = /**
     * @private
     * @param {?} file
     * @return {?}
     */
    function (file) {
        this.files
            .filter((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            return item.data.entry.id === file.data.entry.id &&
                item.options.newVersion;
        }))
            .map((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            item.status = FileUploadStatus.Deleted;
        }));
    };
    /**
     * @private
     * @param {...?} files
     * @return {?}
     */
    FileUploadingListComponent.prototype.notifyError = /**
     * @private
     * @param {...?} files
     * @return {?}
     */
    function () {
        var files = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            files[_i] = arguments[_i];
        }
        /** @type {?} */
        var messageError = null;
        if (files.length === 1) {
            messageError = this.translateService.instant('FILE_UPLOAD.MESSAGES.REMOVE_FILE_ERROR', { fileName: files[0].name });
        }
        else {
            messageError = this.translateService.instant('FILE_UPLOAD.MESSAGES.REMOVE_FILES_ERROR', { total: files.length });
        }
        this.error.emit(messageError);
    };
    /**
     * @private
     * @return {?}
     */
    FileUploadingListComponent.prototype.getUploadingFiles = /**
     * @private
     * @return {?}
     */
    function () {
        return this.files.filter((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            if (item.status === FileUploadStatus.Pending ||
                item.status === FileUploadStatus.Progress ||
                item.status === FileUploadStatus.Starting) {
                return item;
            }
        }));
    };
    FileUploadingListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-file-uploading-list',
                    template: "<div class=\"upload-list\">\n    <ng-template\n        ngFor\n        [ngForOf]=\"files\"\n        [ngForTemplate]=\"template\">\n    </ng-template>\n</div>\n",
                    styles: [":host{display:flex;flex-direction:column}"]
                }] }
    ];
    /** @nocollapse */
    FileUploadingListComponent.ctorParameters = function () { return [
        { type: UploadService },
        { type: NodesApiService },
        { type: TranslationService }
    ]; };
    FileUploadingListComponent.propDecorators = {
        template: [{ type: ContentChild, args: [TemplateRef,] }],
        files: [{ type: Input }],
        error: [{ type: Output }]
    };
    return FileUploadingListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FileUploadingDialogComponent = /** @class */ (function () {
    function FileUploadingDialogComponent(uploadService, changeDetector) {
        this.uploadService = uploadService;
        this.changeDetector = changeDetector;
        /**
         * Dialog position. Can be 'left' or 'right'.
         */
        this.position = 'right';
        /**
         * Emitted when a file in the list has an error.
         */
        this.error = new EventEmitter();
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.isDialogMinimized = false;
        this.isConfirmation = false;
    }
    /**
     * @return {?}
     */
    FileUploadingDialogComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.listSubscription = this.uploadService
            .queueChanged.subscribe((/**
         * @param {?} fileList
         * @return {?}
         */
        function (fileList) {
            _this.filesUploadingList = fileList;
            if (_this.filesUploadingList.length) {
                _this.isDialogActive = true;
            }
        }));
        this.counterSubscription = merge(this.uploadService.fileUploadComplete, this.uploadService.fileUploadDeleted)
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this.totalCompleted = event.totalComplete;
            _this.changeDetector.detectChanges();
        }));
        this.errorSubscription = this.uploadService.fileUploadError
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this.totalErrors = event.totalError;
            _this.changeDetector.detectChanges();
        }));
        this.fileUploadSubscription = this.uploadService
            .fileUpload.subscribe((/**
         * @return {?}
         */
        function () {
            _this.changeDetector.detectChanges();
        }));
        this.uploadService.fileDeleted.subscribe((/**
         * @param {?} objId
         * @return {?}
         */
        function (objId) {
            if (_this.filesUploadingList) {
                /** @type {?} */
                var file = _this.filesUploadingList.find((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    return item.data.entry.id === objId;
                }));
                if (file) {
                    file.status = FileUploadStatus.Cancelled;
                    _this.changeDetector.detectChanges();
                }
            }
        }));
    };
    /**
     * Toggle confirmation message.
     */
    /**
     * Toggle confirmation message.
     * @return {?}
     */
    FileUploadingDialogComponent.prototype.toggleConfirmation = /**
     * Toggle confirmation message.
     * @return {?}
     */
    function () {
        this.isConfirmation = !this.isConfirmation;
        if (this.isDialogMinimized) {
            this.isDialogMinimized = false;
        }
    };
    /**
     * Cancel uploads and hide confirmation
     */
    /**
     * Cancel uploads and hide confirmation
     * @return {?}
     */
    FileUploadingDialogComponent.prototype.cancelAllUploads = /**
     * Cancel uploads and hide confirmation
     * @return {?}
     */
    function () {
        this.toggleConfirmation();
        this.uploadList.cancelAllFiles();
    };
    /**
     * Toggle dialog minimized state.
     */
    /**
     * Toggle dialog minimized state.
     * @return {?}
     */
    FileUploadingDialogComponent.prototype.toggleMinimized = /**
     * Toggle dialog minimized state.
     * @return {?}
     */
    function () {
        this.isDialogMinimized = !this.isDialogMinimized;
        this.changeDetector.detectChanges();
    };
    /**
     * Dismiss dialog
     */
    /**
     * Dismiss dialog
     * @return {?}
     */
    FileUploadingDialogComponent.prototype.close = /**
     * Dismiss dialog
     * @return {?}
     */
    function () {
        this.isConfirmation = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.isDialogMinimized = false;
        this.uploadService.clearQueue();
        this.changeDetector.detectChanges();
    };
    /**
     * @return {?}
     */
    FileUploadingDialogComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.uploadService.clearQueue();
        this.listSubscription.unsubscribe();
        this.counterSubscription.unsubscribe();
        this.fileUploadSubscription.unsubscribe();
        this.errorSubscription.unsubscribe();
    };
    FileUploadingDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-file-uploading-dialog',
                    template: "<div *ngIf=\"isDialogActive\"\n     class=\"adf-upload-dialog\"\n     id=\"upload-dialog\"\n     [class.adf-upload-dialog--minimized]=\"isDialogMinimized\"\n     [class.adf-upload-dialog--position-left]=\"position === 'left'\"\n     [class.adf-upload-dialog--position-right]=\"position === 'right'\">\n    <header class=\"adf-upload-dialog__header\">\n        <button\n            mat-button\n            color=\"secondary\"\n            [disabled]=\"isConfirmation\"\n            (click)=\"toggleMinimized()\">\n            <mat-icon\n                mat-list-icon\n                title=\"{{ (isDialogMinimized ? 'ADF_FILE_UPLOAD.BUTTON.MAXIMIZE': 'ADF_FILE_UPLOAD.BUTTON.MINIMIZE') | translate }}\">\n                    {{ isDialogMinimized ? 'keyboard_arrow_up' : 'keyboard_arrow_down' }}\n            </mat-icon>\n        </button>\n\n        <span\n            class=\"adf-upload-dialog__title\"\n            *ngIf=\"!uploadList.isUploadCancelled()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_PROGRESS'\n                | translate: {\n                    completed: totalCompleted,\n                    total: filesUploadingList.length\n                }\n            }}\n        </span>\n\n        <span\n            class=\"adf-upload-dialog__title\"\n            *ngIf=\"uploadList.isUploadCancelled()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_CANCELED' | translate }}\n        </span>\n    </header>\n\n    <section class=\"adf-upload-dialog__info\"\n        *ngIf=\"totalErrors\">\n        {{\n            (totalErrors > 1\n                 ? 'FILE_UPLOAD.MESSAGES.UPLOAD_ERRORS'\n                 : 'FILE_UPLOAD.MESSAGES.UPLOAD_ERROR')\n                 | translate: { total: totalErrors }\n        }}\n    </section>\n\n    <section class=\"adf-upload-dialog__content\"\n        [class.adf-upload-dialog--padding]=\"isConfirmation\">\n        <adf-file-uploading-list\n            [class.adf-upload-dialog--hide]=\"isConfirmation\"\n            #uploadList\n            [files]=\"filesUploadingList\">\n                <ng-template let-file=\"$implicit\">\n                     <adf-file-uploading-list-row\n                        [file]=\"file\"\n                        (remove)=\"uploadList.removeFile(file)\"\n                        (cancel)=\"uploadList.cancelFile(file)\">\n                    </adf-file-uploading-list-row>\n                </ng-template>\n        </adf-file-uploading-list>\n\n        <div\n            class=\"adf-upload-dialog__confirmation\"\n            [class.adf-upload-dialog--hide]=\"!isConfirmation\">\n                <p class=\"adf-upload-dialog__confirmation--title\">\n                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TITLE' | translate }}\n                </p>\n\n                <p class=\"adf-upload-dialog__confirmation--text\">\n                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TEXT' | translate }}\n                </p>\n        </div>\n    </section>\n\n    <footer class=\"adf-upload-dialog__actions\"\n            *ngIf=\"!isConfirmation\">\n        <button\n            id=\"adf-upload-dialog-cancel-all\"\n            color=\"primary\"\n            mat-button\n            *ngIf=\"!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()\"\n            (click)=\"toggleConfirmation()\">\n            {{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_ALL' | translate }}\n        </button>\n\n        <button\n            id=\"adf-upload-dialog-close\"\n            *ngIf=\"uploadList.isUploadCompleted() || uploadList.isUploadCancelled()\"\n            mat-button\n            color=\"primary\"\n            (click)=\"close()\">\n            {{ 'ADF_FILE_UPLOAD.BUTTON.CLOSE' | translate }}\n        </button>\n    </footer>\n\n    <footer class=\"adf-upload-dialog__actions\"\n            *ngIf=\"isConfirmation\">\n        <button\n            id=\"adf-upload-dialog-cancel\"\n            color=\"secondary\"\n            mat-button\n            (click)=\"cancelAllUploads()\">\n            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CANCEL' | translate }}\n        </button>\n\n        <button\n            id=\"adf-upload-dialog-confirm\"\n            mat-button\n            color=\"primary\"\n            (click)=\"toggleConfirmation()\">\n            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CONTINUE' | translate }}\n        </button>\n    </footer>\n</div>\n",
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    FileUploadingDialogComponent.ctorParameters = function () { return [
        { type: UploadService },
        { type: ChangeDetectorRef }
    ]; };
    FileUploadingDialogComponent.propDecorators = {
        uploadList: [{ type: ViewChild, args: ['uploadList',] }],
        position: [{ type: Input }],
        error: [{ type: Output }]
    };
    return FileUploadingDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FileUploadingListRowComponent = /** @class */ (function () {
    function FileUploadingListRowComponent() {
        this.cancel = new EventEmitter();
        this.remove = new EventEmitter();
        this.FileUploadStatus = FileUploadStatus;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    FileUploadingListRowComponent.prototype.onCancel = /**
     * @param {?} file
     * @return {?}
     */
    function (file) {
        this.cancel.emit(file);
    };
    /**
     * @param {?} file
     * @return {?}
     */
    FileUploadingListRowComponent.prototype.onRemove = /**
     * @param {?} file
     * @return {?}
     */
    function (file) {
        this.remove.emit(file);
    };
    /**
     * @return {?}
     */
    FileUploadingListRowComponent.prototype.showCancelledStatus = /**
     * @return {?}
     */
    function () {
        return this.file.status === FileUploadStatus.Cancelled ||
            this.file.status === FileUploadStatus.Aborted ||
            this.file.status === FileUploadStatus.Deleted;
    };
    Object.defineProperty(FileUploadingListRowComponent.prototype, "versionNumber", {
        get: /**
         * @return {?}
         */
        function () {
            return this.file.data.entry.properties['cm:versionLabel'];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileUploadingListRowComponent.prototype, "mimeType", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.file && this.file.file && this.file.file.type) {
                return this.file.file.type;
            }
            return 'default';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FileUploadingListRowComponent.prototype.isUploadVersion = /**
     * @return {?}
     */
    function () {
        return (!!this.file.data &&
            this.file.options &&
            this.file.options.newVersion &&
            this.file.data.entry.properties &&
            this.file.data.entry.properties['cm:versionLabel']);
    };
    FileUploadingListRowComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-file-uploading-list-row',
                    template: "<div class=\"adf-file-uploading-row\">\n    <mat-icon *ngIf=\"mimeType === 'default'\" mat-list-icon class=\"adf-file-uploading-row__type\">\n        insert_drive_file\n    </mat-icon>\n\n    <adf-icon *ngIf=\"mimeType !== 'default'\" value=\"adf:{{ mimeType }}\"></adf-icon>\n\n    <span\n        class=\"adf-file-uploading-row__name\"\n        title=\"{{ file.name }}\">\n        {{ file.name }}\n    </span>\n\n    <span *ngIf=\"isUploadVersion()\" class=\"adf-file-uploading-row__version\">\n        <mat-chip color=\"primary\" [attr.aria-label]=\"'ADF_FILE_UPLOAD.ARIA-LABEL.VERSION' | translate\" [title]=\"'version' + versionNumber\" disabled>{{\n            versionNumber\n        }}</mat-chip>\n    </span>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Progress || file.status === FileUploadStatus.Starting\"\n        (click)=\"onCancel(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\"\n        title=\"{{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_FILE' | translate }}\">\n        <span class=\"adf-file-uploading-row__status\">\n            {{ file.progress.loaded | adfFileSize }} / {{ file.progress.total | adfFileSize }}\n        </span>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--cancel\">\n            clear\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Complete && !isUploadVersion()\"\n        (click)=\"onRemove(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\"\n        title=\"{{ 'ADF_FILE_UPLOAD.BUTTON.REMOVE_FILE' | translate }}\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status adf-file-uploading-row__status--done\">\n            check_circle\n        </mat-icon>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--remove\">\n            remove_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Complete && isUploadVersion()\"\n        class=\"adf-file-uploading-row__file-version\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status--done\">\n            check_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Pending\"\n        (click)=\"onCancel(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status adf-file-uploading-row__status--pending\">\n            schedule\n        </mat-icon>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--remove\">\n            remove_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Error\"\n        class=\"adf-file-uploading-row__block adf-file-uploading-row__status--error\">\n        <mat-icon mat-list-icon\n            [attr.aria-label]=\"'ADF_FILE_UPLOAD.ARIA-LABEL.ERROR' | translate\"\n            [matTooltip]=\"file.errorCode | adfFileUploadError\">\n            report_problem\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"showCancelledStatus()\"\n        class=\"adf-file-uploading-row__block adf-file-uploading-row__status--cancelled\">\n        {{ 'ADF_FILE_UPLOAD.STATUS.FILE_CANCELED_STATUS' | translate }}\n    </div>\n</div>\n",
                    styles: [""]
                }] }
    ];
    FileUploadingListRowComponent.propDecorators = {
        file: [{ type: Input }],
        cancel: [{ type: Output }],
        remove: [{ type: Output }]
    };
    return FileUploadingListRowComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var UploadFilesEvent = /** @class */ (function () {
    function UploadFilesEvent(files, uploadService, callback) {
        this.files = files;
        this.uploadService = uploadService;
        this.callback = callback;
        this.isDefaultPrevented = false;
    }
    Object.defineProperty(UploadFilesEvent.prototype, "defaultPrevented", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isDefaultPrevented;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    UploadFilesEvent.prototype.preventDefault = /**
     * @return {?}
     */
    function () {
        this.isDefaultPrevented = true;
    };
    /**
     * @return {?}
     */
    UploadFilesEvent.prototype.pauseUpload = /**
     * @return {?}
     */
    function () {
        this.preventDefault();
    };
    /**
     * @return {?}
     */
    UploadFilesEvent.prototype.resumeUpload = /**
     * @return {?}
     */
    function () {
        var _a;
        if (this.files && this.files.length > 0) {
            (_a = this.uploadService).addToQueue.apply(_a, __spread(this.files));
            this.uploadService.uploadFilesInTheQueue(this.callback);
        }
    };
    return UploadFilesEvent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var UploadBase = /** @class */ (function () {
    function UploadBase(uploadService, translationService, ngZone) {
        this.uploadService = uploadService;
        this.translationService = translationService;
        this.ngZone = ngZone;
        /**
         * The ID of the root. Use the nodeId for
         * Content Services or the taskId/processId for Process Services.
         */
        this.rootFolderId = '-root-';
        /**
         * Toggles component disabled state (if there is no node permission checking).
         */
        this.disabled = false;
        /**
         * Filter for accepted file types.
         */
        this.acceptedFilesType = '*';
        /**
         * Toggles versioning.
         */
        this.versioning = false;
        /**
         * majorVersion boolean field to true to indicate a major version should be created.
         */
        this.majorVersion = false;
        /**
         * Custom node type for uploaded file
         */
        this.nodeType = 'cm:content';
        /**
         * Emitted when the file is uploaded successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the upload begins.
         */
        this.beginUpload = new EventEmitter();
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    UploadBase.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.uploadService.fileUploadError.subscribe((/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            _this.error.emit(error);
        })));
    };
    /**
     * @return {?}
     */
    UploadBase.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        function (subscription) { return subscription.unsubscribe(); }));
        this.subscriptions = [];
    };
    /**
     * Upload a list of file in the specified path
     * @param files
     * @param path
     */
    /**
     * Upload a list of file in the specified path
     * @param {?} files
     * @return {?}
     */
    UploadBase.prototype.uploadFiles = /**
     * Upload a list of file in the specified path
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        /** @type {?} */
        var filteredFiles = files
            .map((/**
         * @param {?} file
         * @return {?}
         */
        function (file) {
            return _this.createFileModel(file, _this.rootFolderId, (((/** @type {?} */ (file))).webkitRelativePath || '').replace(/\/[^\/]*$/, ''));
        }));
        this.uploadQueue(filteredFiles);
    };
    /**
     * @param {?} files
     * @return {?}
     */
    UploadBase.prototype.uploadFilesInfo = /**
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        /** @type {?} */
        var filteredFiles = files
            .map((/**
         * @param {?} fileInfo
         * @return {?}
         */
        function (fileInfo) {
            return _this.createFileModel(fileInfo.file, _this.rootFolderId, fileInfo.relativeFolder);
        }));
        this.uploadQueue(filteredFiles);
    };
    /**
     * @private
     * @param {?} files
     * @return {?}
     */
    UploadBase.prototype.uploadQueue = /**
     * @private
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        /** @type {?} */
        var filteredFiles = files
            .filter(this.isFileAcceptable.bind(this))
            .filter(this.isFileSizeAcceptable.bind(this));
        this.ngZone.run((/**
         * @return {?}
         */
        function () {
            var _a;
            /** @type {?} */
            var event = new UploadFilesEvent(__spread(filteredFiles), _this.uploadService, _this.success);
            _this.beginUpload.emit(event);
            if (!event.defaultPrevented) {
                if (filteredFiles.length > 0) {
                    (_a = _this.uploadService).addToQueue.apply(_a, __spread(filteredFiles));
                    _this.uploadService.uploadFilesInTheQueue(_this.success);
                }
            }
        }));
    };
    /**
     * Checks if the given file is allowed by the extension filters
     *
     * @param file FileModel
     */
    /**
     * Checks if the given file is allowed by the extension filters
     *
     * @protected
     * @param {?} file FileModel
     * @return {?}
     */
    UploadBase.prototype.isFileAcceptable = /**
     * Checks if the given file is allowed by the extension filters
     *
     * @protected
     * @param {?} file FileModel
     * @return {?}
     */
    function (file) {
        if (this.acceptedFilesType === '*') {
            return true;
        }
        /** @type {?} */
        var allowedExtensions = this.acceptedFilesType
            .split(',')
            .map((/**
         * @param {?} ext
         * @return {?}
         */
        function (ext) { return ext.trim().replace(/^\./, ''); }));
        if (allowedExtensions.indexOf(file.extension) !== -1) {
            return true;
        }
        return false;
    };
    /**
     * Creates FileModel from File
     *
     * @param file
     */
    /**
     * Creates FileModel from File
     *
     * @protected
     * @param {?} file
     * @param {?} parentId
     * @param {?} path
     * @param {?=} id
     * @return {?}
     */
    UploadBase.prototype.createFileModel = /**
     * Creates FileModel from File
     *
     * @protected
     * @param {?} file
     * @param {?} parentId
     * @param {?} path
     * @param {?=} id
     * @return {?}
     */
    function (file, parentId, path, id) {
        return new FileModel(file, {
            comment: this.comment,
            majorVersion: this.majorVersion,
            newVersion: this.versioning,
            parentId: parentId,
            path: path,
            nodeType: this.nodeType
        }, id);
    };
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    UploadBase.prototype.isFileSizeAllowed = /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    function (file) {
        /** @type {?} */
        var isFileSizeAllowed = true;
        if (this.isMaxFileSizeDefined()) {
            isFileSizeAllowed = this.isFileSizeCorrect(file);
        }
        return isFileSizeAllowed;
    };
    /**
     * @protected
     * @return {?}
     */
    UploadBase.prototype.isMaxFileSizeDefined = /**
     * @protected
     * @return {?}
     */
    function () {
        return this.maxFilesSize !== undefined && this.maxFilesSize !== null;
    };
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    UploadBase.prototype.isFileSizeCorrect = /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    function (file) {
        return this.maxFilesSize >= 0 && file.size <= this.maxFilesSize;
    };
    /**
     * Checks if the given file is an acceptable size
     *
     * @param file FileModel
     */
    /**
     * Checks if the given file is an acceptable size
     *
     * @private
     * @param {?} file FileModel
     * @return {?}
     */
    UploadBase.prototype.isFileSizeAcceptable = /**
     * Checks if the given file is an acceptable size
     *
     * @private
     * @param {?} file FileModel
     * @return {?}
     */
    function (file) {
        /** @type {?} */
        var acceptableSize = true;
        if (!this.isFileSizeAllowed(file)) {
            acceptableSize = false;
            /** @type {?} */
            var message = this.translationService.instant('FILE_UPLOAD.MESSAGES.EXCEED_MAX_FILE_SIZE', { fileName: file.name });
            this.error.emit(message);
        }
        return acceptableSize;
    };
    UploadBase.propDecorators = {
        maxFilesSize: [{ type: Input }],
        rootFolderId: [{ type: Input }],
        disabled: [{ type: Input }],
        acceptedFilesType: [{ type: Input }],
        versioning: [{ type: Input }],
        majorVersion: [{ type: Input }],
        comment: [{ type: Input }],
        nodeType: [{ type: Input }],
        success: [{ type: Output }],
        error: [{ type: Output }],
        beginUpload: [{ type: Output }]
    };
    return UploadBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var UploadButtonComponent = /** @class */ (function (_super) {
    __extends(UploadButtonComponent, _super);
    function UploadButtonComponent(uploadService, contentService, translationService, logService, ngZone) {
        var _this = _super.call(this, uploadService, translationService, ngZone) || this;
        _this.uploadService = uploadService;
        _this.contentService = contentService;
        _this.translationService = translationService;
        _this.logService = logService;
        _this.ngZone = ngZone;
        /**
         * Allows/disallows upload folders (only for Chrome).
         */
        _this.uploadFolders = false;
        /**
         * Allows/disallows multiple files
         */
        _this.multipleFiles = false;
        /**
         * Custom tooltip text.
         */
        _this.tooltip = null;
        /**
         * Emitted when create permission is missing.
         */
        _this.permissionEvent = new EventEmitter();
        _this.hasAllowableOperations = false;
        _this.permissionValue = new Subject();
        return _this;
    }
    /**
     * @return {?}
     */
    UploadButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.permissionValue.subscribe((/**
         * @param {?} permission
         * @return {?}
         */
        function (permission) {
            _this.hasAllowableOperations = permission;
        }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    UploadButtonComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var rootFolderId = changes['rootFolderId'];
        if (rootFolderId && rootFolderId.currentValue) {
            this.checkPermission();
        }
    };
    /**
     * @return {?}
     */
    UploadButtonComponent.prototype.isButtonDisabled = /**
     * @return {?}
     */
    function () {
        return this.disabled ? true : undefined;
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    UploadButtonComponent.prototype.onFilesAdded = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        /** @type {?} */
        var files = FileUtils.toFileArray($event.currentTarget.files);
        if (this.hasAllowableOperations) {
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        // reset the value of the input file
        $event.target.value = '';
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    UploadButtonComponent.prototype.onDirectoryAdded = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (this.hasAllowableOperations) {
            /** @type {?} */
            var files = FileUtils.toFileArray($event.currentTarget.files);
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        // reset the value of the input file
        $event.target.value = '';
    };
    /**
     * @return {?}
     */
    UploadButtonComponent.prototype.checkPermission = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.rootFolderId) {
            /** @type {?} */
            var opts = {
                includeSource: true,
                include: ['allowableOperations']
            };
            this.contentService.getNode(this.rootFolderId, opts).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            function (res) { return _this.permissionValue.next(_this.nodeHasPermission(res.entry, AllowableOperationsEnum.CREATE)); }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return _this.error.emit(error); }));
        }
    };
    /**
     * @param {?} node
     * @param {?} permission
     * @return {?}
     */
    UploadButtonComponent.prototype.nodeHasPermission = /**
     * @param {?} node
     * @param {?} permission
     * @return {?}
     */
    function (node, permission) {
        return this.contentService.hasAllowableOperations(node, permission);
    };
    UploadButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-upload-button',
                    template: "<form class=\"adf-upload-button-file-container\">\n    <!--Files Upload-->\n    <a *ngIf=\"!uploadFolders\"\n        [disabled]=\"isButtonDisabled()\"\n        mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n\n        <!--Multiple Files Upload-->\n        <span *ngIf=\"multipleFiles\">\n            <label\n                id=\"upload-multiple-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-multiple-files\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-multiple-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-multiple-files\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-multiple-files\"\n                data-automation-id=\"upload-multiple-files\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n\n        <!--Single Files Upload-->\n        <span *ngIf=\"!multipleFiles\">\n            <label\n                id=\"upload-single-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-single-file\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-single-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-single-file\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-single-file\"\n                data-automation-id=\"upload-single-file\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n    </a>\n\n    <!--Folders Upload-->\n    <a *ngIf=\"uploadFolders\"\n        [disabled]=\"isButtonDisabled()\" mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n        <label\n            id=\"uploadFolder-label\"\n            *ngIf=\"!staticTitle\"\n            for=\"uploadFolder\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>\n        <label\n            id=\"uploadFolder-label-static\"\n            *ngIf=\"staticTitle\"\n            for=\"uploadFolder\">{{ staticTitle }}</label>\n        <input #uploadFolders\n            id=\"uploadFolder\"\n            data-automation-id=\"uploadFolder\"\n            type=\"file\"\n            name=\"uploadFiles\"\n            multiple=\"multiple\"\n            accept=\"{{acceptedFilesType}}\"\n            webkitdirectory directory\n            [attr.disabled]=\"isButtonDisabled()\"\n            [title]=\"tooltip\"\n            (change)=\"onDirectoryAdded($event)\">\n    </a>\n</form>\n",
                    viewProviders: [
                        { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return UploadButtonComponent; })) }
                    ],
                    encapsulation: ViewEncapsulation.None,
                    styles: [".adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}"]
                }] }
    ];
    /** @nocollapse */
    UploadButtonComponent.ctorParameters = function () { return [
        { type: UploadService },
        { type: ContentService },
        { type: TranslationService },
        { type: LogService },
        { type: NgZone }
    ]; };
    UploadButtonComponent.propDecorators = {
        uploadFolders: [{ type: Input }],
        multipleFiles: [{ type: Input }],
        staticTitle: [{ type: Input }],
        tooltip: [{ type: Input }],
        permissionEvent: [{ type: Output }]
    };
    return UploadButtonComponent;
}(UploadBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var UploadVersionButtonComponent = /** @class */ (function (_super) {
    __extends(UploadVersionButtonComponent, _super);
    function UploadVersionButtonComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    UploadVersionButtonComponent.prototype.createFileModel = /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    function (file) {
        /** @type {?} */
        var fileModel = _super.prototype.createFileModel.call(this, file, this.rootFolderId, (((/** @type {?} */ (file))).webkitRelativePath || '').replace(/\/[^\/]*$/, ''), this.node.id);
        if (!this.isFileAcceptable(fileModel)) {
            /** @type {?} */
            var message = this.translationService.instant('FILE_UPLOAD.VERSION.MESSAGES.INCOMPATIBLE_VERSION');
            this.error.emit(message);
        }
        return fileModel;
    };
    /**
     * @return {?}
     */
    UploadVersionButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.checkPermission();
    };
    /**
     * @return {?}
     */
    UploadVersionButtonComponent.prototype.checkPermission = /**
     * @return {?}
     */
    function () {
        this.permissionValue.next(this.nodeHasPermission(this.node, AllowableOperationsEnum.UPDATE));
    };
    UploadVersionButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-upload-version-button',
                    template: "<form class=\"adf-upload-button-file-container\">\n    <!--Files Upload-->\n    <a *ngIf=\"!uploadFolders\"\n        [disabled]=\"isButtonDisabled()\"\n        mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n\n        <!--Multiple Files Upload-->\n        <span *ngIf=\"multipleFiles\">\n            <label\n                id=\"upload-multiple-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-multiple-files\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-multiple-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-multiple-files\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-multiple-files\"\n                data-automation-id=\"upload-multiple-files\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n\n        <!--Single Files Upload-->\n        <span *ngIf=\"!multipleFiles\">\n            <label\n                id=\"upload-single-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-single-file\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-single-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-single-file\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-single-file\"\n                data-automation-id=\"upload-single-file\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n    </a>\n\n    <!--Folders Upload-->\n    <a *ngIf=\"uploadFolders\"\n        [disabled]=\"isButtonDisabled()\" mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n        <label\n            id=\"uploadFolder-label\"\n            *ngIf=\"!staticTitle\"\n            for=\"uploadFolder\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>\n        <label\n            id=\"uploadFolder-label-static\"\n            *ngIf=\"staticTitle\"\n            for=\"uploadFolder\">{{ staticTitle }}</label>\n        <input #uploadFolders\n            id=\"uploadFolder\"\n            data-automation-id=\"uploadFolder\"\n            type=\"file\"\n            name=\"uploadFiles\"\n            multiple=\"multiple\"\n            accept=\"{{acceptedFilesType}}\"\n            webkitdirectory directory\n            [attr.disabled]=\"isButtonDisabled()\"\n            [title]=\"tooltip\"\n            (change)=\"onDirectoryAdded($event)\">\n    </a>\n</form>\n",
                    viewProviders: [
                        { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return UploadVersionButtonComponent; })) }
                    ],
                    encapsulation: ViewEncapsulation.None,
                    styles: [".adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}"]
                }] }
    ];
    UploadVersionButtonComponent.propDecorators = {
        node: [{ type: Input }]
    };
    return UploadVersionButtonComponent;
}(UploadButtonComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var UploadDragAreaComponent = /** @class */ (function (_super) {
    __extends(UploadDragAreaComponent, _super);
    function UploadDragAreaComponent(uploadService, translationService, notificationService, contentService, ngZone) {
        var _this = _super.call(this, uploadService, translationService, ngZone) || this;
        _this.uploadService = uploadService;
        _this.translationService = translationService;
        _this.notificationService = notificationService;
        _this.contentService = contentService;
        _this.ngZone = ngZone;
        return _this;
    }
    /**
     * Method called when files are dropped in the drag area.
     *
     * @param files - files dropped in the drag area.
     */
    /**
     * Method called when files are dropped in the drag area.
     *
     * @param {?} files - files dropped in the drag area.
     * @return {?}
     */
    UploadDragAreaComponent.prototype.onFilesDropped = /**
     * Method called when files are dropped in the drag area.
     *
     * @param {?} files - files dropped in the drag area.
     * @return {?}
     */
    function (files) {
        if (!this.disabled && files.length) {
            this.uploadFiles(files);
        }
    };
    /**
     * Called when a folder are dropped in the drag area
     *
     * @param folder - name of the dropped folder
     */
    /**
     * Called when a folder are dropped in the drag area
     *
     * @param {?} folder - name of the dropped folder
     * @return {?}
     */
    UploadDragAreaComponent.prototype.onFolderEntityDropped = /**
     * Called when a folder are dropped in the drag area
     *
     * @param {?} folder - name of the dropped folder
     * @return {?}
     */
    function (folder) {
        var _this = this;
        if (!this.disabled && folder.isDirectory) {
            FileUtils.flatten(folder).then((/**
             * @param {?} filesInfo
             * @return {?}
             */
            function (filesInfo) {
                _this.uploadFilesInfo(filesInfo);
            }));
        }
    };
    /**
     * Show undo notification bar.
     *
     * @param latestFilesAdded - files in the upload queue enriched with status flag and xhr object.
     */
    /**
     * Show undo notification bar.
     *
     * @param {?} latestFilesAdded - files in the upload queue enriched with status flag and xhr object.
     * @return {?}
     */
    UploadDragAreaComponent.prototype.showUndoNotificationBar = /**
     * Show undo notification bar.
     *
     * @param {?} latestFilesAdded - files in the upload queue enriched with status flag and xhr object.
     * @return {?}
     */
    function (latestFilesAdded) {
        var _this = this;
        /** @type {?} */
        var messageTranslate;
        /** @type {?} */
        var actionTranslate;
        messageTranslate = this.translationService.get('FILE_UPLOAD.MESSAGES.PROGRESS');
        actionTranslate = this.translationService.get('FILE_UPLOAD.ACTION.UNDO');
        this.notificationService.openSnackMessageAction(messageTranslate.value, actionTranslate.value, 3000).onAction().subscribe((/**
         * @return {?}
         */
        function () {
            var _a;
            (_a = _this.uploadService).cancelUpload.apply(_a, __spread(latestFilesAdded));
        }));
    };
    /** Returns true or false considering the component options and node permissions */
    /**
     * Returns true or false considering the component options and node permissions
     * @return {?}
     */
    UploadDragAreaComponent.prototype.isDroppable = /**
     * Returns true or false considering the component options and node permissions
     * @return {?}
     */
    function () {
        return !this.disabled;
    };
    /**
     * Handles 'upload-files' events raised by child components.
     *
     * @param event DOM event
     */
    /**
     * Handles 'upload-files' events raised by child components.
     *
     * @param {?} event DOM event
     * @return {?}
     */
    UploadDragAreaComponent.prototype.onUploadFiles = /**
     * Handles 'upload-files' events raised by child components.
     *
     * @param {?} event DOM event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        event.preventDefault();
        /** @type {?} */
        var isAllowed = this.contentService.hasAllowableOperations(event.detail.data.obj.entry, AllowableOperationsEnum.CREATE);
        if (isAllowed) {
            /** @type {?} */
            var fileInfo = event.detail.files;
            if (this.isTargetNodeFolder(event)) {
                /** @type {?} */
                var destinationFolderName_1 = event.detail.data.obj.entry.name;
                fileInfo.map((/**
                 * @param {?} file
                 * @return {?}
                 */
                function (file) { return file.relativeFolder = destinationFolderName_1 ? destinationFolderName_1.concat(file.relativeFolder) : file.relativeFolder; }));
            }
            if (fileInfo && fileInfo.length > 0) {
                this.uploadFilesInfo(fileInfo);
            }
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    UploadDragAreaComponent.prototype.isTargetNodeFolder = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return event.detail.data.obj && event.detail.data.obj.entry.isFolder;
    };
    UploadDragAreaComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-upload-drag-area',
                    template: "<div [adf-file-draggable]=\"isDroppable()\" class=\"adf-upload-border\"\n     (filesDropped)=\"onFilesDropped($event)\"\n     (folderEntityDropped)=\"onFolderEntityDropped($event)\"\n     (upload-files)=\"onUploadFiles($event)\"\n     dropzone=\"\" webkitdropzone=\"*\" #droparea>\n    <ng-content></ng-content>\n</div>\n",
                    host: { 'class': 'adf-upload-drag-area' },
                    viewProviders: [
                        { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return UploadDragAreaComponent; })) }
                    ],
                    encapsulation: ViewEncapsulation.None,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    UploadDragAreaComponent.ctorParameters = function () { return [
        { type: UploadService },
        { type: TranslationService },
        { type: NotificationService },
        { type: ContentService },
        { type: NgZone }
    ]; };
    return UploadDragAreaComponent;
}(UploadBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FileUploadErrorPipe = /** @class */ (function () {
    function FileUploadErrorPipe(translation) {
        this.translation = translation;
    }
    /**
     * @param {?} errorCode
     * @return {?}
     */
    FileUploadErrorPipe.prototype.transform = /**
     * @param {?} errorCode
     * @return {?}
     */
    function (errorCode) {
        return this.translation.instant("FILE_UPLOAD.ERRORS." + (errorCode || 'GENERIC'));
    };
    FileUploadErrorPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'adfFileUploadError',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    FileUploadErrorPipe.ctorParameters = function () { return [
        { type: TranslationService }
    ]; };
    return FileUploadErrorPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
var FileDraggableDirective = /** @class */ (function () {
    function FileDraggableDirective(el, ngZone) {
        this.ngZone = ngZone;
        /**
         * Enables/disables drag-and-drop functionality.
         */
        this.enabled = true;
        /**
         * Emitted when one or more files are dragged and dropped onto the draggable element.
         */
        this.filesDropped = new EventEmitter();
        /**
         * Emitted when a directory is dragged and dropped onto the draggable element.
         */
        this.folderEntityDropped = new EventEmitter();
        this.cssClassName = 'adf-file-draggable__input-focus';
        this.element = el.nativeElement;
    }
    /**
     * @return {?}
     */
    FileDraggableDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            _this.element.addEventListener('dragenter', _this.onDragEnter.bind(_this));
            _this.element.addEventListener('dragover', _this.onDragOver.bind(_this));
            _this.element.addEventListener('dragleave', _this.onDragLeave.bind(_this));
            _this.element.addEventListener('drop', _this.onDropFiles.bind(_this));
        }));
    };
    /**
     * @return {?}
     */
    FileDraggableDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDropFiles);
    };
    /**
     * Method called when files is dropped in the drag and drop area.
     * @param event DOM event.
     */
    /**
     * Method called when files is dropped in the drag and drop area.
     * @param {?} event DOM event.
     * @return {?}
     */
    FileDraggableDirective.prototype.onDropFiles = /**
     * Method called when files is dropped in the drag and drop area.
     * @param {?} event DOM event.
     * @return {?}
     */
    function (event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            // Chrome, Edge, Firefox, Opera (Files + Folders)
            /** @type {?} */
            var items = event.dataTransfer.items;
            if (items) {
                /** @type {?} */
                var files = [];
                for (var i = 0; i < items.length; i++) {
                    if (items[i].webkitGetAsEntry) {
                        /** @type {?} */
                        var item = items[i].webkitGetAsEntry();
                        if (item) {
                            if (item.isFile) {
                                /** @type {?} */
                                var file = items[i].getAsFile();
                                if (file) {
                                    files.push(file);
                                }
                            }
                            else if (item.isDirectory) {
                                this.folderEntityDropped.emit(item);
                            }
                        }
                    }
                }
                if (files.length > 0) {
                    this.filesDropped.emit(files);
                }
            }
            else {
                // IE, Safari, Chrome, Edge, Firefox, Opera (Files only)
                /** @type {?} */
                var files = FileUtils.toFileArray(event.dataTransfer.files);
                this.filesDropped.emit(files);
            }
            this.element.classList.remove(this.cssClassName);
        }
    };
    /**
     * Change the style of the drag area when a file drag in.
     *
     * @param event - DOM event.
     */
    /**
     * Change the style of the drag area when a file drag in.
     *
     * @param {?} event - DOM event.
     * @return {?}
     */
    FileDraggableDirective.prototype.onDragEnter = /**
     * Change the style of the drag area when a file drag in.
     *
     * @param {?} event - DOM event.
     * @return {?}
     */
    function (event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    };
    /**
     * Change the style of the drag area when a file drag out.
     *
     * @param event - DOM event.
     */
    /**
     * Change the style of the drag area when a file drag out.
     *
     * @param {?} event - DOM event.
     * @return {?}
     */
    FileDraggableDirective.prototype.onDragLeave = /**
     * Change the style of the drag area when a file drag out.
     *
     * @param {?} event - DOM event.
     * @return {?}
     */
    function (event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.remove(this.cssClassName);
        }
    };
    /**
     * Change the style of the drag area when a file is over the drag area.
     *
     * @param event
     */
    /**
     * Change the style of the drag area when a file is over the drag area.
     *
     * @param {?} event
     * @return {?}
     */
    FileDraggableDirective.prototype.onDragOver = /**
     * Change the style of the drag area when a file is over the drag area.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    };
    /**
     * Prevent default and stop propagation of the DOM event.
     *
     * @param $event - DOM event.
     */
    /**
     * Prevent default and stop propagation of the DOM event.
     *
     * @param {?} event
     * @return {?}
     */
    FileDraggableDirective.prototype.preventDefault = /**
     * Prevent default and stop propagation of the DOM event.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        event.preventDefault();
    };
    FileDraggableDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[adf-file-draggable]'
                },] }
    ];
    /** @nocollapse */
    FileDraggableDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    FileDraggableDirective.propDecorators = {
        enabled: [{ type: Input, args: ['adf-file-draggable',] }],
        filesDropped: [{ type: Output }],
        folderEntityDropped: [{ type: Output }]
    };
    return FileDraggableDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var UploadModule = /** @class */ (function () {
    function UploadModule() {
    }
    UploadModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CoreModule.forChild(),
                        CommonModule,
                        MaterialModule
                    ],
                    declarations: [
                        FileDraggableDirective,
                        UploadDragAreaComponent,
                        UploadButtonComponent,
                        UploadVersionButtonComponent,
                        FileUploadingDialogComponent,
                        FileUploadingListComponent,
                        FileUploadingListRowComponent,
                        FileUploadErrorPipe
                    ],
                    exports: [
                        FileDraggableDirective,
                        UploadDragAreaComponent,
                        UploadButtonComponent,
                        UploadVersionButtonComponent,
                        FileUploadingDialogComponent,
                        FileUploadingListComponent,
                        FileUploadingListRowComponent,
                        FileUploadErrorPipe
                    ]
                },] }
    ];
    return UploadModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DocumentListModule = /** @class */ (function () {
    function DocumentListModule() {
    }
    DocumentListModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CoreModule.forChild(),
                        CommonModule,
                        FlexLayoutModule,
                        MaterialModule,
                        UploadModule
                    ],
                    declarations: [
                        DocumentListComponent,
                        ContentColumnComponent,
                        TrashcanNameColumnComponent,
                        LibraryStatusColumnComponent,
                        LibraryRoleColumnComponent,
                        LibraryNameColumnComponent,
                        NameColumnComponent,
                        ContentColumnListComponent,
                        ContentActionComponent,
                        ContentActionListComponent
                    ],
                    exports: [
                        DocumentListComponent,
                        ContentColumnComponent,
                        TrashcanNameColumnComponent,
                        LibraryStatusColumnComponent,
                        LibraryRoleColumnComponent,
                        LibraryNameColumnComponent,
                        NameColumnComponent,
                        ContentColumnListComponent,
                        ContentActionComponent,
                        ContentActionListComponent
                    ],
                    entryComponents: [
                        TrashcanNameColumnComponent,
                        LibraryStatusColumnComponent,
                        LibraryRoleColumnComponent,
                        LibraryNameColumnComponent,
                        NameColumnComponent
                    ]
                },] }
    ];
    return DocumentListModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchQueryBuilderService = /** @class */ (function () {
    function SearchQueryBuilderService(appConfig, alfrescoApiService) {
        this.appConfig = appConfig;
        this.alfrescoApiService = alfrescoApiService;
        this._userQuery = '';
        this.updated = new Subject();
        this.executed = new Subject();
        this.error = new Subject();
        this.categories = [];
        this.queryFragments = {};
        this.filterQueries = [];
        this.paging = null;
        this.sorting = [];
        this.userFacetBuckets = {};
        this.config = {
            categories: []
        };
        // TODO: to be supported in future iterations
        this.ranges = {};
        this.resetToDefaults();
    }
    Object.defineProperty(SearchQueryBuilderService.prototype, "userQuery", {
        get: /**
         * @return {?}
         */
        function () {
            return this._userQuery;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = (value || '').trim();
            this._userQuery = value ? "(" + value + ")" : '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the query to the defaults specified in the app config.
     */
    /**
     * Resets the query to the defaults specified in the app config.
     * @return {?}
     */
    SearchQueryBuilderService.prototype.resetToDefaults = /**
     * Resets the query to the defaults specified in the app config.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var template = this.appConfig.get('search');
        if (template) {
            this.config = JSON.parse(JSON.stringify(template));
            this.categories = (this.config.categories || []).filter((/**
             * @param {?} category
             * @return {?}
             */
            function (category) { return category.enabled; }));
            this.filterQueries = this.config.filterQueries || [];
            this.userFacetBuckets = {};
            if (this.config.sorting) {
                this.sorting = this.config.sorting.defaults || [];
            }
        }
    };
    /**
     * Adds a facet bucket to a field.
     * @param field The target field
     * @param bucket Bucket to add
     */
    /**
     * Adds a facet bucket to a field.
     * @param {?} field The target field
     * @param {?} bucket Bucket to add
     * @return {?}
     */
    SearchQueryBuilderService.prototype.addUserFacetBucket = /**
     * Adds a facet bucket to a field.
     * @param {?} field The target field
     * @param {?} bucket Bucket to add
     * @return {?}
     */
    function (field, bucket) {
        if (field && field.field && bucket) {
            /** @type {?} */
            var buckets = this.userFacetBuckets[field.field] || [];
            /** @type {?} */
            var existing = buckets.find((/**
             * @param {?} facetBucket
             * @return {?}
             */
            function (facetBucket) { return facetBucket.label === bucket.label; }));
            if (!existing) {
                buckets.push(bucket);
            }
            this.userFacetBuckets[field.field] = buckets;
        }
    };
    /**
     * Gets the buckets currently added to a field
     * @param field The target fields
     * @returns Bucket array
     */
    /**
     * Gets the buckets currently added to a field
     * @param {?} field The target fields
     * @return {?} Bucket array
     */
    SearchQueryBuilderService.prototype.getUserFacetBuckets = /**
     * Gets the buckets currently added to a field
     * @param {?} field The target fields
     * @return {?} Bucket array
     */
    function (field) {
        return this.userFacetBuckets[field] || [];
    };
    /**
     * Removes an existing bucket from a field.
     * @param field The target field
     * @param bucket Bucket to remove
     */
    /**
     * Removes an existing bucket from a field.
     * @param {?} field The target field
     * @param {?} bucket Bucket to remove
     * @return {?}
     */
    SearchQueryBuilderService.prototype.removeUserFacetBucket = /**
     * Removes an existing bucket from a field.
     * @param {?} field The target field
     * @param {?} bucket Bucket to remove
     * @return {?}
     */
    function (field, bucket) {
        if (field && field.field && bucket) {
            /** @type {?} */
            var buckets = this.userFacetBuckets[field.field] || [];
            this.userFacetBuckets[field.field] = buckets
                .filter((/**
             * @param {?} facetBucket
             * @return {?}
             */
            function (facetBucket) { return facetBucket.label !== bucket.label; }));
        }
    };
    /**
     * Adds a filter query to the current query.
     * @param query Query string to add
     */
    /**
     * Adds a filter query to the current query.
     * @param {?} query Query string to add
     * @return {?}
     */
    SearchQueryBuilderService.prototype.addFilterQuery = /**
     * Adds a filter query to the current query.
     * @param {?} query Query string to add
     * @return {?}
     */
    function (query) {
        if (query) {
            /** @type {?} */
            var existing = this.filterQueries.find((/**
             * @param {?} filterQuery
             * @return {?}
             */
            function (filterQuery) { return filterQuery.query === query; }));
            if (!existing) {
                this.filterQueries.push({ query: query });
            }
        }
    };
    /**
     * Removes an existing filter query.
     * @param query The query to remove
     */
    /**
     * Removes an existing filter query.
     * @param {?} query The query to remove
     * @return {?}
     */
    SearchQueryBuilderService.prototype.removeFilterQuery = /**
     * Removes an existing filter query.
     * @param {?} query The query to remove
     * @return {?}
     */
    function (query) {
        if (query) {
            this.filterQueries = this.filterQueries
                .filter((/**
             * @param {?} filterQuery
             * @return {?}
             */
            function (filterQuery) { return filterQuery.query !== query; }));
        }
    };
    /**
     * Gets a facet query by label.
     * @param label Label of the query
     * @returns Facet query data
     */
    /**
     * Gets a facet query by label.
     * @param {?} label Label of the query
     * @return {?} Facet query data
     */
    SearchQueryBuilderService.prototype.getFacetQuery = /**
     * Gets a facet query by label.
     * @param {?} label Label of the query
     * @return {?} Facet query data
     */
    function (label) {
        if (label && this.hasFacetQueries) {
            /** @type {?} */
            var result = this.config.facetQueries.queries.find((/**
             * @param {?} query
             * @return {?}
             */
            function (query) { return query.label === label; }));
            if (result) {
                return __assign({}, result);
            }
        }
        return null;
    };
    /**
     * Gets a facet field by label.
     * @param label Label of the facet field
     * @returns Facet field data
     */
    /**
     * Gets a facet field by label.
     * @param {?} label Label of the facet field
     * @return {?} Facet field data
     */
    SearchQueryBuilderService.prototype.getFacetField = /**
     * Gets a facet field by label.
     * @param {?} label Label of the facet field
     * @return {?} Facet field data
     */
    function (label) {
        if (label) {
            /** @type {?} */
            var fields = this.config.facetFields.fields || [];
            /** @type {?} */
            var result = fields.find((/**
             * @param {?} field
             * @return {?}
             */
            function (field) { return field.label === label; }));
            if (result) {
                result.label = this.getSupportedLabel(result.label);
                return __assign({}, result);
            }
        }
        return null;
    };
    /**
     * Builds the current query and triggers the `updated` event.
     */
    /**
     * Builds the current query and triggers the `updated` event.
     * @return {?}
     */
    SearchQueryBuilderService.prototype.update = /**
     * Builds the current query and triggers the `updated` event.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var query = this.buildQuery();
        this.updated.next(query);
    };
    /**
     * Builds and executes the current query.
     * @returns Nothing
     */
    /**
     * Builds and executes the current query.
     * @return {?} Nothing
     */
    SearchQueryBuilderService.prototype.execute = /**
     * Builds and executes the current query.
     * @return {?} Nothing
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var query, resultSetPaging, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        query = this.buildQuery();
                        if (!query) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.alfrescoApiService.searchApi.search(query)];
                    case 1:
                        resultSetPaging = _a.sent();
                        this.executed.next(resultSetPaging);
                        _a.label = 2;
                    case 2: return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        this.error.next(error_1);
                        this.executed.next({
                            list: {
                                pagination: {
                                    totalItems: 0
                                },
                                entries: []
                            }
                        });
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Builds the current query.
     * @returns The finished query
     */
    /**
     * Builds the current query.
     * @return {?} The finished query
     */
    SearchQueryBuilderService.prototype.buildQuery = /**
     * Builds the current query.
     * @return {?} The finished query
     */
    function () {
        /** @type {?} */
        var query = this.getFinalQuery();
        /** @type {?} */
        var include = this.config.include || [];
        if (include.length === 0) {
            include.push('path', 'allowableOperations');
        }
        if (query) {
            /** @type {?} */
            var result = (/** @type {?} */ ({
                query: {
                    query: query,
                    language: 'afts'
                },
                include: include,
                paging: this.paging,
                fields: this.config.fields,
                filterQueries: this.filterQueries,
                facetQueries: this.facetQueries,
                facetIntervals: this.facetIntervals,
                facetFields: this.facetFields,
                sort: this.sort,
                highlight: this.highlight
            }));
            result['facetFormat'] = 'V2';
            return result;
        }
        return null;
    };
    /**
     * Gets the primary sorting definition.
     * @returns The primary sorting definition
     */
    /**
     * Gets the primary sorting definition.
     * @return {?} The primary sorting definition
     */
    SearchQueryBuilderService.prototype.getPrimarySorting = /**
     * Gets the primary sorting definition.
     * @return {?} The primary sorting definition
     */
    function () {
        if (this.sorting && this.sorting.length > 0) {
            return this.sorting[0];
        }
        return null;
    };
    /**
     * Gets all pre-configured sorting options that users can choose from.
     * @returns Pre-configured sorting options
     */
    /**
     * Gets all pre-configured sorting options that users can choose from.
     * @return {?} Pre-configured sorting options
     */
    SearchQueryBuilderService.prototype.getSortingOptions = /**
     * Gets all pre-configured sorting options that users can choose from.
     * @return {?} Pre-configured sorting options
     */
    function () {
        if (this.config && this.config.sorting) {
            return this.config.sorting.options || [];
        }
        return [];
    };
    /**
     * Gets the query group.
     * @param query Target query
     * @returns Query group
     */
    /**
     * Gets the query group.
     * @param {?} query Target query
     * @return {?} Query group
     */
    SearchQueryBuilderService.prototype.getQueryGroup = /**
     * Gets the query group.
     * @param {?} query Target query
     * @return {?} Query group
     */
    function (query) {
        return query.group || this.config.facetQueries.label || 'Facet Queries';
    };
    Object.defineProperty(SearchQueryBuilderService.prototype, "hasFacetQueries", {
        /**
         * Checks if FacetQueries has been defined
         * @returns True if defined, false otherwise
         */
        get: /**
         * Checks if FacetQueries has been defined
         * @return {?} True if defined, false otherwise
         */
        function () {
            if (this.config
                && this.config.facetQueries
                && this.config.facetQueries.queries
                && this.config.facetQueries.queries.length > 0) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchQueryBuilderService.prototype, "hasFacetIntervals", {
        /**
         * Checks if FacetIntervals has been defined
         * @returns True if defined, false otherwise
         */
        get: /**
         * Checks if FacetIntervals has been defined
         * @return {?} True if defined, false otherwise
         */
        function () {
            if (this.config
                && this.config.facetIntervals
                && this.config.facetIntervals.intervals
                && this.config.facetIntervals.intervals.length > 0) {
                return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchQueryBuilderService.prototype, "hasFacetHighlight", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config && this.config.highlight ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchQueryBuilderService.prototype, "sort", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.sorting.map((/**
             * @param {?} def
             * @return {?}
             */
            function (def) {
                return new RequestSortDefinitionInner({
                    type: def.type,
                    field: def.field,
                    ascending: def.ascending
                });
            }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchQueryBuilderService.prototype, "facetQueries", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.hasFacetQueries) {
                return this.config.facetQueries.queries.map((/**
                 * @param {?} query
                 * @return {?}
                 */
                function (query) {
                    query.group = _this.getQueryGroup(query);
                    return (/** @type {?} */ (__assign({}, query)));
                }));
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchQueryBuilderService.prototype, "facetIntervals", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.hasFacetIntervals) {
                /** @type {?} */
                var configIntervals = this.config.facetIntervals;
                return {
                    intervals: configIntervals.intervals.map((/**
                     * @param {?} interval
                     * @return {?}
                     */
                    function (interval) { return (/** @type {?} */ ({
                        label: _this.getSupportedLabel(interval.label),
                        field: interval.field,
                        sets: interval.sets.map((/**
                         * @param {?} set
                         * @return {?}
                         */
                        function (set) { return (/** @type {?} */ ({
                            label: _this.getSupportedLabel(set.label),
                            start: set.start,
                            end: set.end,
                            startInclusive: set.startInclusive,
                            endInclusive: set.endInclusive
                        })); }))
                    })); }))
                };
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchQueryBuilderService.prototype, "highlight", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.hasFacetHighlight ? this.config.highlight : null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    SearchQueryBuilderService.prototype.getFinalQuery = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var query = '';
        this.categories.forEach((/**
         * @param {?} facet
         * @return {?}
         */
        function (facet) {
            /** @type {?} */
            var customQuery = _this.queryFragments[facet.id];
            if (customQuery) {
                if (query.length > 0) {
                    query += ' AND ';
                }
                query += "(" + customQuery + ")";
            }
        }));
        /** @type {?} */
        var result = [this.userQuery, query]
            .filter((/**
         * @param {?} entry
         * @return {?}
         */
        function (entry) { return entry; }))
            .join(' AND ');
        if (this.userFacetBuckets) {
            Object.keys(this.userFacetBuckets).forEach((/**
             * @param {?} key
             * @return {?}
             */
            function (key) {
                /** @type {?} */
                var subQuery = (_this.userFacetBuckets[key] || [])
                    .filter((/**
                 * @param {?} bucket
                 * @return {?}
                 */
                function (bucket) { return bucket.filterQuery; }))
                    .map((/**
                 * @param {?} bucket
                 * @return {?}
                 */
                function (bucket) { return bucket.filterQuery; }))
                    .join(' OR ');
                if (subQuery) {
                    if (result.length > 0) {
                        result += ' AND ';
                    }
                    result += "(" + subQuery + ")";
                }
            }));
        }
        return result;
    };
    Object.defineProperty(SearchQueryBuilderService.prototype, "facetFields", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var facetFields = this.config.facetFields && this.config.facetFields.fields;
            if (facetFields && facetFields.length > 0) {
                return {
                    facets: facetFields.map((/**
                     * @param {?} facet
                     * @return {?}
                     */
                    function (facet) { return (/** @type {?} */ ({
                        field: facet.field,
                        mincount: facet.mincount,
                        label: _this.getSupportedLabel(facet.label),
                        limit: facet.limit,
                        offset: facet.offset,
                        prefix: facet.prefix
                    })); }))
                };
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Encloses a label name with double quotes if it contains whitespace characters.
     * @param configLabel Original label text
     * @returns Label, possibly with quotes if it contains spaces
     */
    /**
     * Encloses a label name with double quotes if it contains whitespace characters.
     * @param {?} configLabel Original label text
     * @return {?} Label, possibly with quotes if it contains spaces
     */
    SearchQueryBuilderService.prototype.getSupportedLabel = /**
     * Encloses a label name with double quotes if it contains whitespace characters.
     * @param {?} configLabel Original label text
     * @return {?} Label, possibly with quotes if it contains spaces
     */
    function (configLabel) {
        /** @type {?} */
        var spaceInsideLabelIndex = configLabel.search(/\s/g);
        if (spaceInsideLabelIndex > -1) {
            return "\"" + configLabel + "\"";
        }
        return configLabel;
    };
    SearchQueryBuilderService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    SearchQueryBuilderService.ctorParameters = function () { return [
        { type: AppConfigService },
        { type: AlfrescoApiService }
    ]; };
    /** @nocollapse */ SearchQueryBuilderService.ngInjectableDef = defineInjectable({ factory: function SearchQueryBuilderService_Factory() { return new SearchQueryBuilderService(inject(AppConfigService), inject(AlfrescoApiService)); }, token: SearchQueryBuilderService, providedIn: "root" });
    return SearchQueryBuilderService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchComponent = /** @class */ (function () {
    function SearchComponent(searchService, _elementRef) {
        var _this = this;
        this.searchService = searchService;
        this._elementRef = _elementRef;
        /**
         * Function that maps an option's value to its display value in the trigger.
         */
        this.displayWith = null;
        /**
         * Maximum number of results to show in the search.
         */
        this.maxResults = 20;
        /**
         * Number of results to skip from the results pagination.
         */
        this.skipResults = 0;
        /**
         * Search term to use when executing the search. Updating this value will
         * run a new search and update the results.
         */
        this.searchTerm = '';
        /**
         * Emitted when search results have fully loaded.
         */
        this.resultLoaded = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.showPanel = false;
        this._isOpen = false;
        this.keyPressedStream = new Subject();
        this._classList = {};
        this.keyPressedStream.asObservable()
            .pipe(debounceTime(200))
            .subscribe((/**
         * @param {?} searchedWord
         * @return {?}
         */
        function (searchedWord) {
            _this.loadSearchResults(searchedWord);
        }));
        searchService.dataLoaded.subscribe((/**
         * @param {?} nodePaging
         * @return {?}
         */
        function (nodePaging) { return _this.onSearchDataLoaded(nodePaging); }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return _this.onSearchDataError(error); }));
    }
    Object.defineProperty(SearchComponent.prototype, "classList", {
        /** CSS class for display. */
        set: /**
         * CSS class for display.
         * @param {?} classList
         * @return {?}
         */
        function (classList) {
            var _this = this;
            if (classList && classList.length) {
                classList.split(' ').forEach((/**
                 * @param {?} className
                 * @return {?}
                 */
                function (className) { return _this._classList[className.trim()] = true; }));
                this._elementRef.nativeElement.className = '';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchComponent.prototype, "isOpen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isOpen && this.showPanel;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isOpen = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SearchComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.setVisibility();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SearchComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.searchTerm && changes.searchTerm.currentValue) {
            this.loadSearchResults(changes.searchTerm.currentValue);
        }
    };
    /**
     * @return {?}
     */
    SearchComponent.prototype.resetResults = /**
     * @return {?}
     */
    function () {
        this.cleanResults();
        this.setVisibility();
    };
    /**
     * @return {?}
     */
    SearchComponent.prototype.reload = /**
     * @return {?}
     */
    function () {
        this.loadSearchResults(this.searchTerm);
    };
    /**
     * @private
     * @return {?}
     */
    SearchComponent.prototype.cleanResults = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.results) {
            this.results = {};
        }
    };
    /**
     * @private
     * @param {?=} searchTerm
     * @return {?}
     */
    SearchComponent.prototype.loadSearchResults = /**
     * @private
     * @param {?=} searchTerm
     * @return {?}
     */
    function (searchTerm) {
        var _this = this;
        this.resetResults();
        if (searchTerm) {
            this.searchService.search(searchTerm, this.maxResults, this.skipResults).subscribe((/**
             * @param {?} result
             * @return {?}
             */
            function (result) { return _this.onSearchDataLoaded(result); }), (/**
             * @param {?} err
             * @return {?}
             */
            function (err) { return _this.onSearchDataError(err); }));
        }
        else {
            this.cleanResults();
        }
    };
    /**
     * @param {?} nodePaging
     * @return {?}
     */
    SearchComponent.prototype.onSearchDataLoaded = /**
     * @param {?} nodePaging
     * @return {?}
     */
    function (nodePaging) {
        if (nodePaging) {
            this.results = nodePaging;
            this.resultLoaded.emit(this.results);
            this.isOpen = true;
            this.setVisibility();
        }
    };
    /**
     * @param {?} error
     * @return {?}
     */
    SearchComponent.prototype.onSearchDataError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        if (error && error.status !== 400) {
            this.results = null;
            this.error.emit(error);
        }
    };
    /**
     * @return {?}
     */
    SearchComponent.prototype.hidePanel = /**
     * @return {?}
     */
    function () {
        if (this.isOpen) {
            this._classList['adf-search-show'] = false;
            this._classList['adf-search-hide'] = true;
            this.isOpen = false;
        }
    };
    /**
     * @return {?}
     */
    SearchComponent.prototype.setVisibility = /**
     * @return {?}
     */
    function () {
        this.showPanel = !!this.results && !!this.results.list;
        this._classList['adf-search-show'] = this.showPanel;
        this._classList['adf-search-hide'] = !this.showPanel;
    };
    SearchComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search',
                    template: "<div role=\"listbox\" id=\"adf-search-results-content\" [ngClass]=\"_classList\" #panel>\n    <ng-template\n        [ngTemplateOutlet]=\"template\"\n        [ngTemplateOutletContext]=\"{ $implicit: results }\">\n    </ng-template>\n</div>\n\n\n",
                    encapsulation: ViewEncapsulation.None,
                    preserveWhitespaces: false,
                    exportAs: 'searchAutocomplete',
                    host: {
                        'class': 'adf-search'
                    },
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    SearchComponent.ctorParameters = function () { return [
        { type: SearchService },
        { type: ElementRef }
    ]; };
    SearchComponent.propDecorators = {
        panel: [{ type: ViewChild, args: ['panel',] }],
        template: [{ type: ContentChild, args: [TemplateRef,] }],
        displayWith: [{ type: Input }],
        maxResults: [{ type: Input }],
        skipResults: [{ type: Input }],
        searchTerm: [{ type: Input }],
        classList: [{ type: Input, args: ['class',] }],
        resultLoaded: [{ type: Output }],
        error: [{ type: Output }]
    };
    return SearchComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var EmptySearchResultComponent = /** @class */ (function () {
    function EmptySearchResultComponent() {
    }
    EmptySearchResultComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-empty-search-result',
                    template: "<div class=\"adf-empty-search-result\">\n    <ng-content></ng-content>\n</div>\n",
                    encapsulation: ViewEncapsulation.None
                }] }
    ];
    return EmptySearchResultComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchControlComponent = /** @class */ (function () {
    function SearchControlComponent(authService, thumbnailService) {
        var _this = this;
        this.authService = authService;
        this.thumbnailService = thumbnailService;
        /**
         * Toggles whether to use an expanding search control. If false
         * then a regular input is used.
         */
        this.expandable = true;
        /**
         * Toggles highlighting of the search term in the results.
         */
        this.highlight = false;
        /**
         * Type of the input field to render, e.g. "search" or "text" (default).
         */
        this.inputType = 'text';
        /**
         * Toggles auto-completion of the search input field.
         */
        this.autocomplete = false;
        /**
         * Toggles "find-as-you-type" suggestions for possible matches.
         */
        this.liveSearchEnabled = true;
        /**
         * Maximum number of results to show in the live search.
         */
        this.liveSearchMaxResults = 5;
        /**
         * Emitted when the search is submitted by pressing the ENTER key.
         * The search term is provided as the value of the event.
         */
        this.submit = new EventEmitter();
        /**
         * Emitted when the search term is changed. The search term is provided
         * in the 'value' property of the returned object.  If the term is less
         * than three characters in length then it is truncated to an empty
         * string.
         */
        this.searchChange = new EventEmitter();
        /**
         * Emitted when a file item from the list of "find-as-you-type" results is selected.
         */
        this.optionClicked = new EventEmitter();
        this.searchTerm = '';
        this.noSearchResultTemplate = null;
        this.toggleSearch = new Subject();
        this.focusSubject = new Subject();
        this.toggleSearch.asObservable().pipe(debounceTime(200)).subscribe((/**
         * @return {?}
         */
        function () {
            if (_this.expandable) {
                _this.subscriptAnimationState = _this.subscriptAnimationState === 'inactive' ? 'active' : 'inactive';
                if (_this.subscriptAnimationState === 'inactive') {
                    _this.searchTerm = '';
                    _this.searchAutocomplete.resetResults();
                    if (document.activeElement.id === _this.searchInput.nativeElement.id) {
                        _this.searchInput.nativeElement.blur();
                    }
                }
            }
        }));
    }
    /**
     * @param {?} animationDoneEvent
     * @return {?}
     */
    SearchControlComponent.prototype.applySearchFocus = /**
     * @param {?} animationDoneEvent
     * @return {?}
     */
    function (animationDoneEvent) {
        if (animationDoneEvent.toState === 'active') {
            this.searchInput.nativeElement.focus();
        }
    };
    /**
     * @return {?}
     */
    SearchControlComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.subscriptAnimationState = this.expandable ? 'inactive' : 'no-animation';
        this.setupFocusEventHandlers();
    };
    /**
     * @return {?}
     */
    SearchControlComponent.prototype.isNoSearchTemplatePresent = /**
     * @return {?}
     */
    function () {
        return this.emptySearchTemplate ? true : false;
    };
    /**
     * @return {?}
     */
    SearchControlComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.focusSubject) {
            this.focusSubject.complete();
            this.focusSubject = null;
        }
        if (this.toggleSearch) {
            this.toggleSearch.complete();
            this.toggleSearch = null;
        }
    };
    /**
     * @return {?}
     */
    SearchControlComponent.prototype.isLoggedIn = /**
     * @return {?}
     */
    function () {
        return this.authService.isEcmLoggedIn();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchControlComponent.prototype.searchSubmit = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.submit.emit(event);
        this.toggleSearchBar();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchControlComponent.prototype.inputChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.searchChange.emit(event);
    };
    /**
     * @return {?}
     */
    SearchControlComponent.prototype.getAutoComplete = /**
     * @return {?}
     */
    function () {
        return this.autocomplete ? 'on' : 'off';
    };
    /**
     * @param {?} node
     * @return {?}
     */
    SearchControlComponent.prototype.getMimeTypeIcon = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var mimeType = this.getMimeType(node);
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    SearchControlComponent.prototype.getMimeType = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var mimeType;
        if (node.entry.content && node.entry.content.mimeType) {
            mimeType = node.entry.content.mimeType;
        }
        if (node.entry.isFolder) {
            mimeType = 'folder';
        }
        return mimeType;
    };
    /**
     * @return {?}
     */
    SearchControlComponent.prototype.isSearchBarActive = /**
     * @return {?}
     */
    function () {
        return this.subscriptAnimationState === 'active' && this.liveSearchEnabled;
    };
    /**
     * @return {?}
     */
    SearchControlComponent.prototype.toggleSearchBar = /**
     * @return {?}
     */
    function () {
        if (this.toggleSearch) {
            this.toggleSearch.next();
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    SearchControlComponent.prototype.elementClicked = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item.entry) {
            this.optionClicked.next(item);
            this.toggleSearchBar();
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    SearchControlComponent.prototype.onFocus = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.focusSubject.next($event);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    SearchControlComponent.prototype.onBlur = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.focusSubject.next($event);
    };
    /**
     * @return {?}
     */
    SearchControlComponent.prototype.activateToolbar = /**
     * @return {?}
     */
    function () {
        if (!this.isSearchBarActive()) {
            this.toggleSearchBar();
        }
    };
    /**
     * @return {?}
     */
    SearchControlComponent.prototype.selectFirstResult = /**
     * @return {?}
     */
    function () {
        if (this.listResultElement && this.listResultElement.length > 0) {
            /** @type {?} */
            var firstElement = (/** @type {?} */ (this.listResultElement.first));
            firstElement._getHostElement().focus();
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    SearchControlComponent.prototype.onRowArrowDown = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        /** @type {?} */
        var nextElement = this.getNextElementSibling((/** @type {?} */ ($event.target)));
        if (nextElement) {
            nextElement.focus();
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    SearchControlComponent.prototype.onRowArrowUp = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        /** @type {?} */
        var previousElement = this.getPreviousElementSibling((/** @type {?} */ ($event.target)));
        if (previousElement) {
            previousElement.focus();
        }
        else {
            this.searchInput.nativeElement.focus();
            this.focusSubject.next(new FocusEvent('focus'));
        }
    };
    /**
     * @private
     * @return {?}
     */
    SearchControlComponent.prototype.setupFocusEventHandlers = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var focusEvents = this.focusSubject
            .asObservable()
            .pipe(debounceTime(50), filter((/**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            return _this.isSearchBarActive() && ($event.type === 'blur' || $event.type === 'focusout');
        })));
        focusEvents.subscribe((/**
         * @return {?}
         */
        function () {
            _this.toggleSearchBar();
        }));
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    SearchControlComponent.prototype.getNextElementSibling = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.nextElementSibling;
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    SearchControlComponent.prototype.getPreviousElementSibling = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.previousElementSibling;
    };
    SearchControlComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-control',
                    template: "<div class=\"adf-search-container\" [attr.state]=\"subscriptAnimationState\">\n    <div *ngIf=\"isLoggedIn()\" [@transitionMessages]=\"subscriptAnimationState\"\n         (@transitionMessages.done)=\"applySearchFocus($event)\">\n        <button mat-icon-button\n                *ngIf=\"expandable\"\n                id=\"adf-search-button\"\n                class=\"adf-search-button\"\n                [title]=\"'SEARCH.BUTTON.TOOLTIP' | translate\"\n                (click)=\"toggleSearchBar()\"\n                (keyup.enter)=\"toggleSearchBar()\">\n            <mat-icon [attr.aria-label]=\"'SEARCH.BUTTON.ARIA-LABEL' | translate\">search</mat-icon>\n        </button>\n        <mat-form-field class=\"adf-input-form-field-divider\">\n            <input matInput\n                   #searchInput\n                   [attr.aria-label]=\"'SEARCH.INPUT.ARIA-LABEL' | translate\"\n                   [attr.type]=\"inputType\"\n                   [autocomplete]=\"getAutoComplete()\"\n                   id=\"adf-control-input\"\n                   [(ngModel)]=\"searchTerm\"\n                   (focus)=\"activateToolbar()\"\n                   (blur)=\"onBlur($event)\"\n                   (keyup.escape)=\"toggleSearchBar()\"\n                   (keyup.arrowdown)=\"selectFirstResult()\"\n                   (ngModelChange)=\"inputChange($event)\"\n                   [searchAutocomplete]=\"auto\"\n                   (keyup.enter)=\"searchSubmit($event)\">\n        </mat-form-field>\n    </div>\n</div>\n\n<adf-search #search\n            #auto=\"searchAutocomplete\"\n            class=\"adf-search-result-autocomplete\"\n            [maxResults]=\"liveSearchMaxResults\">\n    <ng-template let-data>\n        <mat-list *ngIf=\"isSearchBarActive()\" id=\"autocomplete-search-result-list\">\n            <mat-list-item\n                *ngFor=\"let item of data?.list?.entries; let idx = index\"\n                id=\"result_option_{{idx}}\"\n                [attr.data-automation-id]=\"'autocomplete_for_' + item.entry.name\"\n                [tabindex]=\"0\"\n                (focus)=\"onFocus($event)\"\n                (blur)=\"onBlur($event)\"\n                (keyup.arrowdown)=\"onRowArrowDown($event)\"\n                (keyup.arrowup)=\"onRowArrowUp($event)\"\n                class=\"adf-search-autocomplete-item\"\n                (click)=\"elementClicked(item)\"\n                (keyup.enter)=\"elementClicked(item)\"\n                (touchend)=\"elementClicked(item)\">\n                <!-- This is a comment -->\n                <mat-icon mat-list-icon>\n                    <img [alt]=\"getMimeType(item)\" [src]=\"getMimeTypeIcon(item)\"/>\n                </mat-icon>\n                <h4 mat-line id=\"result_name_{{idx}}\"\n                    *ngIf=\"highlight; else elseBlock\"\n                    class=\"adf-search-fixed-text\"\n                    [innerHtml]=\"item.entry.name | highlight: searchTerm\">\n                    {{ item?.entry.name }}\n                </h4>\n                <ng-template #elseBlock>\n                    <h4 class=\"adf-search-fixed-text\" mat-line id=\"result_name_{{idx}}\"\n                        [innerHtml]=\"item.entry.name\"></h4>\n                </ng-template>\n                <p mat-line class=\"adf-search-fixed-text\"> {{item?.entry.createdByUser.displayName}} </p>\n            </mat-list-item>\n            <mat-list-item id=\"search_no_result\"\n                           data-automation-id=\"search_no_result_found\"\n                           *ngIf=\"data?.list?.entries.length === 0\">\n                <ng-content\n                    selector=\"adf-empty-search-result\"\n                    *ngIf=\"isNoSearchTemplatePresent() else defaultNoResult\">\n                </ng-content>\n                <ng-template #defaultNoResult>\n                    <p mat-line class=\"adf-search-fixed-text\">{{ 'SEARCH.RESULTS.NONE' | translate:{searchTerm:\n                        searchTerm} }}</p>\n                </ng-template>\n            </mat-list-item>\n        </mat-list>\n    </ng-template>\n</adf-search>\n",
                    animations: [
                        trigger('transitionMessages', [
                            state('active', style({ transform: 'translateX(0%)', 'margin-left': '13px' })),
                            state('inactive', style({ transform: 'translateX(82%)' })),
                            state('no-animation', style({ transform: 'translateX(0%)', width: '100%' })),
                            transition('inactive => active', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')),
                            transition('active => inactive', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
                        ])
                    ],
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-control' },
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    SearchControlComponent.ctorParameters = function () { return [
        { type: AuthenticationService },
        { type: ThumbnailService }
    ]; };
    SearchControlComponent.propDecorators = {
        expandable: [{ type: Input }],
        highlight: [{ type: Input }],
        inputType: [{ type: Input }],
        autocomplete: [{ type: Input }],
        liveSearchEnabled: [{ type: Input }],
        liveSearchMaxResults: [{ type: Input }],
        submit: [{ type: Output }],
        searchChange: [{ type: Output }],
        optionClicked: [{ type: Output }],
        searchAutocomplete: [{ type: ViewChild, args: ['search',] }],
        searchInput: [{ type: ViewChild, args: ['searchInput',] }],
        listResultElement: [{ type: ViewChildren, args: [MatListItem,] }],
        emptySearchTemplate: [{ type: ContentChild, args: [EmptySearchResultComponent,] }]
    };
    return SearchControlComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return SearchTriggerDirective; })),
    multi: true
};
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
var SearchTriggerDirective = /** @class */ (function () {
    function SearchTriggerDirective(element, ngZone, changeDetectorRef, document) {
        this.element = element;
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.document = document;
        this.onDestroy$ = new Subject();
        this.autocomplete = 'off';
        this._panelOpen = false;
        this.escapeEventStream = new Subject();
        this.onChange = (/**
         * @return {?}
         */
        function () { });
        this.onTouched = (/**
         * @return {?}
         */
        function () { });
    }
    /**
     * @return {?}
     */
    SearchTriggerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
        if (this.escapeEventStream) {
            this.escapeEventStream = null;
        }
        if (this.closingActionsSubscription) {
            this.closingActionsSubscription.unsubscribe();
        }
    };
    Object.defineProperty(SearchTriggerDirective.prototype, "panelOpen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._panelOpen && this.searchPanel.showPanel;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SearchTriggerDirective.prototype.openPanel = /**
     * @return {?}
     */
    function () {
        this.searchPanel.isOpen = this._panelOpen = true;
        this.closingActionsSubscription = this.subscribeToClosingActions();
    };
    /**
     * @return {?}
     */
    SearchTriggerDirective.prototype.closePanel = /**
     * @return {?}
     */
    function () {
        if (this._panelOpen) {
            this.closingActionsSubscription.unsubscribe();
            this._panelOpen = false;
            this.searchPanel.resetResults();
            this.searchPanel.hidePanel();
            this.changeDetectorRef.detectChanges();
        }
    };
    Object.defineProperty(SearchTriggerDirective.prototype, "panelClosingActions", {
        get: /**
         * @return {?}
         */
        function () {
            return merge(this.escapeEventStream, this.outsideClickStream);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchTriggerDirective.prototype, "outsideClickStream", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.document) {
                return of(null);
            }
            return merge(fromEvent(this.document, 'click'), fromEvent(this.document, 'touchend')).pipe(filter((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                /** @type {?} */
                var clickTarget = (/** @type {?} */ (event.target));
                return _this._panelOpen && clickTarget !== _this.element.nativeElement;
            })), takeUntil(this.onDestroy$));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    SearchTriggerDirective.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        Promise.resolve(null).then((/**
         * @return {?}
         */
        function () { return _this.setTriggerValue(value); }));
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    SearchTriggerDirective.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    SearchTriggerDirective.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchTriggerDirective.prototype.handleKeydown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        if (keyCode === ESCAPE && this.panelOpen) {
            this.escapeEventStream.next();
            event.stopPropagation();
        }
        else if (keyCode === ENTER) {
            this.escapeEventStream.next();
            event.preventDefault();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchTriggerDirective.prototype.handleInput = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (document.activeElement === event.target) {
            /** @type {?} */
            var inputValue = ((/** @type {?} */ (event.target))).value;
            this.onChange(inputValue);
            if (inputValue) {
                this.searchPanel.keyPressedStream.next(inputValue);
                this.openPanel();
            }
            else {
                this.searchPanel.resetResults();
                this.closePanel();
            }
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    SearchTriggerDirective.prototype.isPanelOptionClicked = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var isPanelOption = false;
        if (event) {
            /** @type {?} */
            var clickTarget = (/** @type {?} */ (event.target));
            isPanelOption = !this.isNoResultOption(event) &&
                !!this.searchPanel.panel &&
                !!this.searchPanel.panel.nativeElement.contains(clickTarget);
        }
        return isPanelOption;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    SearchTriggerDirective.prototype.isNoResultOption = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return this.searchPanel.results.list ? this.searchPanel.results.list.entries.length === 0 : true;
    };
    /**
     * @private
     * @return {?}
     */
    SearchTriggerDirective.prototype.subscribeToClosingActions = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var firstStable = this.ngZone.onStable.asObservable();
        /** @type {?} */
        var optionChanges = this.searchPanel.keyPressedStream.asObservable();
        return merge(firstStable, optionChanges)
            .pipe(switchMap((/**
         * @return {?}
         */
        function () {
            _this.searchPanel.setVisibility();
            return _this.panelClosingActions;
        })), takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.setValueAndClose(event); }));
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    SearchTriggerDirective.prototype.setTriggerValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var toDisplay = this.searchPanel && this.searchPanel.displayWith ?
            this.searchPanel.displayWith(value) : value;
        /** @type {?} */
        var inputValue = toDisplay != null ? toDisplay : '';
        this.element.nativeElement.value = inputValue;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    SearchTriggerDirective.prototype.setValueAndClose = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isPanelOptionClicked(event) && !event.defaultPrevented) {
            this.setTriggerValue(event.target.textContent.trim());
            this.onChange(event.target.textContent.trim());
            this.element.nativeElement.focus();
        }
        this.closePanel();
    };
    SearchTriggerDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: "input[searchAutocomplete], textarea[searchAutocomplete]",
                    host: {
                        'role': 'combobox',
                        '[attr.autocomplete]': 'autocomplete',
                        'aria-autocomplete': 'list',
                        '[attr.aria-expanded]': 'panelOpen.toString()',
                        '(blur)': 'onTouched()',
                        '(input)': 'handleInput($event)',
                        '(keydown)': 'handleKeydown($event)'
                    },
                    providers: [SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR]
                },] }
    ];
    /** @nocollapse */
    SearchTriggerDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: ChangeDetectorRef },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    SearchTriggerDirective.propDecorators = {
        searchPanel: [{ type: Input, args: ['searchAutocomplete',] }],
        autocomplete: [{ type: Input }]
    };
    return SearchTriggerDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
var DEFAULT_PAGE_SIZE = 5;
/**
 * @template T
 */
var /**
 * @template T
 */
SearchFilterList = /** @class */ (function () {
    function SearchFilterList(items, pageSize) {
        if (items === void 0) { items = []; }
        this.filteredItems = [];
        this._filterText = '';
        this.items = [];
        this.pageSize = DEFAULT_PAGE_SIZE;
        this.currentPageSize = DEFAULT_PAGE_SIZE;
        this._filter = (/**
         * @return {?}
         */
        function () { return true; });
        this.items = items;
        this.filteredItems = items;
        this.pageSize = pageSize || DEFAULT_PAGE_SIZE;
        this.currentPageSize = pageSize || DEFAULT_PAGE_SIZE;
    }
    Object.defineProperty(SearchFilterList.prototype, "filterText", {
        get: /**
         * @return {?}
         */
        function () {
            return this._filterText;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filterText = value;
            this.applyFilter();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchFilterList.prototype, "filter", {
        get: /**
         * @return {?}
         */
        function () {
            return this._filter;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filter = value;
            this.applyFilter();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    SearchFilterList.prototype.applyFilter = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.filter) {
            this.filteredItems = this.items.filter(this.filter);
        }
        else {
            this.filteredItems = this.items;
        }
        this.currentPageSize = this.pageSize;
    };
    Object.defineProperty(SearchFilterList.prototype, "visibleItems", {
        /** Returns visible portion of the items.  */
        get: /**
         * Returns visible portion of the items.
         * @return {?}
         */
        function () {
            return this.filteredItems.slice(0, this.currentPageSize);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchFilterList.prototype, "length", {
        /** Returns entire collection length including items not displayed on the page. */
        get: /**
         * Returns entire collection length including items not displayed on the page.
         * @return {?}
         */
        function () {
            return this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchFilterList.prototype, "canShowMoreItems", {
        /** Detects whether more items can be displayed. */
        get: /**
         * Detects whether more items can be displayed.
         * @return {?}
         */
        function () {
            return this.filteredItems.length > this.currentPageSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchFilterList.prototype, "canShowLessItems", {
        /** Detects whether less items can be displayed. */
        get: /**
         * Detects whether less items can be displayed.
         * @return {?}
         */
        function () {
            return this.currentPageSize > this.pageSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchFilterList.prototype, "fitsPage", {
        /** Detects whether content fits single page. */
        get: /**
         * Detects whether content fits single page.
         * @return {?}
         */
        function () {
            return this.pageSize >= this.filteredItems.length;
        },
        enumerable: true,
        configurable: true
    });
    /** Display more items. */
    /**
     * Display more items.
     * @return {?}
     */
    SearchFilterList.prototype.showMoreItems = /**
     * Display more items.
     * @return {?}
     */
    function () {
        if (this.canShowMoreItems) {
            this.currentPageSize += this.pageSize;
        }
    };
    /** Display less items. */
    /**
     * Display less items.
     * @return {?}
     */
    SearchFilterList.prototype.showLessItems = /**
     * Display less items.
     * @return {?}
     */
    function () {
        if (this.canShowLessItems) {
            this.currentPageSize -= this.pageSize;
        }
    };
    /** Reset entire collection and page settings. */
    /**
     * Reset entire collection and page settings.
     * @return {?}
     */
    SearchFilterList.prototype.clear = /**
     * Reset entire collection and page settings.
     * @return {?}
     */
    function () {
        this.currentPageSize = this.pageSize;
        this.items = [];
        this.filteredItems = [];
        this.filterText = '';
    };
    /**
     * @param {?} item
     * @return {?}
     */
    SearchFilterList.prototype.addItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (!item) {
            return;
        }
        this.items.push(item);
        this.applyFilter();
    };
    /**
     * @param {?} item
     * @return {?}
     */
    SearchFilterList.prototype.deleteItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var removeIndex = this.items.indexOf(item);
        if (removeIndex > -1) {
            this.items.splice(removeIndex, 1);
            this.filteredItems.splice(removeIndex, 1);
        }
    };
    /**
     * @return {?}
     */
    SearchFilterList.prototype[Symbol.iterator] = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var pointer = 0;
        /** @type {?} */
        var items = this.visibleItems;
        return {
            next: /**
             * @return {?}
             */
            function () {
                if (pointer < items.length) {
                    return {
                        done: false,
                        value: items[pointer++]
                    };
                }
                else {
                    return {
                        done: true,
                        value: null
                    };
                }
            }
        };
    };
    return SearchFilterList;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchFilterComponent = /** @class */ (function () {
    function SearchFilterComponent(queryBuilder, searchService, translationService) {
        var _this = this;
        this.queryBuilder = queryBuilder;
        this.searchService = searchService;
        this.translationService = translationService;
        this.DEFAULT_PAGE_SIZE = 5;
        this.isAlive = true;
        /**
         * All facet field items to be displayed in the component. These are updated according to the response.
         *  When a new search is performed, the already existing items are updated with the new bucket count values and
         *  the newly received items are added to the responseFacets.
         */
        this.responseFacets = null;
        this.facetQueriesPageSize = this.DEFAULT_PAGE_SIZE;
        this.facetQueriesLabel = 'Facet Queries';
        this.facetExpanded = {
            'default': false
        };
        this.selectedBuckets = [];
        if (queryBuilder.config && queryBuilder.config.facetQueries) {
            this.facetQueriesLabel = queryBuilder.config.facetQueries.label || 'Facet Queries';
            this.facetQueriesPageSize = queryBuilder.config.facetQueries.pageSize || this.DEFAULT_PAGE_SIZE;
            this.facetExpanded['query'] = queryBuilder.config.facetQueries.expanded;
        }
        if (queryBuilder.config && queryBuilder.config.facetFields) {
            this.facetExpanded['field'] = queryBuilder.config.facetFields.expanded;
        }
        if (queryBuilder.config && queryBuilder.config.facetIntervals) {
            this.facetExpanded['interval'] = queryBuilder.config.facetIntervals.expanded;
        }
        this.displayResetButton = this.queryBuilder.config && !!this.queryBuilder.config.resetButton;
        this.queryBuilder.updated.pipe(takeWhile((/**
         * @return {?}
         */
        function () { return _this.isAlive; }))).subscribe((/**
         * @return {?}
         */
        function () {
            _this.queryBuilder.execute();
        }));
    }
    /**
     * @return {?}
     */
    SearchFilterComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.queryBuilder) {
            this.queryBuilder.executed.pipe(takeWhile((/**
             * @return {?}
             */
            function () { return _this.isAlive; }))).subscribe((/**
             * @param {?} resultSetPaging
             * @return {?}
             */
            function (resultSetPaging) {
                _this.onDataLoaded(resultSetPaging);
                _this.searchService.dataLoaded.next(resultSetPaging);
            }));
        }
    };
    /**
     * @return {?}
     */
    SearchFilterComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.isAlive = false;
    };
    /**
     * @private
     * @return {?}
     */
    SearchFilterComponent.prototype.updateSelectedBuckets = /**
     * @private
     * @return {?}
     */
    function () {
        var e_1, _a;
        if (this.responseFacets) {
            this.selectedBuckets = [];
            var _loop_1 = function (field) {
                var _a;
                if (field.buckets) {
                    (_a = this_1.selectedBuckets).push.apply(_a, __spread(this_1.queryBuilder.getUserFacetBuckets(field.field)
                        .filter((/**
                     * @param {?} bucket
                     * @return {?}
                     */
                    function (bucket) { return bucket.checked; }))
                        .map((/**
                     * @param {?} bucket
                     * @return {?}
                     */
                    function (bucket) {
                        return { field: field, bucket: bucket };
                    }))));
                }
            };
            var this_1 = this;
            try {
                for (var _b = __values(this.responseFacets), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var field = _c.value;
                    _loop_1(field);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else {
            this.selectedBuckets = [];
        }
    };
    /**
     * @param {?} event
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    SearchFilterComponent.prototype.onToggleBucket = /**
     * @param {?} event
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    function (event, field, bucket) {
        if (event && bucket) {
            if (event.checked) {
                this.selectFacetBucket(field, bucket);
            }
            else {
                this.unselectFacetBucket(field, bucket);
            }
        }
    };
    /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    SearchFilterComponent.prototype.selectFacetBucket = /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    function (field, bucket) {
        if (bucket) {
            bucket.checked = true;
            this.queryBuilder.addUserFacetBucket(field, bucket);
            this.updateSelectedBuckets();
            this.queryBuilder.update();
        }
    };
    /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    SearchFilterComponent.prototype.unselectFacetBucket = /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    function (field, bucket) {
        if (bucket) {
            bucket.checked = false;
            this.queryBuilder.removeUserFacetBucket(field, bucket);
            this.updateSelectedBuckets();
            this.queryBuilder.update();
        }
    };
    /**
     * @param {?} field
     * @return {?}
     */
    SearchFilterComponent.prototype.canResetSelectedBuckets = /**
     * @param {?} field
     * @return {?}
     */
    function (field) {
        if (field && field.buckets) {
            return field.buckets.items.some((/**
             * @param {?} bucket
             * @return {?}
             */
            function (bucket) { return bucket.checked; }));
        }
        return false;
    };
    /**
     * @param {?} field
     * @return {?}
     */
    SearchFilterComponent.prototype.resetSelectedBuckets = /**
     * @param {?} field
     * @return {?}
     */
    function (field) {
        var e_2, _a;
        if (field && field.buckets) {
            try {
                for (var _b = __values(field.buckets.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var bucket = _c.value;
                    bucket.checked = false;
                    this.queryBuilder.removeUserFacetBucket(field, bucket);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.updateSelectedBuckets();
            this.queryBuilder.update();
        }
    };
    /**
     * @return {?}
     */
    SearchFilterComponent.prototype.resetAllSelectedBuckets = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.responseFacets.forEach((/**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            var e_3, _a;
            if (field && field.buckets) {
                try {
                    for (var _b = __values(field.buckets.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var bucket = _c.value;
                        bucket.checked = false;
                        _this.queryBuilder.removeUserFacetBucket(field, bucket);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                _this.updateSelectedBuckets();
            }
        }));
        this.queryBuilder.update();
    };
    /**
     * @return {?}
     */
    SearchFilterComponent.prototype.resetAll = /**
     * @return {?}
     */
    function () {
        this.resetAllSelectedBuckets();
        this.responseFacets = null;
    };
    /**
     * @param {?} field
     * @return {?}
     */
    SearchFilterComponent.prototype.shouldExpand = /**
     * @param {?} field
     * @return {?}
     */
    function (field) {
        return this.facetExpanded[field.type] || this.facetExpanded['default'];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    SearchFilterComponent.prototype.onDataLoaded = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var context = data.list.context;
        if (context) {
            this.parseFacets(context);
        }
        else {
            this.responseFacets = null;
        }
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    SearchFilterComponent.prototype.parseFacets = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        this.parseFacetFields(context);
        this.parseFacetIntervals(context);
        this.parseFacetQueries(context);
    };
    /**
     * @private
     * @param {?} context
     * @param {?} configFacetFields
     * @param {?} itemType
     * @return {?}
     */
    SearchFilterComponent.prototype.parseFacetItems = /**
     * @private
     * @param {?} context
     * @param {?} configFacetFields
     * @param {?} itemType
     * @return {?}
     */
    function (context, configFacetFields, itemType) {
        var _this = this;
        configFacetFields.forEach((/**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            /** @type {?} */
            var responseField = _this.findFacet(context, itemType, field.label);
            /** @type {?} */
            var responseBuckets = _this.getResponseBuckets(responseField, field)
                .filter(_this.getFilterByMinCount(field.mincount));
            /** @type {?} */
            var alreadyExistingField = _this.findResponseFacet(itemType, field.label);
            if (alreadyExistingField) {
                /** @type {?} */
                var alreadyExistingBuckets = alreadyExistingField.buckets && alreadyExistingField.buckets.items || [];
                _this.updateExistingBuckets(responseField, responseBuckets, alreadyExistingField, alreadyExistingBuckets);
            }
            else if (responseField) {
                /** @type {?} */
                var bucketList = new SearchFilterList(responseBuckets, field.pageSize);
                bucketList.filter = _this.getBucketFilterFunction(bucketList);
                if (!_this.responseFacets) {
                    _this.responseFacets = [];
                }
                _this.responseFacets.push((/** @type {?} */ (__assign({}, field, { type: responseField.type || itemType, label: field.label, pageSize: field.pageSize | _this.DEFAULT_PAGE_SIZE, currentPageSize: field.pageSize | _this.DEFAULT_PAGE_SIZE, buckets: bucketList }))));
            }
        }));
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    SearchFilterComponent.prototype.parseFacetFields = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        /** @type {?} */
        var configFacetFields = this.queryBuilder.config.facetFields && this.queryBuilder.config.facetFields.fields || [];
        this.parseFacetItems(context, configFacetFields, 'field');
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    SearchFilterComponent.prototype.parseFacetIntervals = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        /** @type {?} */
        var configFacetIntervals = this.queryBuilder.config.facetIntervals && this.queryBuilder.config.facetIntervals.intervals || [];
        this.parseFacetItems(context, configFacetIntervals, 'interval');
    };
    /**
     * @private
     * @param {?} context
     * @return {?}
     */
    SearchFilterComponent.prototype.parseFacetQueries = /**
     * @private
     * @param {?} context
     * @return {?}
     */
    function (context) {
        var _this = this;
        /** @type {?} */
        var configFacetQueries = this.queryBuilder.config.facetQueries && this.queryBuilder.config.facetQueries.queries || [];
        /** @type {?} */
        var configGroups = configFacetQueries.reduce((/**
         * @param {?} acc
         * @param {?} query
         * @return {?}
         */
        function (acc, query) {
            /** @type {?} */
            var group = _this.queryBuilder.getQueryGroup(query);
            if (acc[group]) {
                acc[group].push(query);
            }
            else {
                acc[group] = [query];
            }
            return acc;
        }), []);
        /** @type {?} */
        var mincount = this.queryBuilder.config.facetQueries && this.queryBuilder.config.facetQueries.mincount;
        /** @type {?} */
        var mincountFilter = this.getFilterByMinCount(mincount);
        Object.keys(configGroups).forEach((/**
         * @param {?} group
         * @return {?}
         */
        function (group) {
            /** @type {?} */
            var responseField = _this.findFacet(context, 'query', group);
            /** @type {?} */
            var responseBuckets = _this.getResponseQueryBuckets(responseField, configGroups[group])
                .filter(mincountFilter);
            /** @type {?} */
            var alreadyExistingField = _this.findResponseFacet('query', group);
            if (alreadyExistingField) {
                /** @type {?} */
                var alreadyExistingBuckets = alreadyExistingField.buckets && alreadyExistingField.buckets.items || [];
                _this.updateExistingBuckets(responseField, responseBuckets, alreadyExistingField, alreadyExistingBuckets);
            }
            else if (responseField) {
                /** @type {?} */
                var bucketList = new SearchFilterList(responseBuckets, _this.facetQueriesPageSize);
                bucketList.filter = _this.getBucketFilterFunction(bucketList);
                if (!_this.responseFacets) {
                    _this.responseFacets = [];
                }
                _this.responseFacets.push((/** @type {?} */ ({
                    field: group,
                    type: responseField.type || 'query',
                    label: group,
                    pageSize: _this.DEFAULT_PAGE_SIZE,
                    currentPageSize: _this.DEFAULT_PAGE_SIZE,
                    buckets: bucketList
                })));
            }
        }));
    };
    /**
     * @private
     * @param {?} responseField
     * @param {?} configField
     * @return {?}
     */
    SearchFilterComponent.prototype.getResponseBuckets = /**
     * @private
     * @param {?} responseField
     * @param {?} configField
     * @return {?}
     */
    function (responseField, configField) {
        var _this = this;
        return ((responseField && responseField.buckets) || []).map((/**
         * @param {?} respBucket
         * @return {?}
         */
        function (respBucket) {
            respBucket['count'] = _this.getCountValue(respBucket);
            respBucket.filterQuery = respBucket.filterQuery || _this.getCorrespondingFilterQuery(configField, respBucket.label);
            return (/** @type {?} */ (__assign({}, respBucket, { checked: false, display: respBucket.display, label: respBucket.label })));
        }));
    };
    /**
     * @private
     * @param {?} responseField
     * @param {?} configGroup
     * @return {?}
     */
    SearchFilterComponent.prototype.getResponseQueryBuckets = /**
     * @private
     * @param {?} responseField
     * @param {?} configGroup
     * @return {?}
     */
    function (responseField, configGroup) {
        var _this = this;
        return (configGroup || []).map((/**
         * @param {?} query
         * @return {?}
         */
        function (query) {
            /** @type {?} */
            var respBucket = ((responseField && responseField.buckets) || [])
                .find((/**
             * @param {?} bucket
             * @return {?}
             */
            function (bucket) { return bucket.label === query.label; }));
            respBucket['count'] = _this.getCountValue(respBucket);
            return (/** @type {?} */ (__assign({}, respBucket, { checked: false, display: respBucket.display, label: respBucket.label })));
        }));
    };
    /**
     * @private
     * @param {?} bucket
     * @return {?}
     */
    SearchFilterComponent.prototype.getCountValue = /**
     * @private
     * @param {?} bucket
     * @return {?}
     */
    function (bucket) {
        return (!!bucket && !!bucket.metrics && bucket.metrics[0] && bucket.metrics[0].value && bucket.metrics[0].value.count)
            || 0;
    };
    /**
     * @param {?} bucket
     * @return {?}
     */
    SearchFilterComponent.prototype.getBucketCountDisplay = /**
     * @param {?} bucket
     * @return {?}
     */
    function (bucket) {
        return bucket.count === null ? '' : "(" + bucket.count + ")";
    };
    /**
     * @private
     * @param {?} mincountInput
     * @return {?}
     */
    SearchFilterComponent.prototype.getFilterByMinCount = /**
     * @private
     * @param {?} mincountInput
     * @return {?}
     */
    function (mincountInput) {
        return (/**
         * @param {?} bucket
         * @return {?}
         */
        function (bucket) {
            /** @type {?} */
            var mincount = mincountInput;
            if (mincount === undefined) {
                mincount = 1;
            }
            return bucket.count >= mincount;
        });
    };
    /**
     * @private
     * @param {?} configFacetItem
     * @param {?} bucketLabel
     * @return {?}
     */
    SearchFilterComponent.prototype.getCorrespondingFilterQuery = /**
     * @private
     * @param {?} configFacetItem
     * @param {?} bucketLabel
     * @return {?}
     */
    function (configFacetItem, bucketLabel) {
        /** @type {?} */
        var filterQuery = null;
        if (configFacetItem.field && bucketLabel) {
            if (configFacetItem.sets) {
                /** @type {?} */
                var configSet = configFacetItem.sets.find((/**
                 * @param {?} set
                 * @return {?}
                 */
                function (set) { return bucketLabel === set.label; }));
                if (configSet) {
                    filterQuery = this.buildIntervalQuery(configFacetItem.field, configSet);
                }
            }
            else {
                filterQuery = configFacetItem.field + ":\"" + bucketLabel + "\"";
            }
        }
        return filterQuery;
    };
    /**
     * @private
     * @param {?} fieldName
     * @param {?} interval
     * @return {?}
     */
    SearchFilterComponent.prototype.buildIntervalQuery = /**
     * @private
     * @param {?} fieldName
     * @param {?} interval
     * @return {?}
     */
    function (fieldName, interval) {
        /** @type {?} */
        var start = interval.start;
        /** @type {?} */
        var end = interval.end;
        /** @type {?} */
        var startLimit = (interval.startInclusive === undefined || interval.startInclusive === true) ? '[' : '<';
        /** @type {?} */
        var endLimit = (interval.endInclusive === undefined || interval.endInclusive === true) ? ']' : '>';
        return fieldName + ":" + startLimit + "\"" + start + "\" TO \"" + end + "\"" + endLimit;
    };
    /**
     * @private
     * @param {?} context
     * @param {?} itemType
     * @param {?} fieldLabel
     * @return {?}
     */
    SearchFilterComponent.prototype.findFacet = /**
     * @private
     * @param {?} context
     * @param {?} itemType
     * @param {?} fieldLabel
     * @return {?}
     */
    function (context, itemType, fieldLabel) {
        return (context.facets || []).find((/**
         * @param {?} response
         * @return {?}
         */
        function (response) { return response.type === itemType && response.label === fieldLabel; })) || {};
    };
    /**
     * @private
     * @param {?} itemType
     * @param {?} fieldLabel
     * @return {?}
     */
    SearchFilterComponent.prototype.findResponseFacet = /**
     * @private
     * @param {?} itemType
     * @param {?} fieldLabel
     * @return {?}
     */
    function (itemType, fieldLabel) {
        return (this.responseFacets || []).find((/**
         * @param {?} response
         * @return {?}
         */
        function (response) { return response.type === itemType && response.label === fieldLabel; }));
    };
    /**
     * @private
     * @param {?} responseField
     * @param {?} responseBuckets
     * @param {?} alreadyExistingField
     * @param {?} alreadyExistingBuckets
     * @return {?}
     */
    SearchFilterComponent.prototype.updateExistingBuckets = /**
     * @private
     * @param {?} responseField
     * @param {?} responseBuckets
     * @param {?} alreadyExistingField
     * @param {?} alreadyExistingBuckets
     * @return {?}
     */
    function (responseField, responseBuckets, alreadyExistingField, alreadyExistingBuckets) {
        var _this = this;
        /** @type {?} */
        var bucketsToDelete = [];
        alreadyExistingBuckets
            .map((/**
         * @param {?} bucket
         * @return {?}
         */
        function (bucket) {
            /** @type {?} */
            var responseBucket = ((responseField && responseField.buckets) || []).find((/**
             * @param {?} respBucket
             * @return {?}
             */
            function (respBucket) { return respBucket.label === bucket.label; }));
            if (!responseBucket) {
                bucketsToDelete.push(bucket);
            }
            bucket.count = _this.getCountValue(responseBucket);
            return bucket;
        }));
        /** @type {?} */
        var hasSelection = this.selectedBuckets
            .find((/**
         * @param {?} selBuckets
         * @return {?}
         */
        function (selBuckets) { return alreadyExistingField.label === selBuckets.field.label && alreadyExistingField.type === selBuckets.field.type; }));
        if (!hasSelection && bucketsToDelete.length) {
            bucketsToDelete.forEach((/**
             * @param {?} bucket
             * @return {?}
             */
            function (bucket) {
                alreadyExistingField.buckets.deleteItem(bucket);
            }));
        }
        responseBuckets.forEach((/**
         * @param {?} respBucket
         * @return {?}
         */
        function (respBucket) {
            /** @type {?} */
            var existingBucket = alreadyExistingBuckets.find((/**
             * @param {?} oldBucket
             * @return {?}
             */
            function (oldBucket) { return oldBucket.label === respBucket.label; }));
            if (!existingBucket) {
                alreadyExistingField.buckets.addItem(respBucket);
            }
        }));
    };
    /**
     * @private
     * @param {?} bucketList
     * @return {?}
     */
    SearchFilterComponent.prototype.getBucketFilterFunction = /**
     * @private
     * @param {?} bucketList
     * @return {?}
     */
    function (bucketList) {
        var _this = this;
        return (/**
         * @param {?} bucket
         * @return {?}
         */
        function (bucket) {
            if (bucket && bucketList.filterText) {
                /** @type {?} */
                var pattern = (bucketList.filterText || '').toLowerCase();
                /** @type {?} */
                var label = (_this.translationService.instant(bucket.display) || _this.translationService.instant(bucket.label)).toLowerCase();
                return _this.queryBuilder.config.filterWithContains ? label.indexOf(pattern) !== -1 : label.startsWith(pattern);
            }
            return true;
        });
    };
    SearchFilterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-filter',
                    template: "<mat-accordion multi=\"true\" displayMode=\"flat\">\n\n    <button *ngIf=\"displayResetButton && responseFacets\"\n            mat-button\n            color=\"primary\"\n            matTooltip=\"{{ 'SEARCH.FILTER.BUTTONS.RESET-ALL.TOOLTIP' | translate }}\"\n            matTooltipPosition=\"right\"\n            (click)=\"resetAll()\">\n        {{ 'SEARCH.FILTER.BUTTONS.RESET-ALL.LABEL' | translate }}\n    </button>\n    <mat-expansion-panel\n        *ngFor=\"let category of queryBuilder.categories\"\n        [attr.data-automation-id]=\"'expansion-panel-'+category.name\"\n        [(expanded)]=\"category.expanded\">\n        <mat-expansion-panel-header>\n            <mat-panel-title>\n                {{ category.name | translate }}\n            </mat-panel-title>\n        </mat-expansion-panel-header>\n        <adf-search-widget-container\n            [id]=\"category.id\"\n            [selector]=\"category.component.selector\"\n            [settings]=\"category.component.settings\">\n        </adf-search-widget-container>\n    </mat-expansion-panel>\n\n    <ng-container *ngIf=\"responseFacets\">\n        <mat-expansion-panel [attr.data-automation-id]=\"'expansion-panel-'+field.label\" *ngFor=\"let field of responseFacets\"\n                             [expanded]=\"shouldExpand(field)\">\n            <mat-expansion-panel-header>\n                <mat-panel-title>{{ field.label | translate }}</mat-panel-title>\n            </mat-expansion-panel-header>\n\n            <div class=\"adf-facet-result-filter\">\n                <mat-form-field>\n                    <input\n                        matInput\n                        placeholder=\"{{ 'SEARCH.FILTER.ACTIONS.FILTER-CATEGORY' | translate }}\"\n                        [attr.data-automation-id]=\"'facet-result-filter-'+field.label\"\n                        [(ngModel)]=\"field.buckets.filterText\">\n                    <button *ngIf=\"field.buckets.filterText\"\n                        mat-button matSuffix mat-icon-button\n                        (click)=\"field.buckets.filterText = ''\">\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </mat-form-field>\n            </div>\n\n            <div class=\"adf-checklist\">\n                <mat-checkbox\n                    *ngFor=\"let bucket of field.buckets\"\n                    [checked]=\"bucket.checked\"\n                    [attr.data-automation-id]=\"'checkbox-'+field.label+'-'+(bucket.display || bucket.label)\"\n                    (change)=\"onToggleBucket($event, field, bucket)\">\n                    <div \n                        matTooltip=\"{{ bucket.display || bucket.label | translate }} {{ getBucketCountDisplay(bucket) }}\"\n                        matTooltipPosition=\"right\"\n                        class=\"adf-facet-label\">\n                        {{ bucket.display || bucket.label | translate }} {{ getBucketCountDisplay(bucket) }}\n                    </div>\n                </mat-checkbox>\n            </div>\n\n            <div class=\"adf-facet-buttons\" *ngIf=\"field.buckets.fitsPage\">\n                <button *ngIf=\"canResetSelectedBuckets(field)\"\n                    mat-button\n                    color=\"primary\"\n                    (click)=\"resetSelectedBuckets(field)\">\n                    {{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\n                </button>\n            </div>\n\n            <div class=\"adf-facet-buttons\" *ngIf=\"!field.buckets.fitsPage\">\n                <button mat-icon-button\n                    *ngIf=\"canResetSelectedBuckets(field)\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\"\n                    (click)=\"resetSelectedBuckets(field)\">\n                    <mat-icon>clear</mat-icon>\n                </button>\n                <button mat-icon-button\n                    *ngIf=\"field.buckets.canShowLessItems\"\n                    (click)=\"field.buckets.showLessItems()\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\">\n                    <mat-icon>keyboard_arrow_up</mat-icon>\n                </button>\n                <button mat-icon-button\n                    *ngIf=\"field.buckets.canShowMoreItems\"\n                    (click)=\"field.buckets.showMoreItems()\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\">\n                    <mat-icon>keyboard_arrow_down</mat-icon>\n                </button>\n            </div>\n        </mat-expansion-panel>\n    </ng-container>\n</mat-accordion>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-filter' },
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    SearchFilterComponent.ctorParameters = function () { return [
        { type: SearchQueryBuilderService },
        { type: SearchService },
        { type: TranslationService }
    ]; };
    return SearchFilterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchTextComponent = /** @class */ (function () {
    function SearchTextComponent() {
        /**
         * The content of the text box.
         */
        this.value = '';
    }
    /**
     * @return {?}
     */
    SearchTextComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.context && this.settings && this.settings.pattern) {
            /** @type {?} */
            var pattern = new RegExp(this.settings.pattern, 'g');
            /** @type {?} */
            var match = pattern.exec(this.context.queryFragments[this.id] || '');
            if (match && match.length > 1) {
                this.value = match[1];
            }
        }
    };
    /**
     * @return {?}
     */
    SearchTextComponent.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.value = '';
        this.updateQuery(null);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchTextComponent.prototype.onChangedHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.value = event.target.value;
        this.updateQuery(this.value);
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    SearchTextComponent.prototype.updateQuery = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.context && this.settings && this.settings.field) {
            this.context.queryFragments[this.id] = value ? this.settings.field + ":'" + value + "'" : '';
            this.context.update();
        }
    };
    SearchTextComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-text',
                    template: "<mat-form-field>\n    <input\n        matInput\n        [placeholder]=\"settings?.placeholder\"\n        [(ngModel)]=\"value\"\n        (change)=\"onChangedHandler($event)\">\n    <button mat-button *ngIf=\"value\" matSuffix mat-icon-button (click)=\"reset()\">\n        <mat-icon>close</mat-icon>\n    </button>\n</mat-form-field>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-text' },
                    styles: [".adf-search-text .mat-form-field{width:100%}"]
                }] }
    ];
    SearchTextComponent.propDecorators = {
        value: [{ type: Input }]
    };
    return SearchTextComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchRadioComponent = /** @class */ (function () {
    function SearchRadioComponent() {
        this.pageSize = 5;
        this.options = new SearchFilterList();
    }
    /**
     * @return {?}
     */
    SearchRadioComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.settings) {
            this.pageSize = this.settings.pageSize || 5;
            if (this.settings.options && this.settings.options.length > 0) {
                this.options = new SearchFilterList(this.settings.options, this.pageSize);
            }
        }
        /** @type {?} */
        var initialValue = this.getSelectedValue();
        if (initialValue !== null) {
            this.setValue(initialValue);
        }
    };
    /**
     * @private
     * @return {?}
     */
    SearchRadioComponent.prototype.getSelectedValue = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var options = this.settings['options'] || [];
        if (options && options.length > 0) {
            /** @type {?} */
            var selected = options.find((/**
             * @param {?} opt
             * @return {?}
             */
            function (opt) { return opt.default; }));
            if (!selected) {
                selected = options[0];
            }
            return selected.value;
        }
        return null;
    };
    /**
     * @private
     * @param {?} newValue
     * @return {?}
     */
    SearchRadioComponent.prototype.setValue = /**
     * @private
     * @param {?} newValue
     * @return {?}
     */
    function (newValue) {
        this.value = newValue;
        this.context.queryFragments[this.id] = newValue;
        this.context.update();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchRadioComponent.prototype.changeHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setValue(event.value);
    };
    SearchRadioComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-radio',
                    template: "<mat-radio-group\n    [(ngModel)]=\"value\"\n    (change)=\"changeHandler($event)\">\n    <mat-radio-button [attr.data-automation-id]=\"'search-radio-'+(option.name | translate)\"\n        *ngFor=\"let option of options\"\n        [value]=\"option.value\"\n        class=\"adf-facet-filter\">\n        <div \n            matTooltip=\"{{ option.name | translate }}\"\n            matTooltipPosition=\"right\"\n            class=\"filter-label\">\n            {{ option.name | translate }}\n        </div>\n    </mat-radio-button>\n</mat-radio-group>\n\n<div class=\"adf-facet-buttons\" *ngIf=\"!options.fitsPage\">\n    <button mat-icon-button\n        *ngIf=\"options.canShowLessItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\"\n        (click)=\"options.showLessItems()\">\n        <mat-icon>keyboard_arrow_up</mat-icon>\n    </button>\n    <button mat-icon-button\n        *ngIf=\"options.canShowMoreItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\"\n        (click)=\"options.showMoreItems()\">\n        <mat-icon>keyboard_arrow_down</mat-icon>\n    </button>\n</div>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-radio' },
                    styles: [".adf-search-radio .mat-radio-group{display:flex;flex-direction:column}.adf-search-radio .mat-radio-button{margin:5px}.adf-search-radio .adf-facet-filter .mat-radio-label-content{text-overflow:ellipsis;overflow:hidden;width:100%}.adf-search-radio .adf-facet-filter .mat-radio-label{width:100%}.adf-search-radio .adf-facet-filter .adf-filter-label{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}"]
                }] }
    ];
    /** @nocollapse */
    SearchRadioComponent.ctorParameters = function () { return []; };
    SearchRadioComponent.propDecorators = {
        value: [{ type: Input }]
    };
    return SearchRadioComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchSliderComponent = /** @class */ (function () {
    function SearchSliderComponent() {
        this.thumbLabel = false;
    }
    /**
     * @return {?}
     */
    SearchSliderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.settings) {
            if (this.settings.hasOwnProperty('min')) {
                this.min = this.settings['min'];
            }
            if (this.settings.hasOwnProperty('max')) {
                this.max = this.settings['max'];
            }
            if (this.settings.hasOwnProperty('step')) {
                this.step = this.settings['step'];
            }
            this.thumbLabel = this.settings['thumbLabel'] ? true : false;
        }
    };
    /**
     * @return {?}
     */
    SearchSliderComponent.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.value = this.min || 0;
        this.updateQuery(null);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchSliderComponent.prototype.onChangedHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.value = event.value;
        this.updateQuery(this.value);
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    SearchSliderComponent.prototype.updateQuery = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.id && this.context && this.settings && this.settings.field) {
            if (value === null) {
                this.context.queryFragments[this.id] = '';
            }
            else {
                this.context.queryFragments[this.id] = this.settings.field + ":[0 TO " + value + "]";
            }
            this.context.update();
        }
    };
    SearchSliderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-slider',
                    template: "<mat-slider\n    [(value)]=\"value\"\n    [min]=\"min\"\n    [max]=\"max\"\n    [step]=\"step\"\n    [thumbLabel]=\"thumbLabel\"\n    (change)=\"onChangedHandler($event)\"\n    data-automation-id=\"slider-range\">\n</mat-slider>\n\n<div class=\"facet-buttons\">\n    <button mat-button color=\"primary\" (click)=\"reset()\" data-automation-id=\"slider-btn-clear\">\n        {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n    </button>\n</div>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-slider' },
                    styles: [".adf-search-slider .mat-slider{width:100%}"]
                }] }
    ];
    SearchSliderComponent.propDecorators = {
        value: [{ type: Input }]
    };
    return SearchSliderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LiveErrorStateMatcher = /** @class */ (function () {
    function LiveErrorStateMatcher() {
    }
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    LiveErrorStateMatcher.prototype.isErrorState = /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        /** @type {?} */
        var isSubmitted = form && form.submitted;
        return !!(control && control.invalid && (control.dirty || control.touched || (!control.pristine && isSubmitted)));
    };
    return LiveErrorStateMatcher;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchNumberRangeComponent = /** @class */ (function () {
    function SearchNumberRangeComponent() {
        this.matcher = new LiveErrorStateMatcher();
        this.format = '[{FROM} TO {TO}]';
    }
    /**
     * @return {?}
     */
    SearchNumberRangeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.settings) {
            this.field = this.settings.field;
            this.format = this.settings.format || '[{FROM} TO {TO}]';
        }
        this.validators = Validators.compose([
            Validators.required,
            Validators.pattern(/^-?(0|[1-9]\d*)?$/),
            Validators.min(0)
        ]);
        this.from = new FormControl('', this.validators);
        this.to = new FormControl('', this.validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        }, this.formValidator);
    };
    /**
     * @param {?} formGroup
     * @return {?}
     */
    SearchNumberRangeComponent.prototype.formValidator = /**
     * @param {?} formGroup
     * @return {?}
     */
    function (formGroup) {
        return parseInt(formGroup.get('from').value, 10) < parseInt(formGroup.get('to').value, 10) ? null : { 'mismatch': true };
    };
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    SearchNumberRangeComponent.prototype.apply = /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    function (model, isValid) {
        if (isValid && this.id && this.context && this.field) {
            /** @type {?} */
            var map$$1 = new Map();
            map$$1.set('FROM', model.from);
            map$$1.set('TO', model.to);
            /** @type {?} */
            var value = this.formatString(this.format, map$$1);
            this.context.queryFragments[this.id] = this.field + ":" + value;
            this.context.update();
        }
    };
    /**
     * @private
     * @param {?} str
     * @param {?} map
     * @return {?}
     */
    SearchNumberRangeComponent.prototype.formatString = /**
     * @private
     * @param {?} str
     * @param {?} map
     * @return {?}
     */
    function (str, map$$1) {
        /** @type {?} */
        var result = str;
        map$$1.forEach((/**
         * @param {?} value
         * @param {?} key
         * @return {?}
         */
        function (value, key) {
            /** @type {?} */
            var expr = new RegExp('{' + key + '}', 'gm');
            result = result.replace(expr, value);
        }));
        return result;
    };
    /**
     * @return {?}
     */
    SearchNumberRangeComponent.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    };
    SearchNumberRangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-number-range',
                    template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"from\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM' | translate }}\"\n            autocomplete=\"off\"\n            data-automation-id=\"number-range-from-input\">\n        <mat-error *ngIf=\"from.hasError('pattern') || from.hasError('min')\" data-automation-id=\"number-range-from-error-invalid\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"from.hasError('required')\" data-automation-id=\"number-range-from-error-required\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"to\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO' | translate }}\"\n            autocomplete=\"off\"\n            data-automation-id=\"number-range-to-input\">\n        <mat-error *ngIf=\"to.hasError('pattern') || to.hasError('min')\" data-automation-id=\"number-range-to-error-invalid\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"to.hasError('required')\" data-automation-id=\"number-range-to-error-required\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n\n    <div class=\"adf-facet-buttons\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\" data-automation-id=\"number-range-btn-clear\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\" data-automation-id=\"number-range-btn-apply\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-number-range' },
                    styles: [".adf-search-number-range>form{display:inline-flex;flex-direction:column;width:100%}"]
                }] }
    ];
    return SearchNumberRangeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchCheckListComponent = /** @class */ (function () {
    function SearchCheckListComponent() {
        this.operator = 'OR';
        this.pageSize = 5;
        this.options = new SearchFilterList();
    }
    /**
     * @return {?}
     */
    SearchCheckListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.settings) {
            this.operator = this.settings.operator || 'OR';
            this.pageSize = this.settings.pageSize || 5;
            if (this.settings.options && this.settings.options.length > 0) {
                this.options = new SearchFilterList(this.settings.options, this.pageSize);
            }
        }
    };
    /**
     * @return {?}
     */
    SearchCheckListComponent.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.options.items.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        function (opt) {
            opt.checked = false;
        }));
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    };
    /**
     * @param {?} event
     * @param {?} option
     * @return {?}
     */
    SearchCheckListComponent.prototype.changeHandler = /**
     * @param {?} event
     * @param {?} option
     * @return {?}
     */
    function (event, option) {
        option.checked = event.checked;
        this.flush();
    };
    /**
     * @return {?}
     */
    SearchCheckListComponent.prototype.flush = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var checkedValues = this.options.items
            .filter((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option.checked; }))
            .map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option.value; }));
        /** @type {?} */
        var query = checkedValues.join(" " + this.operator + " ");
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = query;
            this.context.update();
        }
    };
    SearchCheckListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-check-list',
                    template: "<div class=\"checklist\">\n    <mat-checkbox\n        *ngFor=\"let option of options\"\n        [checked]=\"option.checked\"\n        [attr.data-automation-id]=\"'checkbox-' + (option.name)\"\n        (change)=\"changeHandler($event, option)\"\n        class=\"adf-facet-filter\">\n        <div \n            matTooltip=\"{{ option.name | translate }}\"\n            matTooltipPosition=\"right\"\n            class=\"facet-name\">\n            {{ option.name | translate }}\n        </div>\n        \n    </mat-checkbox>\n</div>\n\n<div class=\"adf-facet-buttons\" *ngIf=\"options.fitsPage\">\n    <button mat-button color=\"primary\" (click)=\"reset()\">\n        {{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\n    </button>\n</div>\n\n<div class=\"adf-facet-buttons\" *ngIf=\"!options.fitsPage\">\n    <button mat-icon-button\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\"\n        (click)=\"reset()\">\n        <mat-icon>clear</mat-icon>\n    </button>\n    <button mat-icon-button\n        *ngIf=\"options.canShowLessItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\"\n        (click)=\"options.showLessItems()\">\n        <mat-icon>keyboard_arrow_up</mat-icon>\n    </button>\n    <button mat-icon-button\n        *ngIf=\"options.canShowMoreItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\"\n        (click)=\"options.showMoreItems()\">\n        <mat-icon>keyboard_arrow_down</mat-icon>\n    </button>\n</div>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-check-list' },
                    styles: [".adf-search-check-list{display:flex;flex-direction:column}.adf-search-check-list .adf-facet-filter .mat-checkbox-label{text-overflow:ellipsis;overflow:hidden;width:100%}.adf-search-check-list .adf-facet-filter .mat-checkbox-layout{width:100%}.adf-search-check-list .adf-facet-filter .adf-facet-name{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}"]
                }] }
    ];
    /** @nocollapse */
    SearchCheckListComponent.ctorParameters = function () { return []; };
    return SearchCheckListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_FORMAT_DATE = 'DD/MM/YYYY';
var ɵ0 = MOMENT_DATE_FORMATS;
var SearchDateRangeComponent = /** @class */ (function () {
    function SearchDateRangeComponent(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.matcher = new LiveErrorStateMatcher();
        this.datePickerDateFormat = DEFAULT_FORMAT_DATE;
    }
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.getFromValidationMessage = /**
     * @return {?}
     */
    function () {
        return this.from.hasError('invalidOnChange') || this.hasParseError(this.from) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.from.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                this.from.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                    '';
    };
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.getToValidationMessage = /**
     * @return {?}
     */
    function () {
        return this.to.hasError('invalidOnChange') || this.hasParseError(this.to) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.to.hasError('matDatepickerMin') ? 'SEARCH.FILTER.VALIDATION.NO-DAYS' :
                this.to.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                    this.to.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                        '';
    };
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.settings) {
            this.datePickerDateFormat = this.settings.dateFormat || DEFAULT_FORMAT_DATE;
        }
        /** @type {?} */
        var theCustomDateAdapter = (/** @type {?} */ ((/** @type {?} */ (this.dateAdapter))));
        theCustomDateAdapter.overrideDisplayFormat = this.datePickerDateFormat;
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        function (locale) {
            _this.setLocale(locale);
        }));
        /** @type {?} */
        var validators = Validators.compose([
            Validators.required
        ]);
        this.from = new FormControl('', validators);
        this.to = new FormControl('', validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        });
        this.maxDate = this.dateAdapter.today().startOf('day');
    };
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    SearchDateRangeComponent.prototype.apply = /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    function (model, isValid) {
        if (isValid && this.id && this.context && this.settings && this.settings.field) {
            /** @type {?} */
            var start = moment(model.from).startOf('day').format();
            /** @type {?} */
            var end = moment(model.to).endOf('day').format();
            this.context.queryFragments[this.id] = this.settings.field + ":['" + start + "' TO '" + end + "']";
            this.context.update();
        }
    };
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    };
    /**
     * @param {?} event
     * @param {?} formControl
     * @return {?}
     */
    SearchDateRangeComponent.prototype.onChangedHandler = /**
     * @param {?} event
     * @param {?} formControl
     * @return {?}
     */
    function (event, formControl) {
        /** @type {?} */
        var inputValue = event.srcElement.value;
        /** @type {?} */
        var formatDate = this.dateAdapter.parse(inputValue, this.datePickerDateFormat);
        if (formatDate && formatDate.isValid()) {
            formControl.setValue(formatDate);
        }
        else if (formatDate) {
            formControl.setErrors({
                'invalidOnChange': true
            });
        }
        else {
            formControl.setErrors({
                'required': true
            });
        }
    };
    /**
     * @param {?} locale
     * @return {?}
     */
    SearchDateRangeComponent.prototype.setLocale = /**
     * @param {?} locale
     * @return {?}
     */
    function (locale) {
        this.dateAdapter.setLocale(locale);
        moment.locale(locale);
    };
    /**
     * @param {?} formControl
     * @return {?}
     */
    SearchDateRangeComponent.prototype.hasParseError = /**
     * @param {?} formControl
     * @return {?}
     */
    function (formControl) {
        return formControl.hasError('matDatepickerParse') && formControl.getError('matDatepickerParse').text;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchDateRangeComponent.prototype.forcePlaceholder = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.srcElement.click();
    };
    SearchDateRangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-date-range',
                    template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"from\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM-DATE' | translate }}\"\n                [matDatepicker]=\"fromDatepicker\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, from)\"\n                data-automation-id=\"date-range-from-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"fromDatepicker\" data-automation-id=\"date-range-from-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #fromDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"from.invalid\" data-automation-id=\"date-range-from-error\">\n            {{ getFromValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"to\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO-DATE' | translate }}\"\n                [matDatepicker]=\"toDatepicker\"\n                [min]=\"from.value\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, to)\"\n                data-automation-id=\"date-range-to-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"toDatepicker\" data-automation-id=\"date-range-to-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #toDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"to.invalid\" data-automation-id=\"date-range-to-error\">\n            {{ getToValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <div class=\"adf-facet-buttons adf-facet-buttons--topSpace\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\" data-automation-id=\"date-range-clear-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\" data-automation-id=\"date-range-apply-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                    providers: [
                        { provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                        { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                    ],
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-date-range' },
                    styles: [".adf-search-date-range>form{display:inline-flex;flex-direction:column;width:100%}"]
                }] }
    ];
    /** @nocollapse */
    SearchDateRangeComponent.ctorParameters = function () { return [
        { type: DateAdapter },
        { type: UserPreferencesService }
    ]; };
    return SearchDateRangeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchFilterService = /** @class */ (function () {
    function SearchFilterService() {
        /**
         * Contains string-to-type mappings for registered widgets.
         */
        this.widgets = {
            'text': SearchTextComponent,
            'radio': SearchRadioComponent,
            'slider': SearchSliderComponent,
            'number-range': SearchNumberRangeComponent,
            'check-list': SearchCheckListComponent,
            'date-range': SearchDateRangeComponent
        };
    }
    SearchFilterService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */ SearchFilterService.ngInjectableDef = defineInjectable({ factory: function SearchFilterService_Factory() { return new SearchFilterService(); }, token: SearchFilterService, providedIn: "root" });
    return SearchFilterService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchChipListComponent = /** @class */ (function () {
    function SearchChipListComponent() {
        /**
         * Flag used to enable the display of a clear-all-filters button.
         */
        this.clearAll = false;
    }
    SearchChipListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-chip-list',
                    template: "<mat-chip-list>\n    <ng-container *ngIf=\"searchFilter && searchFilter.selectedBuckets.length\">\n        <mat-chip *ngIf=\"clearAll && searchFilter.selectedBuckets.length > 1\"\n                  color=\"primary\"\n                  selected\n                  matTooltip=\"{{ 'SEARCH.FILTER.BUTTONS.CLEAR-ALL.TOOLTIP' | translate }}\"\n                  matTooltipPosition=\"right\"\n                  (click)=\"searchFilter.resetAllSelectedBuckets()\">\n            {{ 'SEARCH.FILTER.BUTTONS.CLEAR-ALL.LABEL' | translate }}\n        </mat-chip>\n\n        <mat-chip\n            *ngFor=\"let selection of searchFilter.selectedBuckets\"\n            [removable]=\"true\"\n            (removed)=\"searchFilter.unselectFacetBucket(selection.field, selection.bucket)\">\n            {{ (selection.bucket.display || selection.bucket.label) | translate }}\n            <mat-icon matChipRemove>cancel</mat-icon>\n        </mat-chip>\n    </ng-container>\n</mat-chip-list>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-chip-list' }
                }] }
    ];
    SearchChipListComponent.propDecorators = {
        searchFilter: [{ type: Input }],
        clearAll: [{ type: Input }]
    };
    return SearchChipListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchSortingPickerComponent = /** @class */ (function () {
    function SearchSortingPickerComponent(queryBuilder) {
        this.queryBuilder = queryBuilder;
        this.options = [];
    }
    /**
     * @return {?}
     */
    SearchSortingPickerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.options = this.queryBuilder.getSortingOptions();
        /** @type {?} */
        var primary = this.queryBuilder.getPrimarySorting();
        if (primary) {
            this.value = primary.key;
            this.ascending = primary.ascending;
        }
    };
    /**
     * @param {?} key
     * @return {?}
     */
    SearchSortingPickerComponent.prototype.onValueChanged = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        this.value = key;
        this.ascending = this.getSortingOrder();
        this.applySorting();
    };
    /**
     * @param {?} ascending
     * @return {?}
     */
    SearchSortingPickerComponent.prototype.onSortingChanged = /**
     * @param {?} ascending
     * @return {?}
     */
    function (ascending) {
        this.ascending = ascending;
        this.applySorting();
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    SearchSortingPickerComponent.prototype.findOptionByKey = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        if (key) {
            return this.options.find((/**
             * @param {?} opt
             * @return {?}
             */
            function (opt) { return opt.key === key; }));
        }
        return null;
    };
    /**
     * @private
     * @return {?}
     */
    SearchSortingPickerComponent.prototype.applySorting = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var option = this.findOptionByKey(this.value);
        if (option) {
            this.queryBuilder.sorting = [__assign({}, option, { ascending: this.ascending })];
            this.queryBuilder.update();
        }
    };
    /**
     * @private
     * @return {?}
     */
    SearchSortingPickerComponent.prototype.getSortingOrder = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var option = this.findOptionByKey(this.value);
        if (option) {
            return option.ascending;
        }
        return this.queryBuilder.getPrimarySorting().ascending;
    };
    SearchSortingPickerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-sorting-picker',
                    template: "<adf-sorting-picker\n    [options]=\"options\"\n    [selected]=\"value\"\n    [ascending]=\"ascending\"\n    (valueChange)=\"onValueChanged($event)\"\n    (sortingChange)=\"onSortingChanged($event)\">\n</adf-sorting-picker>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-sorting-picker' },
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    SearchSortingPickerComponent.ctorParameters = function () { return [
        { type: SearchQueryBuilderService }
    ]; };
    return SearchSortingPickerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchWidgetContainerComponent = /** @class */ (function () {
    function SearchWidgetContainerComponent(searchFilterService, queryBuilder, componentFactoryResolver) {
        this.searchFilterService = searchFilterService;
        this.queryBuilder = queryBuilder;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * @return {?}
     */
    SearchWidgetContainerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var componentType = this.searchFilterService.widgets[this.selector];
        if (componentType) {
            /** @type {?} */
            var factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
                this.setupWidget(this.componentRef);
            }
        }
    };
    /**
     * @private
     * @param {?} ref
     * @return {?}
     */
    SearchWidgetContainerComponent.prototype.setupWidget = /**
     * @private
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        if (ref && ref.instance) {
            ref.instance.id = this.id;
            ref.instance.settings = __assign({}, this.settings);
            ref.instance.context = this.queryBuilder;
        }
    };
    /**
     * @return {?}
     */
    SearchWidgetContainerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    };
    SearchWidgetContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-widget-container',
                    template: '<div #content></div>'
                }] }
    ];
    /** @nocollapse */
    SearchWidgetContainerComponent.ctorParameters = function () { return [
        { type: SearchFilterService },
        { type: SearchQueryBuilderService },
        { type: ComponentFactoryResolver }
    ]; };
    SearchWidgetContainerComponent.propDecorators = {
        content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] }],
        id: [{ type: Input }],
        selector: [{ type: Input }],
        settings: [{ type: Input }],
        config: [{ type: Input }]
    };
    return SearchWidgetContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ALFRESCO_SEARCH_DIRECTIVES = [
    SearchComponent,
    SearchControlComponent,
    SearchTriggerDirective,
    EmptySearchResultComponent,
    SearchFilterComponent,
    SearchChipListComponent
];
var SearchModule = /** @class */ (function () {
    function SearchModule() {
    }
    SearchModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MaterialModule,
                        CoreModule.forChild()
                    ],
                    declarations: __spread(ALFRESCO_SEARCH_DIRECTIVES, [
                        SearchWidgetContainerComponent,
                        SearchTextComponent,
                        SearchRadioComponent,
                        SearchSliderComponent,
                        SearchNumberRangeComponent,
                        SearchCheckListComponent,
                        SearchDateRangeComponent,
                        SearchSortingPickerComponent
                    ]),
                    exports: __spread(ALFRESCO_SEARCH_DIRECTIVES, [
                        SearchWidgetContainerComponent,
                        SearchTextComponent,
                        SearchRadioComponent,
                        SearchSliderComponent,
                        SearchNumberRangeComponent,
                        SearchCheckListComponent,
                        SearchDateRangeComponent,
                        SearchSortingPickerComponent
                    ]),
                    entryComponents: [
                        SearchWidgetContainerComponent,
                        SearchTextComponent,
                        SearchRadioComponent,
                        SearchSliderComponent,
                        SearchNumberRangeComponent,
                        SearchCheckListComponent,
                        SearchDateRangeComponent
                    ]
                },] }
    ];
    return SearchModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var Relations = {
    Members: 'members',
    Containers: 'containers',
};
var DropdownSitesComponent = /** @class */ (function () {
    function DropdownSitesComponent(sitesService, logService) {
        this.sitesService = sitesService;
        this.logService = logService;
        /**
         * Hide the "My Files" option.
         */
        this.hideMyFiles = false;
        /**
         * A custom list of sites to be displayed by the dropdown. If no value
         * is given, the sites of the current user are displayed by default. A
         * list of objects only with properties 'title' and 'guid' is enough to
         * be able to display the dropdown.
         */
        this.siteList = null;
        /**
         * Id of the selected site
         */
        this.value = null;
        /**
         * Text or a translation key to act as a placeholder. Default value is the
         * key "DROPDOWN.PLACEHOLDER_LABEL".
         */
        this.placeholder = 'DROPDOWN.PLACEHOLDER_LABEL';
        /**
         * Emitted when the user selects a site. When the default option is selected,
         * an empty model is emitted.
         */
        this.change = new EventEmitter();
        this.loading = true;
        this.skipCount = 0;
        this.MAX_ITEMS = 50;
        this.ITEM_HEIGHT = 45;
        this.ITEM_HEIGHT_TO_WAIT_BEFORE_LOAD_NEXT = (this.ITEM_HEIGHT * (this.MAX_ITEMS / 2));
        this.selected = null;
        this.MY_FILES_VALUE = '-my-';
    }
    /**
     * @return {?}
     */
    DropdownSitesComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.siteSelect.openedChange.subscribe((/**
         * @return {?}
         */
        function () {
            if (_this.siteSelect.panelOpen) {
                _this.siteSelect.panel.nativeElement.addEventListener('scroll', (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.loadAllOnScroll(event); }));
            }
        }));
        if (!this.siteList) {
            this.loadSiteList();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DropdownSitesComponent.prototype.loadAllOnScroll = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isInfiniteScrollingEnabled() && this.isScrollInNextFetchArea(event)) {
            this.loading = true;
            this.loadSiteList();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DropdownSitesComponent.prototype.isScrollInNextFetchArea = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return event.target.scrollTop >= (event.target.scrollHeight - event.target.offsetHeight - this.ITEM_HEIGHT_TO_WAIT_BEFORE_LOAD_NEXT);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DropdownSitesComponent.prototype.selectedSite = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.change.emit(event.value);
    };
    /**
     * @private
     * @return {?}
     */
    DropdownSitesComponent.prototype.loadSiteList = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var extendedOptions = {
            skipCount: this.skipCount,
            maxItems: this.MAX_ITEMS
        };
        this.skipCount += this.MAX_ITEMS;
        if (this.relations) {
            extendedOptions.relations = [this.relations];
        }
        this.sitesService.getSites(extendedOptions).subscribe((/**
         * @param {?} sitePaging
         * @return {?}
         */
        function (sitePaging) {
            if (!_this.siteList) {
                _this.siteList = _this.relations === Relations.Members ? _this.filteredResultsByMember(sitePaging) : sitePaging;
                if (!_this.hideMyFiles) {
                    /** @type {?} */
                    var siteEntry = new SiteEntry({
                        entry: {
                            id: '-my-',
                            guid: '-my-',
                            title: 'DROPDOWN.MY_FILES_OPTION'
                        }
                    });
                    _this.siteList.list.entries.unshift(siteEntry);
                    if (!_this.value) {
                        _this.value = '-my-';
                    }
                }
            }
            else {
                /** @type {?} */
                var siteList = _this.relations === Relations.Members ? _this.filteredResultsByMember(sitePaging) : sitePaging;
                _this.siteList.list.entries = _this.siteList.list.entries.concat(siteList.list.entries);
                _this.siteList.list.pagination = sitePaging.list.pagination;
            }
            _this.selected = _this.siteList.list.entries.find((/**
             * @param {?} site
             * @return {?}
             */
            function (site) { return site.entry.id === _this.value; }));
            _this.loading = false;
        }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            _this.logService.error(error);
        }));
    };
    /**
     * @return {?}
     */
    DropdownSitesComponent.prototype.showLoading = /**
     * @return {?}
     */
    function () {
        return this.loading && (this.siteList && this.siteList.list.pagination && this.siteList.list.pagination.hasMoreItems);
    };
    /**
     * @return {?}
     */
    DropdownSitesComponent.prototype.isInfiniteScrollingEnabled = /**
     * @return {?}
     */
    function () {
        return !this.loading && (this.siteList && this.siteList.list.pagination && this.siteList.list.pagination.hasMoreItems);
    };
    /**
     * @private
     * @param {?} sites
     * @return {?}
     */
    DropdownSitesComponent.prototype.filteredResultsByMember = /**
     * @private
     * @param {?} sites
     * @return {?}
     */
    function (sites) {
        var _this = this;
        /** @type {?} */
        var loggedUserName = this.sitesService.getEcmCurrentLoggedUserName();
        sites.list.entries = sites.list.entries.filter((/**
         * @param {?} site
         * @return {?}
         */
        function (site) { return _this.isCurrentUserMember(site, loggedUserName); }));
        return sites;
    };
    /**
     * @private
     * @param {?} site
     * @param {?} loggedUserName
     * @return {?}
     */
    DropdownSitesComponent.prototype.isCurrentUserMember = /**
     * @private
     * @param {?} site
     * @param {?} loggedUserName
     * @return {?}
     */
    function (site, loggedUserName) {
        return site.entry.visibility === 'PUBLIC' ||
            !!site.relations.members.list.entries.find((/**
             * @param {?} member
             * @return {?}
             */
            function (member) {
                return member.entry.id.toLowerCase() === loggedUserName.toLowerCase();
            }));
    };
    DropdownSitesComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-sites-dropdown',
                    template: "<div id=\"site-dropdown-container\" class=\"adf-site-dropdown-container\">\n    <mat-form-field>\n        <mat-select\n            #siteSelect\n            data-automation-id=\"site-my-files-option\"\n            class=\"adf-site-dropdown-list-element\"\n            id=\"site-dropdown\"\n            placeholder=\"{{placeholder | translate}}\"\n            floatPlaceholder=\"never\"\n            [(value)]=\"selected\"\n            (selectionChange)=\"selectedSite($event)\">\n            <mat-option *ngFor=\"let site of siteList?.list.entries;\" [value]=\"site\">\n                {{ site.entry.title | translate}}\n            </mat-option>\n            <mat-option *ngIf=\"showLoading()\" disabled=\"true\" data-automation-id=\"site-loading\">\n                {{ 'ADF_DROPDOWN.LOADING' | translate}}\n            </mat-option>\n        </mat-select>\n    </mat-form-field>\n</div>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { 'class': 'adf-sites-dropdown' },
                    styles: [".adf-sites-dropdown.adf-full-width .mat-form-field{width:100%}"]
                }] }
    ];
    /** @nocollapse */
    DropdownSitesComponent.ctorParameters = function () { return [
        { type: SitesService },
        { type: LogService }
    ]; };
    DropdownSitesComponent.propDecorators = {
        hideMyFiles: [{ type: Input }],
        siteList: [{ type: Input }],
        value: [{ type: Input }],
        placeholder: [{ type: Input }],
        relations: [{ type: Input }],
        change: [{ type: Output }],
        siteSelect: [{ type: ViewChild, args: ['siteSelect',] }]
    };
    return DropdownSitesComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SitesDropdownModule = /** @class */ (function () {
    function SitesDropdownModule() {
    }
    SitesDropdownModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule,
                        FormsModule,
                        ReactiveFormsModule,
                        CoreModule.forChild()
                    ],
                    exports: [
                        DropdownSitesComponent
                    ],
                    declarations: [
                        DropdownSitesComponent
                    ]
                },] }
    ];
    return SitesDropdownModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BreadcrumbComponent = /** @class */ (function () {
    function BreadcrumbComponent() {
        /**
         * Active node, builds UI based on folderNode.path.elements collection.
         */
        this.folderNode = null;
        /**
         * (optional) Name of the root element of the breadcrumb. You can use
         * this property to rename "Company Home" to "Personal Files" for
         * example. You can use an i18n resource key for the property value.
         */
        this.root = null;
        /**
         * (optional) The id of the root element. You can use this property
         * to set a custom element the breadcrumb should start with.
         */
        this.rootId = null;
        this.route = [];
        /**
         * Emitted when the user clicks on a breadcrumb.
         */
        this.navigate = new EventEmitter();
    }
    Object.defineProperty(BreadcrumbComponent.prototype, "hasRoot", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.root;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BreadcrumbComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.transform = this.transform ? this.transform : null;
        if (this.target) {
            this.target.$folderNode.subscribe((/**
             * @param {?} folderNode
             * @return {?}
             */
            function (folderNode) {
                _this.folderNode = folderNode;
                _this.recalculateNodes();
            }));
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    BreadcrumbComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.recalculateNodes();
    };
    /**
     * @protected
     * @return {?}
     */
    BreadcrumbComponent.prototype.recalculateNodes = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var node = this.transform ? this.transform(this.folderNode) : this.folderNode;
        this.route = this.parseRoute(node);
        if (this.maxItems && this.route.length > this.maxItems) {
            this.lastNodes = this.route.slice(this.route.length - this.maxItems);
            this.previousNodes = this.route.slice(0, this.route.length - this.maxItems);
            this.previousNodes.reverse();
        }
        else {
            this.lastNodes = this.route;
            this.previousNodes = null;
        }
    };
    /**
     * @return {?}
     */
    BreadcrumbComponent.prototype.open = /**
     * @return {?}
     */
    function () {
        if (this.dropdown) {
            this.dropdown.open();
        }
    };
    /**
     * @return {?}
     */
    BreadcrumbComponent.prototype.hasPreviousNodes = /**
     * @return {?}
     */
    function () {
        return this.previousNodes ? true : false;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    BreadcrumbComponent.prototype.parseRoute = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (node && node.path) {
            /** @type {?} */
            var route = (/** @type {?} */ ((node.path.elements || []).slice()));
            route.push((/** @type {?} */ ({
                id: node.id,
                name: node.name,
                node: node
            })));
            /** @type {?} */
            var rootPos = this.getElementPosition(route, this.rootId);
            if (rootPos > 0) {
                route.splice(0, rootPos);
            }
            if (rootPos === -1 && this.rootId) {
                route[0].id = this.rootId;
            }
            if (this.root) {
                route[0].name = this.root;
            }
            return route;
        }
        return [];
    };
    /**
     * @private
     * @param {?} route
     * @param {?} nodeId
     * @return {?}
     */
    BreadcrumbComponent.prototype.getElementPosition = /**
     * @private
     * @param {?} route
     * @param {?} nodeId
     * @return {?}
     */
    function (route, nodeId) {
        /** @type {?} */
        var position = -1;
        if (route && route.length > 0 && nodeId) {
            position = route.findIndex((/**
             * @param {?} el
             * @return {?}
             */
            function (el) { return el.id === nodeId; }));
        }
        return position;
    };
    /**
     * @param {?} route
     * @param {?=} event
     * @return {?}
     */
    BreadcrumbComponent.prototype.onRoutePathClick = /**
     * @param {?} route
     * @param {?=} event
     * @return {?}
     */
    function (route, event) {
        if (event) {
            event.preventDefault();
        }
        if (route) {
            this.navigate.emit(route);
            if (this.target) {
                this.target.navigateTo(route.id);
            }
        }
    };
    BreadcrumbComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-breadcrumb',
                    template: "<nav *ngIf=\"folderNode\" data-automation-id=\"breadcrumb\" class=\"adf-breadcrumb-container\" role=\"list\">\n    <button\n        *ngIf=\"hasPreviousNodes()\"\n        tabindex=\"0\"\n        class=\"adf-breadcrumb-dropdown-trigger\"\n        (click)=\"open()\">\n        <div class=\"adf-breadcrumb-dropdown-trigger-icon\">\n            <mat-icon [class.adf-isRoot]=\"!hasPreviousNodes()\">folder</mat-icon>\n            <mat-icon [class.adf-isRoot]=\"!hasPreviousNodes()\" class=\"adf-breadcrumb-dropdown-trigger-arrow\">arrow_drop_down</mat-icon>\n        </div>\n    </button>\n\n    <mat-select\n        #dropdown\n        *ngIf=\"hasPreviousNodes()\"\n        class=\"adf-breadcrumb-dropdown-path\"\n        tabindex=\"0\">\n\n        <mat-option\n            *ngFor=\"let node of previousNodes;\"\n            (click)=\"onRoutePathClick(node, $event)\"\n            class=\"adf-breadcrumb-path-option\"\n            tabindex=\"0\">\n            {{ node.name | translate }}\n        </mat-option>\n    </mat-select>\n\n    <div *ngFor=\"let item of lastNodes; let last = last\"\n        [class.adf-active]=\"last\"\n        [ngSwitch]=\"last\"\n        title=\"{{ item.name | translate }}\"\n        class=\"adf-breadcrumb-item\"\n        role=\"listitem\">\n\n        <a *ngSwitchDefault href=\"#\" [attr.data-automation-id]=\"'breadcrumb_' + item.name\"\n            class=\"adf-breadcrumb-item-anchor\"\n            (click)=\"onRoutePathClick(item, $event)\">\n            {{ item.name | translate }}\n        </a>\n\n        <div *ngSwitchCase=\"true\" class=\"adf-breadcrumb-item-current\">\n            {{ item.name | translate }}\n        </div>\n\n        <mat-icon class=\"adf-breadcrumb-item-chevron\" *ngIf=\"!last\">\n            chevron_right\n        </mat-icon>\n    </div>\n</nav>\n\n<nav *ngIf=\"!folderNode && hasRoot\" data-automation-id=\"breadcrumb\" role=\"navigation\">\n    <div class=\"adf-breadcrumb-item adf-active\" role=\"listitem\">\n        <div class=\"adf-breadcrumb-item-current\">\n            {{ root | translate }}\n        </div>\n    </div>\n</nav>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        'class': 'adf-breadcrumb'
                    },
                    styles: [""]
                }] }
    ];
    BreadcrumbComponent.propDecorators = {
        folderNode: [{ type: Input }],
        root: [{ type: Input }],
        rootId: [{ type: Input }],
        target: [{ type: Input }],
        transform: [{ type: Input }],
        dropdown: [{ type: ViewChild, args: ['dropdown',] }],
        maxItems: [{ type: Input }],
        navigate: [{ type: Output }]
    };
    return BreadcrumbComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DropdownBreadcrumbComponent = /** @class */ (function (_super) {
    __extends(DropdownBreadcrumbComponent, _super);
    function DropdownBreadcrumbComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Calculate the current and previous nodes from the route array
     */
    /**
     * Calculate the current and previous nodes from the route array
     * @protected
     * @return {?}
     */
    DropdownBreadcrumbComponent.prototype.recalculateNodes = /**
     * Calculate the current and previous nodes from the route array
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var node = this.transform ? this.transform(this.folderNode) : this.folderNode;
        this.route = this.parseRoute(node);
        this.currentNode = this.route[this.route.length - 1];
        this.previousNodes = this.route.slice(0, this.route.length - 1).reverse();
    };
    /**
     * Opens the node picker menu
     */
    /**
     * Opens the node picker menu
     * @return {?}
     */
    DropdownBreadcrumbComponent.prototype.open = /**
     * Opens the node picker menu
     * @return {?}
     */
    function () {
        if (this.dropdown) {
            this.dropdown.open();
        }
    };
    /**
     * Return if route has more than one element (means: we are not in the root directory)
     */
    /**
     * Return if route has more than one element (means: we are not in the root directory)
     * @return {?}
     */
    DropdownBreadcrumbComponent.prototype.hasPreviousNodes = /**
     * Return if route has more than one element (means: we are not in the root directory)
     * @return {?}
     */
    function () {
        return this.previousNodes.length > 0;
    };
    DropdownBreadcrumbComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-dropdown-breadcrumb',
                    template: "<ng-container *ngIf=\"route.length > 0\" class=\"adf-dropdown-breadcrumb-container\">\n\n    <button\n        tabindex=\"0\"\n        class=\"adf-dropdown-breadcrumb-trigger\"\n        (click)=\"open()\"\n        data-automation-id=\"dropdown-breadcrumb-trigger\">\n        <mat-icon [class.adf-isRoot]=\"!hasPreviousNodes()\">folder</mat-icon>\n    </button>\n\n    <mat-icon class=\"adf-dropdown-breadcrumb-item-chevron\">chevron_right</mat-icon>\n\n    <div class=\"adf-dropdown-breadcrumb-path\">\n        <mat-select\n            #dropdown\n            *ngIf=\"hasPreviousNodes()\"\n            tabindex=\"0\"\n            data-automation-id=\"dropdown-breadcrumb-path\">\n\n            <mat-option\n                *ngFor=\"let node of previousNodes;\"\n                (click)=\"onRoutePathClick(node, $event)\"\n                class=\"adf-dropdown-breadcrumb-path-option\"\n                tabindex=\"0\"\n                data-automation-class=\"dropdown-breadcrumb-path-option\">\n                {{ node.name | translate }}\n            </mat-option>\n        </mat-select>\n    </div>\n\n    <span\n        class=\"adf-current-folder\"\n        [class.adf-isRoot]=\"!hasPreviousNodes()\"\n        data-automation-id=\"current-folder\">{{ currentNode.name }}\n    </span>\n</ng-container>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        'class': 'adf-dropdown-breadcrumb'
                    },
                    styles: [""]
                }] }
    ];
    DropdownBreadcrumbComponent.propDecorators = {
        dropdown: [{ type: ViewChild, args: ['dropdown',] }]
    };
    return DropdownBreadcrumbComponent;
}(BreadcrumbComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BreadcrumbModule = /** @class */ (function () {
    function BreadcrumbModule() {
    }
    BreadcrumbModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule,
                        CoreModule.forChild()
                    ],
                    exports: [
                        BreadcrumbComponent,
                        DropdownBreadcrumbComponent
                    ],
                    declarations: [
                        BreadcrumbComponent,
                        DropdownBreadcrumbComponent
                    ]
                },] }
    ];
    return BreadcrumbModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ConfirmDialogComponent = /** @class */ (function () {
    function ConfirmDialogComponent(data, sanitizer) {
        this.sanitizer = sanitizer;
        data = data || {};
        this.title = data.title || 'ADF_CONFIRM_DIALOG.CONFIRM';
        this.message = data.message || 'ADF_CONFIRM_DIALOG.MESSAGE';
        this.yesLabel = data.yesLabel || 'ADF_CONFIRM_DIALOG.YES_LABEL';
        this.thirdOptionLabel = data.thirdOptionLabel;
        this.noLabel = data.noLabel || 'ADF_CONFIRM_DIALOG.NO_LABEL';
        this.htmlContent = data.htmlContent;
    }
    /**
     * @return {?}
     */
    ConfirmDialogComponent.prototype.sanitizedHtmlContent = /**
     * @return {?}
     */
    function () {
        return this.sanitizer.sanitize(SecurityContext.HTML, this.htmlContent);
    };
    ConfirmDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-confirm-dialog',
                    template: "<h1 mat-dialog-title data-automation-id=\"adf-confirm-dialog-title\">{{ title | translate }}</h1>\n<mat-dialog-content>\n    <p *ngIf=\"!htmlContent; else cutomContent\" data-automation-id=\"adf-confirm-dialog-base-message\">\n        {{ message | translate }}\n    </p>\n    <ng-template #cutomContent>\n        <span [innerHTML]=\"sanitizedHtmlContent()\" data-automation-id=\"adf-confirm-dialog-custom-content\">\n        </span>\n    </ng-template>\n</mat-dialog-content>\n<mat-dialog-actions>\n    <span class=\"adf-dialog-spacer\" data-automation-id=\"adf-confirm-dialog-spacer\"></span>\n    <button id=\"adf-confirm-accept\" mat-button color=\"primary\" data-automation-id=\"adf-confirm-dialog-confirmation\"\n        [mat-dialog-close]=\"true\">{{ yesLabel | translate }}</button>\n    <button id=\"adf-confirm-all\" mat-button *ngIf=\"thirdOptionLabel\" [mat-dialog-close]=\"thirdOptionLabel\" data-automation-id=\"adf-confirm-dialog-confirm-all\">{{ thirdOptionLabel | translate }}</button>\n    <button id=\"adf-confirm-cancel\" mat-button [mat-dialog-close]=\"false\" data-automation-id=\"adf-confirm-dialog-reject\"\n        cdkFocusInitial>{{ noLabel | translate }}</button>\n</mat-dialog-actions>\n",
                    host: { 'class': 'adf-confirm-dialog' },
                    encapsulation: ViewEncapsulation.None,
                    styles: [".adf-dialog-spacer{flex:1 1 auto}.adf-confirm-dialog .mat-dialog-actions .mat-button-wrapper{text-transform:uppercase}"]
                }] }
    ];
    /** @nocollapse */
    ConfirmDialogComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
        { type: DomSanitizer }
    ]; };
    return ConfirmDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VersionListComponent = /** @class */ (function () {
    function VersionListComponent(alfrescoApi, contentService, dialog) {
        this.alfrescoApi = alfrescoApi;
        this.contentService = contentService;
        this.dialog = dialog;
        this.versions = [];
        this.isLoading = true;
        /**
         * Toggles showing/hiding of comments
         */
        this.showComments = true;
        /**
         * Enable/disable downloading a version of the current node.
         */
        this.allowDownload = true;
        /**
         * Toggles showing/hiding of version actions
         */
        this.showActions = true;
        /**
         * Emitted when a version is restored
         */
        this.restored = new EventEmitter();
        /**
         * Emitted when a version is deleted
         */
        this.deleted = new EventEmitter();
        this.versionsApi = this.alfrescoApi.versionsApi;
    }
    /**
     * @return {?}
     */
    VersionListComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this.loadVersionHistory();
    };
    /**
     * @return {?}
     */
    VersionListComponent.prototype.canUpdate = /**
     * @return {?}
     */
    function () {
        return this.contentService.hasAllowableOperations(this.node, 'update') && this.versions.length > 1;
    };
    /**
     * @return {?}
     */
    VersionListComponent.prototype.canDelete = /**
     * @return {?}
     */
    function () {
        return this.contentService.hasAllowableOperations(this.node, 'delete') && this.versions.length > 1;
    };
    /**
     * @param {?} versionId
     * @return {?}
     */
    VersionListComponent.prototype.restore = /**
     * @param {?} versionId
     * @return {?}
     */
    function (versionId) {
        var _this = this;
        if (this.canUpdate()) {
            this.versionsApi
                .revertVersion(this.node.id, versionId, { majorVersion: true, comment: '' })
                .then((/**
             * @return {?}
             */
            function () {
                return _this.alfrescoApi.nodesApi.getNodeInfo(_this.node.id, { include: ['permissions', 'path', 'isFavorite', 'allowableOperations'] });
            }))
                .then((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return _this.onVersionRestored(node); }));
        }
    };
    /**
     * @return {?}
     */
    VersionListComponent.prototype.loadVersionHistory = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.isLoading = true;
        this.versionsApi.listVersionHistory(this.node.id).then((/**
         * @param {?} versionPaging
         * @return {?}
         */
        function (versionPaging) {
            _this.versions = versionPaging.list.entries;
            _this.isLoading = false;
        }));
    };
    /**
     * @param {?} versionId
     * @return {?}
     */
    VersionListComponent.prototype.downloadVersion = /**
     * @param {?} versionId
     * @return {?}
     */
    function (versionId) {
        if (this.allowDownload) {
            /** @type {?} */
            var versionDownloadUrl = this.getVersionContentUrl(this.node.id, versionId, true);
            this.downloadContent(versionDownloadUrl);
        }
    };
    /**
     * @param {?} versionId
     * @return {?}
     */
    VersionListComponent.prototype.deleteVersion = /**
     * @param {?} versionId
     * @return {?}
     */
    function (versionId) {
        var _this = this;
        if (this.canUpdate()) {
            /** @type {?} */
            var dialogRef = this.dialog.open(ConfirmDialogComponent, {
                data: {
                    title: 'ADF_VERSION_LIST.CONFIRM_DELETE.TITLE',
                    message: 'ADF_VERSION_LIST.CONFIRM_DELETE.MESSAGE',
                    yesLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.YES_LABEL',
                    noLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.NO_LABEL'
                },
                minWidth: '250px'
            });
            dialogRef.afterClosed().subscribe((/**
             * @param {?} result
             * @return {?}
             */
            function (result) {
                if (result === true) {
                    _this.alfrescoApi.versionsApi
                        .deleteVersion(_this.node.id, versionId)
                        .then((/**
                     * @return {?}
                     */
                    function () { return _this.onVersionDeleted(_this.node); }));
                }
            }));
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    VersionListComponent.prototype.onVersionDeleted = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.loadVersionHistory();
        this.deleted.emit(node);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    VersionListComponent.prototype.onVersionRestored = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.loadVersionHistory();
        this.restored.emit(node);
    };
    /**
     * @private
     * @param {?} nodeId
     * @param {?} versionId
     * @param {?=} attachment
     * @return {?}
     */
    VersionListComponent.prototype.getVersionContentUrl = /**
     * @private
     * @param {?} nodeId
     * @param {?} versionId
     * @param {?=} attachment
     * @return {?}
     */
    function (nodeId, versionId, attachment) {
        /** @type {?} */
        var nodeDownloadUrl = this.alfrescoApi.contentApi.getContentUrl(nodeId, attachment);
        return nodeDownloadUrl.replace('/content', '/versions/' + versionId + '/content');
    };
    /**
     * @param {?} url
     * @return {?}
     */
    VersionListComponent.prototype.downloadContent = /**
     * @param {?} url
     * @return {?}
     */
    function (url) {
        if (url) {
            /** @type {?} */
            var link = document.createElement('a');
            link.style.display = 'none';
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };
    VersionListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-version-list',
                    template: "<mat-list class=\"adf-version-list\" *ngIf=\"!isLoading; else loading_template\">\n    <mat-list-item *ngFor=\"let version of versions; let idx = index\">\n        <mat-icon mat-list-icon>insert_drive_file</mat-icon>\n        <h4 mat-line class=\"adf-version-list-item-name\" [id]=\"'adf-version-list-item-name-' + version.entry.id\" >{{version.entry.name}}</h4>\n        <p mat-line>\n            <span class=\"adf-version-list-item-version\"  [id]=\"'adf-version-list-item-version-' + version.entry.id\" >{{version.entry.id}}</span> -\n            <span class=\"adf-version-list-item-date\"     [id]=\"'adf-version-list-item-date-' + version.entry.id\" >{{version.entry.modifiedAt | date}}</span>\n        </p>\n        <p mat-line [id]=\"'adf-version-list-item-comment-'+ version.entry.id\" class=\"adf-version-list-item-comment\"\n           *ngIf=\"showComments\">{{version.entry.versionComment}}</p>\n\n        <div *ngIf=\"showActions\">\n            <mat-menu [id]=\"'adf-version-list-action-menu-'+version.entry.id\"\n                      #versionMenu=\"matMenu\" yPosition=\"below\" xPosition=\"before\">\n                <button\n                    [id]=\"'adf-version-list-action-restore-'+version.entry.id\"\n                    [disabled]=\"!canUpdate()\"\n                    mat-menu-item\n                    (click)=\"restore(version.entry.id)\">\n                    {{ 'ADF_VERSION_LIST.ACTIONS.RESTORE' | translate }}\n                </button>\n                <button *ngIf=\"allowDownload\"\n                        [id]=\"'adf-version-list-action-download-'+version.entry.id\"\n                        mat-menu-item\n                        (click)=\"downloadVersion(version.entry.id)\">\n                    {{ 'ADF_VERSION_LIST.ACTIONS.DOWNLOAD' | translate }}\n                </button>\n                <button\n                    [disabled]=\"!canDelete()\"\n                    [id]=\"'adf-version-list-action-delete-'+version.entry.id\"\n                    (click)=\"deleteVersion(version.entry.id)\"\n                    mat-menu-item>\n                    {{ 'ADF_VERSION_LIST.ACTIONS.DELETE' | translate }}\n                </button>\n            </mat-menu>\n\n            <button mat-icon-button [matMenuTriggerFor]=\"versionMenu\" [id]=\"'adf-version-list-action-menu-button-'+version.entry.id\">\n                <mat-icon>more_vert</mat-icon>\n            </button>\n        </div>\n    </mat-list-item>\n</mat-list>\n\n<ng-template #loading_template>\n    <mat-progress-bar data-automation-id=\"version-history-loading-bar\" mode=\"indeterminate\"\n                      color=\"accent\"></mat-progress-bar>\n</ng-template>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        'class': 'adf-version-list'
                    },
                    styles: [".adf-version-list .mat-list-item-content{border-bottom:1px solid #d8d8d8}.adf-version-list-item-version{font-weight:700}.adf-version-list-item-date{opacity:.6}.adf-version-list-item-comment{opacity:.5}"]
                }] }
    ];
    /** @nocollapse */
    VersionListComponent.ctorParameters = function () { return [
        { type: AlfrescoApiService },
        { type: ContentService },
        { type: MatDialog }
    ]; };
    VersionListComponent.propDecorators = {
        node: [{ type: Input }],
        showComments: [{ type: Input }],
        allowDownload: [{ type: Input }],
        showActions: [{ type: Input }],
        restored: [{ type: Output }],
        deleted: [{ type: Output }]
    };
    return VersionListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VersionManagerComponent = /** @class */ (function () {
    function VersionManagerComponent(config, contentService, alfrescoApiService) {
        this.contentService = contentService;
        this.alfrescoApiService = alfrescoApiService;
        /**
         * Toggles showing/hiding of comments.
         */
        this.showComments = true;
        /**
         * Enable/disable downloading a version of the current node.
         */
        this.allowDownload = true;
        /**
         * Emitted when a file is uploaded successfully.
         */
        this.uploadSuccess = new EventEmitter();
        /**
         * Emitted when an error occurs during upload.
         */
        this.uploadError = new EventEmitter();
        this.uploadState = 'close';
    }
    /**
     * @param {?} node
     * @return {?}
     */
    VersionManagerComponent.prototype.refresh = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.alfrescoApiService.nodeUpdated.next(node);
        this.versionListComponent.loadVersionHistory();
        this.uploadSuccess.emit(node);
        this.uploadState = 'close';
    };
    /**
     * @param {?} event
     * @return {?}
     */
    VersionManagerComponent.prototype.onUploadSuccess = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.alfrescoApiService.nodeUpdated.next(event.value.entry);
        this.versionListComponent.loadVersionHistory();
        this.uploadSuccess.emit(event.value.entry);
        this.uploadState = 'close';
    };
    /**
     * @param {?} event
     * @return {?}
     */
    VersionManagerComponent.prototype.onUploadError = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.uploadError.emit(event);
    };
    /**
     * @return {?}
     */
    VersionManagerComponent.prototype.onUploadCancel = /**
     * @return {?}
     */
    function () {
        this.uploadState = 'close';
    };
    /**
     * @return {?}
     */
    VersionManagerComponent.prototype.toggleNewVersion = /**
     * @return {?}
     */
    function () {
        this.uploadState = this.uploadState === 'open' ? 'close' : 'open';
    };
    /**
     * @return {?}
     */
    VersionManagerComponent.prototype.canUpdate = /**
     * @return {?}
     */
    function () {
        return this.contentService.hasAllowableOperations(this.node, 'update');
    };
    VersionManagerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-version-manager',
                    template: "<div class=\"adf-new-version-container\">\n    <div class=\"adf-new-version-uploader-container\" id=\"adf-new-version-uploader-container\" fxLayout=\"row\" fxLayoutAlign=\"end center\" [@uploadToggle]=\"uploadState\">\n        <table class=\"adf-version-upload\" *ngIf=\"uploadState !== 'close'\">\n            <tr>\n                <td>\n                    <adf-version-upload\n                        id=\"adf-version-upload-button\"\n                        [node]=\"node\"\n                        (success)=\"onUploadSuccess($event)\"\n                        (cancel)=\"onUploadCancel()\"\n                        (error)=\"onUploadError($event)\">\n                    </adf-version-upload>\n                </td>\n            </tr>\n        </table>\n    </div>\n\n    <div class=\"adf-version-list-container\">\n        <div class=\"adf-version-list-table\">\n            <div>\n                <button mat-raised-button\n                        id=\"adf-show-version-upload-button\"\n                        (click)=\"toggleNewVersion()\" color=\"primary\"\n                        *ngIf=\"uploadState ==='close'\">{{\n                    'ADF_VERSION_LIST.ACTIONS.UPLOAD.ADD'|\n                    translate }}\n                </button>\n            </div>\n            <div>\n\n                <adf-version-list\n                    #versionList\n                    [node]=\"node\"\n                    [allowDownload]=\"allowDownload\"\n                    [showComments]=\"showComments\"\n                    (deleted)=\"refresh($event)\"\n                    (restored)=\"refresh($event)\">\n                </adf-version-list>\n            </div>\n        </div>\n    </div>\n</div>\n",
                    animations: [
                        trigger('uploadToggle', [
                            state('open', style({ height: '175px', opacity: 1, visibility: 'visible' })),
                            state('close', style({ height: '0%', opacity: 0, visibility: 'hidden' })),
                            transition('open => close', [
                                style({ visibility: 'hidden' }),
                                animate('0.4s cubic-bezier(0.25, 0.8, 0.25, 1)')
                            ]),
                            transition('close => open', [
                                style({ visibility: 'visible' }),
                                animate('0.4s cubic-bezier(0.25, 0.8, 0.25, 1)')
                            ])
                        ])
                    ],
                    encapsulation: ViewEncapsulation.None,
                    styles: ["adf-version-manager .mat-list .mat-3-line{height:auto!important;width:100%!important}adf-version-manager .mat-list-item-content{padding:16px 0!important}.adf-version-list-item-comment.mat-line{height:100%;word-break:break-all;white-space:unset!important;overflow:unset!important}.adf-button.adf-upload-new-version{box-shadow:none;width:100%;height:175px;float:left;position:relative}.adf-new-version-uploader-container{padding:16px 0;width:100%;height:0%;position:relative;float:left!important}.adf-new-version-container{height:inherit;overflow:hidden}.adf-version-list-table,.adf-version-upload-table{width:100%}.adf-version-list{width:100%!important;float:left!important}"]
                }] }
    ];
    /** @nocollapse */
    VersionManagerComponent.ctorParameters = function () { return [
        { type: AppConfigService },
        { type: ContentService },
        { type: AlfrescoApiService }
    ]; };
    VersionManagerComponent.propDecorators = {
        node: [{ type: Input }],
        showComments: [{ type: Input }],
        allowDownload: [{ type: Input }],
        uploadSuccess: [{ type: Output }],
        uploadError: [{ type: Output }],
        versionListComponent: [{ type: ViewChild, args: ['versionList',] }]
    };
    return VersionManagerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VersionUploadComponent = /** @class */ (function () {
    function VersionUploadComponent(contentService) {
        this.contentService = contentService;
        this.semanticVersion = 'minor';
        this.uploadVersion = false;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.cancel = new EventEmitter();
    }
    /**
     * @return {?}
     */
    VersionUploadComponent.prototype.canUpload = /**
     * @return {?}
     */
    function () {
        return this.contentService.hasAllowableOperations(this.node, 'update');
    };
    /**
     * @return {?}
     */
    VersionUploadComponent.prototype.isMajorVersion = /**
     * @return {?}
     */
    function () {
        return this.semanticVersion === 'minor' ? false : true;
    };
    /**
     * @return {?}
     */
    VersionUploadComponent.prototype.cancelUpload = /**
     * @return {?}
     */
    function () {
        this.cancel.emit();
    };
    VersionUploadComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-version-upload',
                    template: "<div class=\"adf-new-version-max-width\">\n    <mat-radio-group class=\"adf-new-version-radio-group\" [(ngModel)]=\"semanticVersion\">\n        <mat-radio-button class=\"adf-new-version-radio-button\" id=\"adf-new-version-minor\"[value]=\"'minor'\">{{\n            'ADF_VERSION_LIST.ACTIONS.UPLOAD.MINOR' |\n            translate }}\n        </mat-radio-button>\n        <mat-radio-button class=\"adf-new-version-radio-button\" id=\"adf-new-version-major\" [value]=\"'major'\">{{\n            'ADF_VERSION_LIST.ACTIONS.UPLOAD.MAJOR' |\n            translate }}\n        </mat-radio-button>\n    </mat-radio-group>\n    <mat-form-field class=\"adf-new-version-max-width\">\n                    <textarea matInput [(ngModel)]=\"comment\" class=\"adf-new-version-text-area\" id=\"adf-new-version-text-area\"\n                              placeholder=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.COMMENT' | translate }}\"></textarea>\n    </mat-form-field>\n\n</div>\n<div class=\"adf-version-upload-buttons\">\n    <adf-upload-version-button\n        data-automation-id=\"adf-new-version-file-upload\"\n        staticTitle=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TITLE' | translate }}\"\n        [node]=\"node\"\n        [disabled]=\"!canUpload()\"\n        [rootFolderId]=\"node.parentId\"\n        tooltip=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TOOLTIP' | translate }}\"\n        [comment]=\"comment\"\n        [versioning]=\"true\"\n        [majorVersion]=\"isMajorVersion()\"\n        (success)=\"success.emit($event)\"\n        (error)=\"error.emit($event)\">\n    </adf-upload-version-button>\n    <button mat-raised-button (click)=\"cancelUpload()\" id=\"adf-new-version-cancel\"  >{{\n        'ADF_VERSION_LIST.ACTIONS.UPLOAD.CANCEL'| translate }}\n    </button>\n</div>\n\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { 'class': 'adf-version-upload' },
                    styles: [".adf-new-version-radio-group{display:inline-flex;flex-direction:column}.adf-new-version-radio-button{margin:5px}.adf-version-upload-buttons{display:flex;float:right;justify-content:space-between;width:100%}.adf-new-version-max-width{width:100%;float:right}.adf-new-version-text-area{resize:none!important}"]
                }] }
    ];
    /** @nocollapse */
    VersionUploadComponent.ctorParameters = function () { return [
        { type: ContentService }
    ]; };
    VersionUploadComponent.propDecorators = {
        node: [{ type: Input }],
        success: [{ type: Output }],
        error: [{ type: Output }],
        cancel: [{ type: Output }]
    };
    return VersionUploadComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VersionManagerModule = /** @class */ (function () {
    function VersionManagerModule() {
    }
    VersionManagerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule,
                        CoreModule.forChild(),
                        UploadModule,
                        FormsModule
                    ],
                    exports: [
                        VersionUploadComponent,
                        VersionManagerComponent,
                        VersionListComponent,
                        FormsModule
                    ],
                    declarations: [
                        VersionUploadComponent,
                        VersionManagerComponent,
                        VersionListComponent
                    ]
                },] }
    ];
    return VersionManagerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NameLocationCellComponent = /** @class */ (function () {
    function NameLocationCellComponent() {
        this.name = '';
        this.path = '';
    }
    /**
     * @return {?}
     */
    NameLocationCellComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.row) {
            this.name = this.row.getValue('name');
            /** @type {?} */
            var fullPath = this.row.getValue('path');
            if (fullPath) {
                this.path = fullPath.name || '';
            }
        }
    };
    NameLocationCellComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-name-location-cell',
                    template: "\n        <div class=\"adf-name-location-cell-name adf-datatable-cell-value\">{{ name }}</div>\n        <div class=\"adf-name-location-cell-location adf-datatable-cell-value\" [title]=\"path\">{{ path }}</div>\n    ",
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: { class: 'adf-name-location-cell adf-datatable-content-cell' },
                    styles: [""]
                }] }
    ];
    NameLocationCellComponent.propDecorators = {
        row: [{ type: Input }]
    };
    return NameLocationCellComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal service used by ContentNodeSelector component.
 */
var ContentNodeSelectorService = /** @class */ (function () {
    function ContentNodeSelectorService(searchService) {
        this.searchService = searchService;
    }
    /**
     * Performs a search for content node selection
     *
     * @param searchTerm    The term to search for
     * @param rootNodeId    The root is to start the search from
     * @param skipCount     From where to start the loading
     * @param maxItems      How many items to load
     * @param [extraNodeIds]  List of extra node ids to search from. This last parameter is necessary when
     * the rootNodeId is one of the supported aliases (e.g. '-my-', '-root-', '-mysites-', etc.)
     * and search is not supported for that alias, but can be performed on its corresponding nodes.
     */
    /**
     * Performs a search for content node selection
     *
     * @param {?} searchTerm    The term to search for
     * @param {?=} rootNodeId    The root is to start the search from
     * @param {?=} skipCount     From where to start the loading
     * @param {?=} maxItems      How many items to load
     * @param {?=} extraNodeIds
     * @return {?}
     */
    ContentNodeSelectorService.prototype.search = /**
     * Performs a search for content node selection
     *
     * @param {?} searchTerm    The term to search for
     * @param {?=} rootNodeId    The root is to start the search from
     * @param {?=} skipCount     From where to start the loading
     * @param {?=} maxItems      How many items to load
     * @param {?=} extraNodeIds
     * @return {?}
     */
    function (searchTerm, rootNodeId, skipCount, maxItems, extraNodeIds) {
        if (rootNodeId === void 0) { rootNodeId = null; }
        if (skipCount === void 0) { skipCount = 0; }
        if (maxItems === void 0) { maxItems = 25; }
        /** @type {?} */
        var extraParentFiltering = '';
        if (extraNodeIds && extraNodeIds.length) {
            extraNodeIds
                .filter((/**
             * @param {?} id
             * @return {?}
             */
            function (id) { return id !== rootNodeId; }))
                .forEach((/**
             * @param {?} extraId
             * @return {?}
             */
            function (extraId) {
                extraParentFiltering += " OR ANCESTOR:'workspace://SpacesStore/" + extraId + "'";
            }));
        }
        /** @type {?} */
        var parentFiltering = rootNodeId ? [{ query: "ANCESTOR:'workspace://SpacesStore/" + rootNodeId + "'" + extraParentFiltering }] : [];
        /** @type {?} */
        var defaultSearchNode = {
            query: {
                query: searchTerm + "* OR name:" + searchTerm + "*"
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: maxItems,
                skipCount: skipCount
            },
            filterQueries: __spread([
                { query: "TYPE:'cm:folder'" },
                { query: 'NOT cm:creator:System' }
            ], parentFiltering),
            scope: {
                locations: ['nodes']
            }
        };
        return this.searchService.searchByQueryBody(defaultSearchNode);
    };
    ContentNodeSelectorService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ContentNodeSelectorService.ctorParameters = function () { return [
        { type: SearchService }
    ]; };
    /** @nocollapse */ ContentNodeSelectorService.ngInjectableDef = defineInjectable({ factory: function ContentNodeSelectorService_Factory() { return new ContentNodeSelectorService(inject(SearchService)); }, token: ContentNodeSelectorService, providedIn: "root" });
    return ContentNodeSelectorService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var defaultValidation = (/**
 * @return {?}
 */
function () { return true; });
var ContentNodeSelectorPanelComponent = /** @class */ (function () {
    function ContentNodeSelectorPanelComponent(contentNodeSelectorService, customResourcesService, userPreferencesService) {
        var _this = this;
        this.contentNodeSelectorService = contentNodeSelectorService;
        this.customResourcesService = customResourcesService;
        this.userPreferencesService = userPreferencesService;
        this.DEFAULT_PAGINATION = new Pagination({
            maxItems: 25,
            skipCount: 0,
            totalItems: 0,
            hasMoreItems: false
        });
        /**
         * Node ID of the folder currently listed.
         */
        this.currentFolderId = null;
        /**
         * Hide the "My Files" option added to the site list by default.
         * See the [Sites Dropdown component](sites-dropdown.component.md)
         * for more information.
         */
        this.dropdownHideMyFiles = false;
        /**
         * Custom site for site dropdown. This is the same as the `siteList`.
         * property of the Sites Dropdown component (see its doc page
         * for more information).
         */
        this.dropdownSiteList = null;
        this._rowFilter = defaultValidation;
        this._excludeSiteContent = [];
        /**
         * Custom image resolver function. See the
         * [Image Resolver Model](image-resolver.model.md) page
         * for more information.
         */
        this.imageResolver = null;
        /**
         * Number of items shown per page in the list.
         */
        this.pageSize = this.DEFAULT_PAGINATION.maxItems;
        /**
         * Function used to decide if the selected node has permission to be selected.
         * Default value is a function that always returns true.
         */
        this.isSelectionValid = defaultValidation;
        /**
         * Emitted when the user has chosen an item.
         */
        this.select = new EventEmitter();
        this.nodePaging = null;
        this.searchTerm = '';
        this.showingSearchResults = false;
        this.loadingSearchResults = false;
        this.inDialog = false;
        this._chosenNode = null;
        this.folderIdToShow = null;
        this.breadcrumbFolderTitle = null;
        this.pagination = this.DEFAULT_PAGINATION;
        this.infiniteScroll = false;
        this.debounceSearch = 200;
        this.searchInput = new FormControl();
        this.searchInput.valueChanges
            .pipe(debounceTime(this.debounceSearch))
            .subscribe((/**
         * @param {?} searchValue
         * @return {?}
         */
        function (searchValue) {
            _this.search(searchValue);
        }));
        this.userPreferencesService.select(UserPreferenceValues.PaginationSize).subscribe((/**
         * @param {?} pagSize
         * @return {?}
         */
        function (pagSize) {
            _this.pageSize = pagSize;
        }));
    }
    Object.defineProperty(ContentNodeSelectorPanelComponent.prototype, "rowFilter", {
        get: /**
         * @return {?}
         */
        function () {
            return this._rowFilter;
        },
        /**
         * Custom row filter function. See the
         * [Row Filter Model](row-filter.model.md) page
         * for more information.
         */
        set: /**
         * Custom row filter function. See the
         * [Row Filter Model](row-filter.model.md) page
         * for more information.
         * @param {?} rowFilter
         * @return {?}
         */
        function (rowFilter) {
            this.createRowFilter(rowFilter);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContentNodeSelectorPanelComponent.prototype, "excludeSiteContent", {
        get: /**
         * @return {?}
         */
        function () {
            return this._excludeSiteContent;
        },
        /** Custom list of site content componentIds.
         * Used to filter out the corresponding items from the displayed nodes
         */
        set: /**
         * Custom list of site content componentIds.
         * Used to filter out the corresponding items from the displayed nodes
         * @param {?} excludeSiteContent
         * @return {?}
         */
        function (excludeSiteContent) {
            this._excludeSiteContent = excludeSiteContent;
            this.createRowFilter(this._rowFilter);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContentNodeSelectorPanelComponent.prototype, "chosenNode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._chosenNode;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._chosenNode = value;
            /** @type {?} */
            var valuesArray = null;
            if (value) {
                valuesArray = [value];
            }
            this.select.next(valuesArray);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.target = this.documentList;
        this.folderIdToShow = this.currentFolderId;
        this.breadcrumbTransform = this.breadcrumbTransform ? this.breadcrumbTransform : null;
        this.isSelectionValid = this.isSelectionValid ? this.isSelectionValid : defaultValidation;
    };
    /**
     * @private
     * @param {?=} filter
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.createRowFilter = /**
     * @private
     * @param {?=} filter
     * @return {?}
     */
    function (filter$$1) {
        var _this = this;
        if (!filter$$1) {
            filter$$1 = (/**
             * @return {?}
             */
            function () { return true; });
        }
        this._rowFilter = (/**
         * @param {?} value
         * @param {?} index
         * @param {?} array
         * @return {?}
         */
        function (value, index, array) {
            return filter$$1(value, index, array) &&
                !_this.isExcludedSiteContent(value);
        });
    };
    /**
     * @private
     * @param {?} row
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.isExcludedSiteContent = /**
     * @private
     * @param {?} row
     * @return {?}
     */
    function (row) {
        /** @type {?} */
        var entry = row.node.entry;
        if (this._excludeSiteContent && this._excludeSiteContent.length &&
            entry &&
            entry.properties &&
            entry.properties['st:componentId']) {
            /** @type {?} */
            var excludedItem = this._excludeSiteContent.find((/**
             * @param {?} id
             * @return {?}
             */
            function (id) { return entry.properties['st:componentId'] === id; }));
            return !!excludedItem;
        }
        return false;
    };
    /**
     * Updates the site attribute and starts a new search
     *
     * @param chosenSite SiteEntry to search within
     */
    /**
     * Updates the site attribute and starts a new search
     *
     * @param {?} chosenSite SiteEntry to search within
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.siteChanged = /**
     * Updates the site attribute and starts a new search
     *
     * @param {?} chosenSite SiteEntry to search within
     * @return {?}
     */
    function (chosenSite) {
        this.siteId = chosenSite.entry.guid;
        this.setTitleIfCustomSite(chosenSite);
        this.updateResults();
    };
    /**
     * Updates the searchTerm attribute and starts a new search
     *
     * @param searchTerm string value to search against
     */
    /**
     * Updates the searchTerm attribute and starts a new search
     *
     * @param {?} searchTerm string value to search against
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.search = /**
     * Updates the searchTerm attribute and starts a new search
     *
     * @param {?} searchTerm string value to search against
     * @return {?}
     */
    function (searchTerm) {
        this.searchTerm = searchTerm;
        this.updateResults();
    };
    Object.defineProperty(ContentNodeSelectorPanelComponent.prototype, "breadcrumbFolderNode", {
        /**
         * Returns the actually selected|entered folder node or null in case of searching for the breadcrumb
         */
        get: /**
         * Returns the actually selected|entered folder node or null in case of searching for the breadcrumb
         * @return {?}
         */
        function () {
            /** @type {?} */
            var folderNode;
            if (this.showingSearchResults && this.chosenNode) {
                folderNode = this.chosenNode;
            }
            else {
                folderNode = this.documentList.folderNode;
            }
            return folderNode;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clear the search input and reset to last folder node in which search was performed
     */
    /**
     * Clear the search input and reset to last folder node in which search was performed
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.clear = /**
     * Clear the search input and reset to last folder node in which search was performed
     * @return {?}
     */
    function () {
        this.clearSearch();
        this.folderIdToShow = this.siteId || this.currentFolderId;
    };
    /**
     * Clear the search input and search related data
     */
    /**
     * Clear the search input and search related data
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.clearSearch = /**
     * Clear the search input and search related data
     * @return {?}
     */
    function () {
        this.searchTerm = '';
        this.nodePaging = null;
        this.pagination.maxItems = this.pageSize;
        this.chosenNode = null;
        this.showingSearchResults = false;
    };
    /**
     * Update the result list depending on the criteria
     */
    /**
     * Update the result list depending on the criteria
     * @private
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.updateResults = /**
     * Update the result list depending on the criteria
     * @private
     * @return {?}
     */
    function () {
        this.target = this.searchTerm.length > 0 ? null : this.documentList;
        if (this.searchTerm.length === 0) {
            this.clear();
        }
        else {
            this.startNewSearch();
        }
    };
    /**
     * Load the first page of a new search result
     */
    /**
     * Load the first page of a new search result
     * @private
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.startNewSearch = /**
     * Load the first page of a new search result
     * @private
     * @return {?}
     */
    function () {
        this.nodePaging = null;
        this.pagination.maxItems = this.pageSize;
        if (this.target) {
            this.infinitePaginationComponent.reset();
        }
        this.chosenNode = null;
        this.folderIdToShow = null;
        this.querySearch();
    };
    /**
     * Perform the call to searchService with the proper parameters
     */
    /**
     * Perform the call to searchService with the proper parameters
     * @private
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.querySearch = /**
     * Perform the call to searchService with the proper parameters
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.loadingSearchResults = true;
        if (this.customResourcesService.hasCorrespondingNodeIds(this.siteId)) {
            this.customResourcesService.getCorrespondingNodeIds(this.siteId)
                .subscribe((/**
             * @param {?} nodeIds
             * @return {?}
             */
            function (nodeIds) {
                _this.contentNodeSelectorService.search(_this.searchTerm, _this.siteId, _this.pagination.skipCount, _this.pagination.maxItems, nodeIds)
                    .subscribe(_this.showSearchResults.bind(_this));
            }), (/**
             * @return {?}
             */
            function () {
                _this.showSearchResults({ list: { entries: [] } });
            }));
        }
        else {
            this.contentNodeSelectorService.search(this.searchTerm, this.siteId, this.pagination.skipCount, this.pagination.maxItems)
                .subscribe(this.showSearchResults.bind(this));
        }
    };
    /**
     * Show the results of the search
     *
     * @param results Search results
     */
    /**
     * Show the results of the search
     *
     * @private
     * @param {?} nodePaging
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.showSearchResults = /**
     * Show the results of the search
     *
     * @private
     * @param {?} nodePaging
     * @return {?}
     */
    function (nodePaging) {
        this.showingSearchResults = true;
        this.loadingSearchResults = false;
        this.nodePaging = nodePaging;
    };
    /**
     * Sets showingSearchResults state to be able to differentiate between search results or folder results
     */
    /**
     * Sets showingSearchResults state to be able to differentiate between search results or folder results
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.onFolderChange = /**
     * Sets showingSearchResults state to be able to differentiate between search results or folder results
     * @return {?}
     */
    function () {
        this.showingSearchResults = false;
        this.infiniteScroll = false;
        this.clearSearch();
    };
    /**
     * Attempts to set the currently loaded node
     */
    /**
     * Attempts to set the currently loaded node
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.onFolderLoaded = /**
     * Attempts to set the currently loaded node
     * @return {?}
     */
    function () {
        if (!this.showingSearchResults) {
            this.attemptNodeSelection(this.documentList.folderNode);
        }
    };
    /**
     * Returns whether breadcrumb has to be shown or not
     */
    /**
     * Returns whether breadcrumb has to be shown or not
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.showBreadcrumbs = /**
     * Returns whether breadcrumb has to be shown or not
     * @return {?}
     */
    function () {
        return !this.showingSearchResults || this.chosenNode;
    };
    /**
     * Loads the next batch of search results
     *
     * @param event Pagination object
     */
    /**
     * Loads the next batch of search results
     *
     * @param {?} pagination
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.getNextPageOfSearch = /**
     * Loads the next batch of search results
     *
     * @param {?} pagination
     * @return {?}
     */
    function (pagination) {
        this.infiniteScroll = true;
        this.pagination = pagination;
        if (this.searchTerm.length > 0) {
            this.querySearch();
        }
    };
    /**
     * Selects node as chosen if it has the right permission, clears the selection otherwise
     *
     * @param entry
     */
    /**
     * Selects node as chosen if it has the right permission, clears the selection otherwise
     *
     * @private
     * @param {?} entry
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.attemptNodeSelection = /**
     * Selects node as chosen if it has the right permission, clears the selection otherwise
     *
     * @private
     * @param {?} entry
     * @return {?}
     */
    function (entry) {
        if (entry && this.isSelectionValid(entry)) {
            this.chosenNode = entry;
        }
        else {
            this.resetChosenNode();
        }
    };
    /**
     * Clears the chosen node
     */
    /**
     * Clears the chosen node
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.resetChosenNode = /**
     * Clears the chosen node
     * @return {?}
     */
    function () {
        this.chosenNode = null;
    };
    /**
     * Invoked when user selects a node
     *
     * @param event CustomEvent for node-select
     */
    /**
     * Invoked when user selects a node
     *
     * @param {?} event CustomEvent for node-select
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.onNodeSelect = /**
     * Invoked when user selects a node
     *
     * @param {?} event CustomEvent for node-select
     * @return {?}
     */
    function (event) {
        this.attemptNodeSelection(event.detail.node.entry);
    };
    /**
     * @param {?} site
     * @return {?}
     */
    ContentNodeSelectorPanelComponent.prototype.setTitleIfCustomSite = /**
     * @param {?} site
     * @return {?}
     */
    function (site) {
        if (this.customResourcesService.isCustomSource(site.entry.guid)) {
            this.breadcrumbFolderTitle = site.entry.title;
        }
        else {
            this.breadcrumbFolderTitle = null;
        }
    };
    ContentNodeSelectorPanelComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-content-node-selector-panel',
                    template: "<div class=\"adf-content-node-selector-content\" (node-select)=\"onNodeSelect($event)\">\n    <mat-form-field floatPlaceholder=\"never\" class=\"adf-content-node-selector-content-input\">\n        <input matInput\n            id=\"searchInput\"\n            [formControl]=\"searchInput\"\n            type=\"text\"\n            placeholder=\"{{'NODE_SELECTOR.SEARCH' | translate}}\"\n            [value]=\"searchTerm\"\n            data-automation-id=\"content-node-selector-search-input\">\n\n        <mat-icon *ngIf=\"searchTerm.length > 0\"\n            matSuffix (click)=\"clear()\"\n            class=\"adf-content-node-selector-content-input-icon\"\n            data-automation-id=\"content-node-selector-search-clear\">clear\n        </mat-icon>\n\n        <mat-icon *ngIf=\"searchTerm.length === 0\"\n            matSuffix\n            class=\"adf-content-node-selector-content-input-icon\"\n            data-automation-id=\"content-node-selector-search-icon\">search\n        </mat-icon>\n\n    </mat-form-field>\n\n    <adf-sites-dropdown\n        class=\"full-width\"\n        (change)=\"siteChanged($event)\"\n        [placeholder]=\"'NODE_SELECTOR.SELECT_LOCATION'\"\n        [hideMyFiles]=\"dropdownHideMyFiles\"\n        [siteList]=\"dropdownSiteList\"\n        data-automation-id=\"content-node-selector-sites-combo\">\n    </adf-sites-dropdown>\n\n    <adf-toolbar>\n        <adf-toolbar-title>\n            <ng-container *ngIf=\"!showBreadcrumbs()\">\n                <span class=\"adf-search-results-label\">{{ 'NODE_SELECTOR.SEARCH_RESULTS' | translate }}</span>\n            </ng-container>\n            <adf-dropdown-breadcrumb *ngIf=\"showBreadcrumbs()\"\n                class=\"adf-content-node-selector-content-breadcrumb\"\n                (navigate)=\"clearSearch()\"\n                [target]=\"documentList\"\n                [transform]=\"breadcrumbTransform\"\n                [folderNode]=\"breadcrumbFolderNode\"\n                [root]=\"breadcrumbFolderTitle\"\n                data-automation-id=\"content-node-selector-content-breadcrumb\">\n            </adf-dropdown-breadcrumb>\n        </adf-toolbar-title>\n    </adf-toolbar>\n\n    <div\n        class=\"adf-content-node-selector-content-list\"\n        [class.adf-content-node-selector-content-list-searchLayout]=\"showingSearchResults\"\n        data-automation-id=\"content-node-selector-content-list\">\n        <adf-document-list\n            #documentList\n            [adf-highlight]=\"searchTerm\"\n            adf-highlight-selector=\".adf-name-location-cell-name\"\n            [showHeader]=\"false\"\n            [node]=\"nodePaging\"\n            [maxItems]=\"pageSize\"\n            [rowFilter]=\"_rowFilter\"\n            [imageResolver]=\"imageResolver\"\n            [currentFolderId]=\"folderIdToShow\"\n            selectionMode=\"single\"\n            [contextMenuActions]=\"false\"\n            [contentActions]=\"false\"\n            [allowDropFiles]=\"false\"\n            [sorting]=\"'server'\"\n            [where]=\"where\"\n            (folderChange)=\"onFolderChange()\"\n            (ready)=\"onFolderLoaded()\"\n            data-automation-id=\"content-node-selector-document-list\">\n\n            <adf-custom-empty-content-template>\n                <div>{{ 'NODE_SELECTOR.NO_RESULTS' | translate }}</div>\n            </adf-custom-empty-content-template>\n\n            <data-columns>\n                <data-column key=\"$thumbnail\" type=\"image\"></data-column>\n                <data-column key=\"name\" type=\"text\" class=\"adf-full-width adf-ellipsis-cell\">\n                    <ng-template let-context>\n                        <adf-name-location-cell [row]=\"context.row\"></adf-name-location-cell>\n                    </ng-template>\n                </data-column>\n                <data-column key=\"modifiedAt\" type=\"date\" format=\"timeAgo\" class=\"adf-content-selector-modified-cell\"></data-column>\n                <data-column key=\"createdByUser.displayName\" type=\"text\" class=\"adf-content-selector-modifier-cell\"></data-column>\n                <data-column key=\"visibility\" type=\"text\" class=\"adf-content-selector-visibility-cell\"></data-column>\n            </data-columns>\n\n        </adf-document-list>\n\n        <adf-infinite-pagination\n            [target]=\"target\"\n            [loading]=\"loadingSearchResults\"\n            (loadMore)=\"getNextPageOfSearch($event)\"\n            data-automation-id=\"content-node-selector-search-pagination\">\n            {{ 'ADF-DOCUMENT-LIST.LAYOUT.LOAD_MORE' | translate }}\n        </adf-infinite-pagination>\n    </div>\n</div>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { 'class': 'adf-content-node-selector-panel' },
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    ContentNodeSelectorPanelComponent.ctorParameters = function () { return [
        { type: ContentNodeSelectorService },
        { type: CustomResourcesService },
        { type: UserPreferencesService }
    ]; };
    ContentNodeSelectorPanelComponent.propDecorators = {
        currentFolderId: [{ type: Input }],
        dropdownHideMyFiles: [{ type: Input }],
        dropdownSiteList: [{ type: Input }],
        where: [{ type: Input }],
        rowFilter: [{ type: Input }],
        excludeSiteContent: [{ type: Input }],
        imageResolver: [{ type: Input }],
        pageSize: [{ type: Input }],
        isSelectionValid: [{ type: Input }],
        breadcrumbTransform: [{ type: Input }],
        select: [{ type: Output }],
        documentList: [{ type: ViewChild, args: ['documentList',] }],
        highlighter: [{ type: ViewChild, args: [HighlightDirective,] }],
        infinitePaginationComponent: [{ type: ViewChild, args: [InfinitePaginationComponent,] }]
    };
    return ContentNodeSelectorPanelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentNodeSelectorModule = /** @class */ (function () {
    function ContentNodeSelectorModule() {
    }
    ContentNodeSelectorModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        FormsModule,
                        ReactiveFormsModule,
                        CoreModule.forChild(),
                        CommonModule,
                        MaterialModule,
                        SitesDropdownModule,
                        BreadcrumbModule,
                        DocumentListModule
                    ],
                    exports: [
                        ContentNodeSelectorPanelComponent,
                        NameLocationCellComponent,
                        ContentNodeSelectorComponent
                    ],
                    entryComponents: [
                        ContentNodeSelectorPanelComponent,
                        ContentNodeSelectorComponent
                    ],
                    declarations: [
                        ContentNodeSelectorPanelComponent,
                        NameLocationCellComponent,
                        ContentNodeSelectorComponent
                    ]
                },] }
    ];
    return ContentNodeSelectorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
var I18N_ERRORS_PATH = 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS';
/**
 * @param {?} __0
 * @return {?}
 */
function forbidSpecialCharacters(_a) {
    var value = _a.value;
    /** @type {?} */
    var specialCharacters = /([\*\"\<\>\\\/\?\:\|])/;
    /** @type {?} */
    var isValid = !specialCharacters.test(value);
    return (isValid) ? null : {
        message: I18N_ERRORS_PATH + ".SPECIAL_CHARACTERS"
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function forbidEndingDot(_a) {
    var value = _a.value;
    /** @type {?} */
    var isValid = ((value || '').trim().split('').pop() !== '.');
    return isValid ? null : {
        message: I18N_ERRORS_PATH + ".ENDING_DOT"
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function forbidOnlySpaces(_a) {
    var value = _a.value;
    /** @type {?} */
    var isValid = !!((value || '')).trim();
    return isValid ? null : {
        message: I18N_ERRORS_PATH + ".ONLY_SPACES"
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FolderDialogComponent = /** @class */ (function () {
    function FolderDialogComponent(formBuilder, dialog, nodesApi, translation, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.nodesApi = nodesApi;
        this.translation = translation;
        this.data = data;
        this.folder = null;
        /**
         * Emitted when the edit/create folder give error for example a folder with same name already exist
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the edit/create folder is successfully created/modified
         */
        this.success = new EventEmitter();
        this.editTitle = 'CORE.FOLDER_DIALOG.EDIT_FOLDER_TITLE';
        this.createTitle = 'CORE.FOLDER_DIALOG.CREATE_FOLDER_TITLE';
        this.nodeType = 'cm:folder';
        if (data) {
            this.editTitle = data.editTitle || this.editTitle;
            this.createTitle = data.createTitle || this.createTitle;
            this.nodeType = data.nodeType || this.nodeType;
        }
    }
    Object.defineProperty(FolderDialogComponent.prototype, "editing", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.data.folder;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FolderDialogComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var folder = this.data.folder;
        /** @type {?} */
        var name = '';
        /** @type {?} */
        var description = '';
        if (folder) {
            var properties = folder.properties;
            name = folder.name || '';
            description = properties ? properties['cm:description'] : '';
        }
        /** @type {?} */
        var validators = {
            name: [
                Validators.required,
                forbidSpecialCharacters,
                forbidEndingDot,
                forbidOnlySpaces
            ]
        };
        this.form = this.formBuilder.group({
            name: [name, validators.name],
            description: [description]
        });
    };
    Object.defineProperty(FolderDialogComponent.prototype, "name", {
        get: /**
         * @return {?}
         */
        function () {
            var name = this.form.value.name;
            return (name || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderDialogComponent.prototype, "description", {
        get: /**
         * @return {?}
         */
        function () {
            var description = this.form.value.description;
            return (description || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderDialogComponent.prototype, "properties", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            var _a = this, title = _a.name, description = _a.description;
            return {
                'cm:title': title,
                'cm:description': description
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    FolderDialogComponent.prototype.create = /**
     * @private
     * @return {?}
     */
    function () {
        var _a = this, name = _a.name, properties = _a.properties, nodeType = _a.nodeType, nodesApi = _a.nodesApi, parentNodeId = _a.data.parentNodeId;
        return nodesApi.createFolder(parentNodeId, { name: name, properties: properties, nodeType: nodeType });
    };
    /**
     * @private
     * @return {?}
     */
    FolderDialogComponent.prototype.edit = /**
     * @private
     * @return {?}
     */
    function () {
        var _a = this, name = _a.name, properties = _a.properties, nodesApi = _a.nodesApi, nodeId = _a.data.folder.id;
        return nodesApi.updateNode(nodeId, { name: name, properties: properties });
    };
    /**
     * @return {?}
     */
    FolderDialogComponent.prototype.submit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var _a = this, form = _a.form, dialog = _a.dialog, editing = _a.editing;
        if (!form.valid) {
            return;
        }
        (editing ? this.edit() : this.create())
            .subscribe((/**
         * @param {?} folder
         * @return {?}
         */
        function (folder) {
            _this.success.emit(folder);
            dialog.close(folder);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return _this.handleError(error); }));
    };
    /**
     * @param {?} error
     * @return {?}
     */
    FolderDialogComponent.prototype.handleError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        /** @type {?} */
        var errorMessage = 'CORE.MESSAGES.ERRORS.GENERIC';
        try {
            var statusCode = JSON.parse(error.message).error.statusCode;
            if (statusCode === 409) {
                errorMessage = 'CORE.MESSAGES.ERRORS.EXISTENT_FOLDER';
            }
        }
        catch (err) { /* Do nothing, keep the original message */ }
        this.error.emit(this.translation.instant(errorMessage));
        return error;
    };
    FolderDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-folder-dialog',
                    template: "<h2 mat-dialog-title>\n    {{ (editing ? editTitle : createTitle) | translate }}\n</h2>\n\n<mat-dialog-content>\n    <form [formGroup]=\"form\" (submit)=\"submit()\">\n        <mat-form-field class=\"adf-full-width\">\n            <input\n                id=\"adf-folder-name-input\"\n                placeholder=\"{{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.LABEL' | translate }}\"\n                matInput\n                required\n                [formControl]=\"form.controls['name']\"/>\n\n            <mat-hint *ngIf=\"form.controls['name'].dirty\">\n                <span *ngIf=\"form.controls['name'].errors?.required\">\n                    {{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS.REQUIRED' | translate }}\n                </span>\n\n                <span *ngIf=\"!form.controls['name'].errors?.required && form.controls['name'].errors?.message\">\n                    {{ form.controls['name'].errors?.message | translate }}\n                </span>\n            </mat-hint>\n        </mat-form-field>\n\n        <br />\n        <br />\n\n        <mat-form-field class=\"adf-full-width\">\n            <textarea\n                id=\"adf-folder-description-input\"\n                matInput\n                placeholder=\"{{ 'CORE.FOLDER_DIALOG.FOLDER_DESCRIPTION.LABEL' | translate }}\"\n                rows=\"4\"\n                [formControl]=\"form.controls['description']\"></textarea>\n        </mat-form-field>\n    </form>\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button\n        mat-button\n        id=\"adf-folder-cancel-button\"\n        mat-dialog-close>\n        {{ 'CORE.FOLDER_DIALOG.CANCEL_BUTTON.LABEL' | translate }}\n    </button>\n\n    <button class=\"adf-dialog-action-button\"\n            id=\"adf-folder-create-button\"\n            mat-button\n            (click)=\"submit()\"\n            [disabled]=\"!form.valid\">\n        {{\n        (editing\n        ? 'CORE.FOLDER_DIALOG.UPDATE_BUTTON.LABEL'\n        : 'CORE.FOLDER_DIALOG.CREATE_BUTTON.LABEL'\n        ) | translate\n        }}\n    </button>\n</mat-dialog-actions>\n",
                    styles: [".adf-fill-remaining-space{flex:1 1 auto}.adf-full-width,.adf-lock-file-name .mat-checkbox-layout{width:100%}.adf-lock-file-name .mat-checkbox-label{text-overflow:ellipsis;overflow:hidden}.adf-lock-file-name .mat-checkbox-inner-container{margin:auto 8px auto 0}"]
                }] }
    ];
    /** @nocollapse */
    FolderDialogComponent.ctorParameters = function () { return [
        { type: FormBuilder },
        { type: MatDialogRef },
        { type: NodesApiService },
        { type: TranslationService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] }] }
    ]; };
    FolderDialogComponent.propDecorators = {
        error: [{ type: Output }],
        success: [{ type: Output }]
    };
    return FolderDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LibraryDialogComponent = /** @class */ (function () {
    function LibraryDialogComponent(alfrescoApiService, formBuilder, dialog) {
        this.alfrescoApiService = alfrescoApiService;
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the new library is created successfully. The
         * event parameter is a SiteEntry object with the details of the
         * newly-created library.
         */
        this.success = new EventEmitter();
        this.onDestroy$ = new Subject();
        this.createTitle = 'LIBRARY.DIALOG.CREATE_TITLE';
        this.libraryTitleExists = false;
        this.visibilityOptions = [
            { value: 'PUBLIC', label: 'LIBRARY.VISIBILITY.PUBLIC', disabled: false },
            { value: 'PRIVATE', label: 'LIBRARY.VISIBILITY.PRIVATE', disabled: false },
            {
                value: 'MODERATED',
                label: 'LIBRARY.VISIBILITY.MODERATED',
                disabled: false
            }
        ];
    }
    /**
     * @return {?}
     */
    LibraryDialogComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var validators = {
            id: [
                Validators.required,
                Validators.maxLength(72),
                this.forbidSpecialCharacters
            ],
            title: [
                Validators.required,
                this.forbidOnlySpaces,
                Validators.minLength(2),
                Validators.maxLength(256)
            ],
            description: [Validators.maxLength(512)]
        };
        this.form = this.formBuilder.group({
            title: [null, validators.title],
            id: [null, validators.id, this.createSiteIdValidator()],
            description: ['', validators.description]
        });
        this.visibilityOption = this.visibilityOptions[0].value;
        this.form.controls['title'].valueChanges
            .pipe(debounceTime(300), mergeMap((/**
         * @param {?} title
         * @return {?}
         */
        function (title) { return _this.checkLibraryNameExists(title); }), (/**
         * @param {?} title
         * @return {?}
         */
        function (title) { return title; })), takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} title
         * @return {?}
         */
        function (title) {
            if (!_this.form.controls['id'].dirty && _this.canGenerateId(title)) {
                _this.form.patchValue({ id: _this.sanitize(title.trim()) });
                _this.form.controls['id'].markAsTouched();
            }
        }));
    };
    /**
     * @return {?}
     */
    LibraryDialogComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    };
    Object.defineProperty(LibraryDialogComponent.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            var title = this.form.value.title;
            return (title || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryDialogComponent.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            var id = this.form.value.id;
            return (id || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryDialogComponent.prototype, "description", {
        get: /**
         * @return {?}
         */
        function () {
            var description = this.form.value.description;
            return (description || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryDialogComponent.prototype, "visibility", {
        get: /**
         * @return {?}
         */
        function () {
            return this.visibilityOption || '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    LibraryDialogComponent.prototype.submit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var _a = this, form = _a.form, dialog = _a.dialog;
        if (!form.valid) {
            return;
        }
        this.create().subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            _this.success.emit(node);
            dialog.close(node);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return _this.handleError(error); }));
    };
    /**
     * @param {?} event
     * @return {?}
     */
    LibraryDialogComponent.prototype.visibilityChangeHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.visibilityOption = event.value;
    };
    /**
     * @private
     * @return {?}
     */
    LibraryDialogComponent.prototype.create = /**
     * @private
     * @return {?}
     */
    function () {
        var _a = this, title = _a.title, id = _a.id, description = _a.description, visibility = _a.visibility;
        /** @type {?} */
        var siteBody = (/** @type {?} */ ({
            id: id,
            title: title,
            description: description,
            visibility: visibility
        }));
        return from(this.alfrescoApiService.sitesApi.createSite(siteBody));
    };
    /**
     * @private
     * @param {?} input
     * @return {?}
     */
    LibraryDialogComponent.prototype.sanitize = /**
     * @private
     * @param {?} input
     * @return {?}
     */
    function (input) {
        return input.replace(/[\s\s]+/g, '-').replace(/[^A-Za-z0-9-]/g, '');
    };
    /**
     * @private
     * @param {?} title
     * @return {?}
     */
    LibraryDialogComponent.prototype.canGenerateId = /**
     * @private
     * @param {?} title
     * @return {?}
     */
    function (title) {
        return Boolean(title.replace(/[^A-Za-z0-9-]/g, '').length);
    };
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    LibraryDialogComponent.prototype.handleError = /**
     * @private
     * @param {?} error
     * @return {?}
     */
    function (error) {
        var statusCode = JSON.parse(error.message).error.statusCode;
        if (statusCode === 409) {
            this.form.controls['id'].setErrors({
                message: 'LIBRARY.ERRORS.CONFLICT'
            });
        }
        return error;
    };
    /**
     * @private
     * @param {?} libraryTitle
     * @return {?}
     */
    LibraryDialogComponent.prototype.checkLibraryNameExists = /**
     * @private
     * @param {?} libraryTitle
     * @return {?}
     */
    function (libraryTitle) {
        return __awaiter(this, void 0, void 0, function () {
            var entries, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        entries = [];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.findLibraryByTitle(libraryTitle)];
                    case 2:
                        entries = (_b.sent()).list.entries;
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        entries = [];
                        return [3 /*break*/, 4];
                    case 4:
                        if (entries.length) {
                            this.libraryTitleExists = entries[0].entry.title.toLowerCase() === libraryTitle.toLowerCase();
                        }
                        else {
                            this.libraryTitleExists = false;
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @private
     * @param {?} libraryTitle
     * @return {?}
     */
    LibraryDialogComponent.prototype.findLibraryByTitle = /**
     * @private
     * @param {?} libraryTitle
     * @return {?}
     */
    function (libraryTitle) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.alfrescoApiService
                        .getInstance()
                        .core.queriesApi.findSites(libraryTitle, {
                        maxItems: 1,
                        fields: ['title']
                    })];
            });
        });
    };
    /**
     * @private
     * @param {?} __0
     * @return {?}
     */
    LibraryDialogComponent.prototype.forbidSpecialCharacters = /**
     * @private
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var value = _a.value;
        if (value === null || value.length === 0) {
            return null;
        }
        /** @type {?} */
        var validCharacters = /[^A-Za-z0-9-]/;
        /** @type {?} */
        var isValid = !validCharacters.test(value);
        return isValid
            ? null
            : {
                message: 'LIBRARY.ERRORS.ILLEGAL_CHARACTERS'
            };
    };
    /**
     * @private
     * @param {?} __0
     * @return {?}
     */
    LibraryDialogComponent.prototype.forbidOnlySpaces = /**
     * @private
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var value = _a.value;
        if (value === null || value.length === 0) {
            return null;
        }
        /** @type {?} */
        var isValid = !!(value || '').trim();
        return isValid
            ? null
            : {
                message: 'LIBRARY.ERRORS.ONLY_SPACES'
            };
    };
    /**
     * @private
     * @return {?}
     */
    LibraryDialogComponent.prototype.createSiteIdValidator = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var timer;
        return (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            if (timer) {
                clearTimeout(timer);
            }
            return new Promise((/**
             * @param {?} resolve
             * @return {?}
             */
            function (resolve) {
                timer = setTimeout((/**
                 * @return {?}
                 */
                function () {
                    return from(_this.alfrescoApiService.sitesApi.getSite(control.value)).subscribe((/**
                     * @return {?}
                     */
                    function () { return resolve({ message: 'LIBRARY.ERRORS.EXISTENT_SITE' }); }), (/**
                     * @return {?}
                     */
                    function () { return resolve(null); }));
                }), 300);
            }));
        });
    };
    LibraryDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-library-dialog',
                    template: "<h2 mat-dialog-title>{{ createTitle | translate }}</h2>\n\n<mat-dialog-content>\n  <form novalidate [formGroup]=\"form\" (submit)=\"submit()\">\n    <mat-form-field>\n      <input\n        placeholder=\"{{ 'LIBRARY.DIALOG.FORM.NAME' | translate }}\"\n        required\n        matInput\n        autofocus\n        formControlName=\"title\"\n        autocomplete=\"off\"\n      />\n\n      <mat-hint *ngIf=\"libraryTitleExists\">{{\n        'LIBRARY.HINTS.SITE_TITLE_EXISTS' | translate\n      }}</mat-hint>\n      <mat-error *ngIf=\"form.controls['title'].hasError('maxlength')\">\n        {{ 'LIBRARY.ERRORS.TITLE_TOO_LONG' | translate }}\n      </mat-error>\n\n      <mat-error *ngIf=\"form.controls['title'].hasError('minlength')\">\n        {{ 'LIBRARY.ERRORS.TITLE_TOO_SHORT' | translate }}\n      </mat-error>\n\n      <mat-error *ngIf=\"form.controls['title'].errors?.message\">\n        {{ form.controls['title'].errors?.message | translate }}\n      </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n      <input\n        required\n        placeholder=\"{{ 'LIBRARY.DIALOG.FORM.SITE_ID' | translate }}\"\n        matInput\n        formControlName=\"id\"\n        autocomplete=\"off\"\n      />\n\n      <mat-error *ngIf=\"form.controls['id'].errors?.message\">\n        {{ form.controls['id'].errors?.message | translate }}\n      </mat-error>\n\n      <mat-error *ngIf=\"form.controls['id'].hasError('maxlength')\">\n        {{ 'LIBRARY.ERRORS.ID_TOO_LONG' | translate }}\n      </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n      <textarea\n        matInput\n        placeholder=\"{{ 'LIBRARY.DIALOG.FORM.DESCRIPTION' | translate }}\"\n        rows=\"3\"\n        formControlName=\"description\"\n      ></textarea>\n\n      <mat-error *ngIf=\"form.controls['description'].hasError('maxlength')\">\n        {{ 'LIBRARY.ERRORS.DESCRIPTION_TOO_LONG' | translate }}\n      </mat-error>\n    </mat-form-field>\n\n    <mat-radio-group\n      [ngModelOptions]=\"{ standalone: true }\"\n      [(ngModel)]=\"visibilityOption\"\n      (change)=\"visibilityChangeHandler($event)\"\n    >\n      <mat-radio-button\n        color=\"primary\"\n        [disabled]=\"option.disabled\"\n        *ngFor=\"let option of visibilityOptions\"\n        [attr.data-automation-id]=\"option.value\"\n        [value]=\"option.value\"\n        [checked]=\"visibilityOption.value === option.value\"\n      >\n        {{ option.label | translate }}\n      </mat-radio-button>\n    </mat-radio-group>\n  </form>\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-action-buttons\">\n  <button mat-button mat-dialog-close data-automation-id=\"cancel-library-id\">\n    {{ 'LIBRARY.DIALOG.CANCEL' | translate }}\n  </button>\n\n  <button\n    color=\"primary\"\n    mat-button\n    (click)=\"submit()\"\n    [disabled]=\"!form.valid\"\n    data-automation-id=\"create-library-id\"\n  >\n    {{ 'LIBRARY.DIALOG.CREATE' | translate }}\n  </button>\n</mat-dialog-actions>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-library-dialog' },
                    styles: [".adf-library-dialog .mat-radio-group{display:flex;flex-direction:column;margin:0 0 20px}.adf-library-dialog .mat-radio-group .mat-radio-button{margin:10px 0}.adf-library-dialog .mat-form-field{width:100%}.adf-library-dialog mat-form-field{padding-top:20px}.adf-library-dialog .adf-action-buttons{display:flex;flex-direction:row;justify-content:flex-end}.adf-library-dialog .adf-action-buttons .mat-button{text-transform:uppercase}"]
                }] }
    ];
    /** @nocollapse */
    LibraryDialogComponent.ctorParameters = function () { return [
        { type: AlfrescoApiService },
        { type: FormBuilder },
        { type: MatDialogRef }
    ]; };
    LibraryDialogComponent.propDecorators = {
        error: [{ type: Output }],
        success: [{ type: Output }]
    };
    return LibraryDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DialogModule = /** @class */ (function () {
    function DialogModule() {
    }
    DialogModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule,
                        CoreModule.forChild(),
                        FormsModule,
                        ReactiveFormsModule,
                        MatMomentDatetimeModule,
                        MatDatetimepickerModule
                    ],
                    declarations: [
                        FolderDialogComponent,
                        NodeLockDialogComponent,
                        ConfirmDialogComponent,
                        LibraryDialogComponent
                    ],
                    exports: [
                        FolderDialogComponent,
                        NodeLockDialogComponent,
                        ConfirmDialogComponent,
                        LibraryDialogComponent
                    ],
                    entryComponents: [
                        FolderDialogComponent,
                        NodeLockDialogComponent,
                        ConfirmDialogComponent,
                        LibraryDialogComponent
                    ]
                },] }
    ];
    return DialogModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_FOLDER_PARENT_ID = '-my-';
var FolderCreateDirective = /** @class */ (function () {
    function FolderCreateDirective(dialogRef, content) {
        this.dialogRef = dialogRef;
        this.content = content;
        /**
         * Parent folder where the new folder will be located after creation.
         */
        this.parentNodeId = DEFAULT_FOLDER_PARENT_ID;
        /**
         * Title of folder creation dialog.
         */
        this.title = null;
        /**
         * Type of node to create.
         */
        this.nodeType = 'cm:folder';
        /**
         * Emitted when an error occurs (eg, a folder with same name already exists).
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the folder is created successfully.
         */
        this.success = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    FolderCreateDirective.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.openDialog();
    };
    Object.defineProperty(FolderCreateDirective.prototype, "dialogConfig", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            var width = FolderCreateDirective.DIALOG_WIDTH;
            var _a = this, parentNodeId = _a.parentNodeId, createTitle = _a.title, nodeType = _a.nodeType;
            return {
                data: { parentNodeId: parentNodeId, createTitle: createTitle, nodeType: nodeType },
                width: width + "px"
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    FolderCreateDirective.prototype.openDialog = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        var _a = this, dialogRef = _a.dialogRef, dialogConfig = _a.dialogConfig, content = _a.content;
        /** @type {?} */
        var dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe((/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            _this.error.emit(error);
        }));
        dialogInstance.componentInstance.success.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            _this.success.emit(node);
        }));
        dialogInstance.afterClosed().subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            if (node) {
                content.folderCreate.next(node);
            }
        }));
    };
    FolderCreateDirective.DIALOG_WIDTH = 400;
    FolderCreateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[adf-create-folder]'
                },] }
    ];
    /** @nocollapse */
    FolderCreateDirective.ctorParameters = function () { return [
        { type: MatDialog },
        { type: ContentService }
    ]; };
    FolderCreateDirective.propDecorators = {
        parentNodeId: [{ type: Input, args: ['adf-create-folder',] }],
        title: [{ type: Input }],
        nodeType: [{ type: Input }],
        error: [{ type: Output }],
        success: [{ type: Output }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return FolderCreateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FolderEditDirective = /** @class */ (function () {
    function FolderEditDirective(dialogRef, elementRef, content) {
        this.dialogRef = dialogRef;
        this.elementRef = elementRef;
        this.content = content;
        /**
         * Emitted when an error occurs (eg, a folder with same name already exists).
         */
        this.error = new EventEmitter();
        /**
         * Title of folder edit dialog.
         */
        this.title = null;
        /**
         * Emitted when the folder has been edited successfully.
         */
        this.success = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    FolderEditDirective.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        if (this.folder) {
            this.openDialog();
        }
    };
    Object.defineProperty(FolderEditDirective.prototype, "dialogConfig", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            var width = FolderEditDirective.DIALOG_WIDTH;
            var folder = this.folder;
            return {
                data: {
                    folder: folder,
                    editTitle: this.title
                },
                width: width + "px"
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    FolderEditDirective.prototype.openDialog = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        var _a = this, dialogRef = _a.dialogRef, dialogConfig = _a.dialogConfig, content = _a.content;
        /** @type {?} */
        var dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe((/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            _this.error.emit(error);
        }));
        dialogInstance.componentInstance.success.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            _this.success.emit(node);
        }));
        dialogInstance.afterClosed().subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            if (node) {
                content.folderEdit.next(node);
            }
        }));
    };
    FolderEditDirective.DIALOG_WIDTH = 400;
    FolderEditDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[adf-edit-folder]'
                },] }
    ];
    /** @nocollapse */
    FolderEditDirective.ctorParameters = function () { return [
        { type: MatDialog },
        { type: ElementRef },
        { type: ContentService }
    ]; };
    FolderEditDirective.propDecorators = {
        folder: [{ type: Input, args: ['adf-edit-folder',] }],
        error: [{ type: Output }],
        title: [{ type: Input }],
        success: [{ type: Output }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return FolderEditDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FolderDirectiveModule = /** @class */ (function () {
    function FolderDirectiveModule() {
    }
    FolderDirectiveModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule
                    ],
                    declarations: [
                        FolderCreateDirective,
                        FolderEditDirective
                    ],
                    exports: [
                        FolderCreateDirective,
                        FolderEditDirective
                    ]
                },] }
    ];
    return FolderDirectiveModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentMetadataCardComponent = /** @class */ (function () {
    function ContentMetadataCardComponent(contentService) {
        this.contentService = contentService;
        /**
         * (optional) This flag displays/hides empty metadata
         * fields.
         */
        this.displayEmpty = false;
        /**
         * (optional) This flag displays desired aspect when open for the first time
         * fields.
         */
        this.displayAspect = null;
        /**
         * (optional) This flag sets the metadata in read only mode
         * preventing changes.
         */
        this.readOnly = false;
        /**
         * (optional) This flag allows the component to display more
         * than one accordion at a time.
         */
        this.multi = false;
        this._displayDefaultProperties = true;
        this.editable = false;
    }
    Object.defineProperty(ContentMetadataCardComponent.prototype, "displayDefaultProperties", {
        get: /**
         * @return {?}
         */
        function () {
            return this._displayDefaultProperties;
        },
        /** (optional) This flag displays/hides the metadata
         * properties.
         */
        set: /**
         * (optional) This flag displays/hides the metadata
         * properties.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._displayDefaultProperties = value;
            this.onDisplayDefaultPropertiesChange();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    ContentMetadataCardComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.displayAspect && changes.displayAspect.currentValue) {
            this.expanded = true;
        }
    };
    /**
     * @return {?}
     */
    ContentMetadataCardComponent.prototype.onDisplayDefaultPropertiesChange = /**
     * @return {?}
     */
    function () {
        this.expanded = !this._displayDefaultProperties;
    };
    /**
     * @return {?}
     */
    ContentMetadataCardComponent.prototype.toggleEdit = /**
     * @return {?}
     */
    function () {
        this.editable = !this.editable;
    };
    /**
     * @return {?}
     */
    ContentMetadataCardComponent.prototype.toggleExpanded = /**
     * @return {?}
     */
    function () {
        this.expanded = !this.expanded;
    };
    /**
     * @return {?}
     */
    ContentMetadataCardComponent.prototype.hasAllowableOperations = /**
     * @return {?}
     */
    function () {
        return this.contentService.hasAllowableOperations(this.node, AllowableOperationsEnum.UPDATE);
    };
    ContentMetadataCardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-content-metadata-card',
                    template: "<mat-card *ngIf=\"node\">\n    <mat-card-content>\n        <adf-content-metadata\n            [displayDefaultProperties]=\"displayDefaultProperties\"\n            [expanded]=\"expanded\"\n            [node]=\"node\"\n            [displayEmpty]=\"displayEmpty\"\n            [editable]=\"editable\"\n            [multi]=\"multi\"\n            [displayAspect]=\"displayAspect\"\n            [preset]=\"preset\">\n        </adf-content-metadata>\n    </mat-card-content>\n    <mat-card-footer class=\"adf-content-metadata-card-footer\" fxLayout=\"row\" fxLayoutAlign=\"space-between stretch\">\n        <div>\n            <button *ngIf=\"!readOnly && hasAllowableOperations()\"\n                mat-icon-button\n                (click)=\"toggleEdit()\"\n                [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                data-automation-id=\"meta-data-card-toggle-edit\">\n                <mat-icon>mode_edit</mat-icon>\n            </button>\n        </div>\n        <button *ngIf=\"displayDefaultProperties\" mat-button (click)=\"toggleExpanded()\" data-automation-id=\"meta-data-card-toggle-expand\">\n            <ng-container *ngIf=\"expanded\">\n                <span data-automation-id=\"meta-data-card-toggle-expand-label\">{{ 'ADF_VIEWER.SIDEBAR.METADATA.MORE_INFORMATION' | translate }}</span>\n                <mat-icon>keyboard_arrow_down</mat-icon>\n            </ng-container>\n            <ng-container *ngIf=\"!expanded\">\n                <span data-automation-id=\"meta-data-card-toggle-expand-label\">{{ 'ADF_VIEWER.SIDEBAR.METADATA.LESS_INFORMATION' | translate }}</span>\n                <mat-icon>keyboard_arrow_up</mat-icon>\n            </ng-container>\n        </button>\n    </mat-card-footer>\n</mat-card>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: { 'class': 'adf-content-metadata-card' },
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    ContentMetadataCardComponent.ctorParameters = function () { return [
        { type: ContentService }
    ]; };
    ContentMetadataCardComponent.propDecorators = {
        node: [{ type: Input }],
        displayEmpty: [{ type: Input }],
        displayAspect: [{ type: Input }],
        preset: [{ type: Input }],
        readOnly: [{ type: Input }],
        multi: [{ type: Input }],
        displayDefaultProperties: [{ type: Input }]
    };
    return ContentMetadataCardComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BasicPropertiesService = /** @class */ (function () {
    function BasicPropertiesService(fileSizePipe) {
        this.fileSizePipe = fileSizePipe;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    BasicPropertiesService.prototype.getProperties = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var sizeInBytes = node.content ? node.content.sizeInBytes : '';
        /** @type {?} */
        var mimeTypeName = node.content ? node.content.mimeTypeName : '';
        /** @type {?} */
        var author = node.properties ? node.properties['cm:author'] : '';
        /** @type {?} */
        var description = node.properties ? node.properties['cm:description'] : '';
        /** @type {?} */
        var title = node.properties ? node.properties['cm:title'] : '';
        return [
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.NAME',
                value: node.name,
                key: 'name',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.TITLE',
                value: title,
                key: 'properties.cm:title',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.CREATOR',
                value: node.createdByUser.displayName,
                key: 'createdByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.CREATED_DATE',
                value: node.createdAt,
                key: 'createdAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.SIZE',
                value: sizeInBytes,
                key: 'content.sizeInBytes',
                pipes: [{ pipe: this.fileSizePipe }],
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIER',
                value: node.modifiedByUser.displayName,
                key: 'modifiedByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIED_DATE',
                value: node.modifiedAt,
                key: 'modifiedAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MIMETYPE',
                value: mimeTypeName,
                key: 'content.mimeTypeName',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.AUTHOR',
                value: author,
                key: 'properties.cm:author',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.DESCRIPTION',
                value: description,
                key: 'properties.cm:description',
                multiline: true,
                editable: true
            })
        ];
    };
    BasicPropertiesService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    BasicPropertiesService.ctorParameters = function () { return [
        { type: FileSizePipe }
    ]; };
    /** @nocollapse */ BasicPropertiesService.ngInjectableDef = defineInjectable({ factory: function BasicPropertiesService_Factory() { return new BasicPropertiesService(inject(FileSizePipe)); }, token: BasicPropertiesService, providedIn: "root" });
    return BasicPropertiesService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var D_TEXT = 'd:text';
/** @type {?} */
var D_MLTEXT = 'd:mltext';
/** @type {?} */
var D_DATE = 'd:date';
/** @type {?} */
var D_DATETIME = 'd:datetime';
/** @type {?} */
var D_INT = 'd:int';
/** @type {?} */
var D_LONG = 'd:long';
/** @type {?} */
var D_FLOAT = 'd:float';
/** @type {?} */
var D_DOUBLE = 'd:double';
/** @type {?} */
var D_BOOLEAN = 'd:boolean';
var PropertyGroupTranslatorService = /** @class */ (function () {
    function PropertyGroupTranslatorService(logService, multiValuePipe, appConfig) {
        this.logService = logService;
        this.multiValuePipe = multiValuePipe;
        this.appConfig = appConfig;
        this.valueSeparator = this.appConfig.get('content-metadata.multi-value-pipe-separator');
    }
    /**
     * @param {?} propertyGroups
     * @param {?} propertyValues
     * @return {?}
     */
    PropertyGroupTranslatorService.prototype.translateToCardViewGroups = /**
     * @param {?} propertyGroups
     * @param {?} propertyValues
     * @return {?}
     */
    function (propertyGroups, propertyValues) {
        var _this = this;
        return propertyGroups.map((/**
         * @param {?} propertyGroup
         * @return {?}
         */
        function (propertyGroup) {
            /** @type {?} */
            var translatedPropertyGroup = Object.assign({}, propertyGroup);
            translatedPropertyGroup.properties = _this.translateArray(propertyGroup.properties, propertyValues);
            return translatedPropertyGroup;
        }));
    };
    /**
     * @private
     * @param {?} properties
     * @param {?} propertyValues
     * @return {?}
     */
    PropertyGroupTranslatorService.prototype.translateArray = /**
     * @private
     * @param {?} properties
     * @param {?} propertyValues
     * @return {?}
     */
    function (properties, propertyValues) {
        var _this = this;
        return properties.map((/**
         * @param {?} property
         * @return {?}
         */
        function (property) {
            return _this.translate(property, propertyValues);
        }));
    };
    /**
     * @private
     * @param {?} property
     * @param {?} propertyValues
     * @return {?}
     */
    PropertyGroupTranslatorService.prototype.translate = /**
     * @private
     * @param {?} property
     * @param {?} propertyValues
     * @return {?}
     */
    function (property, propertyValues) {
        /** @type {?} */
        var propertyValue;
        if (propertyValues && propertyValues[property.name]) {
            propertyValue = propertyValues[property.name];
        }
        this.checkECMTypeValidity(property.dataType);
        /** @type {?} */
        var prefix = 'properties.';
        /** @type {?} */
        var propertyDefinition = {
            label: property.title || property.name,
            value: propertyValue,
            key: "" + prefix + property.name,
            default: property.defaultValue,
            editable: true
        };
        /** @type {?} */
        var cardViewItemProperty;
        switch (property.dataType) {
            case D_MLTEXT:
                cardViewItemProperty = new CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multiline: true
                }));
                break;
            case D_INT:
            case D_LONG:
                cardViewItemProperty = new CardViewIntItemModel(propertyDefinition);
                break;
            case D_FLOAT:
            case D_DOUBLE:
                cardViewItemProperty = new CardViewFloatItemModel(propertyDefinition);
                break;
            case D_DATE:
                cardViewItemProperty = new CardViewDateItemModel(propertyDefinition);
                break;
            case D_DATETIME:
                cardViewItemProperty = new CardViewDatetimeItemModel(propertyDefinition);
                break;
            case D_BOOLEAN:
                cardViewItemProperty = new CardViewBoolItemModel(propertyDefinition);
                break;
            case D_TEXT:
            default:
                cardViewItemProperty = new CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multivalued: property.multiValued,
                    multiline: property.multiValued,
                    pipes: [{ pipe: this.multiValuePipe, params: [this.valueSeparator] }]
                }));
        }
        return cardViewItemProperty;
    };
    /**
     * @private
     * @param {?} ecmPropertyType
     * @return {?}
     */
    PropertyGroupTranslatorService.prototype.checkECMTypeValidity = /**
     * @private
     * @param {?} ecmPropertyType
     * @return {?}
     */
    function (ecmPropertyType) {
        if (PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES.indexOf(ecmPropertyType) === -1) {
            this.logService.error("Unknown type for mapping: " + ecmPropertyType);
        }
    };
    PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES = [D_TEXT, D_MLTEXT, D_DATE, D_DATETIME, D_INT, D_LONG, D_FLOAT, D_DOUBLE, D_BOOLEAN];
    PropertyGroupTranslatorService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    PropertyGroupTranslatorService.ctorParameters = function () { return [
        { type: LogService },
        { type: MultiValuePipe },
        { type: AppConfigService }
    ]; };
    /** @nocollapse */ PropertyGroupTranslatorService.ngInjectableDef = defineInjectable({ factory: function PropertyGroupTranslatorService_Factory() { return new PropertyGroupTranslatorService(inject(LogService), inject(MultiValuePipe), inject(AppConfigService)); }, token: PropertyGroupTranslatorService, providedIn: "root" });
    return PropertyGroupTranslatorService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
var emptyGroup = {
    properties: {}
};
/**
 * @param {?} object
 * @return {?}
 */
function convertObjectToArray(object) {
    return Object.keys(object).map((/**
     * @param {?} key
     * @return {?}
     */
    function (key) { return object[key]; }));
}
/**
 * @param {?} propertyGroups
 * @param {?} groupName
 * @return {?}
 */
function getGroup(propertyGroups, groupName) {
    return propertyGroups[groupName];
}
/**
 * @param {?} propertyGroups
 * @param {?} groupName
 * @param {?} propertyName
 * @return {?}
 */
function getProperty(propertyGroups, groupName, propertyName) {
    /** @type {?} */
    var groupDefinition = getGroup(propertyGroups, groupName) || emptyGroup;
    /** @type {?} */
    var propertyDefinitions;
    if (propertyName === '*') {
        propertyDefinitions = convertObjectToArray(groupDefinition.properties);
    }
    else {
        propertyDefinitions = groupDefinition.properties[propertyName];
    }
    return propertyDefinitions;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AspectOrientedConfigService = /** @class */ (function () {
    function AspectOrientedConfigService(config) {
        this.config = config;
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    AspectOrientedConfigService.prototype.isGroupAllowed = /**
     * @param {?} groupName
     * @return {?}
     */
    function (groupName) {
        if (this.isIncludeAllEnabled()) {
            return true;
        }
        /** @type {?} */
        var groupNames = Object.keys(this.config);
        return groupNames.indexOf(groupName) !== -1;
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    AspectOrientedConfigService.prototype.reorganiseByConfig = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        var _this = this;
        /** @type {?} */
        var aspects = this.config;
        /** @type {?} */
        var aspectNames = Object.keys(aspects);
        return aspectNames
            .reduce((/**
         * @param {?} groupAccumulator
         * @param {?} aspectName
         * @return {?}
         */
        function (groupAccumulator, aspectName) {
            /** @type {?} */
            var newGroup = _this.getOrganisedPropertyGroup(propertyGroups, aspectName);
            return groupAccumulator.concat(newGroup);
        }), [])
            .filter((/**
         * @param {?} organisedPropertyGroup
         * @return {?}
         */
        function (organisedPropertyGroup) { return organisedPropertyGroup.properties.length > 0; }));
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    AspectOrientedConfigService.prototype.appendAllPreset = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        /** @type {?} */
        var groups = Object.keys(propertyGroups)
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        function (groupName) {
            /** @type {?} */
            var propertyGroup = propertyGroups[groupName];
            /** @type {?} */
            var properties = propertyGroup.properties;
            return Object.assign({}, propertyGroup, {
                properties: Object.keys(properties).map((/**
                 * @param {?} propertyName
                 * @return {?}
                 */
                function (propertyName) { return properties[propertyName]; }))
            });
        }));
        return groups;
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    AspectOrientedConfigService.prototype.filterExcludedPreset = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        var _this = this;
        if (this.config.exclude) {
            return propertyGroups.filter((/**
             * @param {?} preset
             * @return {?}
             */
            function (preset) {
                return !_this.config.exclude.includes(preset.name);
            }));
        }
        return propertyGroups;
    };
    /**
     * @return {?}
     */
    AspectOrientedConfigService.prototype.isIncludeAllEnabled = /**
     * @return {?}
     */
    function () {
        return this.config.includeAll;
    };
    /**
     * @private
     * @param {?} propertyGroups
     * @param {?} aspectName
     * @return {?}
     */
    AspectOrientedConfigService.prototype.getOrganisedPropertyGroup = /**
     * @private
     * @param {?} propertyGroups
     * @param {?} aspectName
     * @return {?}
     */
    function (propertyGroups, aspectName) {
        /** @type {?} */
        var group = getGroup(propertyGroups, aspectName);
        /** @type {?} */
        var newGroup = [];
        if (group) {
            /** @type {?} */
            var aspectProperties = this.config[aspectName];
            /** @type {?} */
            var properties = void 0;
            if (aspectProperties === '*') {
                properties = getProperty(propertyGroups, aspectName, aspectProperties);
            }
            else {
                properties = ((/** @type {?} */ (aspectProperties)))
                    .map((/**
                 * @param {?} propertyName
                 * @return {?}
                 */
                function (propertyName) { return getProperty(propertyGroups, aspectName, propertyName); }))
                    .filter((/**
                 * @param {?} props
                 * @return {?}
                 */
                function (props) { return props !== undefined; }));
            }
            newGroup = [{ title: group.title, properties: properties }];
        }
        return newGroup;
    };
    return AspectOrientedConfigService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var IndifferentConfigService = /** @class */ (function () {
    function IndifferentConfigService(config) {
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    IndifferentConfigService.prototype.isGroupAllowed = /**
     * @param {?} groupName
     * @return {?}
     */
    function (groupName) {
        return true;
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    IndifferentConfigService.prototype.reorganiseByConfig = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        return Object.keys(propertyGroups)
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        function (groupName) {
            /** @type {?} */
            var propertyGroup = propertyGroups[groupName];
            /** @type {?} */
            var properties = propertyGroup.properties;
            return Object.assign({}, propertyGroup, {
                properties: Object.keys(properties).map((/**
                 * @param {?} propertyName
                 * @return {?}
                 */
                function (propertyName) { return properties[propertyName]; }))
            });
        }));
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    IndifferentConfigService.prototype.filterExcludedPreset = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        return propertyGroups;
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    IndifferentConfigService.prototype.appendAllPreset = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        return [];
    };
    /**
     * @return {?}
     */
    IndifferentConfigService.prototype.isIncludeAllEnabled = /**
     * @return {?}
     */
    function () {
        return true;
    };
    return IndifferentConfigService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LayoutOrientedConfigService = /** @class */ (function () {
    function LayoutOrientedConfigService(config) {
        this.config = config;
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    LayoutOrientedConfigService.prototype.isGroupAllowed = /**
     * @param {?} groupName
     * @return {?}
     */
    function (groupName) {
        if (this.isIncludeAllEnabled()) {
            return true;
        }
        return this.getMatchingGroups(groupName).length > 0;
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    LayoutOrientedConfigService.prototype.reorganiseByConfig = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        var _this = this;
        /** @type {?} */
        var layoutBlocks = this.config.filter((/**
         * @param {?} itemsGroup
         * @return {?}
         */
        function (itemsGroup) { return itemsGroup.items; }));
        /** @type {?} */
        var organisedPropertyGroup = layoutBlocks.map((/**
         * @param {?} layoutBlock
         * @return {?}
         */
        function (layoutBlock) {
            /** @type {?} */
            var flattenedItems = _this.flattenItems(layoutBlock.items);
            /** @type {?} */
            var properties = flattenedItems.reduce((/**
             * @param {?} props
             * @param {?} explodedItem
             * @return {?}
             */
            function (props, explodedItem) {
                /** @type {?} */
                var property = getProperty(propertyGroups, explodedItem.groupName, explodedItem.propertyName) || [];
                return props.concat(property);
            }), []);
            return {
                title: layoutBlock.title,
                properties: properties
            };
        }));
        return organisedPropertyGroup;
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    LayoutOrientedConfigService.prototype.appendAllPreset = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        return Object.keys(propertyGroups)
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        function (groupName) {
            /** @type {?} */
            var propertyGroup = propertyGroups[groupName];
            /** @type {?} */
            var properties = propertyGroup.properties;
            return Object.assign({}, propertyGroup, {
                properties: Object.keys(properties).map((/**
                 * @param {?} propertyName
                 * @return {?}
                 */
                function (propertyName) { return properties[propertyName]; }))
            });
        }));
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    LayoutOrientedConfigService.prototype.filterExcludedPreset = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        /** @type {?} */
        var excludedConfig = this.config
            .map((/**
         * @param {?} config
         * @return {?}
         */
        function (config) { return config.exclude; }))
            .find((/**
         * @param {?} exclude
         * @return {?}
         */
        function (exclude) { return exclude !== undefined; }));
        if (excludedConfig === undefined) {
            excludedConfig = [];
        }
        else if (typeof excludedConfig === 'string') {
            excludedConfig = [excludedConfig];
        }
        return propertyGroups.filter((/**
         * @param {?} props
         * @return {?}
         */
        function (props) {
            return !excludedConfig.includes(props.name);
        }));
    };
    /**
     * @return {?}
     */
    LayoutOrientedConfigService.prototype.isIncludeAllEnabled = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var includeAllProperty = this.config
            .map((/**
         * @param {?} config
         * @return {?}
         */
        function (config) { return config.includeAll; }))
            .find((/**
         * @param {?} includeAll
         * @return {?}
         */
        function (includeAll) { return includeAll !== undefined; }));
        return includeAllProperty !== undefined ? includeAllProperty : false;
    };
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    LayoutOrientedConfigService.prototype.flattenItems = /**
     * @private
     * @param {?} items
     * @return {?}
     */
    function (items) {
        return items.reduce((/**
         * @param {?} accumulator
         * @param {?} item
         * @return {?}
         */
        function (accumulator, item) {
            /** @type {?} */
            var properties = Array.isArray(item.properties) ? item.properties : [item.properties];
            /** @type {?} */
            var flattenedProperties = properties.map((/**
             * @param {?} propertyName
             * @return {?}
             */
            function (propertyName) {
                return {
                    groupName: item.aspect || item.type,
                    propertyName: propertyName
                };
            }));
            return accumulator.concat(flattenedProperties);
        }), []);
    };
    /**
     * @private
     * @param {?} groupName
     * @return {?}
     */
    LayoutOrientedConfigService.prototype.getMatchingGroups = /**
     * @private
     * @param {?} groupName
     * @return {?}
     */
    function (groupName) {
        return this.config
            .map((/**
         * @param {?} layoutBlock
         * @return {?}
         */
        function (layoutBlock) { return layoutBlock.items; }))
            .reduce((/**
         * @param {?} accumulator
         * @param {?} items
         * @return {?}
         */
        function (accumulator, items) { return accumulator.concat(items); }), [])
            .filter((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return item.aspect === groupName || item.type === groupName; }));
    };
    return LayoutOrientedConfigService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentMetadataConfigFactory = /** @class */ (function () {
    function ContentMetadataConfigFactory(appConfigService, logService) {
        this.appConfigService = appConfigService;
        this.logService = logService;
    }
    /**
     * @param {?=} presetName
     * @return {?}
     */
    ContentMetadataConfigFactory.prototype.get = /**
     * @param {?=} presetName
     * @return {?}
     */
    function (presetName) {
        if (presetName === void 0) { presetName = 'default'; }
        /** @type {?} */
        var presetConfig;
        try {
            presetConfig = this.appConfigService.config['content-metadata'].presets[presetName];
        }
        catch (_a) {
            if (presetName !== ContentMetadataConfigFactory.DEFAULT_PRESET_NAME) {
                this.logService.error("No content-metadata preset for: " + presetName);
            }
            presetConfig = ContentMetadataConfigFactory.INDIFFERENT_PRESET;
        }
        return this.createConfig(presetConfig);
    };
    /**
     * @private
     * @param {?} presetConfig
     * @return {?}
     */
    ContentMetadataConfigFactory.prototype.createConfig = /**
     * @private
     * @param {?} presetConfig
     * @return {?}
     */
    function (presetConfig) {
        /** @type {?} */
        var config;
        if (this.isLayoutOrientedPreset(presetConfig)) {
            config = new LayoutOrientedConfigService((/** @type {?} */ (presetConfig)));
        }
        else if (this.isAspectOrientedPreset(presetConfig)) {
            config = new AspectOrientedConfigService((/** @type {?} */ (presetConfig)));
        }
        else {
            config = new IndifferentConfigService((/** @type {?} */ (presetConfig)));
        }
        Object.freeze(config);
        return config;
    };
    /**
     * @private
     * @param {?} presetConfig
     * @return {?}
     */
    ContentMetadataConfigFactory.prototype.isAspectOrientedPreset = /**
     * @private
     * @param {?} presetConfig
     * @return {?}
     */
    function (presetConfig) {
        return this.isObject(presetConfig);
    };
    /**
     * @private
     * @param {?} presetConfig
     * @return {?}
     */
    ContentMetadataConfigFactory.prototype.isLayoutOrientedPreset = /**
     * @private
     * @param {?} presetConfig
     * @return {?}
     */
    function (presetConfig) {
        return Array.isArray(presetConfig);
    };
    /**
     * @private
     * @param {?} x
     * @return {?}
     */
    ContentMetadataConfigFactory.prototype.isObject = /**
     * @private
     * @param {?} x
     * @return {?}
     */
    function (x) {
        return x != null && typeof x === 'object';
    };
    ContentMetadataConfigFactory.INDIFFERENT_PRESET = '*';
    ContentMetadataConfigFactory.DEFAULT_PRESET_NAME = 'default';
    ContentMetadataConfigFactory.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ContentMetadataConfigFactory.ctorParameters = function () { return [
        { type: AppConfigService },
        { type: LogService }
    ]; };
    /** @nocollapse */ ContentMetadataConfigFactory.ngInjectableDef = defineInjectable({ factory: function ContentMetadataConfigFactory_Factory() { return new ContentMetadataConfigFactory(inject(AppConfigService), inject(LogService)); }, token: ContentMetadataConfigFactory, providedIn: "root" });
    return ContentMetadataConfigFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PropertyDescriptorsService = /** @class */ (function () {
    function PropertyDescriptorsService(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    /**
     * @param {?} groupNames
     * @return {?}
     */
    PropertyDescriptorsService.prototype.load = /**
     * @param {?} groupNames
     * @return {?}
     */
    function (groupNames) {
        var _this = this;
        /** @type {?} */
        var groupFetchStreams = groupNames
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        function (groupName) { return groupName.replace(':', '_'); }))
            .map((/**
         * @param {?} groupName
         * @return {?}
         */
        function (groupName) { return defer((/**
         * @return {?}
         */
        function () { return _this.alfrescoApiService.classesApi.getClass(groupName); })); }));
        return forkJoin(groupFetchStreams).pipe(map(this.convertToObject));
    };
    /**
     * @private
     * @param {?} propertyGroupsArray
     * @return {?}
     */
    PropertyDescriptorsService.prototype.convertToObject = /**
     * @private
     * @param {?} propertyGroupsArray
     * @return {?}
     */
    function (propertyGroupsArray) {
        return propertyGroupsArray.reduce((/**
         * @param {?} propertyGroups
         * @param {?} propertyGroup
         * @return {?}
         */
        function (propertyGroups, propertyGroup) {
            var _a;
            return Object.assign({}, propertyGroups, (_a = {},
                _a[propertyGroup.name] = propertyGroup,
                _a));
        }), {});
    };
    PropertyDescriptorsService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    PropertyDescriptorsService.ctorParameters = function () { return [
        { type: AlfrescoApiService }
    ]; };
    /** @nocollapse */ PropertyDescriptorsService.ngInjectableDef = defineInjectable({ factory: function PropertyDescriptorsService_Factory() { return new PropertyDescriptorsService(inject(AlfrescoApiService)); }, token: PropertyDescriptorsService, providedIn: "root" });
    return PropertyDescriptorsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentMetadataService = /** @class */ (function () {
    function ContentMetadataService(basicPropertiesService, contentMetadataConfigFactory, propertyGroupTranslatorService, propertyDescriptorsService) {
        this.basicPropertiesService = basicPropertiesService;
        this.contentMetadataConfigFactory = contentMetadataConfigFactory;
        this.propertyGroupTranslatorService = propertyGroupTranslatorService;
        this.propertyDescriptorsService = propertyDescriptorsService;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    ContentMetadataService.prototype.getBasicProperties = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return of(this.basicPropertiesService.getProperties(node));
    };
    /**
     * @param {?} node
     * @param {?=} presetName
     * @return {?}
     */
    ContentMetadataService.prototype.getGroupedProperties = /**
     * @param {?} node
     * @param {?=} presetName
     * @return {?}
     */
    function (node, presetName) {
        var _this = this;
        if (presetName === void 0) { presetName = 'default'; }
        /** @type {?} */
        var groupedProperties = of([]);
        if (node.aspectNames) {
            /** @type {?} */
            var contentMetadataConfig_1 = this.contentMetadataConfigFactory.get(presetName);
            /** @type {?} */
            var groupNames = node.aspectNames
                .concat(node.nodeType)
                .filter((/**
             * @param {?} groupName
             * @return {?}
             */
            function (groupName) { return contentMetadataConfig_1.isGroupAllowed(groupName); }));
            if (groupNames.length > 0) {
                groupedProperties = this.propertyDescriptorsService.load(groupNames).pipe(switchMap((/**
                 * @param {?} groups
                 * @return {?}
                 */
                function (groups) {
                    return iif((/**
                     * @return {?}
                     */
                    function () { return contentMetadataConfig_1.isIncludeAllEnabled(); }), of(contentMetadataConfig_1.appendAllPreset(groups).concat(contentMetadataConfig_1.reorganiseByConfig(groups))), of(contentMetadataConfig_1.reorganiseByConfig(groups)));
                })), map((/**
                 * @param {?} groups
                 * @return {?}
                 */
                function (groups) { return contentMetadataConfig_1.filterExcludedPreset(groups); })), map((/**
                 * @param {?} groups
                 * @return {?}
                 */
                function (groups) { return _this.filterEmptyPreset(groups); })), map((/**
                 * @param {?} groups
                 * @return {?}
                 */
                function (groups) { return _this.setTitleToNameIfNotSet(groups); })), map((/**
                 * @param {?} groups
                 * @return {?}
                 */
                function (groups) { return _this.propertyGroupTranslatorService.translateToCardViewGroups(groups, node.properties); })));
            }
        }
        return groupedProperties;
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    ContentMetadataService.prototype.setTitleToNameIfNotSet = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        propertyGroups.map((/**
         * @param {?} propertyGroup
         * @return {?}
         */
        function (propertyGroup) {
            propertyGroup.title = propertyGroup.title || propertyGroup.name;
        }));
        return propertyGroups;
    };
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    ContentMetadataService.prototype.filterEmptyPreset = /**
     * @param {?} propertyGroups
     * @return {?}
     */
    function (propertyGroups) {
        return propertyGroups.filter((/**
         * @param {?} props
         * @return {?}
         */
        function (props) { return props.properties.length; }));
    };
    ContentMetadataService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ContentMetadataService.ctorParameters = function () { return [
        { type: BasicPropertiesService },
        { type: ContentMetadataConfigFactory },
        { type: PropertyGroupTranslatorService },
        { type: PropertyDescriptorsService }
    ]; };
    /** @nocollapse */ ContentMetadataService.ngInjectableDef = defineInjectable({ factory: function ContentMetadataService_Factory() { return new ContentMetadataService(inject(BasicPropertiesService), inject(ContentMetadataConfigFactory), inject(PropertyGroupTranslatorService), inject(PropertyDescriptorsService)); }, token: ContentMetadataService, providedIn: "root" });
    return ContentMetadataService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentMetadataComponent = /** @class */ (function () {
    function ContentMetadataComponent(contentMetadataService, cardViewUpdateService, nodesApiService, logService, alfrescoApiService) {
        this.contentMetadataService = contentMetadataService;
        this.cardViewUpdateService = cardViewUpdateService;
        this.nodesApiService = nodesApiService;
        this.logService = logService;
        this.alfrescoApiService = alfrescoApiService;
        /**
         * Toggles whether the edit button should be shown
         */
        this.editable = false;
        /**
         * Toggles whether to display empty values in the card view
         */
        this.displayEmpty = false;
        /**
         * Toggles between expanded (ie, full information) and collapsed
         * (ie, reduced information) in the display
         */
        this.expanded = false;
        /**
         * The multi parameter of the underlying material expansion panel, set to true to allow multi accordion to be expanded at the same time
         */
        this.multi = false;
        /**
         * Toggles whether the metadata properties should be shown
         */
        this.displayDefaultProperties = true;
        /**
         * (Optional) shows the given aspect in the expanded  card
         */
        this.displayAspect = null;
    }
    /**
     * @return {?}
     */
    ContentMetadataComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.disposableNodeUpdate = this.cardViewUpdateService.itemUpdated$
            .pipe(switchMap(this.saveNode.bind(this)))
            .subscribe((/**
         * @param {?} updatedNode
         * @return {?}
         */
        function (updatedNode) {
            Object.assign(_this.node, updatedNode);
            _this.alfrescoApiService.nodeUpdated.next(_this.node);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return _this.logService.error(error); }));
        this.loadProperties(this.node);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ContentMetadataComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.node && !changes.node.firstChange) {
            this.loadProperties(changes.node.currentValue);
        }
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    ContentMetadataComponent.prototype.loadProperties = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (node) {
            this.basicProperties$ = this.contentMetadataService.getBasicProperties(node);
            this.groupedProperties$ = this.contentMetadataService.getGroupedProperties(node, this.preset);
        }
    };
    /**
     * @private
     * @param {?} __0
     * @return {?}
     */
    ContentMetadataComponent.prototype.saveNode = /**
     * @private
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var nodeBody = _a.changed;
        return this.nodesApiService.updateNode(this.node.id, nodeBody);
    };
    /**
     * @param {?} group
     * @return {?}
     */
    ContentMetadataComponent.prototype.showGroup = /**
     * @param {?} group
     * @return {?}
     */
    function (group) {
        /** @type {?} */
        var properties = group.properties.filter((/**
         * @param {?} property
         * @return {?}
         */
        function (property) {
            return !!property.displayValue;
        }));
        return properties.length;
    };
    /**
     * @return {?}
     */
    ContentMetadataComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.disposableNodeUpdate.unsubscribe();
    };
    /**
     * @param {?} group
     * @return {?}
     */
    ContentMetadataComponent.prototype.canExpandTheCard = /**
     * @param {?} group
     * @return {?}
     */
    function (group) {
        return group.title === this.displayAspect;
    };
    /**
     * @return {?}
     */
    ContentMetadataComponent.prototype.canExpandProperties = /**
     * @return {?}
     */
    function () {
        return !this.expanded || this.displayAspect === 'Properties';
    };
    ContentMetadataComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-content-metadata',
                    template: "<div class=\"adf-metadata-properties\">\n    <mat-accordion displayMode=\"flat\" [multi]=\"multi\">\n        <mat-expansion-panel\n            *ngIf=\"displayDefaultProperties\"\n            [expanded]=\"canExpandProperties()\"\n            [hideToggle]=\"canExpandProperties()\"\n            [attr.data-automation-id]=\"'adf-metadata-group-properties'\" >\n            <mat-expansion-panel-header>\n                <mat-panel-title>\n                    {{ 'CORE.METADATA.BASIC.HEADER' | translate }}\n                </mat-panel-title>\n            </mat-expansion-panel-header>\n\n            <adf-card-view\n                [properties]=\"basicProperties$ | async\"\n                [editable]=\"editable\"\n                [displayEmpty]=\"displayEmpty\">\n            </adf-card-view>\n        </mat-expansion-panel>\n\n        <ng-container *ngIf=\"expanded\">\n            <ng-container *ngIf=\"groupedProperties$ | async; else loading; let groupedProperties\">\n                <div *ngFor=\"let group of groupedProperties; let first = first;\" class=\"adf-metadata-grouped-properties-container\">\n                    <mat-expansion-panel *ngIf=\"showGroup(group) || editable\"\n                    [attr.data-automation-id]=\"'adf-metadata-group-' + group.title\"\n                    [expanded]=\"canExpandTheCard(group) || !displayDefaultProperties && first\">\n                        <mat-expansion-panel-header>\n                            <mat-panel-title>\n                                {{ group.title | translate }}\n                            </mat-panel-title>\n                        </mat-expansion-panel-header>\n\n                        <adf-card-view\n                            [properties]=\"group.properties\"\n                            [editable]=\"editable\"\n                            [displayEmpty]=\"displayEmpty\">\n                        </adf-card-view>\n                    </mat-expansion-panel>\n\n                </div>\n            </ng-container>\n            <ng-template #loading>\n                <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n            </ng-template>\n        </ng-container>\n    </mat-accordion>\n</div>\n",
                    host: { 'class': 'adf-content-metadata' },
                    encapsulation: ViewEncapsulation.None,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    ContentMetadataComponent.ctorParameters = function () { return [
        { type: ContentMetadataService },
        { type: CardViewUpdateService },
        { type: NodesApiService },
        { type: LogService },
        { type: AlfrescoApiService }
    ]; };
    ContentMetadataComponent.propDecorators = {
        node: [{ type: Input }],
        editable: [{ type: Input }],
        displayEmpty: [{ type: Input }],
        expanded: [{ type: Input }],
        multi: [{ type: Input }],
        preset: [{ type: Input }],
        displayDefaultProperties: [{ type: Input }],
        displayAspect: [{ type: Input }]
    };
    return ContentMetadataComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentMetadataModule = /** @class */ (function () {
    function ContentMetadataModule() {
    }
    ContentMetadataModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule,
                        FlexLayoutModule,
                        CoreModule.forChild()
                    ],
                    exports: [
                        ContentMetadataComponent,
                        ContentMetadataCardComponent
                    ],
                    declarations: [
                        ContentMetadataComponent,
                        ContentMetadataCardComponent
                    ]
                },] }
    ];
    return ContentMetadataModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PermissionDisplayModel = /** @class */ (function () {
    function PermissionDisplayModel(obj) {
        this.isInherited = false;
        if (obj) {
            this.authorityId = obj.authorityId;
            this.name = obj.name;
            this.accessStatus = obj.accessStatus;
            this.isInherited = obj.isInherited !== null && obj.isInherited !== undefined ? obj.isInherited : false;
            this.icon = obj.icon ? obj.icon : 'vpn_key';
        }
    }
    return PermissionDisplayModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NodePermissionService = /** @class */ (function () {
    function NodePermissionService(apiService, searchApiService, nodeService, translation) {
        this.apiService = apiService;
        this.searchApiService = searchApiService;
        this.nodeService = nodeService;
        this.translation = translation;
    }
    /**
     * Gets a list of roles for the current node.
     * @param node The target node
     * @returns Array of strings representing the roles
     */
    /**
     * Gets a list of roles for the current node.
     * @param {?} node The target node
     * @return {?} Array of strings representing the roles
     */
    NodePermissionService.prototype.getNodeRoles = /**
     * Gets a list of roles for the current node.
     * @param {?} node The target node
     * @return {?} Array of strings representing the roles
     */
    function (node) {
        var _this = this;
        /** @type {?} */
        var retrieveSiteQueryBody = this.buildRetrieveSiteQueryBody(node.path.elements);
        return this.searchApiService.searchByQueryBody(retrieveSiteQueryBody)
            .pipe(switchMap((/**
         * @param {?} siteNodeList
         * @return {?}
         */
        function (siteNodeList) {
            if (siteNodeList.list.entries.length > 0) {
                /** @type {?} */
                var siteName = siteNodeList.list.entries[0].entry.name;
                return _this.getGroupMembersBySiteName(siteName);
            }
            else {
                return of(node.permissions.settable);
            }
        })));
    };
    /**
     * Updates the permission role for a node.
     * @param node Target node
     * @param updatedPermissionRole Permission role to update or add
     * @returns Node with updated permission
     */
    /**
     * Updates the permission role for a node.
     * @param {?} node Target node
     * @param {?} updatedPermissionRole Permission role to update or add
     * @return {?} Node with updated permission
     */
    NodePermissionService.prototype.updatePermissionRole = /**
     * Updates the permission role for a node.
     * @param {?} node Target node
     * @param {?} updatedPermissionRole Permission role to update or add
     * @return {?} Node with updated permission
     */
    function (node, updatedPermissionRole) {
        /** @type {?} */
        var permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        var index = node.permissions.locallySet.map((/**
         * @param {?} permission
         * @return {?}
         */
        function (permission) { return permission.authorityId; })).indexOf(updatedPermissionRole.authorityId);
        permissionBody.permissions.locallySet = permissionBody.permissions.locallySet.concat(node.permissions.locallySet);
        if (index !== -1) {
            permissionBody.permissions.locallySet[index] = updatedPermissionRole;
        }
        else {
            permissionBody.permissions.locallySet.push(updatedPermissionRole);
        }
        return this.nodeService.updateNode(node.id, permissionBody);
    };
    /**
     * Update permissions for a node.
     * @param nodeId ID of the target node
     * @param permissionList New permission settings
     * @returns Node with updated permissions
     */
    /**
     * Update permissions for a node.
     * @param {?} nodeId ID of the target node
     * @param {?} permissionList New permission settings
     * @return {?} Node with updated permissions
     */
    NodePermissionService.prototype.updateNodePermissions = /**
     * Update permissions for a node.
     * @param {?} nodeId ID of the target node
     * @param {?} permissionList New permission settings
     * @return {?} Node with updated permissions
     */
    function (nodeId, permissionList) {
        var _this = this;
        return this.nodeService.getNode(nodeId).pipe(switchMap((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return _this.getNodeRoles(node).pipe(switchMap((/**
             * @param {?} nodeRoles
             * @return {?}
             */
            function (nodeRoles) { return of({ node: node, nodeRoles: nodeRoles }); })));
        })), switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var node = _a.node, nodeRoles = _a.nodeRoles;
            return _this.updateLocallySetPermissions(node, permissionList, nodeRoles);
        })));
    };
    /**
     * Updates the locally set permissions for a node.
     * @param node ID of the target node
     * @param nodes Permission settings
     * @param nodeRole Permission role
     * @returns Node with updated permissions
     */
    /**
     * Updates the locally set permissions for a node.
     * @param {?} node ID of the target node
     * @param {?} nodes Permission settings
     * @param {?} nodeRole Permission role
     * @return {?} Node with updated permissions
     */
    NodePermissionService.prototype.updateLocallySetPermissions = /**
     * Updates the locally set permissions for a node.
     * @param {?} node ID of the target node
     * @param {?} nodes Permission settings
     * @param {?} nodeRole Permission role
     * @return {?} Node with updated permissions
     */
    function (node, nodes, nodeRole) {
        /** @type {?} */
        var permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        var permissionList = this.transformNodeToPermissionElement(nodes, nodeRole[0]);
        /** @type {?} */
        var duplicatedPermissions = this.getDuplicatedPermissions(node.permissions.locallySet, permissionList);
        if (duplicatedPermissions.length > 0) {
            /** @type {?} */
            var list = duplicatedPermissions.map((/**
             * @param {?} permission
             * @return {?}
             */
            function (permission) { return 'authority -> ' + permission.authorityId + ' / role -> ' + permission.name; })).join(', ');
            /** @type {?} */
            var duplicatePermissionMessage = this.translation.instant('PERMISSION_MANAGER.ERROR.DUPLICATE-PERMISSION', { list: list });
            return throwError(duplicatePermissionMessage);
        }
        permissionBody.permissions.locallySet = node.permissions.locallySet ? node.permissions.locallySet.concat(permissionList) : permissionList;
        return this.nodeService.updateNode(node.id, permissionBody);
    };
    /**
     * @private
     * @param {?} nodeLocallySet
     * @param {?} permissionListAdded
     * @return {?}
     */
    NodePermissionService.prototype.getDuplicatedPermissions = /**
     * @private
     * @param {?} nodeLocallySet
     * @param {?} permissionListAdded
     * @return {?}
     */
    function (nodeLocallySet, permissionListAdded) {
        var _this = this;
        /** @type {?} */
        var duplicatePermissions = [];
        if (nodeLocallySet) {
            permissionListAdded.forEach((/**
             * @param {?} permission
             * @return {?}
             */
            function (permission) {
                /** @type {?} */
                var duplicate = nodeLocallySet.find((/**
                 * @param {?} localPermission
                 * @return {?}
                 */
                function (localPermission) { return _this.isEqualPermission(localPermission, permission); }));
                if (duplicate) {
                    duplicatePermissions.push(duplicate);
                }
            }));
        }
        return duplicatePermissions;
    };
    /**
     * @private
     * @param {?} oldPermission
     * @param {?} newPermission
     * @return {?}
     */
    NodePermissionService.prototype.isEqualPermission = /**
     * @private
     * @param {?} oldPermission
     * @param {?} newPermission
     * @return {?}
     */
    function (oldPermission, newPermission) {
        return oldPermission.accessStatus === newPermission.accessStatus &&
            oldPermission.authorityId === newPermission.authorityId &&
            oldPermission.name === newPermission.name;
    };
    /**
     * @private
     * @param {?} nodes
     * @param {?} nodeRole
     * @return {?}
     */
    NodePermissionService.prototype.transformNodeToPermissionElement = /**
     * @private
     * @param {?} nodes
     * @param {?} nodeRole
     * @return {?}
     */
    function (nodes, nodeRole) {
        return nodes.map((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var newPermissionElement = (/** @type {?} */ ({
                'authorityId': node.entry.properties['cm:authorityName'] ?
                    node.entry.properties['cm:authorityName'] :
                    node.entry.properties['cm:userName'],
                'name': nodeRole,
                'accessStatus': 'ALLOWED'
            }));
            return newPermissionElement;
        }));
    };
    /**
     * Removes a permission setting from a node.
     * @param node ID of the target node
     * @param permissionToRemove Permission setting to remove
     * @returns Node with modified permissions
     */
    /**
     * Removes a permission setting from a node.
     * @param {?} node ID of the target node
     * @param {?} permissionToRemove Permission setting to remove
     * @return {?} Node with modified permissions
     */
    NodePermissionService.prototype.removePermission = /**
     * Removes a permission setting from a node.
     * @param {?} node ID of the target node
     * @param {?} permissionToRemove Permission setting to remove
     * @return {?} Node with modified permissions
     */
    function (node, permissionToRemove) {
        /** @type {?} */
        var permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        var index = node.permissions.locallySet.map((/**
         * @param {?} permission
         * @return {?}
         */
        function (permission) { return permission.authorityId; })).indexOf(permissionToRemove.authorityId);
        if (index !== -1) {
            node.permissions.locallySet.splice(index, 1);
            permissionBody.permissions.locallySet = node.permissions.locallySet;
            return this.nodeService.updateNode(node.id, permissionBody);
        }
    };
    /**
     * @private
     * @param {?} siteName
     * @return {?}
     */
    NodePermissionService.prototype.getGroupMembersBySiteName = /**
     * @private
     * @param {?} siteName
     * @return {?}
     */
    function (siteName) {
        var _this = this;
        /** @type {?} */
        var groupName = 'GROUP_site_' + siteName;
        return this.getGroupMemberByGroupName(groupName)
            .pipe(map((/**
         * @param {?} groupMemberPaging
         * @return {?}
         */
        function (groupMemberPaging) {
            /** @type {?} */
            var displayResult = [];
            groupMemberPaging.list.entries.forEach((/**
             * @param {?} member
             * @return {?}
             */
            function (member) {
                displayResult.push(_this.formattedRoleName(member.entry.displayName, 'site_' + siteName));
            }));
            return displayResult;
        })));
    };
    /**
     * Gets all members related to a group name.
     * @param groupName Name of group to look for members
     * @param opts Extra options supported by JS-API
     * @returns List of members
     */
    /**
     * Gets all members related to a group name.
     * @param {?} groupName Name of group to look for members
     * @param {?=} opts Extra options supported by JS-API
     * @return {?} List of members
     */
    NodePermissionService.prototype.getGroupMemberByGroupName = /**
     * Gets all members related to a group name.
     * @param {?} groupName Name of group to look for members
     * @param {?=} opts Extra options supported by JS-API
     * @return {?} List of members
     */
    function (groupName, opts) {
        return from(this.apiService.groupsApi.getGroupMembers(groupName, opts));
    };
    /**
     * @private
     * @param {?} displayName
     * @param {?} siteName
     * @return {?}
     */
    NodePermissionService.prototype.formattedRoleName = /**
     * @private
     * @param {?} displayName
     * @param {?} siteName
     * @return {?}
     */
    function (displayName, siteName) {
        return displayName.replace(siteName + '_', '');
    };
    /**
     * @private
     * @param {?} nodePath
     * @return {?}
     */
    NodePermissionService.prototype.buildRetrieveSiteQueryBody = /**
     * @private
     * @param {?} nodePath
     * @return {?}
     */
    function (nodePath) {
        /** @type {?} */
        var pathNames = nodePath.map((/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return 'name: "' + node.name + '"'; }));
        /** @type {?} */
        var buildedPathNames = pathNames.join(' OR ');
        return {
            'query': {
                'query': buildedPathNames
            },
            'paging': {
                'maxItems': 100,
                'skipCount': 0
            },
            'include': ['aspectNames', 'properties'],
            'filterQueries': [
                {
                    'query': "TYPE:'st:site'"
                }
            ]
        };
    };
    NodePermissionService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NodePermissionService.ctorParameters = function () { return [
        { type: AlfrescoApiService },
        { type: SearchService },
        { type: NodesApiService },
        { type: TranslationService }
    ]; };
    /** @nocollapse */ NodePermissionService.ngInjectableDef = defineInjectable({ factory: function NodePermissionService_Factory() { return new NodePermissionService(inject(AlfrescoApiService), inject(SearchService), inject(NodesApiService), inject(TranslationService)); }, token: NodePermissionService, providedIn: "root" });
    return NodePermissionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PermissionListComponent = /** @class */ (function () {
    function PermissionListComponent(nodeService, nodePermissionService) {
        this.nodeService = nodeService;
        this.nodePermissionService = nodePermissionService;
        /**
         * ID of the node whose permissions you want to show.
         */
        this.nodeId = '';
        /**
         * Emitted when the permission is updated.
         */
        this.update = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    PermissionListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.fetchNodePermissions();
    };
    /**
     * @return {?}
     */
    PermissionListComponent.prototype.reload = /**
     * @return {?}
     */
    function () {
        this.fetchNodePermissions();
    };
    /**
     * @private
     * @return {?}
     */
    PermissionListComponent.prototype.fetchNodePermissions = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.nodeService.getNode(this.nodeId).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            _this.actualNode = node;
            _this.permissionList = _this.getPermissionList(node);
            _this.nodePermissionService.getNodeRoles(node).subscribe((/**
             * @param {?} settableList
             * @return {?}
             */
            function (settableList) {
                _this.settableRoles = settableList;
            }));
        }));
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    PermissionListComponent.prototype.getPermissionList = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var allPermissions = [];
        if (node.permissions.locallySet) {
            node.permissions.locallySet.map((/**
             * @param {?} permissionElement
             * @return {?}
             */
            function (permissionElement) {
                /** @type {?} */
                var permission = new PermissionDisplayModel(permissionElement);
                allPermissions.push(permission);
            }));
        }
        if (node.permissions.inherited) {
            node.permissions.inherited.map((/**
             * @param {?} permissionElement
             * @return {?}
             */
            function (permissionElement) {
                /** @type {?} */
                var permissionInherited = new PermissionDisplayModel(permissionElement);
                permissionInherited.isInherited = true;
                allPermissions.push(permissionInherited);
            }));
        }
        return allPermissions;
    };
    /**
     * @param {?} event
     * @param {?} permissionRow
     * @return {?}
     */
    PermissionListComponent.prototype.saveNewRole = /**
     * @param {?} event
     * @param {?} permissionRow
     * @return {?}
     */
    function (event, permissionRow) {
        var _this = this;
        /** @type {?} */
        var updatedPermissionRole = this.buildUpdatedPermission(event.value, permissionRow);
        this.nodePermissionService.updatePermissionRole(this.actualNode, updatedPermissionRole)
            .subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            _this.update.emit(updatedPermissionRole);
        }));
    };
    /**
     * @private
     * @param {?} newRole
     * @param {?} permissionRow
     * @return {?}
     */
    PermissionListComponent.prototype.buildUpdatedPermission = /**
     * @private
     * @param {?} newRole
     * @param {?} permissionRow
     * @return {?}
     */
    function (newRole, permissionRow) {
        /** @type {?} */
        var permissionRole = {};
        permissionRole.accessStatus = permissionRow.accessStatus;
        permissionRole.name = newRole;
        permissionRole.authorityId = permissionRow.authorityId;
        return permissionRole;
    };
    /**
     * @param {?} permissionRow
     * @return {?}
     */
    PermissionListComponent.prototype.removePermission = /**
     * @param {?} permissionRow
     * @return {?}
     */
    function (permissionRow) {
        var _this = this;
        this.nodePermissionService.removePermission(this.actualNode, permissionRow).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            _this.update.emit(node);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return _this.error.emit(error); }));
    };
    PermissionListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-permission-list',
                    template: "<div id=\"adf-permission-display-container\" class=\"adf-display-permission-container\">\n\n    <div *ngIf=\"!permissionList || !permissionList.length\" id=\"adf-no-permissions-template\">\n        <div #ref>\n            <ng-content select=\"adf-no-permission-template\"></ng-content>\n        </div>\n\n        <p *ngIf=\"ref.children.length == 0\">\n            {{ 'PERMISSION_MANAGER.PERMISSION_DISPLAY.NO_PERMISSIONS' | translate }}\n        </p>\n    </div>\n\n    <adf-datatable [rows]=\"permissionList\" class=\"adf-datatable-permission\" *ngIf=\"permissionList && permissionList.length\">\n        <data-columns>\n            <data-column [class] = \"'adf-key-icon'\" key=\"icon\" type=\"icon\" [sortable]=\"false\">\n            </data-column>\n            <data-column [class]= \"'adf-authorityId-label adf-ellipsis-cell adf-expand-cell-2'\" title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.AUTHORITY_ID' | translate}}\" key=\"authorityId\"></data-column>\n            <data-column [class]=\"'adf-ellipsis-cell adf-expand-cell-1'\" title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.ROLE' | translate}}\" key=\"name\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-form-field *ngIf=\"!entry.row.getValue('isInherited') else show_only_label\">\n                        <mat-select id=\"adf-select-role-permission\"\n                                    [placeholder]=\"entry.data.getValue(entry.row, entry.col)\"\n                                    value=\"{{entry.data.getValue(entry.row, entry.col)}}\"\n                                    (selectionChange)=\"saveNewRole($event, entry.row.obj)\">\n                          <mat-option *ngFor=\"let role of settableRoles\" [value]=\"role\">\n                            {{ role }}\n                          </mat-option>\n                        </mat-select>\n                      </mat-form-field>\n                      <ng-template #show_only_label>\n                          <span>{{entry.data.getValue(entry.row, entry.col)}}</span>\n                      </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column [class]=\"'adf-permission-label'\" title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}\" key=\"isInherited\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-chip-list>\n                        <mat-chip [class]=\"'mat-chip mat-primary mat-standard-chip mat-chip-selected adf-inherited-label '\"\n                                  *ngIf=\"!!entry.data.getValue(entry.row, entry.col) else locally_set_chip\"\n                                id=\"adf-permission-inherited-label\"\n                                color=\"primary\" selected=\"true\">{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}</mat-chip>\n                    </mat-chip-list>\n                    <ng-template #locally_set_chip>\n                            <mat-chip-list [class] = \"'adf-locallyset-label'\">\n                                    <mat-chip id=\"adf-permission-locallyset-label\"\n                                              color=\"accent\" selected=\"true\">\n                                              {{'PERMISSION_MANAGER.PERMISSION_DISPLAY.LOCALLY_SET' | translate}}\n                                    </mat-chip>\n                            </mat-chip-list>\n                    </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column [class]=\"'adf-delete-permission'\" key=\"delete\">\n            <ng-template let-entry=\"$implicit\">\n                <button *ngIf=\"!entry.row.getValue('isInherited')\" mat-icon-button color=\"primary\" (click)=\"removePermission(entry.row.obj)\" data-automation-id=\"adf-delete-permission-button\">\n                    <mat-icon>highlight_off</mat-icon>\n                </button>\n            </ng-template>\n        </data-column>\n        </data-columns>\n    </adf-datatable>\n</div>\n\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    PermissionListComponent.ctorParameters = function () { return [
        { type: NodesApiService },
        { type: NodePermissionService }
    ]; };
    PermissionListComponent.propDecorators = {
        nodeId: [{ type: Input }],
        update: [{ type: Output }],
        error: [{ type: Output }]
    };
    return PermissionListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NoPermissionTemplateComponent = /** @class */ (function () {
    function NoPermissionTemplateComponent() {
    }
    NoPermissionTemplateComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-no-permission-template',
                    template: '<ng-content></ng-content>'
                }] }
    ];
    return NoPermissionTemplateComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var InheritPermissionDirective = /** @class */ (function () {
    function InheritPermissionDirective(nodeService, contentService) {
        this.nodeService = nodeService;
        this.contentService = contentService;
        /**
         * Emitted when the node is updated.
         */
        this.updated = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    InheritPermissionDirective.prototype.onInheritPermissionClicked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.nodeService.getNode(this.nodeId).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            if (_this.contentService.hasAllowableOperations(node, AllowableOperationsEnum.UPDATEPERMISSIONS)) {
                /** @type {?} */
                var nodeBody = { permissions: { isInheritanceEnabled: !node.permissions.isInheritanceEnabled } };
                _this.nodeService.updateNode(_this.nodeId, nodeBody, { include: ['permissions'] }).subscribe((/**
                 * @param {?} nodeUpdated
                 * @return {?}
                 */
                function (nodeUpdated) {
                    _this.updated.emit(nodeUpdated);
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) { return _this.error.emit(error); }));
            }
            else {
                _this.error.emit('PERMISSION_MANAGER.ERROR.NOT-ALLOWED');
            }
        }));
    };
    InheritPermissionDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'button[adf-inherit-permission], mat-button-toggle[adf-inherit-permission]',
                    host: {
                        'role': 'button',
                        '(click)': 'onInheritPermissionClicked()'
                    }
                },] }
    ];
    /** @nocollapse */
    InheritPermissionDirective.ctorParameters = function () { return [
        { type: NodesApiService },
        { type: ContentService }
    ]; };
    InheritPermissionDirective.propDecorators = {
        nodeId: [{ type: Input }],
        updated: [{ type: Output }],
        error: [{ type: Output }]
    };
    return InheritPermissionDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AddPermissionComponent = /** @class */ (function () {
    function AddPermissionComponent(nodePermissionService, nodeApiService, contentService) {
        var _this = this;
        this.nodePermissionService = nodePermissionService;
        this.nodeApiService = nodeApiService;
        this.contentService = contentService;
        /**
         * Emitted when the node is updated successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs during the update.
         */
        this.error = new EventEmitter();
        this.selectedItems = [];
        this.nodeApiService.getNode(this.nodeId).subscribe((/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return _this.currentNode = node; }));
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    AddPermissionComponent.prototype.onSelect = /**
     * @param {?} selection
     * @return {?}
     */
    function (selection) {
        this.selectedItems = selection;
    };
    /**
     * @return {?}
     */
    AddPermissionComponent.prototype.isAddEnabled = /**
     * @return {?}
     */
    function () {
        return this.contentService.hasAllowableOperations(this.currentNode, AllowableOperationsEnum.UPDATEPERMISSIONS) &&
            this.selectedItems.length !== 0;
    };
    /**
     * @return {?}
     */
    AddPermissionComponent.prototype.applySelection = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.contentService.hasAllowableOperations(this.currentNode, AllowableOperationsEnum.UPDATEPERMISSIONS)) {
            this.nodePermissionService.updateNodePermissions(this.nodeId, this.selectedItems)
                .subscribe((/**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                _this.success.emit(node);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                _this.error.emit(error);
            }));
        }
    };
    AddPermissionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-add-permission',
                    template: "<adf-add-permission-panel\n    (select)=\"onSelect($event)\">\n</adf-add-permission-panel>\n<div id=\"adf-add-permission-actions\">\n   <button mat-button\n          id=\"adf-add-permission-action-button\"\n          class=\"adf-permission-action\"\n          [disabled]=\"!isAddEnabled()\"\n          (click)=\"applySelection()\">\n     {{'PERMISSION_MANAGER.ADD-PERMISSION.ADD-ACTION' | translate}}\n    </button>\n</div>\n\n\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    AddPermissionComponent.ctorParameters = function () { return [
        { type: NodePermissionService },
        { type: NodesApiService },
        { type: ContentService }
    ]; };
    AddPermissionComponent.propDecorators = {
        nodeId: [{ type: Input }],
        success: [{ type: Output }],
        error: [{ type: Output }]
    };
    return AddPermissionComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AddPermissionDialogComponent = /** @class */ (function () {
    function AddPermissionDialogComponent(data) {
        this.data = data;
        this.currentSelection = [];
    }
    /**
     * @param {?} items
     * @return {?}
     */
    AddPermissionDialogComponent.prototype.onSelect = /**
     * @param {?} items
     * @return {?}
     */
    function (items) {
        this.currentSelection = items;
    };
    /**
     * @return {?}
     */
    AddPermissionDialogComponent.prototype.onAddClicked = /**
     * @return {?}
     */
    function () {
        this.data.confirm.next(this.currentSelection);
        this.data.confirm.complete();
    };
    AddPermissionDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-add-permission-dialog',
                    template: "<h2 mat-dialog-title id=\"add-permission-dialog-title\">\n    {{(data?.title ? data?.title : 'PERMISSION_MANAGER.ADD-PERMISSION.BASE-DIALOG-TITLE') | translate}}\n</h2>\n<mat-dialog-content>\n    <adf-add-permission-panel\n        (select)=\"onSelect($event)\">\n    </adf-add-permission-panel>\n</mat-dialog-content>\n<mat-dialog-actions>\n    <button mat-button mat-dialog-close id=\"add-permission-dialog-close-button\">{{'PERMISSION_MANAGER.ADD-PERMISSION.CLOSE-ACTION' | translate}}</button>\n    <button mat-button id=\"add-permission-dialog-confirm-button\" [mat-dialog-close]=\"true\"\n            class=\"adf-choose-action\"\n            [disabled]=\"currentSelection?.length === 0\"\n            (click)=\"onAddClicked()\">{{'PERMISSION_MANAGER.ADD-PERMISSION.ADD-ACTION' | translate}}</button>\n</mat-dialog-actions>\n\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    AddPermissionDialogComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
    ]; };
    AddPermissionDialogComponent.propDecorators = {
        addPermissionComponent: [{ type: ViewChild, args: ['addPermission',] }]
    };
    return AddPermissionDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NodePermissionDialogService = /** @class */ (function () {
    function NodePermissionDialogService(dialog, nodePermissionService, contentService) {
        this.dialog = dialog;
        this.nodePermissionService = nodePermissionService;
        this.contentService = contentService;
    }
    /**
     * Opens a dialog to add permissions to a node.
     * @param node ID of the target node
     * @param title Dialog title
     * @returns Node with updated permissions
     */
    /**
     * Opens a dialog to add permissions to a node.
     * @param {?} node ID of the target node
     * @param {?=} title Dialog title
     * @return {?} Node with updated permissions
     */
    NodePermissionDialogService.prototype.openAddPermissionDialog = /**
     * Opens a dialog to add permissions to a node.
     * @param {?} node ID of the target node
     * @param {?=} title Dialog title
     * @return {?} Node with updated permissions
     */
    function (node, title) {
        if (this.contentService.hasAllowableOperations(node, AllowableOperationsEnum.UPDATEPERMISSIONS)) {
            /** @type {?} */
            var confirm_1 = new Subject();
            confirm_1.subscribe({
                complete: this.close.bind(this)
            });
            /** @type {?} */
            var data = {
                nodeId: node.id,
                title: title,
                confirm: confirm_1
            };
            this.openDialog(data, 'adf-add-permission-dialog', '630px');
            return confirm_1;
        }
        else {
            /** @type {?} */
            var errors = new Error(JSON.stringify({ error: { statusCode: 403 } }));
            errors.message = 'PERMISSION_MANAGER.ERROR.NOT-ALLOWED';
            return throwError(errors);
        }
    };
    /**
     * @private
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    NodePermissionDialogService.prototype.openDialog = /**
     * @private
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    function (data, currentPanelClass, chosenWidth) {
        this.dialog.open(AddPermissionDialogComponent, { data: data, panelClass: currentPanelClass, width: chosenWidth });
    };
    /**
     * Closes the currently-open dialog.
     */
    /**
     * Closes the currently-open dialog.
     * @return {?}
     */
    NodePermissionDialogService.prototype.close = /**
     * Closes the currently-open dialog.
     * @return {?}
     */
    function () {
        this.dialog.closeAll();
    };
    /**
     * Opens a dialog to update permissions for a node.
     * @param nodeId ID of the target node
     * @param title Dialog title
     * @returns Node with updated permissions
     */
    /**
     * Opens a dialog to update permissions for a node.
     * @param {?=} nodeId ID of the target node
     * @param {?=} title Dialog title
     * @return {?} Node with updated permissions
     */
    NodePermissionDialogService.prototype.updateNodePermissionByDialog = /**
     * Opens a dialog to update permissions for a node.
     * @param {?=} nodeId ID of the target node
     * @param {?=} title Dialog title
     * @return {?} Node with updated permissions
     */
    function (nodeId, title) {
        var _this = this;
        return this.contentService.getNode(nodeId, { include: ['allowableOperations'] })
            .pipe(switchMap((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return _this.openAddPermissionDialog(node.entry, title)
                .pipe(switchMap((/**
             * @param {?} selection
             * @return {?}
             */
            function (selection) {
                return _this.nodePermissionService.updateNodePermissions(nodeId, selection);
            })));
        })));
    };
    NodePermissionDialogService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NodePermissionDialogService.ctorParameters = function () { return [
        { type: MatDialog },
        { type: NodePermissionService },
        { type: ContentService }
    ]; };
    /** @nocollapse */ NodePermissionDialogService.ngInjectableDef = defineInjectable({ factory: function NodePermissionDialogService_Factory() { return new NodePermissionDialogService(inject(MatDialog$1), inject(NodePermissionService), inject(ContentService)); }, token: NodePermissionDialogService, providedIn: "root" });
    return NodePermissionDialogService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SearchPermissionConfigurationService = /** @class */ (function () {
    function SearchPermissionConfigurationService() {
    }
    /**
     * @param {?} searchTerm
     * @param {?} maxResults
     * @param {?} skipCount
     * @return {?}
     */
    SearchPermissionConfigurationService.prototype.generateQueryBody = /**
     * @param {?} searchTerm
     * @param {?} maxResults
     * @param {?} skipCount
     * @return {?}
     */
    function (searchTerm, maxResults, skipCount) {
        /** @type {?} */
        var defaultQueryBody = {
            query: {
                query: searchTerm ? "authorityName:*" + searchTerm + "* OR userName:*" + searchTerm + "*" : searchTerm
            },
            include: ['properties', 'aspectNames'],
            paging: {
                maxItems: maxResults,
                skipCount: skipCount
            },
            filterQueries: [
                /*tslint:disable-next-line */
                { query: "TYPE:'cm:authority'" }
            ]
        };
        return defaultQueryBody;
    };
    return SearchPermissionConfigurationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AddPermissionPanelComponent = /** @class */ (function () {
    function AddPermissionPanelComponent() {
        var _this = this;
        /**
         * Emitted when a permission list item is selected.
         */
        this.select = new EventEmitter();
        this.searchInput = new FormControl();
        this.searchedWord = '';
        this.debounceSearch = 200;
        this.selectedItems = [];
        this.EVERYONE = new NodeEntry({ entry: { properties: { 'cm:authorityName': 'GROUP_EVERYONE' } } });
        this.searchInput.valueChanges
            .pipe(debounceTime(this.debounceSearch))
            .subscribe((/**
         * @param {?} searchValue
         * @return {?}
         */
        function (searchValue) {
            _this.searchedWord = searchValue;
            if (!searchValue) {
                _this.search.resetResults();
            }
        }));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    AddPermissionPanelComponent.prototype.elementClicked = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.isAlreadySelected(item)) {
            this.selectedItems.splice(this.selectedItems.indexOf(item), 1);
        }
        else {
            this.selectedItems.push(item);
        }
        this.select.emit(this.selectedItems);
    };
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    AddPermissionPanelComponent.prototype.isAlreadySelected = /**
     * @private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.selectedItems.indexOf(item) >= 0;
    };
    /**
     * @return {?}
     */
    AddPermissionPanelComponent.prototype.clearSearch = /**
     * @return {?}
     */
    function () {
        this.searchedWord = '';
        this.selectedItems.splice(0, this.selectedItems.length);
        this.search.resetResults();
    };
    AddPermissionPanelComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-add-permission-panel',
                    template: "<mat-form-field floatPlaceholder=\"never\" class=\"adf-permission-search-input\">\n    <input matInput\n        id=\"searchInput\"\n        [formControl]=\"searchInput\"\n        type=\"text\"\n        placeholder=\"{{'PERMISSION_MANAGER.ADD-PERMISSION.SEARCH' | translate}}\"\n        [value]=\"searchedWord\">\n\n    <mat-icon *ngIf=\"searchedWord?.length > 0\"\n        class=\"adf-permission-search-icon\"\n        data-automation-id=\"adf-permission-clear-input\"\n        id=\"adf-permission-clear-input\"\n        matSuffix (click)=\"clearSearch()\">clear\n    </mat-icon>\n\n    <mat-icon *ngIf=\"searchedWord?.length === 0\"\n        class=\"adf-permission-search-icon\"\n        data-automation-id=\"adf-permission-search-icon\"\n        matSuffix>search\n    </mat-icon>\n</mat-form-field>\n\n<div *ngIf=\"searchedWord?.length === 0\" id=\"adf-add-permission-type-search\">\n    <span class=\"adf-permission-start-message\">{{'PERMISSION_MANAGER.ADD-PERMISSION.TYPE-MESSAGE' | translate}}</span>\n</div>\n\n<adf-search #search [searchTerm]=\"searchedWord\"\n        id=\"adf-add-permission-authority-results\"\n        class=\"adf-permission-result-list\"\n        [class.adf-permission-result-list-search]=\"searchedWord.length === 0\">\n<ng-template let-data>\n    <mat-selection-list class=\"adf-permission-result-list-elements\">\n        <mat-list-option\n            id=\"adf-add-permission-group-everyone\"\n            class=\"adf-list-option-item\"\n            (click)=\"elementClicked(EVERYONE)\">\n            <mat-icon mat-list-icon id=\"add-group-icon\">\n                group_add\n            </mat-icon>\n            <p>\n                {{'PERMISSION_MANAGER.ADD-PERMISSION.EVERYONE' | translate}}\n            </p>\n        </mat-list-option>\n\n        <mat-list-option *ngFor=\"let item of data?.list?.entries; let idx = index\"\n                            (click)=\"elementClicked(item)\"\n                            class=\"adf-list-option-item\"\n                            id=\"result_option_{{idx}}\">\n            <mat-icon mat-list-icon id=\"add-group-icon\"\n                      *ngIf=\"item?.entry?.nodeType === 'cm:authorityContainer' else show_person_icon\">\n                      group_add\n            </mat-icon>\n            <ng-template #show_person_icon>\n                <mat-icon id=\"add-person-icon\" mat-list-icon>person_add</mat-icon>\n            </ng-template>\n            <p>\n             {{item.entry?.properties['cm:authorityName']?\n                                    item.entry?.properties['cm:authorityName'] :\n                                    item.entry?.properties['cm:firstName']}}</p>\n        </mat-list-option>\n    </mat-selection-list>\n</ng-template>\n</adf-search>\n",
                    encapsulation: ViewEncapsulation.None,
                    providers: [
                        { provide: SearchConfigurationService, useClass: SearchPermissionConfigurationService },
                        SearchService
                    ],
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    AddPermissionPanelComponent.ctorParameters = function () { return []; };
    AddPermissionPanelComponent.propDecorators = {
        search: [{ type: ViewChild, args: ['search',] }],
        select: [{ type: Output }]
    };
    return AddPermissionPanelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PermissionManagerModule = /** @class */ (function () {
    function PermissionManagerModule() {
    }
    PermissionManagerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CoreModule.forChild(),
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MaterialModule,
                        SearchModule
                    ],
                    declarations: [
                        PermissionListComponent,
                        NoPermissionTemplateComponent,
                        AddPermissionPanelComponent,
                        InheritPermissionDirective,
                        AddPermissionComponent,
                        AddPermissionDialogComponent
                    ],
                    entryComponents: [
                        AddPermissionPanelComponent,
                        AddPermissionComponent,
                        AddPermissionDialogComponent
                    ],
                    exports: [
                        PermissionListComponent,
                        NoPermissionTemplateComponent,
                        AddPermissionPanelComponent,
                        InheritPermissionDirective,
                        AddPermissionComponent,
                        AddPermissionDialogComponent
                    ]
                },] }
    ];
    return PermissionManagerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ShareDialogComponent = /** @class */ (function () {
    function ShareDialogComponent(sharedLinksApiService, dialogRef, dialog, nodesApiService, contentService, renditionService, data) {
        this.sharedLinksApiService = sharedLinksApiService;
        this.dialogRef = dialogRef;
        this.dialog = dialog;
        this.nodesApiService = nodesApiService;
        this.contentService = contentService;
        this.renditionService = renditionService;
        this.data = data;
        this.subscriptions = [];
        this.minDate = moment$1().add(1, 'd');
        this.isFileShared = false;
        this.isDisabled = false;
        this.form = new FormGroup({
            'sharedUrl': new FormControl(''),
            'time': new FormControl({ value: '', disabled: false })
        });
    }
    /**
     * @return {?}
     */
    ShareDialogComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.canUpdate) {
            this.form.controls['time'].disable();
        }
        this.subscriptions.push(this.form.valueChanges
            .pipe(skip(1), tap((/**
         * @param {?} updates
         * @return {?}
         */
        function (updates) {
            _this.updateNode(updates);
        })))
            .subscribe((/**
         * @param {?} updates
         * @return {?}
         */
        function (updates) { return _this.updateEntryExpiryDate(updates); })));
        if (this.data.node && this.data.node.entry) {
            this.fileName = this.data.node.entry.name;
            this.baseShareUrl = this.data.baseShareUrl;
            /** @type {?} */
            var properties = this.data.node.entry.properties;
            if (properties && !properties['qshare:sharedId']) {
                this.createSharedLinks(this.data.node.entry.id);
            }
            else {
                this.sharedId = properties['qshare:sharedId'];
                this.isFileShared = true;
                this.updateForm();
            }
        }
    };
    /**
     * @return {?}
     */
    ShareDialogComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        function (subscription) { return subscription.unsubscribe; }));
    };
    /**
     * @return {?}
     */
    ShareDialogComponent.prototype.removeShare = /**
     * @return {?}
     */
    function () {
        this.deleteSharedLink(this.sharedId);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ShareDialogComponent.prototype.onSlideShareChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.checked) {
            this.createSharedLinks(this.data.node.entry.id);
        }
        else {
            this.openConfirmationDialog();
        }
    };
    Object.defineProperty(ShareDialogComponent.prototype, "canUpdate", {
        get: /**
         * @return {?}
         */
        function () {
            return this.contentService.hasAllowableOperations(this.data.node.entry, 'update');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    ShareDialogComponent.prototype.openConfirmationDialog = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.isFileShared = false;
        this.dialog
            .open(ConfirmDialogComponent, {
            data: {
                title: 'SHARE.CONFIRMATION.DIALOG-TITLE',
                message: 'SHARE.CONFIRMATION.MESSAGE',
                yesLabel: 'SHARE.CONFIRMATION.REMOVE',
                noLabel: 'SHARE.CONFIRMATION.CANCEL'
            },
            minWidth: '250px',
            closeOnNavigation: true
        })
            .beforeClose().subscribe((/**
         * @param {?} deleteSharedLink
         * @return {?}
         */
        function (deleteSharedLink) {
            if (deleteSharedLink) {
                _this.deleteSharedLink(_this.sharedId);
            }
            else {
                _this.isFileShared = true;
            }
        }));
    };
    /**
     * @private
     * @param {?} nodeId
     * @return {?}
     */
    ShareDialogComponent.prototype.createSharedLinks = /**
     * @private
     * @param {?} nodeId
     * @return {?}
     */
    function (nodeId) {
        var _this = this;
        this.isDisabled = true;
        this.sharedLinksApiService.createSharedLinks(nodeId)
            .subscribe((/**
         * @param {?} sharedLink
         * @return {?}
         */
        function (sharedLink) {
            if (sharedLink.entry) {
                _this.sharedId = sharedLink.entry.id;
                _this.data.node.entry.properties['qshare:sharedId'] = _this.sharedId;
                _this.isDisabled = false;
                _this.isFileShared = true;
                _this.renditionService.generateRenditionForNode(_this.data.node.entry.id).subscribe((/**
                 * @return {?}
                 */
                function () { }));
                _this.updateForm();
            }
        }), (/**
         * @return {?}
         */
        function () {
            _this.isDisabled = false;
            _this.isFileShared = false;
        }));
    };
    /**
     * @private
     * @param {?} sharedId
     * @return {?}
     */
    ShareDialogComponent.prototype.deleteSharedLink = /**
     * @private
     * @param {?} sharedId
     * @return {?}
     */
    function (sharedId) {
        var _this = this;
        this.isDisabled = true;
        this.sharedLinksApiService.deleteSharedLink(sharedId).subscribe((/**
         * @return {?}
         */
        function () {
            _this.data.node.entry.properties['qshare:sharedId'] = null;
            _this.data.node.entry.properties['qshare:expiryDate'] = null;
            _this.dialogRef.close(false);
        }), (/**
         * @return {?}
         */
        function () {
            _this.isDisabled = false;
            _this.isFileShared = false;
        }));
    };
    /**
     * @private
     * @return {?}
     */
    ShareDialogComponent.prototype.updateForm = /**
     * @private
     * @return {?}
     */
    function () {
        var entry = this.data.node.entry;
        /** @type {?} */
        var expiryDate = entry.properties['qshare:expiryDate'];
        this.form.setValue({
            'sharedUrl': "" + this.baseShareUrl + this.sharedId,
            'time': expiryDate ? expiryDate : null
        });
    };
    /**
     * @private
     * @param {?} updates
     * @return {?}
     */
    ShareDialogComponent.prototype.updateNode = /**
     * @private
     * @param {?} updates
     * @return {?}
     */
    function (updates) {
        return this.nodesApiService.updateNode(this.data.node.entry.id, {
            properties: {
                'qshare:expiryDate': updates.time ? updates.time.utc().format() : null
            }
        });
    };
    /**
     * @private
     * @param {?} updates
     * @return {?}
     */
    ShareDialogComponent.prototype.updateEntryExpiryDate = /**
     * @private
     * @param {?} updates
     * @return {?}
     */
    function (updates) {
        var properties = this.data.node.entry.properties;
        properties['qshare:expiryDate'] = updates.time
            ? updates.time.local()
            : null;
    };
    ShareDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-share-dialog',
                    template: "<div class=\"adf-share-link__dialog-content\">\n    <h1 data-automation-id=\"adf-share-dialog-title\"\n        class=\"adf-share-link__title\">\n        {{ 'SHARE.DIALOG-TITLE' | translate }} {{ fileName }}\n    </h1>\n\n    <mat-dialog-content>\n        <p class=\"adf-share-link__info\">{{ 'SHARE.DESCRIPTION' | translate }}</p>\n\n        <div class=\"adf-share-link--row\">\n            <h1 class=\"adf-share-link__label\">{{ 'SHARE.TITLE' | translate }}</h1>\n\n            <mat-slide-toggle\n                color=\"primary\"\n                data-automation-id=\"adf-share-toggle\"\n                [checked]=\"isFileShared\"\n                [disabled]=\"!canUpdate || isDisabled\"\n                (change)=\"onSlideShareChange($event)\">\n            </mat-slide-toggle>\n        </div>\n\n        <form [formGroup]=\"form\">\n            <mat-form-field class=\"adf-full-width\">\n                <input #sharedLinkInput\n                    data-automation-id=\"adf-share-link\"\n                    class=\"adf-share-link__input\"\n                    matInput\n                    cdkFocusInitial\n                    placeholder=\"{{ 'SHARE.PUBLIC-LINK' | translate }}\"\n                    formControlName=\"sharedUrl\"\n                    readonly=\"readonly\">\n                    <mat-icon class=\"adf-input-action\" matSuffix\n                          [clipboard-notification]=\"'SHARE.CLIPBOARD-MESSAGE' | translate\"\n                          [adf-clipboard] [target]=\"sharedLinkInput\">\n                        link\n                    </mat-icon>\n            </mat-form-field>\n\n            <h1 class=\"adf-share-link__label\">{{ 'SHARE.EXPIRES' | translate }}</h1>\n            <mat-form-field class=\"adf-full-width\">\n                <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\n                <mat-datetimepicker #datetimePicker type=\"datetime\" openOnFocus=\"true\" timeInterval=\"1\"></mat-datetimepicker>\n                <input class=\"adf-share-link__input\"\n                    matInput\n                    [min]=\"minDate\"\n                    formControlName=\"time\"\n                    [matDatetimepicker]=\"datetimePicker\">\n            </mat-form-field>\n        </form>\n    </mat-dialog-content>\n\n    <div mat-dialog-actions>\n        <button\n            data-automation-id=\"adf-share-dialog-close\"\n            mat-button color=\"primary\" mat-dialog-close>\n            {{ 'SHARE.CLOSE' | translate }}\n        </button>\n    </div>\n</div>\n",
                    host: { 'class': 'adf-share-dialog' },
                    encapsulation: ViewEncapsulation.None,
                    styles: [".adf-share-link-dialog .adf-share-link__dialog-content{display:flex;flex-direction:column}.adf-share-link-dialog .adf-share-link__label{letter-spacing:-.4px;line-height:2;font-weight:400;font-style:normal;font-stretch:normal;font-size:16px;opacity:.87;flex:1 1 auto}.adf-share-link-dialog .adf-share-link__title{letter-spacing:-.4px;line-height:2;font-weight:400;font-style:normal;font-stretch:normal;font-size:16px;opacity:.87}.adf-share-link-dialog .adf-share-link__info{letter-spacing:-.4px;line-height:2;font-weight:400;font-style:normal;font-stretch:normal;opacity:.87;opacity:.54;font-size:13px}.adf-share-link-dialog .adf-share-link--row{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center}.adf-share-link-dialog .adf-share-link__input{opacity:.54}.adf-share-link-dialog .adf-input-action{cursor:pointer}.adf-share-link-dialog .adf-full-width{width:100%}.adf-share-link-dialog .mat-form-field-infix{border-top:unset}.adf-share-link-dialog .mat-dialog-actions{justify-content:flex-end}.adf-share-link-dialog .mat-dialog-actions>button{text-transform:uppercase}.adf-share-link-dialog .mat-form-field-flex{align-items:center}"]
                }] }
    ];
    /** @nocollapse */
    ShareDialogComponent.ctorParameters = function () { return [
        { type: SharedLinksApiService },
        { type: MatDialogRef },
        { type: MatDialog },
        { type: NodesApiService },
        { type: ContentService },
        { type: RenditionsService },
        { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
    ]; };
    ShareDialogComponent.propDecorators = {
        sharedLinkInput: [{ type: ViewChild, args: ['sharedLinkInput',] }]
    };
    return ShareDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NodeSharedDirective = /** @class */ (function () {
    function NodeSharedDirective(dialog, zone) {
        this.dialog = dialog;
        this.zone = zone;
        this.isFile = false;
        this.isShared = false;
    }
    /**
     * @return {?}
     */
    NodeSharedDirective.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (this.node) {
            this.shareNode(this.node);
        }
    };
    /**
     * @param {?} nodeEntry
     * @return {?}
     */
    NodeSharedDirective.prototype.shareNode = /**
     * @param {?} nodeEntry
     * @return {?}
     */
    function (nodeEntry) {
        if (nodeEntry && nodeEntry.entry && nodeEntry.entry.isFile) {
            this.dialog.open(ShareDialogComponent, {
                width: '600px',
                panelClass: 'adf-share-link-dialog',
                data: {
                    node: nodeEntry,
                    baseShareUrl: this.baseShareUrl
                }
            });
        }
    };
    /**
     * @return {?}
     */
    NodeSharedDirective.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.onStable.subscribe((/**
         * @return {?}
         */
        function () {
            if (_this.node && _this.node.entry) {
                _this.isFile = _this.node.entry.isFile;
                _this.isShared = _this.node.entry.properties['qshare:sharedId'];
            }
        }));
    };
    NodeSharedDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[adf-share]',
                    exportAs: 'adfShare'
                },] }
    ];
    /** @nocollapse */
    NodeSharedDirective.ctorParameters = function () { return [
        { type: MatDialog },
        { type: NgZone }
    ]; };
    NodeSharedDirective.propDecorators = {
        node: [{ type: Input, args: ['adf-share',] }],
        baseShareUrl: [{ type: Input }],
        onClick: [{ type: HostListener, args: ['click',] }]
    };
    return NodeSharedDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentNodeShareModule = /** @class */ (function () {
    function ContentNodeShareModule() {
    }
    /**
     * @return {?}
     */
    ContentNodeShareModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: ContentNodeShareModule
        };
    };
    /**
     * @return {?}
     */
    ContentNodeShareModule.forChild = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: ContentNodeShareModule
        };
    };
    ContentNodeShareModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CoreModule.forChild(),
                        CommonModule,
                        MaterialModule
                    ],
                    declarations: [
                        ShareDialogComponent,
                        NodeSharedDirective
                    ],
                    exports: [
                        ShareDialogComponent,
                        NodeSharedDirective
                    ],
                    entryComponents: [
                        ShareDialogComponent
                    ]
                },] }
    ];
    return ContentNodeShareModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeBaseNode = /** @class */ (function () {
    function TreeBaseNode(nodeEntry, level, expandable) {
        this.expandable = true;
        this.name = nodeEntry.entry.name;
        this.nodeId = nodeEntry.entry.id;
        this.level = level ? level : 0;
        this.expandable = expandable ? expandable : true;
        this.node = nodeEntry ? new NodeEntry(nodeEntry) : undefined;
    }
    return TreeBaseNode;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeViewService = /** @class */ (function () {
    function TreeViewService(nodeApi) {
        this.nodeApi = nodeApi;
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    TreeViewService.prototype.getTreeNodes = /**
     * @param {?} nodeId
     * @return {?}
     */
    function (nodeId) {
        return this.nodeApi.getNodeChildren(nodeId)
            .pipe(map((/**
         * @param {?} nodePage
         * @return {?}
         */
        function (nodePage) {
            return nodePage.list.entries.filter((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return node.entry.isFolder ? node : null; }));
        })), map((/**
         * @param {?} nodes
         * @return {?}
         */
        function (nodes) { return nodes.map((/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return new TreeBaseNode(node); })); })));
    };
    TreeViewService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    TreeViewService.ctorParameters = function () { return [
        { type: NodesApiService }
    ]; };
    /** @nocollapse */ TreeViewService.ngInjectableDef = defineInjectable({ factory: function TreeViewService_Factory() { return new TreeViewService(inject(NodesApiService)); }, token: TreeViewService, providedIn: "root" });
    return TreeViewService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeViewDataSource = /** @class */ (function () {
    function TreeViewDataSource(treeControl, treeViewService) {
        var _this = this;
        this.treeControl = treeControl;
        this.treeViewService = treeViewService;
        this.dataChange = new BehaviorSubject([]);
        this.childrenSubscription = null;
        this.changeSubscription = null;
        this.dataChange.subscribe((/**
         * @param {?} treeNodes
         * @return {?}
         */
        function (treeNodes) { return _this.treeNodes = treeNodes; }));
    }
    Object.defineProperty(TreeViewDataSource.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this.treeNodes;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.treeControl.dataNodes = value;
            this.dataChange.next(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} collectionViewer
     * @return {?}
     */
    TreeViewDataSource.prototype.connect = /**
     * @param {?} collectionViewer
     * @return {?}
     */
    function (collectionViewer) {
        var _this = this;
        this.changeSubscription = this.treeControl.expansionModel.onChange.subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            if (((/** @type {?} */ (change))).added &&
                ((/** @type {?} */ (change))).added.length > 0) {
                _this.expandTreeNodes((/** @type {?} */ (change)));
            }
            else if (((/** @type {?} */ (change))).removed) {
                _this.reduceTreeNodes((/** @type {?} */ (change)));
            }
        }));
        return merge(collectionViewer.viewChange, this.dataChange).pipe(map((/**
         * @return {?}
         */
        function () { return _this.data; })));
    };
    /**
     * @return {?}
     */
    TreeViewDataSource.prototype.disconnect = /**
     * @return {?}
     */
    function () {
        if (this.childrenSubscription) {
            this.childrenSubscription.unsubscribe();
        }
        if (this.changeSubscription) {
            this.changeSubscription.unsubscribe();
        }
    };
    /**
     * @private
     * @param {?} change
     * @return {?}
     */
    TreeViewDataSource.prototype.expandTreeNodes = /**
     * @private
     * @param {?} change
     * @return {?}
     */
    function (change) {
        var _this = this;
        change.added.forEach((/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return _this.expandNode(node); }));
    };
    /**
     * @private
     * @param {?} change
     * @return {?}
     */
    TreeViewDataSource.prototype.reduceTreeNodes = /**
     * @private
     * @param {?} change
     * @return {?}
     */
    function (change) {
        var _this = this;
        change.removed.slice().reverse().forEach((/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return _this.toggleNode(node); }));
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    TreeViewDataSource.prototype.expandNode = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        this.childrenSubscription = this.treeViewService.getTreeNodes(node.nodeId)
            .subscribe((/**
         * @param {?} children
         * @return {?}
         */
        function (children) {
            var _a;
            /** @type {?} */
            var index = _this.data.indexOf(node);
            if (!children || index < 0) {
                node.expandable = false;
                return;
            }
            /** @type {?} */
            var nodes = children.map((/**
             * @param {?} actualNode
             * @return {?}
             */
            function (actualNode) {
                actualNode.level = node.level + 1;
                return actualNode;
            }));
            (_a = _this.data).splice.apply(_a, __spread([index + 1, 0], nodes));
            _this.dataChange.next(_this.data);
        }));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    TreeViewDataSource.prototype.toggleNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var index = this.data.indexOf(node);
        /** @type {?} */
        var count = 0;
        for (var i = index + 1; i < this.data.length
            && this.data[i].level > node.level; i++, count++) { }
        this.data.splice(index + 1, count);
        this.dataChange.next(this.data);
    };
    TreeViewDataSource.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    TreeViewDataSource.ctorParameters = function () { return [
        { type: FlatTreeControl },
        { type: TreeViewService }
    ]; };
    return TreeViewDataSource;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeViewComponent = /** @class */ (function () {
    function TreeViewComponent(treeViewService) {
        this.treeViewService = treeViewService;
        /**
         * Emitted when a node in the tree view is clicked.
         */
        this.nodeClicked = new EventEmitter();
        /**
         * Emitted when an invalid node id is given.
         */
        this.error = new EventEmitter();
        this.getLevel = (/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return node.level; });
        this.isExpandable = (/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return node.expandable; });
        this.hasChild = (/**
         * @param {?} level
         * @param {?} nodeData
         * @return {?}
         */
        function (level, nodeData) { return nodeData.expandable; });
        this.treeControl = new FlatTreeControl(this.getLevel, this.isExpandable);
        this.dataSource = new TreeViewDataSource(this.treeControl, this.treeViewService);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    TreeViewComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['nodeId'] && changes['nodeId'].currentValue &&
            changes['nodeId'].currentValue !== changes['nodeId'].previousValue) {
            this.loadTreeNode();
        }
        else {
            this.dataSource.data = [];
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    TreeViewComponent.prototype.onNodeClicked = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.nodeClicked.emit(node);
    };
    /**
     * @private
     * @return {?}
     */
    TreeViewComponent.prototype.loadTreeNode = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.treeViewService.getTreeNodes(this.nodeId)
            .subscribe((/**
         * @param {?} treeNode
         * @return {?}
         */
        function (treeNode) {
            _this.dataSource.data = treeNode;
        }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return _this.error.emit(error); }));
    };
    TreeViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-tree-view-list',
                    template: "<mat-tree class=\"adf-tree-view-main\" [dataSource]=\"dataSource\"\n          [treeControl]=\"treeControl\" *ngIf=\"nodeId; else missingNodeId\">\n    <mat-tree-node class=\"adf-tree-view-node\"\n        *matTreeNodeDef=\"let treeNode\" id=\"{{treeNode.name + '-tree-node'}}\"\n        matTreeNodePadding [matTreeNodePaddingIndent]=\"15\">\n        {{treeNode.name}}\n    </mat-tree-node>\n    <mat-tree-node class=\"adf-tree-view-node\"\n        id=\"{{treeNode.name + '-tree-child-node'}}\" *matTreeNodeDef=\"let treeNode; when: hasChild\"\n        matTreeNodePadding [matTreeNodePaddingIndent]=\"15\">\n        <button id=\"{{'button-'+treeNode.name}}\" (click)=\"onNodeClicked(treeNode.node)\"\n                mat-icon-button [attr.aria-label]=\"'toggle ' + treeNode.filename\" matTreeNodeToggle>\n            <mat-icon class=\"adf-tree-view-icon\">\n                {{treeControl.isExpanded(treeNode) ? 'folder_open' : 'folder'}}\n            </mat-icon>\n        </button>\n        {{treeNode.name}}\n    </mat-tree-node>\n</mat-tree>\n<ng-template #missingNodeId>\n    <div id=\"adf-tree-view-missing-node\">\n        {{'ADF-TREE-VIEW.MISSING-ID' | translate}}\n    </div>\n</ng-template>\n",
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    TreeViewComponent.ctorParameters = function () { return [
        { type: TreeViewService }
    ]; };
    TreeViewComponent.propDecorators = {
        nodeId: [{ type: Input }],
        nodeClicked: [{ type: Output }],
        error: [{ type: Output }]
    };
    return TreeViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeViewModule = /** @class */ (function () {
    function TreeViewModule() {
    }
    TreeViewModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        MaterialModule,
                        TranslateModule.forChild()
                    ],
                    declarations: [
                        TreeViewComponent
                    ],
                    exports: [
                        TreeViewComponent
                    ]
                },] }
    ];
    return TreeViewModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ContentModuleLazy = /** @class */ (function () {
    function ContentModuleLazy() {
    }
    ContentModuleLazy.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CoreModule.forChild(),
                        SocialModule,
                        TagModule,
                        CommonModule,
                        WebScriptModule,
                        FormsModule,
                        ReactiveFormsModule,
                        DialogModule,
                        SearchModule,
                        DocumentListModule,
                        UploadModule,
                        MaterialModule,
                        SitesDropdownModule,
                        BreadcrumbModule,
                        ContentNodeSelectorModule,
                        ContentNodeShareModule,
                        ContentMetadataModule,
                        FolderDirectiveModule,
                        ContentDirectiveModule,
                        PermissionManagerModule,
                        VersionManagerModule,
                        TreeViewModule
                    ],
                    exports: [
                        SocialModule,
                        TagModule,
                        WebScriptModule,
                        DocumentListModule,
                        UploadModule,
                        SearchModule,
                        SitesDropdownModule,
                        BreadcrumbModule,
                        ContentNodeSelectorModule,
                        ContentNodeShareModule,
                        ContentMetadataModule,
                        DialogModule,
                        FolderDirectiveModule,
                        ContentDirectiveModule,
                        PermissionManagerModule,
                        VersionManagerModule,
                        TreeViewModule
                    ]
                },] }
    ];
    return ContentModuleLazy;
}());
var ɵ0$2 = {
    name: 'adf-content-services',
    source: 'assets/adf-content-services'
};
var ContentModule = /** @class */ (function () {
    function ContentModule() {
    }
    /**
     * @return {?}
     */
    ContentModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: ContentModule,
            providers: [
                {
                    provide: TRANSLATION_PROVIDER,
                    multi: true,
                    useValue: {
                        name: 'adf-content-services',
                        source: 'assets/adf-content-services'
                    }
                }
            ]
        };
    };
    /**
     * @return {?}
     */
    ContentModule.forChild = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: ContentModuleLazy
        };
    };
    ContentModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CoreModule.forChild(),
                        SocialModule,
                        TagModule,
                        CommonModule,
                        WebScriptModule,
                        FormsModule,
                        ReactiveFormsModule,
                        DialogModule,
                        SearchModule,
                        DocumentListModule,
                        UploadModule,
                        MaterialModule,
                        SitesDropdownModule,
                        BreadcrumbModule,
                        ContentNodeSelectorModule,
                        ContentNodeShareModule,
                        ContentMetadataModule,
                        FolderDirectiveModule,
                        ContentDirectiveModule,
                        PermissionManagerModule,
                        VersionManagerModule,
                        TreeViewModule
                    ],
                    providers: [
                        {
                            provide: TRANSLATION_PROVIDER,
                            multi: true,
                            useValue: ɵ0$2
                        }
                    ],
                    exports: [
                        SocialModule,
                        TagModule,
                        WebScriptModule,
                        DocumentListModule,
                        UploadModule,
                        SearchModule,
                        SitesDropdownModule,
                        BreadcrumbModule,
                        ContentNodeSelectorModule,
                        ContentNodeShareModule,
                        ContentMetadataModule,
                        DialogModule,
                        FolderDirectiveModule,
                        ContentDirectiveModule,
                        PermissionManagerModule,
                        VersionManagerModule,
                        TreeViewModule
                    ]
                },] }
    ];
    return ContentModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ContentDirectiveModule, RatingComponent, LikeComponent, RatingService, SocialModule, TagActionsComponent, TagListComponent, TagNodeListComponent, TagService, TagModule, WebscriptComponent, WebScriptModule, DocumentListComponent, NodeEntityEvent, NodeEntryEvent, ContentColumnComponent, ContentColumnListComponent, ContentActionComponent, ContentActionListComponent, LibraryNameColumnComponent, LibraryRoleColumnComponent, LibraryStatusColumnComponent, NameColumnComponent, TrashcanNameColumnComponent, ShareDataTableAdapter, ShareDataRow, FolderActionsService, DocumentActionsService, DocumentListService, NodeActionsService, CustomResourcesService, ContentActionModel, ContentActionTarget, DocumentActionModel, FolderActionModel, NodePaging, NodePagingList, NodeMinimalEntry, Pagination$1 as Pagination, NodeMinimal, UserInfo, ContentInfo, PathInfoEntity, PathElementEntity, PermissionModel, PermissionStyleModel, DocumentListModule, UploadButtonComponent, UploadVersionButtonComponent, FileUploadingDialogComponent, UploadDragAreaComponent, FileUploadingListComponent, FileUploadingListRowComponent, UploadFilesEvent, FileDraggableDirective, FileUploadErrorPipe, UploadBase, UploadModule, SearchQueryBuilderService, SearchComponent, SearchControlComponent, SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR, SearchTriggerDirective, EmptySearchResultComponent, SearchFilterComponent, SearchFilterService, SearchChipListComponent, SearchSortingPickerComponent, ALFRESCO_SEARCH_DIRECTIVES, SearchModule, Relations, DropdownSitesComponent, SitesDropdownModule, BreadcrumbComponent, DropdownBreadcrumbComponent, BreadcrumbModule, VersionListComponent, VersionManagerComponent, VersionUploadComponent, VersionManagerModule, NameLocationCellComponent, ContentNodeSelectorPanelComponent, ContentNodeSelectorComponent, ContentNodeSelectorService, ContentNodeDialogService, ContentNodeSelectorModule, FolderDialogComponent, NodeLockDialogComponent, ConfirmDialogComponent, DialogModule, LibraryDialogComponent, forbidSpecialCharacters, forbidEndingDot, forbidOnlySpaces, FolderCreateDirective, FolderEditDirective, FolderDirectiveModule, ContentMetadataCardComponent, BasicPropertiesService, ContentMetadataService, PropertyDescriptorsService, PropertyGroupTranslatorService, ContentMetadataConfigFactory, IndifferentConfigService, LayoutOrientedConfigService, AspectOrientedConfigService, ContentMetadataModule, PermissionListComponent, NoPermissionTemplateComponent, InheritPermissionDirective, PermissionDisplayModel, NodePermissionDialogService, NodePermissionService, AddPermissionPanelComponent, AddPermissionComponent, AddPermissionDialogComponent, PermissionManagerModule, ShareDialogComponent, NodeSharedDirective, ContentNodeShareModule, TreeViewModule, TreeViewComponent, TreeViewDataSource, TreeBaseNode, TreeViewService, ContentModuleLazy, ContentModule, ContentMetadataComponent as ɵk, NodeLockDirective as ɵc, MaterialModule as ɵb, modules as ɵa, SearchPermissionConfigurationService as ɵl, SearchCheckListComponent as ɵi, SearchDateRangeComponent as ɵj, SearchNumberRangeComponent as ɵh, SearchRadioComponent as ɵf, SearchSliderComponent as ɵg, SearchTextComponent as ɵe, SearchWidgetContainerComponent as ɵd };

//# sourceMappingURL=adf-content-services.js.map