/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AppsProcessService } from '@alfresco/adf-core';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { FilterParamsModel } from '../models/filter.model';
import { TaskFilterService } from './../services/task-filter.service';
import { TaskListService } from './../services/tasklist.service';
import { IconModel } from '../../app-list/icon.model';
export class TaskFiltersComponent {
    /**
     * @param {?} taskFilterService
     * @param {?} taskListService
     * @param {?} appsProcessService
     */
    constructor(taskFilterService, taskListService, appsProcessService) {
        this.taskFilterService = taskFilterService;
        this.taskListService = taskListService;
        this.appsProcessService = appsProcessService;
        /**
         * Emitted when a filter in the list is clicked.
         */
        this.filterClick = new EventEmitter();
        /**
         * Emitted when the list is loaded.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs during loading.
         */
        this.error = new EventEmitter();
        this.filters = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconsMDL = new IconModel();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const appName = changes['appName'];
        /** @type {?} */
        const appId = changes['appId'];
        /** @type {?} */
        const filter = changes['filterParam'];
        if (appName && appName.currentValue) {
            this.getFiltersByAppName(appName.currentValue);
        }
        else if (appId && appId.currentValue !== appId.previousValue) {
            this.getFiltersByAppId(appId.currentValue);
        }
        else if (filter && filter.currentValue !== filter.previousValue) {
            this.selectFilter(filter.currentValue);
        }
    }
    /**
     * Return the task list filtered by appId or by appName
     * @param {?=} appId
     * @param {?=} appName
     * @return {?}
     */
    getFilters(appId, appName) {
        appName ? this.getFiltersByAppName(appName) : this.getFiltersByAppId(appId);
    }
    /**
     * Return the filter list filtered by appId
     * @param {?=} appId - optional
     * @return {?}
     */
    getFiltersByAppId(appId) {
        this.taskFilterService.getTaskListFilters(appId).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            if (res.length === 0 && this.isFilterListEmpty()) {
                this.createFiltersByAppId(appId);
            }
            else {
                this.resetFilter();
                this.filters = res;
                this.selectFilter(this.filterParam);
                this.success.emit(res);
            }
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * Return the filter list filtered by appName
     * @param {?} appName
     * @return {?}
     */
    getFiltersByAppName(appName) {
        this.appsProcessService.getDeployedApplicationsByName(appName).subscribe((/**
         * @param {?} application
         * @return {?}
         */
        (application) => {
            this.getFiltersByAppId(application.id);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * Create default filters by appId
     * @param {?=} appId
     * @return {?}
     */
    createFiltersByAppId(appId) {
        this.taskFilterService.createDefaultFilters(appId).subscribe((/**
         * @param {?} resDefault
         * @return {?}
         */
        (resDefault) => {
            this.resetFilter();
            this.filters = resDefault;
            this.selectFilter(this.filterParam);
            this.success.emit(resDefault);
        }), (/**
         * @param {?} errDefault
         * @return {?}
         */
        (errDefault) => {
            this.error.emit(errDefault);
        }));
    }
    /**
     * Pass the selected filter as next
     * @param {?} newFilter
     * @return {?}
     */
    selectFilter(newFilter) {
        if (newFilter) {
            this.currentFilter = this.filters.find((/**
             * @param {?} filter
             * @param {?} index
             * @return {?}
             */
            (filter, index) => newFilter.index === index ||
                newFilter.id === filter.id ||
                (newFilter.name &&
                    (newFilter.name.toLocaleLowerCase() === filter.name.toLocaleLowerCase()))));
        }
        if (!this.currentFilter) {
            this.selectDefaultTaskFilter();
        }
    }
    /**
     * @param {?} newFilter
     * @return {?}
     */
    selectFilterAndEmit(newFilter) {
        this.selectFilter(newFilter);
        this.filterClick.emit(this.currentFilter);
    }
    /**
     * Select filter with task
     * @param {?} taskId
     * @return {?}
     */
    selectFilterWithTask(taskId) {
        /** @type {?} */
        const filteredFilterList = [];
        this.taskListService.getFilterForTaskById(taskId, this.filters).subscribe((/**
         * @param {?} filter
         * @return {?}
         */
        (filter) => {
            filteredFilterList.push(filter);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }), (/**
         * @return {?}
         */
        () => {
            if (filteredFilterList.length > 0) {
                this.selectFilter(filteredFilterList[0]);
                this.filterClick.emit(this.currentFilter);
            }
        }));
    }
    /**
     * Select as default task filter the first in the list
     * @return {?}
     */
    selectDefaultTaskFilter() {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
        }
    }
    /**
     * Return the current task
     * @return {?}
     */
    getCurrentFilter() {
        return this.currentFilter;
    }
    /**
     * Check if the filter list is empty
     * @return {?}
     */
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    /**
     * Reset the filters properties
     * @private
     * @return {?}
     */
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
    /**
     * Return current filter icon
     * @param {?} icon
     * @return {?}
     */
    getFilterIcon(icon) {
        return this.iconsMDL.mapGlyphiconToMaterialDesignIcons(icon);
    }
}
TaskFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-filters',
                template: "<div class=\"menu-container\">\n    <mat-list class=\"adf-menu-list\">\n        <mat-list-item (click)=\"selectFilterAndEmit(filter)\" *ngFor=\"let filter of filters\"\n                      class=\"adf-filters__entry\" [class.adf-active]=\"currentFilter === filter\">\n            <mat-icon *ngIf=\"showIcon\" matListIcon class=\"adf-filters__entry-icon\">{{getFilterIcon(filter.icon)}}</mat-icon>\n            <span matLine [attr.data-automation-id]=\"filter.name + '_filter'\">{{filter.name}}</span>\n        </mat-list-item>\n    </mat-list>\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
TaskFiltersComponent.ctorParameters = () => [
    { type: TaskFilterService },
    { type: TaskListService },
    { type: AppsProcessService }
];
TaskFiltersComponent.propDecorators = {
    filterParam: [{ type: Input }],
    filterClick: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    appId: [{ type: Input }],
    appName: [{ type: Input }],
    showIcon: [{ type: Input }]
};
if (false) {
    /**
     * Parameters to use for the task filter. If there is no match then
     * the default filter (the first one the list) is selected.
     * @type {?}
     */
    TaskFiltersComponent.prototype.filterParam;
    /**
     * Emitted when a filter in the list is clicked.
     * @type {?}
     */
    TaskFiltersComponent.prototype.filterClick;
    /**
     * Emitted when the list is loaded.
     * @type {?}
     */
    TaskFiltersComponent.prototype.success;
    /**
     * Emitted when an error occurs during loading.
     * @type {?}
     */
    TaskFiltersComponent.prototype.error;
    /**
     * Display filters available to the current user for the application with the specified ID.
     * @type {?}
     */
    TaskFiltersComponent.prototype.appId;
    /**
     * Display filters available to the current user for the application with the specified name.
     * @type {?}
     */
    TaskFiltersComponent.prototype.appName;
    /**
     * Toggles display of the filter's icon.
     * @type {?}
     */
    TaskFiltersComponent.prototype.showIcon;
    /** @type {?} */
    TaskFiltersComponent.prototype.filter$;
    /** @type {?} */
    TaskFiltersComponent.prototype.currentFilter;
    /** @type {?} */
    TaskFiltersComponent.prototype.filters;
    /**
     * @type {?}
     * @private
     */
    TaskFiltersComponent.prototype.iconsMDL;
    /**
     * @type {?}
     * @private
     */
    TaskFiltersComponent.prototype.taskFilterService;
    /**
     * @type {?}
     * @private
     */
    TaskFiltersComponent.prototype.taskListService;
    /**
     * @type {?}
     * @private
     */
    TaskFiltersComponent.prototype.appsProcessService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFzay1maWx0ZXJzLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtcHJvY2Vzcy1zZXJ2aWNlcy8iLCJzb3VyY2VzIjpbInRhc2stbGlzdC9jb21wb25lbnRzL3Rhc2stZmlsdGVycy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDeEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFxQixNQUFNLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBRXpHLE9BQU8sRUFBRSxpQkFBaUIsRUFBNkIsTUFBTSx3QkFBd0IsQ0FBQztBQUN0RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN0RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDakUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBT3RELE1BQU0sT0FBTyxvQkFBb0I7Ozs7OztJQXdDN0IsWUFBb0IsaUJBQW9DLEVBQ3BDLGVBQWdDLEVBQ2hDLGtCQUFzQztRQUZ0QyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQ3BDLG9CQUFlLEdBQWYsZUFBZSxDQUFpQjtRQUNoQyx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9COzs7O1FBaEMxRCxnQkFBVyxHQUE0QyxJQUFJLFlBQVksRUFBNkIsQ0FBQzs7OztRQUlyRyxZQUFPLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7Ozs7UUFJckQsVUFBSyxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBa0JuRCxZQUFPLEdBQWlDLEVBQUUsQ0FBQztJQU8zQyxDQUFDOzs7O0lBRUQsUUFBUTtRQUNKLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQztJQUNwQyxDQUFDOzs7OztJ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c0JBSU4sTUFBTTtvQkFJTixNQUFNO29CQUlOLEtBQUs7c0JBSUwsS0FBSzt1QkFJTCxLQUFLOzs7Ozs7OztJQXhCTiwyQ0FDK0I7Ozs7O0lBRy9CLDJDQUNxRzs7Ozs7SUFHckcsdUNBQ3FEOzs7OztJQUdyRCxxQ0FDbUQ7Ozs7O0lBR25ELHFDQUNjOzs7OztJQUdkLHVDQUNnQjs7Ozs7SUFHaEIsd0NBQ2tCOztJQUVsQix1Q0FBK0M7O0lBRS9DLDZDQUF5Qzs7SUFFekMsdUNBQTJDOzs7OztJQUUzQyx3Q0FBNEI7Ozs7O0lBRWhCLGlEQUE0Qzs7Ozs7SUFDNUMsK0NBQXdDOzs7OztJQUN4QyxrREFBOEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBcHBzUHJvY2Vzc1NlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBGaWx0ZXJQYXJhbXNNb2RlbCwgRmlsdGVyUmVwcmVzZW50YXRpb25Nb2RlbCB9IGZyb20gJy4uL21vZGVscy9maWx0ZXIubW9kZWwnO1xuaW1wb3J0IHsgVGFza0ZpbHRlclNlcnZpY2UgfSBmcm9tICcuLy4uL3NlcnZpY2VzL3Rhc2stZmlsdGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFza0xpc3RTZXJ2aWNlIH0gZnJvbSAnLi8uLi9zZXJ2aWNlcy90YXNrbGlzdC5zZXJ2aWNlJztcbmltcG9ydCB7IEljb25Nb2RlbCB9IGZyb20gJy4uLy4uL2FwcC1saXN0L2ljb24ubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi10YXNrLWZpbHRlcnMnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi90YXNrLWZpbHRlcnMuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWyd0YXNrLWZpbHRlcnMuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBUYXNrRmlsdGVyc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcblxuICAgIC8qKiBQYXJhbWV0ZXJzIHRvIHVzZSBmb3IgdGhlIHRhc2sgZmlsdGVyLiBJZiB0aGVyZSBpcyBubyBtYXRjaCB0aGVuXG4gICAgICogdGhlIGRlZmF1bHQgZmlsdGVyICh0aGUgZmlyc3Qgb25lIHRoZSBsaXN0KSBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZpbHRlclBhcmFtOiBGaWx0ZXJQYXJhbXNNb2RlbDtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYSBmaWx0ZXIgaW4gdGhlIGxpc3QgaXMgY2xpY2tlZC4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBmaWx0ZXJDbGljazogRXZlbnRFbWl0dGVyPEZpbHRlclJlcHJlc2VudGF0aW9uTW9kZWw+ID0gbmV3IEV2ZW50RW1pdHRlcjxGaWx0ZXJSZXByZXNlbnRhdGlvbk1vZGVsPigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgbGlzdCBpcyBsb2FkZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgc3VjY2VzczogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBsb2FkaW5nLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIERpc3BsYXkgZmlsdGVycyBhdmFpbGFibGUgdG8gdGhlIGN1cnJlbnQgdXNlciBmb3IgdGhlIGFwcGxpY2F0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBJRC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcElkOiBudW1iZXI7XG5cbiAgICAvKiogRGlzcGxheSBmaWx0ZXJzIGF2YWlsYWJsZSB0byB0aGUgY3VycmVudCB1c2VyIGZvciB0aGUgYXBwbGljYXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuICovXG4gICAgQElucHV0KClcbiAgICBhcHBOYW1lOiBzdHJpbmc7XG5cbiAgICAvKiogVG9nZ2xlcyBkaXNwbGF5IG9mIHRoZSBmaWx0ZXIncyBpY29uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0ljb246IGJvb2xlYW47XG5cbiAgICBmaWx0ZXIkOiBPYnNlcnZhYmxlPEZpbHRlclJlcHJlc2VudGF0aW9uTW9kZWw+O1xuXG4gICAgY3VycmVudEZpbHRlcjogRmlsdGVyUmVwcmVzZW50YXRpb25Nb2RlbDtcblxuICAgIGZpbHRlcnM6IEZpbHRlclJlcHJlc2VudGF0aW9uTW9kZWwgW10gPSBbXTtcblxuICAgIHByaXZhdGUgaWNvbnNNREw6IEljb25Nb2RlbDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgdGFza0ZpbHRlclNlcnZpY2U6IFRhc2tGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGFza0xpc3RTZXJ2aWNlOiBUYXNrTGlzdFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBhcHBzUHJvY2Vzc1NlcnZpY2U6IEFwcHNQcm9jZXNzU2VydmljZSkge1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmljb25zTURMID0gbmV3IEljb25Nb2RlbCgpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgYXBwTmFtZSA9IGNoYW5nZXNbJ2FwcE5hbWUnXTtcbiAgICAgICAgY29uc3QgYXBwSWQgPSBjaGFuZ2VzWydhcHBJZCddO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjaGFuZ2VzWydmaWx0ZXJQYXJhbSddO1xuICAgICAgICBpZiAoYXBwTmFtZSAmJiBhcHBOYW1lLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5nZXRGaWx0ZXJzQnlBcHBOYW1lKGFwcE5hbWUuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcHBJZCAmJiBhcHBJZC5jdXJyZW50VmFsdWUgIT09IGFwcElkLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RmlsdGVyc0J5QXBwSWQoYXBwSWQuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmN1cnJlbnRWYWx1ZSAhPT0gZmlsdGVyLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RmlsdGVyKGZpbHRlci5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0YXNrIGxpc3QgZmlsdGVyZWQgYnkgYXBwSWQgb3IgYnkgYXBwTmFtZVxuICAgICAqIEBwYXJhbSBhcHBJZFxuICAgICAqIEBwYXJhbSBhcHBOYW1lXG4gICAgICovXG4gICAgZ2V0RmlsdGVycyhhcHBJZD86IG51bWJlciwgYXBwTmFtZT86IHN0cmluZykge1xuICAgICAgICBhcHBOYW1lID8gdGhpcy5nZXRGaWx0ZXJzQnlBcHBOYW1lKGFwcE5hbWUpIDogdGhpcy5nZXRGaWx0ZXJzQnlBcHBJZChhcHBJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBmaWx0ZXIgbGlzdCBmaWx0ZXJlZCBieSBhcHBJZFxuICAgICAqIEBwYXJhbSBhcHBJZCAtIG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0RmlsdGVyc0J5QXBwSWQoYXBwSWQ/OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy50YXNrRmlsdGVyU2VydmljZS5nZXRUYXNrTGlzdEZpbHRlcnMoYXBwSWQpLnN1YnNjcmliZShcbiAgICAgICAgICAgIChyZXM6IEZpbHRlclJlcHJlc2VudGF0aW9uTW9kZWxbXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID09PSAwICYmIHRoaXMuaXNGaWx0ZXJMaXN0RW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZpbHRlcnNCeUFwcElkKGFwcElkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0RmlsdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGaWx0ZXIodGhpcy5maWx0ZXJQYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzcy5lbWl0KHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZmlsdGVyIGxpc3QgZmlsdGVyZWQgYnkgYXBwTmFtZVxuICAgICAqIEBwYXJhbSBhcHBOYW1lXG4gICAgICovXG4gICAgZ2V0RmlsdGVyc0J5QXBwTmFtZShhcHBOYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5hcHBzUHJvY2Vzc1NlcnZpY2UuZ2V0RGVwbG95ZWRBcHBsaWNhdGlvbnNCeU5hbWUoYXBwTmFtZSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKGFwcGxpY2F0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRGaWx0ZXJzQnlBcHBJZChhcHBsaWNhdGlvbi5pZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGRlZmF1bHQgZmlsdGVycyBieSBhcHBJZFxuICAgICAqIEBwYXJhbSBhcHBJZFxuICAgICAqL1xuICAgIGNyZWF0ZUZpbHRlcnNCeUFwcElkKGFwcElkPzogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMudGFza0ZpbHRlclNlcnZpY2UuY3JlYXRlRGVmYXVsdEZpbHRlcnMoYXBwSWQpLnN1YnNjcmliZShcbiAgICAgICAgICAgIChyZXNEZWZhdWx0OiBGaWx0ZXJSZXByZXNlbnRhdGlvbk1vZGVsW10pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0RmlsdGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gcmVzRGVmYXVsdDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZpbHRlcih0aGlzLmZpbHRlclBhcmFtKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChyZXNEZWZhdWx0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyRGVmYXVsdDogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvci5lbWl0KGVyckRlZmF1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3MgdGhlIHNlbGVjdGVkIGZpbHRlciBhcyBuZXh0XG4gICAgICogQHBhcmFtIGZpbHRlclxuICAgICAqL1xuICAgIHB1YmxpYyBzZWxlY3RGaWx0ZXIobmV3RmlsdGVyOiBGaWx0ZXJQYXJhbXNNb2RlbCkge1xuICAgICAgICBpZiAobmV3RmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXIgPSB0aGlzLmZpbHRlcnMuZmluZCggKGZpbHRlciwgaW5kZXgpID0+XG4gICAgICAgICAgICAgICAgbmV3RmlsdGVyLmluZGV4ID09PSBpbmRleCB8fFxuICAgICAgICAgICAgICAgIG5ld0ZpbHRlci5pZCA9PT0gZmlsdGVyLmlkIHx8XG4gICAgICAgICAgICAgICAgKG5ld0ZpbHRlci5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAgIChuZXdGaWx0ZXIubmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSBmaWx0ZXIubmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50RmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUYXNrRmlsdGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2VsZWN0RmlsdGVyQW5kRW1pdChuZXdGaWx0ZXI6IEZpbHRlclBhcmFtc01vZGVsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RmlsdGVyKG5ld0ZpbHRlcik7XG4gICAgICAgIHRoaXMuZmlsdGVyQ2xpY2suZW1pdCh0aGlzLmN1cnJlbnRGaWx0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBmaWx0ZXIgd2l0aCB0YXNrXG4gICAgICogQHBhcmFtIHRhc2tJZFxuICAgICAqL1xuICAgIHB1YmxpYyBzZWxlY3RGaWx0ZXJXaXRoVGFzayh0YXNrSWQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEZpbHRlckxpc3Q6IEZpbHRlclJlcHJlc2VudGF0aW9uTW9kZWxbXSA9IFtdO1xuICAgICAgICB0aGlzLnRhc2tMaXN0U2VydmljZS5nZXRGaWx0ZXJGb3JUYXNrQnlJZCh0YXNrSWQsIHRoaXMuZmlsdGVycykuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKGZpbHRlcjogRmlsdGVyUmVwcmVzZW50YXRpb25Nb2RlbCkgPT4ge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkRmlsdGVyTGlzdC5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRGaWx0ZXJMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGaWx0ZXIoZmlsdGVyZWRGaWx0ZXJMaXN0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJDbGljay5lbWl0KHRoaXMuY3VycmVudEZpbHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGFzIGRlZmF1bHQgdGFzayBmaWx0ZXIgdGhlIGZpcnN0IGluIHRoZSBsaXN0XG4gICAgICogQHBhcmFtIGZpbHRlcmVkRmlsdGVyTGlzdFxuICAgICAqL1xuICAgIHB1YmxpYyBzZWxlY3REZWZhdWx0VGFza0ZpbHRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRmlsdGVyTGlzdEVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEZpbHRlciA9IHRoaXMuZmlsdGVyc1swXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCB0YXNrXG4gICAgICovXG4gICAgZ2V0Q3VycmVudEZpbHRlcigpOiBGaWx0ZXJSZXByZXNlbnRhdGlvbk1vZGVsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEZpbHRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZmlsdGVyIGxpc3QgaXMgZW1wdHlcbiAgICAgKi9cbiAgICBpc0ZpbHRlckxpc3RFbXB0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycyA9PT0gdW5kZWZpbmVkIHx8ICh0aGlzLmZpbHRlcnMgJiYgdGhpcy5maWx0ZXJzLmxlbmd0aCA9PT0gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGZpbHRlcnMgcHJvcGVydGllc1xuICAgICAqL1xuICAgIHByaXZhdGUgcmVzZXRGaWx0ZXIoKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgZmlsdGVyIGljb25cbiAgICAgKi9cbiAgICBnZXRGaWx0ZXJJY29uKGljb24pOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5pY29uc01ETC5tYXBHbHlwaGljb25Ub01hdGVyaWFsRGVzaWduSWNvbnMoaWNvbik7XG4gICAgfVxufVxuIl19