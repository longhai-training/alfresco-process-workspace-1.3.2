import { UserTaskFilterRepresentation, TaskQueryRepresentation } from '@alfresco/js-api';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material/core';
import { MatDialog as MatDialog$1 } from '@angular/material/dialog';
import { DocumentListService, ContentNodeSelectorService, ContentNodeDialogService, ContentNodeSelectorModule } from '@alfresco/adf-content-services';
import moment$1 from 'moment-es6';
import { Observable, from, forkJoin, throwError, of, BehaviorSubject, Subject, zip } from 'rxjs';
import { map, catchError, switchMap, flatMap, filter, share, defaultIfEmpty, debounceTime, mergeMap } from 'rxjs/operators';
import { MatDialog, MAT_LABEL_GLOBAL_OPTIONS, MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatDatepickerModule, MatDialogModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule, MatTooltipModule, MatMenuModule, MAT_DIALOG_DATA, MatAutocompleteTrigger, MatDialogRef } from '@angular/material';
import { FlexLayoutModule } from '@angular/flex-layout';
import { CommonModule, DatePipe } from '@angular/common';
import { Injectable, NgModule, Component, EventEmitter, Input, Output, ViewEncapsulation, ViewChild, ContentChild, Directive, TemplateRef, Inject, NgZone, defineInjectable, inject } from '@angular/core';
import { FormBuilder, Validators, FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { AlfrescoApiService, AppsProcessService, TranslationService, CustomEmptyContentTemplateDirective, CommentProcessService, ContentService, EmptyListComponent, ThumbnailService, LogService, AppConfigService, CardViewDateItemModel, CardViewTextItemModel, DataTableSchema, CustomLoadingContentTemplateDirective, PaginationComponent, UserPreferencesService, UserPreferenceValues, FormFieldModel, FormModel, FormService, PeopleProcessService, UserProcessModel, AuthenticationService, CardViewUpdateService, UploadService, DataColumnListComponent, TRANSLATION_PROVIDER, CoreModule, ProcessContentService, FormBaseComponent, FormOutcomeModel, EcmModelService, FormEvent, FormErrorEvent, FormOutcomeEvent, WidgetVisibilityService, NodeService, FormRenderingService, AppConfigValues, ActivitiContentService, MOMENT_DATE_FORMATS, MomentDateAdapter, CardViewMapItemModel, BpmUserService, UploadWidgetComponent, WidgetComponent, NodesApiService, SitesService, SearchService, ExternalAlfrescoApiService } from '@alfresco/adf-core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FilterProcessRepresentationModel {
    /**
     * @param {?} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.appId = obj.appId || null;
            this.name = obj.name || null;
            this.recent = !!obj.recent;
            this.icon = obj.icon || null;
            this.filter = obj.filter || null;
            this.index = obj.index;
        }
    }
    /**
     * @return {?}
     */
    hasFilter() {
        return !!this.filter;
    }
}
/**
 * This object represent the parameters of a process filter.
 */
class ProcessFilterParamRepresentationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.processDefinitionId = obj.processDefinitionId || null;
        this.appDefinitionId = obj.appDefinitionId || null;
        this.processInstanceId = obj.processInstanceId || null;
        this.state = obj.state || null;
        this.sort = obj.sort || null;
        this.page = obj.page || null;
        this.size = obj.size || null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessFilterService {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    /**
     * Gets all filters defined for a Process App.
     * @param {?} appId ID of the target app
     * @return {?} Array of filter details
     */
    getProcessFilters(appId) {
        return from(this.callApiProcessFilters(appId))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const filters = [];
            response.data.forEach((/**
             * @param {?} filter
             * @return {?}
             */
            (filter$$1) => {
                /** @type {?} */
                const filterModel = new FilterProcessRepresentationModel(filter$$1);
                filters.push(filterModel);
            }));
            return filters;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Retrieves the process filter by ID.
     * @param {?} filterId ID of the filter
     * @param {?=} appId ID of the target app
     * @return {?} Details of the filter
     */
    getProcessFilterById(filterId, appId) {
        return from(this.callApiProcessFilters(appId))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return response.data.find((/**
             * @param {?} filter
             * @return {?}
             */
            (filter$$1) => filter$$1.id === filterId));
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Retrieves the process filter by name.
     * @param {?} filterName Name of the filter
     * @param {?=} appId ID of the target app
     * @return {?} Details of the filter
     */
    getProcessFilterByName(filterName, appId) {
        return from(this.callApiProcessFilters(appId))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return response.data.find((/**
             * @param {?} filter
             * @return {?}
             */
            (filter$$1) => filter$$1.name === filterName));
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Creates and returns the default filters for an app.
     * @param {?} appId ID of the target app
     * @return {?} Default filters just created
     */
    createDefaultFilters(appId) {
        /** @type {?} */
        const runningFilter = this.getRunningFilterInstance(appId);
        /** @type {?} */
        const runningObservable = this.addProcessFilter(runningFilter);
        /** @type {?} */
        const completedFilter = this.getCompletedFilterInstance(appId);
        /** @type {?} */
        const completedObservable = this.addProcessFilter(completedFilter);
        /** @type {?} */
        const allFilter = this.getAllFilterInstance(appId);
        /** @type {?} */
        const allObservable = this.addProcessFilter(allFilter);
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            forkJoin(runningObservable, completedObservable, allObservable).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                /** @type {?} */
                const filters = [];
                res.forEach((/**
                 * @param {?} filter
                 * @return {?}
                 */
                (filter$$1) => {
                    if (filter$$1.name === runningFilter.name) {
                        runningFilter.id = filter$$1.id;
                        filters.push(runningFilter);
                    }
                    else if (filter$$1.name === completedFilter.name) {
                        completedFilter.id = filter$$1.id;
                        filters.push(completedFilter);
                    }
                    else if (filter$$1.name === allFilter.name) {
                        allFilter.id = filter$$1.id;
                        filters.push(allFilter);
                    }
                }));
                observer.next(filters);
                observer.complete();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.handleProcessError(err);
            }));
        }));
    }
    /**
     * Creates and returns a filter that matches "running" process instances.
     * @param {?} appId ID of the target app
     * @return {?} Filter just created
     */
    getRunningFilterInstance(appId) {
        return new FilterProcessRepresentationModel({
            'name': 'Running',
            'appId': appId,
            'recent': true,
            'icon': 'glyphicon-random',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'running' }
        });
    }
    /**
     * Returns a static Completed filter instance.
     * @private
     * @param {?} appId ID of the target app
     * @return {?} Details of the filter
     */
    getCompletedFilterInstance(appId) {
        return new FilterProcessRepresentationModel({
            'name': 'Completed',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-ok-sign',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'completed' }
        });
    }
    /**
     * Returns a static All filter instance.
     * @private
     * @param {?} appId ID of the target app
     * @return {?} Details of the filter
     */
    getAllFilterInstance(appId) {
        return new FilterProcessRepresentationModel({
            'name': 'All',
            'appId': appId,
            'recent': true,
            'icon': 'glyphicon-th',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'all' }
        });
    }
    /**
     * Adds a filter.
     * @param {?} filter The filter to add
     * @return {?} The filter just added
     */
    addProcessFilter(filter$$1) {
        return from(this.alfrescoApiService.getInstance().activiti.userFiltersApi.createUserProcessInstanceFilter(filter$$1))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return response;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Calls `getUserProcessInstanceFilters` from the Alfresco JS API.
     * @param {?=} appId ID of the target app
     * @return {?} List of filter details
     */
    callApiProcessFilters(appId) {
        if (appId) {
            return this.alfrescoApiService.getInstance().activiti.userFiltersApi.getUserProcessInstanceFilters({ appId: appId });
        }
        else {
            return this.alfrescoApiService.getInstance().activiti.userFiltersApi.getUserProcessInstanceFilters();
        }
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleProcessError(error) {
        return throwError(error || 'Server error');
    }
}
ProcessFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ProcessFilterService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ ProcessFilterService.ngInjectableDef = defineInjectable({ factory: function ProcessFilterService_Factory() { return new ProcessFilterService(inject(AlfrescoApiService)); }, token: ProcessFilterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* spellchecker: disable */
class IconModel {
    constructor() {
        this.initIconsMDL();
    }
    /**
     * @param {?} icon
     * @return {?}
     */
    mapGlyphiconToMaterialDesignIcons(icon) {
        return this.iconsMDL.get(icon) ? this.iconsMDL.get(icon) : IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON;
    }
    /**
     * Map all the bootstrap glyphicon icons with Material design material icon
     * @return {?}
     */
    initIconsMDL() {
        this.iconsMDL = new Map();
        this.iconsMDL.set('glyphicon-asterisk', 'ac_unit');
        this.iconsMDL.set('glyphicon-plus', 'add');
        this.iconsMDL.set('glyphicon-euro', 'euro_symbol');
        this.iconsMDL.set('glyphicon-cloud', 'cloud');
        this.iconsMDL.set('glyphicon-envelope', 'mail');
        this.iconsMDL.set('glyphicon-pencil', 'create');
        this.iconsMDL.set('glyphicon-glass', 'local_bar');
        this.iconsMDL.set('glyphicon-music', 'music_note');
        this.iconsMDL.set('glyphicon-search', 'search');
        this.iconsMDL.set('glyphicon-heart', 'favorite');
        this.iconsMDL.set('glyphicon-heart-empty', 'favorite_border');
        this.iconsMDL.set('glyphicon-star', 'star');
        this.iconsMDL.set('glyphicon-star-empty', 'star_border');
        this.iconsMDL.set('glyphicon-user', 'person');
        this.iconsMDL.set('glyphicon-film', 'movie_creation');
        this.iconsMDL.set('glyphicon-th-large', 'view_comfy');
        this.iconsMDL.set('glyphicon-th', 'dashboard');
        this.iconsMDL.set('glyphicon-th-list', 'list');
        this.iconsMDL.set('glyphicon-ok', 'done');
        this.iconsMDL.set('glyphicon-remove', 'cancel');
        this.iconsMDL.set('glyphicon-zoom-in', 'zoom_in');
        this.iconsMDL.set('glyphicon-zoom-out', 'zoom_out');
        this.iconsMDL.set('glyphicon-off', 'highlight_off');
        this.iconsMDL.set('glyphicon-signal', 'signal_cellular_4_bar');
        this.iconsMDL.set('glyphicon-cog', 'settings');
        this.iconsMDL.set('glyphicon-trash', 'delete');
        this.iconsMDL.set('glyphicon-home', 'home');
        this.iconsMDL.set('glyphicon-file', 'insert_drive_file');
        this.iconsMDL.set('glyphicon-time', 'access_time');
        this.iconsMDL.set('glyphicon-road', 'map');
        this.iconsMDL.set('glyphicon-download-alt', 'file_download');
        this.iconsMDL.set('glyphicon-download', 'file_download');
        this.iconsMDL.set('glyphicon-upload', 'file_upload');
        this.iconsMDL.set('glyphicon-inbox', 'inbox');
        this.iconsMDL.set('glyphicon-play-circle', 'play_circle_outline');
        this.iconsMDL.set('glyphicon-repeat', 'refresh');
        this.iconsMDL.set('glyphicon-refresh', 'sync');
        this.iconsMDL.set('glyphicon-list-alt', 'event_note');
        this.iconsMDL.set('glyphicon-lock', 'lock_outline');
        this.iconsMDL.set('glyphicon-flag', 'assistant_photo');
        this.iconsMDL.set('glyphicon-headphones', 'headset');
        this.iconsMDL.set('glyphicon-volume-up', 'volume_up');
        this.iconsMDL.set('glyphicon-tag', 'local_offer');
        this.iconsMDL.set('glyphicon-tags', 'local_offer');
        this.iconsMDL.set('glyphicon-book', 'library_books');
        this.iconsMDL.set('glyphicon-bookmark', 'collections_bookmark');
        this.iconsMDL.set('glyphicon-print', 'local_printshop');
        this.iconsMDL.set('glyphicon-camera', 'local_see');
        this.iconsMDL.set('glyphicon-list', 'view_list');
        this.iconsMDL.set('glyphicon-facetime-video', 'video_call');
        this.iconsMDL.set('glyphicon-picture', 'photo');
        this.iconsMDL.set('glyphicon-map-marker', 'add_location');
        this.iconsMDL.set('glyphicon-adjust', 'brightness_4');
        this.iconsMDL.set('glyphicon-tint', 'invert_colors');
        this.iconsMDL.set('glyphicon-edit', 'edit');
        this.iconsMDL.set('glyphicon-share', 'share');
        this.iconsMDL.set('glyphicon-check', 'assignment_turned_in');
        this.iconsMDL.set('glyphicon-move', 'open_with');
        this.iconsMDL.set('glyphicon-play', 'play_arrow');
        this.iconsMDL.set('glyphicon-eject', 'eject');
        this.iconsMDL.set('glyphicon-plus-sign', 'add_circle');
        this.iconsMDL.set('glyphicon-minus-sign', 'remove_circle');
        this.iconsMDL.set('glyphicon-remove-sign', 'cancel');
        this.iconsMDL.set('glyphicon-ok-sign', 'check_circle');
        this.iconsMDL.set('glyphicon-question-sign', 'help');
        this.iconsMDL.set('glyphicon-info-sign', 'info');
        this.iconsMDL.set('glyphicon-screenshot', 'flare');
        this.iconsMDL.set('glyphicon-remove-circle', 'cancel');
        this.iconsMDL.set('glyphicon-ok-circle', 'add_circle');
        this.iconsMDL.set('glyphicon-ban-circle', 'block');
        this.iconsMDL.set('glyphicon-share-alt', 'redo');
        this.iconsMDL.set('glyphicon-exclamation-sign', 'error');
        this.iconsMDL.set('glyphicon-gift', 'giftcard');
        this.iconsMDL.set('glyphicon-leaf', 'spa');
        this.iconsMDL.set('glyphicon-fire', 'whatshot');
        this.iconsMDL.set('glyphicon-eye-open', 'remove_red_eye');
        this.iconsMDL.set('glyphicon-eye-close', 'remove_red_eye');
        this.iconsMDL.set('glyphicon-warning-sign', 'warning');
        this.iconsMDL.set('glyphicon-plane', 'airplanemode_active');
        this.iconsMDL.set('glyphicon-calendar', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-random', 'shuffle');
        this.iconsMDL.set('glyphicon-comment', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-magnet', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-retweet', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-shopping-cart', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-folder-close', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-folder-open', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-hdd', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-bullhorn', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-bell', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-certificate', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-thumbs-up', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-thumbs-down', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-hand-left', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-globe', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-wrench', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tasks', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-filter', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-briefcase', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-dashboard', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-paperclip', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-link', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-phone', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-pushpin', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-usd', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-gbp', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-sort', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-flash', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-record', 'radio_button_checked');
        this.iconsMDL.set('glyphicon-save', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-open', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-saved', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-send', 'send');
        this.iconsMDL.set('glyphicon-floppy-disk', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-credit-card', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-cutlery', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-earphone', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-phone-alt', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tower', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-stats', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-cloud-download', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-cloud-upload', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tree-conifer', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tree-deciduous', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-align-left', 'format_align_left');
    }
}
IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON = 'favorite_border';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessFiltersComponent {
    /**
     * @param {?} processFilterService
     * @param {?} appsProcessService
     */
    constructor(processFilterService, appsProcessService) {
        this.processFilterService = processFilterService;
        this.appsProcessService = appsProcessService;
        /**
         * Emitted when the user selects a filter from the list.
         */
        this.filterClick = new EventEmitter();
        /**
         * Emitted when the list of filters has been successfully loaded from the server.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Toggle to show or hide the filter's icon.
         */
        this.showIcon = true;
        /**
         * Emitted when a process filter is selected.
         */
        this.filterSelected = new EventEmitter();
        this.filters = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconsMDL = new IconModel();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const appId = changes['appId'];
        /** @type {?} */
        const appName = changes['appName'];
        /** @type {?} */
        const filter$$1 = changes['filterParam'];
        if (appId && (appId.currentValue || appId.currentValue === null)) {
            this.getFiltersByAppId(appId.currentValue);
        }
        else if (appName && appName.currentValue) {
            this.getFiltersByAppName(appName.currentValue);
        }
        else if (filter$$1 && filter$$1.currentValue !== filter$$1.previousValue) {
            this.selectProcessFilter(filter$$1.currentValue);
        }
    }
    /**
     * Return the filter list filtered by appId
     * @param {?=} appId - optional
     * @return {?}
     */
    getFiltersByAppId(appId) {
        this.processFilterService.getProcessFilters(appId).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            if (res.length === 0 && this.isFilterListEmpty()) {
                this.processFilterService.createDefaultFilters(appId).subscribe((/**
                 * @param {?} resDefault
                 * @return {?}
                 */
                (resDefault) => {
                    this.resetFilter();
                    this.filters = resDefault;
                    this.selectProcessFilter(this.filterParam);
                    this.success.emit(resDefault);
                }), (/**
                 * @param {?} errDefault
                 * @return {?}
                 */
                (errDefault) => {
                    this.error.emit(errDefault);
                }));
            }
            else {
                this.resetFilter();
                this.filters = res;
                this.selectProcessFilter(this.filterParam);
                this.success.emit(res);
            }
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * Return the filter list filtered by appName
     * @param {?} appName
     * @return {?}
     */
    getFiltersByAppName(appName) {
        this.appsProcessService.getDeployedApplicationsByName(appName).subscribe((/**
         * @param {?} application
         * @return {?}
         */
        (application) => {
            this.getFiltersByAppId(application.id);
            this.selectProcessFilter(this.filterParam);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * Pass the selected filter as next
     * @param {?} filter
     * @return {?}
     */
    selectFilter(filter$$1) {
        this.currentFilter = filter$$1;
        this.filterClick.emit(filter$$1);
    }
    /**
     * Select the first filter of a list if present
     * @param {?} filterParam
     * @return {?}
     */
    selectProcessFilter(filterParam) {
        if (filterParam) {
            this.filters.filter((/**
             * @param {?} processFilter
             * @param {?} index
             * @return {?}
             */
            (processFilter, index) => {
                if (filterParam.name && filterParam.name.toLowerCase() === processFilter.name.toLowerCase() ||
                    filterParam.id === processFilter.id ||
                    filterParam.index === index) {
                    this.currentFilter = processFilter;
                    this.filterSelected.emit(processFilter);
                }
            }));
        }
        if (this.isCurrentFilterEmpty()) {
            this.selectDefaultTaskFilter();
        }
    }
    /**
     * Select the Running filter
     * @return {?}
     */
    selectRunningFilter() {
        this.selectProcessFilter(this.processFilterService.getRunningFilterInstance(null));
    }
    /**
     * Select as default task filter the first in the list
     * @return {?}
     */
    selectDefaultTaskFilter() {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
            this.filterSelected.emit(this.filters[0]);
        }
    }
    /**
     * Return the current task
     * @return {?}
     */
    getCurrentFilter() {
        return this.currentFilter;
    }
    /**
     * Check if the filter list is empty
     * @return {?}
     */
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    /**
     * Reset the filters properties
     * @private
     * @return {?}
     */
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
    /**
     * @private
     * @return {?}
     */
    isCurrentFilterEmpty() {
        return this.currentFilter === undefined || null;
    }
    /**
     * Return current filter icon
     * @param {?} icon
     * @return {?}
     */
    getFilterIcon(icon) {
        return this.iconsMDL.mapGlyphiconToMaterialDesignIcons(icon);
    }
}
ProcessFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-filters',
                template: "<div class=\"menu-container\">\n    <mat-list class=\"adf-menu-list\">\n        <mat-list-item (click)=\"selectFilter(filter)\" *ngFor=\"let filter of filters\"\n                        class=\"adf-filters__entry\" [class.adf-active]=\"currentFilter === filter\">\n            <mat-icon *ngIf=\"showIcon\" matListIcon class=\"adf-filters__entry-icon\">{{getFilterIcon(filter.icon)}}</mat-icon>\n            <span matLine [attr.data-automation-id]=\"filter.name + '_filter'\">{{filter.name}}</span>\n        </mat-list-item>\n    </mat-list>\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
ProcessFiltersComponent.ctorParameters = () => [
    { type: ProcessFilterService },
    { type: AppsProcessService }
];
ProcessFiltersComponent.propDecorators = {
    filterParam: [{ type: Input }],
    filterClick: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    appId: [{ type: Input }],
    appName: [{ type: Input }],
    showIcon: [{ type: Input }],
    filterSelected: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessDefinitionRepresentation {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.id = obj && obj.id || null;
        this.name = obj && obj.name || null;
        this.description = obj && obj.description || null;
        this.key = obj && obj.key || null;
        this.category = obj && obj.category || null;
        this.version = obj && obj.version || 0;
        this.deploymentId = obj && obj.deploymentId || null;
        this.tenantId = obj && obj.tenantId || null;
        this.metaDataValues = obj && obj.metaDataValues || [];
        this.hasStartForm = obj && obj.hasStartForm === true ? true : false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceVariable {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.name = obj && obj.name !== undefined ? obj.name : null;
        this.scope = obj && obj.scope !== undefined ? obj.scope : null;
        this.value = obj && obj.value !== undefined ? obj.value : null;
        this.valueUrl = obj && obj.valueUrl !== undefined ? obj.valueUrl : null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstance {
    /**
     * @param {?=} data
     */
    constructor(data) {
        this.businessKey = data && data.businessKey !== undefined ? data.businessKey : null;
        this.ended = data && data.ended !== undefined ? data.ended : null;
        this.graphicalNotationDefined = data && data.graphicalNotationDefined !== undefined ? data.graphicalNotationDefined : null;
        this.id = data && data.id !== undefined ? data.id : null;
        this.name = data && data.name !== undefined ? data.name : null;
        this.processDefinitionCategory = data && data.processDefinitionCategory !== undefined ? data.processDefinitionCategory : null;
        this.processDefinitionDeploymentId = data && data.processDefinitionDeploymentId !== undefined ? data.processDefinitionDeploymentId : null;
        this.processDefinitionDescription = data && data.processDefinitionDescription !== undefined ? data.processDefinitionDescription : null;
        this.processDefinitionId = data && data.processDefinitionId !== undefined ? data.processDefinitionId : null;
        this.processDefinitionKey = data && data.processDefinitionKey !== undefined ? data.processDefinitionKey : null;
        this.processDefinitionName = data && data.processDefinitionName !== undefined ? data.processDefinitionName : null;
        this.processDefinitionVersion = data && data.processDefinitionVersion !== undefined ? data.processDefinitionVersion : null;
        this.startFormDefined = data && data.startFormDefined !== undefined ? data.startFormDefined : null;
        this.started = data && data.started !== undefined ? data.started : null;
        this.startedBy = data && data.startedBy !== undefined ? data.startedBy : null;
        this.tenantId = data && data.tenantId !== undefined ? data.tenantId : null;
        this.variables = data && data.variables !== undefined ? data.variables : null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessListModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.size = obj.size || null;
            this.total = obj.total || null;
            this.start = obj.start || null;
            this.length = obj.length || null;
            this.data = obj.data || [];
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessService {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    /**
     * Gets process instances for a filter and optionally a process definition.
     * @param {?} requestNode Filter for instances
     * @param {?=} processDefinitionKey Limits returned instances to a process definition
     * @return {?} List of process instances
     */
    getProcessInstances(requestNode, processDefinitionKey) {
        return from(this.alfrescoApiService.getInstance().activiti.processApi.getProcessInstances(requestNode))
            .pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            if (processDefinitionKey) {
                /** @type {?} */
                const filtered = res.data.filter((/**
                 * @param {?} process
                 * @return {?}
                 */
                (process) => process.processDefinitionKey === processDefinitionKey));
                res.data = filtered;
                return res;
            }
            else {
                return res;
            }
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Gets processes for a filter and optionally a process definition.
     * @param {?} requestNode Filter for instances
     * @param {?=} processDefinitionKey Limits returned instances to a process definition
     * @return {?} List of processes
     */
    getProcesses(requestNode, processDefinitionKey) {
        return this.getProcessInstances(requestNode, processDefinitionKey)
            .pipe(catchError((/**
         * @return {?}
         */
        () => {
            return of(new ProcessListModel({}));
        })));
    }
    /**
     * Fetches the Process Audit information as a PDF.
     * @param {?} processId ID of the target process
     * @return {?} Binary PDF data
     */
    fetchProcessAuditPdfById(processId) {
        return from(this.alfrescoApiService.getInstance().activiti.processApi.getProcessAuditPdf(processId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Fetches the Process Audit information in a JSON format.
     * @param {?} processId ID of the target process
     * @return {?} JSON data
     */
    fetchProcessAuditJsonById(processId) {
        return from(this.alfrescoApiService.getInstance().activiti.processApi.getProcessAuditJson(processId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Gets Process Instance metadata.
     * @param {?} processInstanceId ID of the target process
     * @return {?} Metadata for the instance
     */
    getProcess(processInstanceId) {
        return from(this.alfrescoApiService.getInstance().activiti.processApi.getProcessInstance(processInstanceId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Gets task instances for a process instance.
     * @param {?} processInstanceId ID of the process instance
     * @param {?=} state Task state filter (can be "active" or "completed")
     * @return {?} Array of task instance details
     */
    getProcessTasks(processInstanceId, state) {
        /** @type {?} */
        const taskOpts = state ? {
            processInstanceId: processInstanceId,
            state: state
        } : {
            processInstanceId: processInstanceId
        };
        return from(this.alfrescoApiService.getInstance().activiti.taskApi.listTasks(taskOpts))
            .pipe(map(this.extractData), map((/**
         * @param {?} tasks
         * @return {?}
         */
        (tasks) => tasks.map((/**
         * @param {?} task
         * @return {?}
         */
        (task) => {
            task.created = moment(task.created, 'YYYY-MM-DD').format();
            return task;
        })))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Gets process definitions associated with an app.
     * @param {?=} appId ID of a target app
     * @return {?} Array of process definitions
     */
    getProcessDefinitions(appId) {
        /** @type {?} */
        const opts = appId ? {
            latest: true,
            appDefinitionId: appId
        } : {
            latest: true
        };
        return from(this.alfrescoApiService.getInstance().activiti.processApi.getProcessDefinitions(opts))
            .pipe(map(this.extractData), map((/**
         * @param {?} processDefs
         * @return {?}
         */
        (processDefs) => processDefs.map((/**
         * @param {?} pd
         * @return {?}
         */
        (pd) => new ProcessDefinitionRepresentation(pd))))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Starts a process based on a process definition, name, form values or variables.
     * @param {?} processDefinitionId Process definition ID
     * @param {?} name Process name
     * @param {?=} outcome Process outcome
     * @param {?=} startFormValues Values for the start form
     * @param {?=} variables Array of process instance variables
     * @return {?} Details of the process instance just started
     */
    startProcess(processDefinitionId, name, outcome, startFormValues, variables) {
        /** @type {?} */
        const startRequest = {
            name: name,
            processDefinitionId: processDefinitionId
        };
        if (outcome) {
            startRequest.outcome = outcome;
        }
        if (startFormValues) {
            startRequest.values = startFormValues;
        }
        if (variables) {
            startRequest.variables = variables;
        }
        return from(this.alfrescoApiService.getInstance().activiti.processApi.startNewProcessInstance(startRequest))
            .pipe(map((/**
         * @param {?} pd
         * @return {?}
         */
        (pd) => new ProcessInstance(pd))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Cancels a process instance.
     * @param {?} processInstanceId ID of process to cancel
     * @return {?} Null response notifying when the operation is complete
     */
    cancelProcess(processInstanceId) {
        return from(this.alfrescoApiService.getInstance().activiti.processApi.deleteProcessInstance(processInstanceId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Gets the variables for a process instance.
     * @param {?} processInstanceId ID of the target process
     * @return {?} Array of instance variable info
     */
    getProcessInstanceVariables(processInstanceId) {
        return from(this.alfrescoApiService.getInstance().activiti.processInstanceVariablesApi.getProcessInstanceVariables(processInstanceId))
            .pipe(map((/**
         * @param {?} processVars
         * @return {?}
         */
        (processVars) => processVars.map((/**
         * @param {?} currentProcessVar
         * @return {?}
         */
        (currentProcessVar) => new ProcessInstanceVariable(currentProcessVar))))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Creates or updates variables for a process instance.
     * @param {?} processInstanceId ID of the target process
     * @param {?} variables Variables to update
     * @return {?} Array of instance variable info
     */
    createOrUpdateProcessInstanceVariables(processInstanceId, variables) {
        return from(this.alfrescoApiService.getInstance().activiti.processInstanceVariablesApi.createOrUpdateProcessInstanceVariables(processInstanceId, variables)).pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * Deletes a variable for a process instance.
     * @param {?} processInstanceId ID of the target process
     * @param {?} variableName Name of the variable to delete
     * @return {?} Null response notifying when the operation is complete
     */
    deleteProcessInstanceVariable(processInstanceId, variableName) {
        return from(this.alfrescoApiService.getInstance().activiti.processInstanceVariablesApi.deleteProcessInstanceVariable(processInstanceId, variableName))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleProcessError(err))));
    }
    /**
     * @private
     * @param {?} res
     * @return {?}
     */
    extractData(res) {
        return res.data || {};
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleProcessError(error) {
        return throwError(error || 'Server error');
    }
}
ProcessService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ProcessService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/** @nocollapse */ ProcessService.ngInjectableDef = defineInjectable({ factory: function ProcessService_Factory() { return new ProcessService(inject(AlfrescoApiService)); }, token: ProcessService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessInstanceHeaderComponent {
    /**
     * @param {?} translationService
     * @param {?} appConfig
     */
    constructor(translationService, appConfig) {
        this.translationService = translationService;
        this.appConfig = appConfig;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.refreshData();
    }
    /**
     * @return {?}
     */
    refreshData() {
        if (this.processInstance) {
            /** @type {?} */
            const defaultProperties = this.initDefaultProperties();
            /** @type {?} */
            const filteredProperties = this.appConfig.get('adf-process-instance-header.presets.properties');
            this.properties = defaultProperties.filter((/**
             * @param {?} cardItem
             * @return {?}
             */
            (cardItem) => this.isValidSelection(filteredProperties, cardItem)));
        }
    }
    /**
     * @private
     * @return {?}
     */
    initDefaultProperties() {
        return [
            new CardViewTextItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.STATUS',
                value: this.getProcessStatus(),
                key: 'status'
            }),
            new CardViewDateItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.END_DATE',
                value: this.processInstance.ended,
                format: 'MMM DD YYYY',
                key: 'ended',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.END_DATE_DEFAULT')
            }),
            new CardViewTextItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.CATEGORY',
                value: this.processInstance.processDefinitionCategory,
                key: 'category',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.CATEGORY_DEFAULT')
            }),
            new CardViewTextItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.BUSINESS_KEY',
                value: this.processInstance.businessKey,
                key: 'businessKey',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.BUSINESS_KEY_DEFAULT')
            }),
            new CardViewTextItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.CREATED_BY',
                value: this.getStartedByFullName(),
                key: 'assignee',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.CREATED_BY_DEFAULT')
            }),
            new CardViewDateItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.CREATED',
                value: this.processInstance.started,
                format: 'MMM DD YYYY',
                key: 'created'
            }),
            new CardViewTextItemModel({ label: 'ADF_PROCESS_LIST.PROPERTIES.ID',
                value: this.processInstance.id,
                key: 'id'
            }),
            new CardViewTextItemModel({ label: 'ADF_PROCESS_LIST.PROPERTIES.DESCRIPTION',
                value: this.processInstance.processDefinitionDescription,
                key: 'description',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.DESCRIPTION_DEFAULT')
            })
        ];
    }
    /**
     * @private
     * @param {?} filteredProperties
     * @param {?} cardItem
     * @return {?}
     */
    isValidSelection(filteredProperties, cardItem) {
        return filteredProperties ? filteredProperties.indexOf(cardItem.key) >= 0 : true;
    }
    /**
     * @return {?}
     */
    getProcessStatus() {
        if (this.processInstance) {
            return this.isRunning() ? 'Running' : 'Completed';
        }
    }
    /**
     * @return {?}
     */
    getStartedByFullName() {
        /** @type {?} */
        let fullName = '';
        if (this.processInstance && this.processInstance.startedBy) {
            fullName += this.processInstance.startedBy.firstName || '';
            fullName += fullName ? ' ' : '';
            fullName += this.processInstance.startedBy.lastName || '';
        }
        return fullName;
    }
    /**
     * @return {?}
     */
    isRunning() {
        return this.processInstance && !this.processInstance.ended;
    }
}
ProcessInstanceHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-header',
                template: "<mat-card *ngIf=\"processInstance\" class=\"adf-card-container\">\n    <mat-card-content>\n        <adf-card-view [properties]=\"properties\"></adf-card-view>\n    </mat-card-content>\n</mat-card>\n",
                styles: [":host{width:100%}.adf-card-container{font-family:inherit}"]
            }] }
];
/** @nocollapse */
ProcessInstanceHeaderComponent.ctorParameters = () => [
    { type: TranslationService },
    { type: AppConfigService }
];
ProcessInstanceHeaderComponent.propDecorators = {
    processInstance: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppDefinitionRepresentationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.defaultAppId = obj.defaultAppId ? obj.defaultAppId : null;
            this.deploymentId = obj.deploymentId ? obj.deploymentId : null;
            this.name = obj.name ? obj.name : null;
            this.description = obj.description ? obj.description : null;
            this.theme = obj.theme ? obj.theme : null;
            this.icon = obj.icon ? obj.icon : null;
            this.id = obj.id ? obj.id : null;
            this.modelId = obj.modelId ? obj.modelId : null;
            this.tenantId = obj.tenantId ? obj.tenantId : null;
        }
    }
}
class FilterParamsModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.name = obj.name || null;
            this.index = obj.index;
        }
    }
}
class FilterRepresentationModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.appId = obj.appId || null;
            this.name = obj.name || null;
            this.recent = !!obj.recent;
            this.icon = obj.icon || null;
            this.filter = new UserTaskFilterRepresentation(obj.filter);
            this.index = obj.index;
        }
    }
    /**
     * @return {?}
     */
    hasFilter() {
        return this.filter ? true : false;
    }
}
class TaskQueryRequestRepresentationModel extends TaskQueryRepresentation {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let taskPresetsDefaultModel = {
    'default': [
        {
            'key': 'name',
            'type': 'text',
            'title': 'ADF_TASK_LIST.PROPERTIES.NAME',
            'sortable': true
        },
        {
            'key': 'created',
            'type': 'text',
            'title': 'ADF_TASK_LIST.PROPERTIES.CREATED',
            'cssClass': 'hidden',
            'sortable': true
        },
        {
            'key': 'assignee',
            'type': 'text',
            'title': 'ADF_TASK_LIST.PROPERTIES.ASSIGNEE',
            'cssClass': 'hidden',
            'sortable': true
        }
    ]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This object represent of the Form.
 */
class Form {
    /**
     * @param {?} id
     * @param {?} name
     */
    constructor(id, name) {
        this.name = name;
        this.id = id;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskDetailsModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.processDefinitionVersion = 0;
        if (obj) {
            this.id = obj.id || null;
            this.name = obj.name || null;
            this.priority = obj.priority;
            this.assignee = obj.assignee ? new UserProcessModel(obj.assignee) : null;
            this.adhocTaskCanBeReassigned = obj.adhocTaskCanBeReassigned;
            this.category = obj.category || null;
            this.created = obj.created || null;
            this.description = obj.description || null;
            this.dueDate = obj.dueDate || null;
            this.duration = obj.duration || null;
            this.endDate = obj.endDate || null;
            this.executionId = obj.executionId || null;
            this.formKey = obj.formKey || null;
            this.initiatorCanCompleteTask = !!obj.initiatorCanCompleteTask;
            this.managerOfCandidateGroup = !!obj.managerOfCandidateGroup;
            this.memberOfCandidateGroup = !!obj.memberOfCandidateGroup;
            this.memberOfCandidateUsers = !!obj.memberOfCandidateUsers;
            this.involvedGroups = obj.involvedGroups;
            this.involvedPeople = obj.involvedPeople;
            this.parentTaskId = obj.parentTaskId || null;
            this.parentTaskName = obj.parentTaskName || null;
            this.processDefinitionCategory = obj.processDefinitionCategory || null;
            this.processDefinitionDeploymentId = obj.processDefinitionDeploymentId || null;
            this.processDefinitionDescription = obj.processDefinitionDescription || null;
            this.processDefinitionId = obj.processDefinitionId || null;
            this.processDefinitionKey = obj.processDefinitionKey || null;
            this.processDefinitionName = obj.processDefinitionName || null;
            this.processDefinitionVersion = obj.processDefinitionVersion || 0;
            this.processInstanceId = obj.processInstanceId || null;
            this.processInstanceName = obj.processInstanceName || null;
            this.processInstanceStartUserId = obj.processInstanceStartUserId || null;
            this.taskDefinitionKey = obj.taskDefinitionKey || null;
        }
    }
    /**
     * @return {?}
     */
    getFullName() {
        /** @type {?} */
        let fullName = '';
        if (this.assignee) {
            /** @type {?} */
            const firstName = this.assignee.firstName ? this.assignee.firstName : '';
            /** @type {?} */
            const lastName = this.assignee.lastName ? this.assignee.lastName : '';
            fullName = `${firstName} ${lastName}`;
        }
        return fullName.trim();
    }
    /**
     * @return {?}
     */
    isCompleted() {
        return !!this.endDate;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskListModel {
    /**
     * @param {?=} input
     */
    constructor(input) {
        this.data = [];
        if (input) {
            Object.assign(this, input);
            if (input.data) {
                this.data = input.data.map((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => {
                    return new TaskDetailsModel(item);
                }));
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskListService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Gets all the filters in the list that belong to a task.
     * @param {?} taskId ID of the target task
     * @param {?} filterList List of filters to search through
     * @return {?} Filters belonging to the task
     */
    getFilterForTaskById(taskId, filterList) {
        return from(filterList)
            .pipe(flatMap((/**
         * @param {?} data
         * @return {?}
         */
        (data) => this.isTaskRelatedToFilter(taskId, data))), filter((/**
         * @param {?} data
         * @return {?}
         */
        (data) => data != null)));
    }
    /**
     * Gets the search query for a task based on the supplied filter.
     * @private
     * @param {?} filterModel
     * @return {?} The search query
     */
    generateTaskRequestNodeFromFilter(filterModel) {
        /** @type {?} */
        const requestNode = {
            appDefinitionId: filterModel.appId,
            assignment: filterModel.filter.assignment,
            state: filterModel.filter.state,
            sort: filterModel.filter.sort
        };
        return new TaskQueryRequestRepresentationModel(requestNode);
    }
    /**
     * Checks if a taskId is filtered with the given filter.
     * @param {?} taskId ID of the target task
     * @param {?} filterModel The filter you want to check
     * @return {?} The filter if it is related or null otherwise
     */
    isTaskRelatedToFilter(taskId, filterModel) {
        /** @type {?} */
        const requestNodeForFilter = this.generateTaskRequestNodeFromFilter(filterModel);
        return from(this.callApiTasksFiltered(requestNodeForFilter))
            .pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            return res.data.find((/**
             * @param {?} element
             * @return {?}
             */
            (element) => element.id === taskId)) ? filterModel : null;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets all the tasks matching the supplied query.
     * @param {?} requestNode Query to search for tasks
     * @return {?} List of tasks
     */
    getTasks(requestNode) {
        return from(this.callApiTasksFiltered(requestNode))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets tasks matching a query and state value.
     * @param {?} requestNode Query to search for tasks
     * @param {?=} state Task state. Can be "open" or "completed".
     * @return {?} List of tasks
     */
    findTasksByState(requestNode, state) {
        if (state) {
            requestNode.state = state;
        }
        return this.getTasks(requestNode)
            .pipe(catchError((/**
         * @return {?}
         */
        () => of(new TaskListModel()))));
    }
    /**
     * Gets all tasks matching a query and state value.
     * @param {?} requestNode Query to search for tasks.
     * @param {?=} state Task state. Can be "open" or "completed".
     * @return {?} List of tasks
     */
    findAllTaskByState(requestNode, state) {
        if (state) {
            requestNode.state = state;
        }
        return this.getTotalTasks(requestNode)
            .pipe(switchMap((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            requestNode.size = res.total;
            return this.getTasks(requestNode);
        })));
    }
    /**
     * Gets all tasks matching the supplied query but ignoring the task state.
     * @param {?} requestNode Query to search for tasks
     * @return {?} List of tasks
     */
    findAllTasksWithoutState(requestNode) {
        return forkJoin(this.findTasksByState(requestNode, 'open'), this.findAllTaskByState(requestNode, 'completed'), (/**
         * @param {?} activeTasks
         * @param {?} completedTasks
         * @return {?}
         */
        (activeTasks, completedTasks) => {
            /** @type {?} */
            const tasks = Object.assign({}, activeTasks);
            tasks.total += completedTasks.total;
            tasks.data = tasks.data.concat(completedTasks.data);
            return tasks;
        }));
    }
    /**
     * Gets details for a task.
     * @param {?} taskId ID of the target task.
     * @return {?} Task details
     */
    getTaskDetails(taskId) {
        return from(this.callApiTaskDetails(taskId))
            .pipe(map((/**
         * @param {?} details
         * @return {?}
         */
        (details) => {
            return new TaskDetailsModel(details);
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the checklist for a task.
     * @param {?} id ID of the target task
     * @return {?} Array of checklist task details
     */
    getTaskChecklist(id) {
        return from(this.callApiTaskChecklist(id))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const checklists = [];
            response.data.forEach((/**
             * @param {?} checklist
             * @return {?}
             */
            (checklist) => {
                checklists.push(new TaskDetailsModel(checklist));
            }));
            return checklists;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets all available reusable forms.
     * @return {?} Array of form details
     */
    getFormList() {
        /** @type {?} */
        const opts = {
            'filter': 'myReusableForms',
            // String | filter
            'sort': 'modifiedDesc',
            // String | sort
            'modelType': 2 // Integer | modelType
        };
        return from(this.apiService.getInstance().activiti.modelsApi.getModels(opts))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const forms = [];
            response.data.forEach((/**
             * @param {?} form
             * @return {?}
             */
            (form) => {
                forms.push(new Form(form.id, form.name));
            }));
            return forms;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Attaches a form to a task.
     * @param {?} taskId ID of the target task
     * @param {?} formId ID of the form to add
     * @return {?} Null response notifying when the operation is complete
     */
    attachFormToATask(taskId, formId) {
        return from(this.apiService.taskApi.attachForm(taskId, { 'formId': formId }))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Adds a subtask (ie, a checklist task) to a parent task.
     * @param {?} task The task to add
     * @return {?} The subtask that was added
     */
    addTask(task) {
        return from(this.callApiAddTask(task))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return new TaskDetailsModel(response);
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Deletes a subtask (ie, a checklist task) from a parent task.
     * @param {?} taskId The task to delete
     * @return {?} Null response notifying when the operation is complete
     */
    deleteTask(taskId) {
        return from(this.callApiDeleteTask(taskId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Deletes a form from a task.
     * @param {?} taskId Task id related to form
     * @return {?} Null response notifying when the operation is complete
     */
    deleteForm(taskId) {
        return from(this.callApiDeleteForm(taskId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gives completed status to a task.
     * @param {?} taskId ID of the target task
     * @return {?} Null response notifying when the operation is complete
     */
    completeTask(taskId) {
        return from(this.apiService.taskApi.completeTask(taskId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets the total number of the tasks found by a query.
     * @param {?} requestNode Query to search for tasks
     * @return {?} Number of tasks
     */
    getTotalTasks(requestNode) {
        requestNode.size = 0;
        return from(this.callApiTasksFiltered(requestNode))
            .pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            return res;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Creates a new standalone task.
     * @param {?} task Details of the new task
     * @return {?} Details of the newly created task
     */
    createNewTask(task) {
        return from(this.callApiCreateTask(task))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return new TaskDetailsModel(response);
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Assigns a task to a user or group.
     * @param {?} taskId The task to assign
     * @param {?} requestNode User or group to assign the task to
     * @return {?} Details of the assigned task
     */
    assignTask(taskId, requestNode) {
        /** @type {?} */
        const assignee = { assignee: requestNode.id };
        return from(this.callApiAssignTask(taskId, assignee))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return new TaskDetailsModel(response);
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Assigns a task to a user.
     * @param {?} taskId ID of the task to assign
     * @param {?} userId ID of the user to assign the task to
     * @return {?} Details of the assigned task
     */
    assignTaskByUserId(taskId, userId) {
        /** @type {?} */
        const assignee = (/** @type {?} */ ({ assignee: userId }));
        return from(this.callApiAssignTask(taskId, assignee))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return new TaskDetailsModel(response);
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Claims a task for the current user.
     * @param {?} taskId ID of the task to claim
     * @return {?} Details of the claimed task
     */
    claimTask(taskId) {
        return from(this.apiService.taskApi.claimTask(taskId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Un-claims a task for the current user.
     * @param {?} taskId ID of the task to unclaim
     * @return {?} Null response notifying when the operation is complete
     */
    unclaimTask(taskId) {
        return from(this.apiService.taskApi.unclaimTask(taskId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Updates the details (name, description, due date) for a task.
     * @param {?} taskId ID of the task to update
     * @param {?} updated Data to update the task (as a `TaskUpdateRepresentation` instance).
     * @return {?} Updated task details
     */
    updateTask(taskId, updated) {
        return from(this.apiService.taskApi.updateTask(taskId, updated))
            .pipe(map((/**
         * @param {?} result
         * @return {?}
         */
        (result) => (/** @type {?} */ (result)))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Fetches the Task Audit information in PDF format.
     * @param {?} taskId ID of the target task
     * @return {?} Binary PDF data
     */
    fetchTaskAuditPdfById(taskId) {
        return from(this.apiService.taskApi.getTaskAuditPdf(taskId))
            .pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        (data) => (/** @type {?} */ (data)))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Fetch the Task Audit information in JSON format
     * @param {?} taskId ID of the target task
     * @return {?} JSON data
     */
    fetchTaskAuditJsonById(taskId) {
        return from(this.apiService.taskApi.getTaskAuditJson(taskId))
            .pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * @private
     * @param {?} requestNode
     * @return {?}
     */
    callApiTasksFiltered(requestNode) {
        return this.apiService.taskApi.listTasks(requestNode);
    }
    /**
     * @private
     * @param {?} taskId
     * @return {?}
     */
    callApiTaskDetails(taskId) {
        return this.apiService.taskApi.getTask(taskId);
    }
    /**
     * @private
     * @param {?} task
     * @return {?}
     */
    callApiAddTask(task) {
        return this.apiService.taskApi.addSubtask(task.parentTaskId, task);
    }
    /**
     * @private
     * @param {?} taskId
     * @return {?}
     */
    callApiDeleteTask(taskId) {
        return this.apiService.taskApi.deleteTask(taskId);
    }
    /**
     * @private
     * @param {?} taskId
     * @return {?}
     */
    callApiDeleteForm(taskId) {
        return this.apiService.taskApi.removeForm(taskId);
    }
    /**
     * @private
     * @param {?} taskId
     * @return {?}
     */
    callApiTaskChecklist(taskId) {
        return this.apiService.taskApi.getChecklist(taskId);
    }
    /**
     * @private
     * @param {?} task
     * @return {?}
     */
    callApiCreateTask(task) {
        return this.apiService.taskApi.createNewTask(task);
    }
    /**
     * @private
     * @param {?} taskId
     * @param {?} requestNode
     * @return {?}
     */
    callApiAssignTask(taskId, requestNode) {
        return this.apiService.taskApi.assignTask(taskId, requestNode);
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
TaskListService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TaskListService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ TaskListService.ngInjectableDef = defineInjectable({ factory: function TaskListService_Factory() { return new TaskListService(inject(AlfrescoApiService), inject(LogService)); }, token: TaskListService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskListComponent extends DataTableSchema {
    /**
     * @param {?} taskListService
     * @param {?} appConfigService
     * @param {?} userPreferences
     */
    constructor(taskListService, appConfigService, userPreferences) {
        super(appConfigService, TaskListComponent.PRESET_KEY, taskPresetsDefaultModel);
        this.taskListService = taskListService;
        this.userPreferences = userPreferences;
        /**
         * Row selection mode. Can be none, `single` or `multiple`. For `multiple` mode,
         * you can use Cmd (macOS) or Ctrl (Win) modifier key to toggle selection for
         * multiple rows.
         */
        this.selectionMode = 'single'; // none|single|multiple
        // none|single|multiple
        /**
         * Toggles multiple row selection, renders checkboxes at the beginning of each row
         */
        this.multiselect = false;
        /**
         * Toggles default selection of the first row
         */
        this.selectFirstRow = true;
        /**
         * Emitted when a task in the list is clicked
         */
        this.rowClick = new EventEmitter();
        /**
         * Emitted when rows are selected/unselected
         */
        this.rowsSelected = new EventEmitter();
        /**
         * Emitted when the task list is loaded
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * The page number of the tasks to fetch.
         */
        this.page = 0;
        /**
         * The number of tasks to fetch. Default value: 25.
         */
        this.size = PaginationComponent.DEFAULT_PAGINATION.maxItems;
        this.rows = [];
        this.isLoading = true;
        this.sorting = ['created', 'desc'];
        /**
         * Toggles custom data source mode.
         * When enabled the component reloads data from it's current source instead of the server side.
         * This allows generating and displaying custom data sets (i.e. filtered out content).
         *
         * \@memberOf TaskListComponent
         */
        this.hasCustomDataSource = false;
        this.userPreferences.select(UserPreferenceValues.PaginationSize).subscribe((/**
         * @param {?} pageSize
         * @return {?}
         */
        (pageSize) => {
            this.size = pageSize;
        }));
        this.pagination = new BehaviorSubject((/** @type {?} */ ({
            maxItems: this.size,
            skipCount: 0,
            totalItems: 0
        })));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.createDatatableSchema();
        if (this.data && this.data.getColumns().length === 0) {
            this.data.setColumns(this.columns);
        }
        if (this.appId) {
            this.reload();
        }
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    setCustomDataSource(rows) {
        if (rows) {
            this.rows = rows;
            this.hasCustomDataSource = true;
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.isPropertyChanged(changes)) {
            if (this.isSortChanged(changes)) {
                this.sorting = this.sort ? this.sort.split('-') : this.sorting;
            }
            this.reload();
        }
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    isSortChanged(changes) {
        /** @type {?} */
        const actualSort = changes['sort'];
        return actualSort && actualSort.currentValue && actualSort.currentValue !== actualSort.previousValue;
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    isPropertyChanged(changes) {
        /** @type {?} */
        let changed = true;
        /** @type {?} */
        const landingTaskId = changes['landingTaskId'];
        /** @type {?} */
        const page = changes['page'];
        /** @type {?} */
        const size = changes['size'];
        if (landingTaskId && landingTaskId.currentValue && this.isEqualToCurrentId(landingTaskId.currentValue)) {
            changed = false;
        }
        else if (page && page.currentValue !== page.previousValue) {
            changed = true;
        }
        else if (size && size.currentValue !== size.previousValue) {
            changed = true;
        }
        return changed;
    }
    /**
     * @return {?}
     */
    reload() {
        if (!this.hasCustomDataSource) {
            this.requestNode = this.createRequestNode();
            this.load(this.requestNode);
        }
        else {
            this.isLoading = false;
        }
    }
    /**
     * @private
     * @param {?} requestNode
     * @return {?}
     */
    load(requestNode) {
        this.isLoading = true;
        this.loadTasksByState().subscribe((/**
         * @param {?} tasks
         * @return {?}
         */
        (tasks) => {
            this.rows = this.optimizeTaskDetails(tasks.data);
            this.selectTask(this.landingTaskId);
            this.success.emit(tasks);
            this.isLoading = false;
            this.pagination.next({
                count: tasks.data.length,
                maxItems: this.size,
                skipCount: this.page * this.size,
                totalItems: tasks.total
            });
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
            this.isLoading = false;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    loadTasksByState() {
        return this.requestNode.state === 'all'
            ? this.taskListService.findAllTasksWithoutState(this.requestNode)
            : this.taskListService.findTasksByState(this.requestNode);
    }
    /**
     * Select the task given in input if present
     * @param {?} taskIdSelected
     * @return {?}
     */
    selectTask(taskIdSelected) {
        if (!this.isListEmpty()) {
            /** @type {?} */
            let dataRow = null;
            if (taskIdSelected) {
                dataRow = this.rows.find((/**
                 * @param {?} currentRow
                 * @return {?}
                 */
                (currentRow) => {
                    return currentRow['id'] === taskIdSelected;
                }));
            }
            if (!dataRow && this.selectFirstRow) {
                dataRow = this.rows[0];
            }
            if (dataRow) {
                dataRow.isSelected = true;
                this.currentInstanceId = dataRow['id'];
            }
        }
        else {
            this.currentInstanceId = null;
        }
    }
    /**
     * Return the current id
     * @return {?}
     */
    getCurrentId() {
        return this.currentInstanceId;
    }
    /**
     * Check if the taskId is the same of the selected task
     * @param {?} taskId
     * @return {?}
     */
    isEqualToCurrentId(taskId) {
        return this.currentInstanceId === taskId;
    }
    /**
     * Check if the list is empty
     * @return {?}
     */
    isListEmpty() {
        return !this.rows || this.rows.length === 0;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onRowClick(item) {
        this.currentInstanceId = item.value.getValue('id');
        this.rowClick.emit(this.currentInstanceId);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRowSelect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRowUnselect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRowKeyUp(event) {
        if (event.detail.keyboardEvent.key === 'Enter') {
            event.preventDefault();
            this.currentInstanceId = event.detail.row.getValue('id');
            this.rowClick.emit(this.currentInstanceId);
        }
    }
    /**
     * Optimize name field
     * @private
     * @param {?} instances
     * @return {?}
     */
    optimizeTaskDetails(instances) {
        instances = instances.map((/**
         * @param {?} task
         * @return {?}
         */
        (task) => {
            if (!task.name) {
                task.name = 'No name';
            }
            return task;
        }));
        return instances;
    }
    /**
     * @private
     * @return {?}
     */
    createRequestNode() {
        /** @type {?} */
        const requestNode = {
            appDefinitionId: this.appId,
            dueAfter: this.dueAfter ? moment$1(this.dueAfter).toDate() : null,
            dueBefore: this.dueBefore ? moment$1(this.dueBefore).toDate() : null,
            processInstanceId: this.processInstanceId,
            processDefinitionId: this.processDefinitionId,
            text: this.name,
            assignment: this.assignment,
            state: this.state,
            sort: this.sort,
            page: this.page,
            size: this.size,
            start: this.start,
            taskId: this.taskId,
            includeProcessInstance: this.includeProcessInstance
        };
        return new TaskQueryRequestRepresentationModel(requestNode);
    }
    /**
     * @param {?} params
     * @return {?}
     */
    updatePagination(params) {
        /** @type {?} */
        const needsReload = params.maxItems || params.skipCount;
        this.size = params.maxItems;
        this.page = this.currentPage(params.skipCount, params.maxItems);
        if (needsReload) {
            this.reload();
        }
    }
    /**
     * @param {?} skipCount
     * @param {?} maxItems
     * @return {?}
     */
    currentPage(skipCount, maxItems) {
        return (skipCount && maxItems) ? Math.floor(skipCount / maxItems) : 0;
    }
}
TaskListComponent.PRESET_KEY = 'adf-task-list.presets';
TaskListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tasklist',
                template: "<div *ngIf=\"!requestNode\">{{ 'ADF_TASK_LIST.FILTERS.MESSAGES.NONE' | translate }}</div>\n<ng-container *ngIf=\"requestNode\">\n        <adf-datatable\n            [data]=\"data\"\n            [rows]=\"rows\"\n            [columns]=\"columns\"\n            [sorting]=\"sorting\"\n            [loading]=\"isLoading\"\n            [multiselect]=\"multiselect\"\n            [selectionMode]=\"selectionMode\"\n            (row-select)=\"onRowSelect($event)\"\n            (row-unselect)=\"onRowUnselect($event)\"\n            (rowClick)=\"onRowClick($event)\"\n            (row-keyup)=\"onRowKeyUp($event)\">\n            <adf-loading-content-template>\n                <ng-template>\n                    <!--Add your custom loading template here-->\n                    <mat-progress-spinner\n                        *ngIf=\"!customLoadingContent\"\n                        class=\"adf-task-list-loading-margin\"\n                        [color]=\"'primary'\"\n                        [mode]=\"'indeterminate'\">\n                    </mat-progress-spinner>\n                    <ng-content select=\"adf-custom-loading-content-template\"></ng-content>\n                </ng-template>\n            </adf-loading-content-template>\n            <adf-no-content-template>\n                <ng-template>\n                    <adf-empty-content *ngIf=\"!customEmptyContent\"\n                        icon=\"assignment\"\n                        [title]=\"'ADF_TASK_LIST.LIST.MESSAGES.TITLE' | translate\"\n                        [subtitle]=\"'ADF_TASK_LIST.LIST.MESSAGES.SUBTITLE' | translate\">\n                    </adf-empty-content>\n                    <ng-content select=\"adf-custom-empty-content-template\"></ng-content>\n                </ng-template>\n            </adf-no-content-template>\n        </adf-datatable>\n</ng-container>\n",
                styles: [".adf-task-list-loading-margin{margin-left:calc((100% - 100px)/ 2);margin-right:calc((100% - 100px)/ 2)}"]
            }] }
];
/** @nocollapse */
TaskListComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: AppConfigService },
    { type: UserPreferencesService }
];
TaskListComponent.propDecorators = {
    customEmptyContent: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    customLoadingContent: [{ type: ContentChild, args: [CustomLoadingContentTemplateDirective,] }],
    appId: [{ type: Input }],
    processInstanceId: [{ type: Input }],
    processDefinitionId: [{ type: Input }],
    state: [{ type: Input }],
    assignment: [{ type: Input }],
    sort: [{ type: Input }],
    name: [{ type: Input }],
    landingTaskId: [{ type: Input }],
    data: [{ type: Input }],
    selectionMode: [{ type: Input }],
    multiselect: [{ type: Input }],
    selectFirstRow: [{ type: Input }],
    taskId: [{ type: Input }],
    includeProcessInstance: [{ type: Input }],
    start: [{ type: Input }],
    rowClick: [{ type: Output }],
    rowsSelected: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    page: [{ type: Input }],
    size: [{ type: Input }],
    dueAfter: [{ type: Input }],
    dueBefore: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChecklistComponent {
    /**
     * Constructor
     * @param {?} activitiTaskList
     * @param {?} dialog
     */
    constructor(activitiTaskList, dialog) {
        this.activitiTaskList = activitiTaskList;
        this.dialog = dialog;
        /**
         * Toggle readonly state of the form. All form widgets
         * will render as readonly if enabled.
         */
        this.readOnly = false;
        /**
         * Emitted when a new checklist task is created.
         */
        this.checklistTaskCreated = new EventEmitter();
        /**
         * Emitted when a checklist task is deleted.
         */
        this.checklistTaskDeleted = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.checklist = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const taskId = changes['taskId'];
        if (taskId && taskId.currentValue) {
            this.getTaskChecklist(taskId.currentValue);
            return;
        }
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getTaskChecklist(taskId) {
        this.checklist = [];
        if (this.taskId) {
            this.activitiTaskList.getTaskChecklist(this.taskId).subscribe((/**
             * @param {?} taskDetailsModel
             * @return {?}
             */
            (taskDetailsModel) => {
                taskDetailsModel.forEach((/**
                 * @param {?} task
                 * @return {?}
                 */
                (task) => {
                    this.checklist.push(task);
                }));
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                this.error.emit(error);
            }));
        }
        else {
            this.checklist = [];
        }
    }
    /**
     * @return {?}
     */
    showDialog() {
        this.dialog.open(this.addNewDialog, { width: '350px' });
    }
    /**
     * @return {?}
     */
    add() {
        /** @type {?} */
        const newTask = new TaskDetailsModel({
            name: this.taskName,
            parentTaskId: this.taskId,
            assignee: { id: this.assignee }
        });
        this.activitiTaskList.addTask(newTask).subscribe((/**
         * @param {?} taskDetailsModel
         * @return {?}
         */
        (taskDetailsModel) => {
            this.checklist.push(taskDetailsModel);
            this.checklistTaskCreated.emit(taskDetailsModel);
            this.taskName = '';
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
        }));
        this.cancel();
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    delete(taskId) {
        this.activitiTaskList.deleteTask(taskId).subscribe((/**
         * @return {?}
         */
        () => {
            this.checklist = this.checklist.filter((/**
             * @param {?} check
             * @return {?}
             */
            (check) => check.id !== taskId));
            this.checklistTaskDeleted.emit(taskId);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
        }));
    }
    /**
     * @return {?}
     */
    cancel() {
        this.dialog.closeAll();
        this.taskName = '';
    }
}
ChecklistComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-checklist',
                template: "<div class=\"adf-checklist-control\">\n    <mat-chip-list data-automation-id=\"checklist-label\">\n        <span class=\"adf-activiti-label\">{{ 'ADF_TASK_LIST.DETAILS.LABELS.CHECKLIST' | translate }}</span>\n        <mat-chip class=\"adf-process-badge\" color=\"accent\" selected=\"true\">{{checklist?.length}}</mat-chip>\n    </mat-chip-list>\n\n\n    <button mat-icon-button *ngIf=\"!readOnly\" matTooltip=\"Add a checklist\" [matTooltipPosition]=\"'before'\"\n            id=\"add-checklist\" class=\"adf-add-to-checklist-button\" (click)=\"showDialog()\">\n        <mat-icon>add</mat-icon>\n    </button>\n</div>\n\n<div class=\"adf-checklist-menu-container\" *ngIf=\"checklist?.length > 0\">\n    <mat-chip-list class=\"mat-chip-list-stacked\">\n        <mat-chip id=\"check-{{check.id}}\" class=\"adf-checklist-chip\" *ngFor=\"let check of checklist\"\n                  (removed)=\"delete(check.id)\">\n            <span>{{check.name}}</span>\n            <mat-icon *ngIf=\"!readOnly && !check.endDate\" id=\"remove-{{check.id}}\" matChipRemove>cancel\n            </mat-icon>\n        </mat-chip>\n    </mat-chip-list>\n\n</div>\n<div *ngIf=\"checklist?.length === 0\" id=\"checklist-none-message\" class=\"adf-checklist-none-message\">\n    {{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.NONE' | translate }}\n</div>\n\n<ng-template #dialog>\n    <div class=\"adf-checklist-dialog\" id=\"checklist-dialog\">\n        <h4 matDialogTitle id=\"add-checklist-title\">{{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.DIALOG.TITLE' | translate }}</h4>\n        <mat-dialog-content>\n            <mat-form-field>\n                <input matInput placeholder=\"{{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.DIALOG.PLACEHOLDER' | translate }}\" [(ngModel)]=\"taskName\" id=\"checklist-name\"\n                       data-automation-id=\"checklist-name\">\n            </mat-form-field>\n        </mat-dialog-content>\n        <mat-dialog-actions class=\"adf-checklist-dialog-actions\">\n            <button mat-button type=\"button\" id=\"close-check-dialog\" (click)=\"cancel()\">{{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.DIALOG.CANCEL-BUTTON' | translate | uppercase }}</button>\n            <button mat-button type=\"button\" id=\"add-check\" (click)=\"add()\">{{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.DIALOG.ADD-BUTTON' | translate | uppercase  }}</button>\n        </mat-dialog-actions>\n    </div>\n</ng-template>\n",
                styles: [":host{width:100%}.adf-activiti-label{font-weight:bolder}.mat-form-field{width:100%}.adf-checklist-cancel-button{margin-top:-13px;margin-right:-13px;float:right}.adf-checklist-chip{outline:0}.adf-checklist-menu-container,.adf-checklist-none-message{margin-top:10px}.adf-checklist-control{display:flex;justify-content:space-between}.adf-checklist-control .adfactiviti-label{margin-top:6px;margin-right:10px}.adf-checklist-control .adf-add-to-checklist-button{float:right}.adf-checklist-dialog-actions{display:flex;justify-content:flex-end}"]
            }] }
];
/** @nocollapse */
ChecklistComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: MatDialog }
];
ChecklistComponent.propDecorators = {
    taskId: [{ type: Input }],
    readOnly: [{ type: Input }],
    assignee: [{ type: Input }],
    checklistTaskCreated: [{ type: Output }],
    checklistTaskDeleted: [{ type: Output }],
    error: [{ type: Output }],
    addNewDialog: [{ type: ViewChild, args: ['dialog',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskDescriptionValidator {
    constructor() {
        this.message = 'ADF_CLOUD_TASK_HEADER.FORM_VALIDATION.INVALID_FIELD';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isValid(value) {
        /** @type {?} */
        const isWhitespace = (value || '').trim().length === 0;
        return value.length === 0 || !isWhitespace;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskHeaderComponent {
    /**
     * @param {?} activitiTaskService
     * @param {?} bpmUserService
     * @param {?} translationService
     * @param {?} logService
     * @param {?} appConfig
     */
    constructor(activitiTaskService, bpmUserService, translationService, logService, appConfig) {
        this.activitiTaskService = activitiTaskService;
        this.bpmUserService = bpmUserService;
        this.translationService = translationService;
        this.logService = logService;
        this.appConfig = appConfig;
        /**
         * The name of the form.
         */
        this.formName = null;
        /**
         * Emitted when the task is claimed.
         */
        this.claim = new EventEmitter();
        /**
         * Emitted when the task is unclaimed (ie, requeued).
         */
        this.unclaim = new EventEmitter();
        this.inEdit = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.loadCurrentBpmUserId();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.refreshData();
    }
    /**
     * @private
     * @param {?} parentInfoMap
     * @return {?}
     */
    initDefaultProperties(parentInfoMap) {
        return [
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.ASSIGNEE',
                value: this.taskDetails.getFullName(),
                key: 'assignee',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.ASSIGNEE_DEFAULT'),
                clickable: !this.isCompleted(),
                icon: 'create'
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.STATUS',
                value: this.getTaskStatus(),
                key: 'status'
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.PRIORITY',
                value: this.taskDetails.priority,
                key: 'priority',
                editable: true
            }),
            new CardViewDateItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.DUE_DATE',
                value: this.taskDetails.dueDate,
                key: 'dueDate',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.DUE_DATE_DEFAULT'),
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.CATEGORY',
                value: this.taskDetails.category,
                key: 'category',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.CATEGORY_DEFAULT')
            }),
            new CardViewMapItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.PARENT_NAME',
                value: parentInfoMap,
                key: 'parentName',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.PARENT_NAME_DEFAULT'),
                clickable: true
            }),
            new CardViewDateItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.CREATED',
                value: this.taskDetails.created,
                key: 'created'
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.DURATION',
                value: this.getTaskDuration(),
                key: 'duration'
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.PARENT_TASK_ID',
                value: this.taskDetails.parentTaskId,
                key: 'parentTaskId'
            }),
            new CardViewDateItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.END_DATE',
                value: this.taskDetails.endDate,
                key: 'endDate'
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.ID',
                value: this.taskDetails.id,
                key: 'id'
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.DESCRIPTION',
                value: this.taskDetails.description,
                key: 'description',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.DESCRIPTION_DEFAULT'),
                multiline: true,
                editable: true,
                validators: [new TaskDescriptionValidator()]
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.FORM_NAME',
                value: this.formName,
                key: 'formName',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.FORM_NAME_DEFAULT'),
                clickable: !!this.formName,
                icon: 'create'
            })
        ];
    }
    /**
     * Refresh the card data
     * @return {?}
     */
    refreshData() {
        if (this.taskDetails) {
            /** @type {?} */
            const parentInfoMap = this.getParentInfo();
            /** @type {?} */
            const defaultProperties = this.initDefaultProperties(parentInfoMap);
            /** @type {?} */
            const filteredProperties = this.appConfig.get('adf-task-header.presets.properties');
            this.properties = defaultProperties.filter((/**
             * @param {?} cardItem
             * @return {?}
             */
            (cardItem) => this.isValidSelection(filteredProperties, cardItem)));
        }
    }
    /**
     * @private
     * @param {?} filteredProperties
     * @param {?} cardItem
     * @return {?}
     */
    isValidSelection(filteredProperties, cardItem) {
        return filteredProperties ? filteredProperties.indexOf(cardItem.key) >= 0 : true;
    }
    /**
     * Loads current bpm userId
     * @private
     * @return {?}
     */
    loadCurrentBpmUserId() {
        this.bpmUserService.getCurrentUserInfo().subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            this.currentUserId = res ? +res.id : null;
        }));
    }
    /**
     * Return the process parent information
     * @return {?}
     */
    getParentInfo() {
        if (this.taskDetails.processInstanceId && this.taskDetails.processDefinitionName) {
            return new Map([[this.taskDetails.processInstanceId, this.taskDetails.processDefinitionName]]);
        }
    }
    /**
     * Does the task have an assignee
     * @return {?}
     */
    hasAssignee() {
        return !!this.taskDetails.assignee ? true : false;
    }
    /**
     * Returns true if the task is assigned to logged in user
     * @param {?} userId
     * @return {?}
     */
    isAssignedTo(userId) {
        return this.hasAssignee() ? this.taskDetails.assignee.id === userId : false;
    }
    /**
     * Return true if the task assigned
     * @return {?}
     */
    isAssignedToCurrentUser() {
        return this.hasAssignee() && this.isAssignedTo(this.currentUserId);
    }
    /**
     * Return true if the user is a candidate member
     * @return {?}
     */
    isCandidateMember() {
        return this.taskDetails.managerOfCandidateGroup || this.taskDetails.memberOfCandidateGroup || this.taskDetails.memberOfCandidateUsers;
    }
    /**
     * Return true if the task claimable
     * @return {?}
     */
    isTaskClaimable() {
        return !this.hasAssignee() && this.isCandidateMember();
    }
    /**
     * Return true if the task claimed by candidate member.
     * @return {?}
     */
    isTaskClaimedByCandidateMember() {
        return this.isCandidateMember() && this.isAssignedToCurrentUser() && !this.isCompleted();
    }
    /**
     * Returns task's status
     * @return {?}
     */
    getTaskStatus() {
        return (this.taskDetails && this.taskDetails.isCompleted()) ? 'Completed' : 'Running';
    }
    /**
     * Claim task
     *
     * @param {?} taskId
     * @return {?}
     */
    claimTask(taskId) {
        this.activitiTaskService.claimTask(taskId).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            this.logService.info('Task claimed');
            this.claim.emit(taskId);
        }));
    }
    /**
     * Unclaim task
     *
     * @param {?} taskId
     * @return {?}
     */
    unclaimTask(taskId) {
        this.activitiTaskService.unclaimTask(taskId).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            this.logService.info('Task unclaimed');
            this.unclaim.emit(taskId);
        }));
    }
    /**
     * Returns true if the task is completed
     * @return {?}
     */
    isCompleted() {
        return this.taskDetails && !!this.taskDetails.endDate;
    }
    /**
     * @return {?}
     */
    getTaskDuration() {
        return this.taskDetails.duration ? `${this.taskDetails.duration} ms` : '';
    }
}
TaskHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-header',
                template: "<mat-card *ngIf=\"taskDetails\" class=\"adf-card-container\">\n    <mat-card-content>\n        <adf-card-view [properties]=\"properties\" [editable]=\"!isCompleted()\"></adf-card-view>\n    </mat-card-content>\n\n    <mat-card-actions class=\"adf-controls\">\n        <button *ngIf=\"isTaskClaimedByCandidateMember()\" mat-button data-automation-id=\"header-unclaim-button\" id=\"unclaim-task\" (click)=\"unclaimTask(taskDetails.id)\" class=\"adf-claim-controls\">{{ 'ADF_TASK_LIST.DETAILS.BUTTON.UNCLAIM' | translate }}\n        </button>\n        <button *ngIf=\"isTaskClaimable()\" mat-button data-automation-id=\"header-claim-button\" id=\"claim-task\" (click)=\"claimTask(taskDetails.id)\" class=\"adf-claim-controls\">{{ 'ADF_TASK_LIST.DETAILS.BUTTON.CLAIM' | translate }}\n        </button>\n    </mat-card-actions>\n</mat-card>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
TaskHeaderComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: BpmUserService },
    { type: TranslationService },
    { type: LogService },
    { type: AppConfigService }
];
TaskHeaderComponent.propDecorators = {
    formName: [{ type: Input }],
    taskDetails: [{ type: Input }],
    claim: [{ type: Output }],
    unclaim: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskDetailsComponent {
    /**
     * @param {?} taskListService
     * @param {?} authService
     * @param {?} peopleProcessService
     * @param {?} logService
     * @param {?} cardViewUpdateService
     * @param {?} dialog
     */
    constructor(taskListService, authService, peopleProcessService, logService, cardViewUpdateService, dialog) {
        this.taskListService = taskListService;
        this.authService = authService;
        this.peopleProcessService = peopleProcessService;
        this.logService = logService;
        this.cardViewUpdateService = cardViewUpdateService;
        this.dialog = dialog;
        /**
         * Toggles debug mode.
         */
        this.debugMode = false;
        /**
         * Automatically renders the next task when the current one is completed.
         */
        this.showNextTask = true;
        /**
         * Toggles task details Header component.
         */
        this.showHeader = true;
        /**
         * Toggles collapsed/expanded state of the Header component.
         */
        this.showHeaderContent = true;
        /**
         * Toggles `Involve People` feature for the Header component.
         */
        this.showInvolvePeople = true;
        /**
         * Toggles `Comments` feature for the Header component.
         */
        this.showComments = true;
        /**
         * Toggles `Checklist` feature for the Header component.
         */
        this.showChecklist = true;
        /**
         * Toggles rendering of the form title.
         */
        this.showFormTitle = false;
        /**
         * Toggles rendering of the `Complete` outcome button.
         */
        this.showFormCompleteButton = true;
        /**
         * Toggles rendering of the `Save` outcome button.
         */
        this.showFormSaveButton = true;
        /**
         * Toggles read-only state of the form. All form widgets render as read-only
         * if enabled.
         */
        this.readOnlyForm = false;
        /**
         * Toggles rendering of the `Refresh` button.
         */
        this.showFormRefreshButton = true;
        /**
         * Field validators for use with the form.
         */
        this.fieldValidators = [];
        /**
         * Emitted when the form is submitted with the `Save` or custom outcomes.
         */
        this.formSaved = new EventEmitter();
        /**
         * Emitted when the form is submitted with the `Complete` outcome.
         */
        this.formCompleted = new EventEmitter();
        /**
         * Emitted when the form field content is clicked.
         */
        this.formContentClicked = new EventEmitter();
        /**
         * Emitted when the form is loaded or reloaded.
         */
        this.formLoaded = new EventEmitter();
        /**
         * Emitted when a checklist task is created.
         */
        this.taskCreated = new EventEmitter();
        /**
         * Emitted when a checklist task is deleted.
         */
        this.taskDeleted = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when any outcome is executed. Default behaviour can be prevented
         * via `event.preventDefault()`.
         */
        this.executeOutcome = new EventEmitter();
        /**
         * Emitted when a task is assigned.
         */
        this.assignTask = new EventEmitter();
        /**
         * Emitted when a task is claimed.
         */
        this.claimedTask = new EventEmitter();
        /**
         * Emitted when a task is unclaimed.
         */
        this.unClaimedTask = new EventEmitter();
        this.taskFormName = null;
        this.taskPeople = [];
        this.showAssignee = false;
        this.showAttachForm = false;
        this.internalReadOnlyForm = false;
        this.peopleSearch = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => this.peopleSearchObserver = observer))
            .pipe(share());
        this.authService.getBpmLoggedUser().subscribe((/**
         * @param {?} user
         * @return {?}
         */
        (user) => {
            this.currentLoggedUser = user;
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.taskId) {
            this.loadDetails(this.taskId);
        }
        this.cardViewUpdateService.itemUpdated$.subscribe(this.updateTaskDetails.bind(this));
        this.cardViewUpdateService.itemClicked$.subscribe(this.clickTaskDetails.bind(this));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const taskId = changes.taskId;
        this.showAssignee = false;
        if (taskId && !taskId.currentValue) {
            this.reset();
        }
        else if (taskId && taskId.currentValue) {
            this.loadDetails(taskId.currentValue);
        }
    }
    /**
     * @return {?}
     */
    isStandaloneTask() {
        return !(this.taskDetails && (!!this.taskDetails.processDefinitionId));
    }
    /**
     * @return {?}
     */
    isStandaloneTaskWithForm() {
        return this.isStandaloneTask() && this.hasFormKey();
    }
    /**
     * @return {?}
     */
    isStandaloneTaskWithoutForm() {
        return this.isStandaloneTask() && !this.hasFormKey();
    }
    /**
     * @return {?}
     */
    isFormComponentVisible() {
        return this.hasFormKey() && !this.isShowAttachForm();
    }
    /**
     * @return {?}
     */
    isTaskStandaloneComponentVisible() {
        return this.isStandaloneTaskWithoutForm() && !this.isShowAttachForm();
    }
    /**
     * @return {?}
     */
    isShowAttachForm() {
        return this.showAttachForm;
    }
    /**
     * Reset the task details
     * @private
     * @return {?}
     */
    reset() {
        this.taskDetails = null;
    }
    /**
     * Check if the task has a form
     * @return {?}
     */
    hasFormKey() {
        return (this.taskDetails && (!!this.taskDetails.formKey));
    }
    /**
     * @return {?}
     */
    isTaskActive() {
        return this.taskDetails && this.taskDetails.duration === null;
    }
    /**
     * Save a task detail and update it after a successful response
     *
     * @private
     * @param {?} updateNotification
     * @return {?}
     */
    updateTaskDetails(updateNotification) {
        this.taskListService.updateTask(this.taskId, updateNotification.changed)
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.loadDetails(this.taskId);
        }));
    }
    /**
     * @private
     * @param {?} clickNotification
     * @return {?}
     */
    clickTaskDetails(clickNotification) {
        if (clickNotification.target.key === 'assignee') {
            this.showAssignee = true;
        }
        if (clickNotification.target.key === 'formName') {
            this.showAttachForm = true;
        }
    }
    /**
     * Load the activiti task details
     * @private
     * @param {?} taskId
     * @return {?}
     */
    loadDetails(taskId) {
        this.taskPeople = [];
        this.taskFormName = null;
        if (taskId) {
            this.taskListService.getTaskDetails(taskId).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.showAttachForm = false;
                this.taskDetails = res;
                if (this.taskDetails.name === 'null') {
                    this.taskDetails.name = 'No name';
                }
                /** @type {?} */
                const endDate = res.endDate;
                if (endDate && !isNaN(endDate.getTime())) {
                    this.internalReadOnlyForm = true;
                }
                else {
                    this.internalReadOnlyForm = this.readOnlyForm;
                }
                if (this.taskDetails && this.taskDetails.involvedPeople) {
                    this.taskDetails.involvedPeople.forEach((/**
                     * @param {?} user
                     * @return {?}
                     */
                    (user) => {
                        this.taskPeople.push(new UserProcessModel(user));
                    }));
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    isAssigned() {
        return !!this.taskDetails.assignee;
    }
    /**
     * @private
     * @return {?}
     */
    hasEmailAddress() {
        return this.taskDetails.assignee.email ? true : false;
    }
    /**
     * @return {?}
     */
    isAssignedToMe() {
        return this.isAssigned() && this.hasEmailAddress() ?
            this.isEmailEqual(this.taskDetails.assignee.email, this.currentLoggedUser.email) :
            this.isExternalIdEqual(this.taskDetails.assignee.externalId, this.currentLoggedUser.externalId);
    }
    /**
     * @private
     * @param {?} assigneeMail
     * @param {?} currentLoggedEmail
     * @return {?}
     */
    isEmailEqual(assigneeMail, currentLoggedEmail) {
        return assigneeMail.toLocaleLowerCase() === currentLoggedEmail.toLocaleLowerCase();
    }
    /**
     * @private
     * @param {?} assigneeExternalId
     * @param {?} currentUserExternalId
     * @return {?}
     */
    isExternalIdEqual(assigneeExternalId, currentUserExternalId) {
        return assigneeExternalId.toLocaleLowerCase() === currentUserExternalId.toLocaleLowerCase();
    }
    /**
     * @return {?}
     */
    isCompleteButtonEnabled() {
        return this.isAssignedToMe() || this.canInitiatorComplete();
    }
    /**
     * @return {?}
     */
    isCompleteButtonVisible() {
        return !this.hasFormKey() && this.isTaskActive() && this.isCompleteButtonEnabled();
    }
    /**
     * @return {?}
     */
    canInitiatorComplete() {
        return this.taskDetails.initiatorCanCompleteTask;
    }
    /**
     * @return {?}
     */
    isSaveButtonVisible() {
        return this.hasSaveButton() && (!this.canInitiatorComplete() || this.isAssignedToMe());
    }
    /**
     * @return {?}
     */
    hasSaveButton() {
        return this.showFormSaveButton;
    }
    /**
     * Retrieve the next open task
     * @private
     * @param {?} processInstanceId
     * @param {?} processDefinitionId
     * @return {?}
     */
    loadNextTask(processInstanceId, processDefinitionId) {
        /** @type {?} */
        const requestNode = new TaskQueryRequestRepresentationModel({
            processInstanceId: processInstanceId,
            processDefinitionId: processDefinitionId
        });
        this.taskListService.getTasks(requestNode).subscribe((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            if (response && response.length > 0) {
                this.taskDetails = new TaskDetailsModel(response[0]);
            }
            else {
                this.reset();
            }
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
        }));
    }
    /**
     * Complete button clicked
     * @return {?}
     */
    onComplete() {
        this.taskListService.completeTask(this.taskId).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => this.onFormCompleted(null)));
    }
    /**
     * @return {?}
     */
    onShowAttachForm() {
        this.showAttachForm = true;
    }
    /**
     * @return {?}
     */
    onCancelAttachForm() {
        this.showAttachForm = false;
    }
    /**
     * @return {?}
     */
    onCompleteAttachForm() {
        this.showAttachForm = false;
        this.loadDetails(this.taskId);
    }
    /**
     * @param {?} content
     * @return {?}
     */
    onFormContentClick(content) {
        this.formContentClicked.emit(content);
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onFormSaved(form) {
        this.formSaved.emit(form);
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onFormCompleted(form) {
        this.formCompleted.emit(form);
        if (this.showNextTask && (this.taskDetails.processInstanceId || this.taskDetails.processDefinitionId)) {
            this.loadNextTask(this.taskDetails.processInstanceId, this.taskDetails.processDefinitionId);
        }
    }
    /**
     * @param {?} form
     * @return {?}
     */
    onFormLoaded(form) {
        this.taskFormName = (form && form.name ? form.name : null);
        this.formLoaded.emit(form);
    }
    /**
     * @param {?} task
     * @return {?}
     */
    onChecklistTaskCreated(task) {
        this.taskCreated.emit(task);
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    onChecklistTaskDeleted(taskId) {
        this.taskDeleted.emit(taskId);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    onFormError(error) {
        this.errorDialogRef = this.dialog.open(this.errorDialog, { width: '500px' });
        this.error.emit(error);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFormExecuteOutcome(event) {
        this.executeOutcome.emit(event);
    }
    /**
     * @return {?}
     */
    closeErrorDialog() {
        this.dialog.closeAll();
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    onClaimAction(taskId) {
        this.claimedTask.emit(taskId);
        this.loadDetails(taskId);
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    onUnclaimAction(taskId) {
        this.unClaimedTask.emit(taskId);
        this.loadDetails(taskId);
    }
    /**
     * @return {?}
     */
    isCompletedTask() {
        return this.taskDetails && this.taskDetails.endDate ? true : undefined;
    }
    /**
     * @param {?} searchedWord
     * @return {?}
     */
    searchUser(searchedWord) {
        this.peopleProcessService.getWorkflowUsers(null, searchedWord)
            .subscribe((/**
         * @param {?} users
         * @return {?}
         */
        (users) => {
            users = users.filter((/**
             * @param {?} user
             * @return {?}
             */
            (user) => user.id !== this.taskDetails.assignee.id));
            this.peopleSearchObserver.next(users);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.logService.error('Could not load users')));
    }
    /**
     * @return {?}
     */
    onCloseSearch() {
        this.showAssignee = false;
    }
    /**
     * @param {?} selectedUser
     * @return {?}
     */
    assignTaskToUser(selectedUser) {
        this.taskListService.assignTask(this.taskDetails.id, selectedUser).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            this.logService.info('Task Assigned to ' + selectedUser.email);
            this.assignTask.emit();
        }));
        this.showAssignee = false;
    }
    /**
     * @return {?}
     */
    getTaskHeaderViewClass() {
        if (this.showAssignee) {
            return 'assign-edit-view';
        }
        else {
            return 'default-view';
        }
    }
    /**
     * @return {?}
     */
    isReadOnlyComment() {
        return (this.taskDetails && this.taskDetails.isCompleted()) && (this.taskPeople && this.taskPeople.length === 0);
    }
}
TaskDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-details',
                template: "<div *ngIf=\"!taskDetails\" data-automation-id=\"adf-tasks-details--empty\">\n    <ng-template *ngIf=\"noTaskDetailsTemplateComponent\" ngFor [ngForOf]=\"[data]\"\n                 [ngForTemplate]=\"noTaskDetailsTemplateComponent\">\n        {{ 'ADF_TASK_LIST.DETAILS.MESSAGES.NONE' | translate }}\n    </ng-template>\n    <div *ngIf=\"!noTaskDetailsTemplateComponent\">\n        {{ 'ADF_TASK_LIST.DETAILS.MESSAGES.NONE' | translate }}\n    </div>\n</div>\n<div *ngIf=\"taskDetails\" class=\"adf-task-details\">\n\n    <div *ngIf=\"showHeader\" class=\"adf-task-details-header\">\n        <h2 class=\"adf-activiti-task-details__header\">\n            <span>{{taskDetails.name || 'No name'}}</span>\n        </h2>\n    </div>\n\n    <div class=\"adf-task-details-core\"\n        fxLayout=\"column\"\n        fxLayoutGap=\"8px\"\n        fxLayout.lt-lg=\"column\">\n\n        <div class=\"adf-task-details-core-form\">\n            <div *ngIf=\"isAssigned()\">\n                <adf-form *ngIf=\"isFormComponentVisible()\" #activitiForm\n                          [taskId]=\"taskDetails.id\"\n                          [showTitle]=\"showFormTitle\"\n                          [showRefreshButton]=\"showFormRefreshButton\"\n                          [showCompleteButton]=\"showFormCompleteButton\"\n                          [disableCompleteButton]=\"!isCompleteButtonEnabled()\"\n                          [showSaveButton]=\"isSaveButtonVisible()\"\n                          [readOnly]=\"internalReadOnlyForm\"\n                          [fieldValidators]=\"fieldValidators\"\n                          (formSaved)='onFormSaved($event)'\n                          (formCompleted)='onFormCompleted($event)'\n                          (formContentClicked)='onFormContentClick($event)'\n                          (formLoaded)='onFormLoaded($event)'\n                          (error)='onFormError($event)'\n                          (executeOutcome)='onFormExecuteOutcome($event)'>\n                </adf-form>\n                <adf-task-standalone *ngIf=\"isTaskStandaloneComponentVisible()\"\n                                     [taskName]=\"taskDetails.name\"\n                                     [taskId]=\"taskDetails.id\"\n                                     [isCompleted]=\"isCompletedTask()\"\n                                     [hasCompletePermission]=\"isCompleteButtonEnabled()\"\n                                     [hideCancelButton]=\"true\"\n                                     (complete)=\"onComplete()\"\n                                     (showAttachForm)=\"onShowAttachForm()\">\n                </adf-task-standalone>\n\n                <mat-card class=\"adf-message-card\" *ngIf=\"!isTaskStandaloneComponentVisible() && !isCompletedTask() && !isFormComponentVisible()\" >\n                    <mat-card-content>\n                        <div class=\"adf-no-form-message-container\">\n                            <div class=\"adf-no-form-message-list\">\n                                <div *ngIf=\"!isCompletedTask()\" class=\"adf-no-form-message\">\n                                    <span id=\"adf-no-form-message\">{{'ADF_TASK_LIST.STANDALONE_TASK.NO_FORM_MESSAGE' | translate}}</span>\n                                </div>\n                            </div>\n                        </div>\n                    </mat-card-content>\n\n                    <mat-card-actions class=\"adf-no-form-mat-card-actions\">\n                        <div>\n                            <button mat-button id=\"adf-no-form-complete-button\" color=\"primary\" (click)=\"onComplete()\">{{ 'ADF_TASK_LIST.DETAILS.BUTTON.COMPLETE' | translate }}</button>\n                        </div>\n                    </mat-card-actions>\n\n                </mat-card>\n\n                <adf-attach-form *ngIf=\"isShowAttachForm()\"\n                                 [taskId]=\"taskDetails.id\"\n                                 [formKey]=\"taskDetails.formKey\"\n                                 (cancelAttachForm)=\"onCancelAttachForm()\"\n                                 (success)=\"onCompleteAttachForm()\">\n                </adf-attach-form>\n            </div>\n            <div *ngIf=\"!isAssigned()\" id=\"claim-message-id\">\n                {{ 'ADF_TASK_LIST.DETAILS.MESSAGES.CLAIM' | translate }}\n            </div>\n        </div>\n        <div class=\"adf-task-details-core-sidebar\">\n            <adf-info-drawer *ngIf=\"showHeaderContent\" title=\"{{ 'ADF_TASK_LIST.DETAILS.LABELS.INFO_DRAWER_TITLE' | translate }}\" id=\"adf-task-details-core-sidebar-drawer\" class=\"adf-task-details-core-sidebar-drawer\">\n                <adf-info-drawer-tab label=\"{{ 'ADF_TASK_LIST.DETAILS.LABELS.INFO_DRAWER_TAB_DETAILS_TITLE' | translate }}\">\n                    <div class=\"adf-assignment-container\" *ngIf=\"showAssignee\">\n                        <adf-people-search\n                            (searchPeople)=\"searchUser($event)\"\n                            (success)=\"assignTaskToUser($event)\"\n                            (closeSearch)=\"onCloseSearch()\"\n                            [results]=\"peopleSearch\">\n                            <ng-container adf-people-search-title>{{ 'ADF_TASK_LIST.DETAILS.LABELS.ADD_ASSIGNEE' | translate }}\n                            </ng-container>\n                            <ng-container adf-people-search-action-label>{{ 'ADF_TASK_LIST.PEOPLE.ADD_ASSIGNEE' | translate }}\n                            </ng-container>\n                        </adf-people-search>\n                    </div>\n                    <adf-task-header\n                        [class]=\"getTaskHeaderViewClass()\"\n                        [taskDetails]=\"taskDetails\"\n                        [formName]=\"taskFormName\"\n                        (claim)=\"onClaimAction($event)\"\n                        (unclaim)=\"onUnclaimAction($event)\">\n                    </adf-task-header>\n                    <adf-people *ngIf=\"showInvolvePeople\" #people\n                                [people]=\"taskPeople\"\n                                [readOnly]=\"internalReadOnlyForm\"\n                                [taskId]=\"taskDetails.id\">\n                    </adf-people>\n                </adf-info-drawer-tab>\n\n                <adf-info-drawer-tab label=\"{{ 'ADF_TASK_LIST.DETAILS.LABELS.INFO_DRAWER_TAB_ACTIVITY_TITLE' | translate }}\">\n                    <mat-card *ngIf=\"showComments\">\n                        <mat-card-content>\n                            <adf-comments #activitiComments\n                                          [readOnly]=\"isReadOnlyComment()\"\n                                          [taskId]=\"taskDetails.id\">\n                            </adf-comments>\n                        </mat-card-content>\n                    </mat-card>\n                </adf-info-drawer-tab>\n\n            </adf-info-drawer>\n\n            <div *ngIf=\"showHeaderContent\" class=\"adf-task-details-core-sidebar-checklist\">\n                <div *ngIf=\"showChecklist\">\n                    <adf-checklist #activitiChecklist\n                                   [readOnly]=\"internalReadOnlyForm\"\n                                   [taskId]=\"taskDetails.id\"\n                                   [assignee]=\"taskDetails?.assignee?.id\"\n                                   (checklistTaskCreated)=\"onChecklistTaskCreated($event)\"\n                                   (checklistTaskDeleted)=\"onChecklistTaskDeleted($event)\">\n                    </adf-checklist>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <ng-template #errorDialog>\n        <h3 matDialogTitle>{{'ADF_TASK_LIST.DETAILS.ERROR.TITLE'|translate}}</h3>\n        <mat-dialog-content>\n            <p>{{'ADF_TASK_LIST.DETAILS.ERROR.DESCRIPTION'|translate}}</p>\n        </mat-dialog-content>\n        <mat-dialog-actions>\n            <button mat-button type=\"button\" (click)=\"closeErrorDialog()\">{{'ADF_TASK_LIST.DETAILS.ERROR.CLOSE'|translate}}\n            </button>\n        </mat-dialog-actions>\n    </ng-template>\n\n</div>\n",
                styles: [":host{width:100%}.adf-error-dialog h3{margin:16px 0}.adf-activiti-task-details__header{align-self:flex-end;display:flex;font-size:24px;font-weight:300;line-height:normal;overflow:hidden;margin:8px 0 16px;cursor:pointer;user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.adf-activiti-task-details__action-button{text-transform:uppercase}.adf-assignment-container{padding:10px 20px;width:auto}adf-task-header.adf-assign-edit-view ::ng-deep adf-card-view ::ng-deep .adf-property[data-automation-id=header-assignee]{display:none}.adf-task-details-header{display:flex;justify-content:space-between}.adf-task-details-header-toggle{position:relative;top:10px;margin-right:2px;height:23px;cursor:pointer;user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.adf-task-details-toggle{position:relative}.adf-task-details-core{display:flex;justify-content:space-between}@media screen and (max-width:1279px){.adf-task-details-core-sidebar-drawer{margin-left:0}}.adf-task-details-core-sidebar-checklist{margin-top:30px;padding-left:20px;padding-right:20px}.adf-task-details-core-form{flex-grow:1}.adf-task-details-core-form ::ng-deep .adf-form-debug-container{display:flex;flex-direction:column;padding:20px 0}.adf-task-details-core-form ::ng-deep .adf-form-debug-container .mat-slide-toggle{margin-left:auto}.adf-task-details-core-form ::ng-deep .adf-form-debug-container .mat-slide-toggle+div{background-color:#000;padding:20px;clear:both;margin-top:30px;color:#fff}.adf-task-details-core-form ::ng-deep .mat-tab-label{flex-grow:1}"]
            }] }
];
/** @nocollapse */
TaskDetailsComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: AuthenticationService },
    { type: PeopleProcessService },
    { type: LogService },
    { type: CardViewUpdateService },
    { type: MatDialog }
];
TaskDetailsComponent.propDecorators = {
    activitiComments: [{ type: ViewChild, args: ['activitiComments',] }],
    activitiChecklist: [{ type: ViewChild, args: ['activitiChecklist',] }],
    errorDialog: [{ type: ViewChild, args: ['errorDialog',] }],
    debugMode: [{ type: Input }],
    taskId: [{ type: Input }],
    showNextTask: [{ type: Input }],
    showHeader: [{ type: Input }],
    showHeaderContent: [{ type: Input }],
    showInvolvePeople: [{ type: Input }],
    showComments: [{ type: Input }],
    showChecklist: [{ type: Input }],
    showFormTitle: [{ type: Input }],
    showFormCompleteButton: [{ type: Input }],
    showFormSaveButton: [{ type: Input }],
    readOnlyForm: [{ type: Input }],
    showFormRefreshButton: [{ type: Input }],
    fieldValidators: [{ type: Input }],
    formSaved: [{ type: Output }],
    formCompleted: [{ type: Output }],
    formContentClicked: [{ type: Output }],
    formLoaded: [{ type: Output }],
    taskCreated: [{ type: Output }],
    taskDeleted: [{ type: Output }],
    error: [{ type: Output }],
    executeOutcome: [{ type: Output }],
    assignTask: [{ type: Output }],
    claimedTask: [{ type: Output }],
    unClaimedTask: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class NoTaskDetailsTemplateDirective {
    /**
     * @param {?} activitiTaskDetails
     */
    constructor(activitiTaskDetails) {
        this.activitiTaskDetails = activitiTaskDetails;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.activitiTaskDetails.noTaskDetailsTemplateComponent = this.template;
    }
}
NoTaskDetailsTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-no-task-details-template, no-task-details-template'
            },] }
];
/** @nocollapse */
NoTaskDetailsTemplateDirective.ctorParameters = () => [
    { type: TaskDetailsComponent }
];
NoTaskDetailsTemplateDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskFilterService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    /**
     * Creates and returns the default filters for a process app.
     * @param {?} appId ID of the target app
     * @return {?} Array of default filters just created
     */
    createDefaultFilters(appId) {
        /** @type {?} */
        const involvedTasksFilter = this.getInvolvedTasksFilterInstance(appId);
        /** @type {?} */
        const involvedObservable = this.addFilter(involvedTasksFilter);
        /** @type {?} */
        const myTasksFilter = this.getMyTasksFilterInstance(appId);
        /** @type {?} */
        const myTaskObservable = this.addFilter(myTasksFilter);
        /** @type {?} */
        const queuedTasksFilter = this.getQueuedTasksFilterInstance(appId);
        /** @type {?} */
        const queuedObservable = this.addFilter(queuedTasksFilter);
        /** @type {?} */
        const completedTasksFilter = this.getCompletedTasksFilterInstance(appId);
        /** @type {?} */
        const completeObservable = this.addFilter(completedTasksFilter);
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            forkJoin(involvedObservable, myTaskObservable, queuedObservable, completeObservable).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                /** @type {?} */
                const filters = [];
                res.forEach((/**
                 * @param {?} filter
                 * @return {?}
                 */
                (filter$$1) => {
                    if (filter$$1.name === involvedTasksFilter.name) {
                        involvedTasksFilter.id = filter$$1.id;
                        filters.push(involvedTasksFilter);
                    }
                    else if (filter$$1.name === myTasksFilter.name) {
                        myTasksFilter.id = filter$$1.id;
                        filters.push(myTasksFilter);
                    }
                    else if (filter$$1.name === queuedTasksFilter.name) {
                        queuedTasksFilter.id = filter$$1.id;
                        filters.push(queuedTasksFilter);
                    }
                    else if (filter$$1.name === completedTasksFilter.name) {
                        completedTasksFilter.id = filter$$1.id;
                        filters.push(completedTasksFilter);
                    }
                }));
                observer.next(filters);
                observer.complete();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.logService.error(err);
            }));
        }));
    }
    /**
     * Gets all task filters for a process app.
     * @param {?=} appId Optional ID for a specific app
     * @return {?} Array of task filter details
     */
    getTaskListFilters(appId) {
        return from(this.callApiTaskFilters(appId))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            /** @type {?} */
            const filters = [];
            response.data.forEach((/**
             * @param {?} filter
             * @return {?}
             */
            (filter$$1) => {
                /** @type {?} */
                const filterModel = new FilterRepresentationModel(filter$$1);
                filters.push(filterModel);
            }));
            return filters;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a task filter by ID.
     * @param {?} filterId ID of the filter
     * @param {?=} appId ID of the app for the filter
     * @return {?} Details of task filter
     */
    getTaskFilterById(filterId, appId) {
        return from(this.callApiTaskFilters(appId)).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => response.data.find((/**
         * @param {?} filter
         * @return {?}
         */
        (filter$$1) => filter$$1.id === filterId)))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Gets a task filter by name.
     * @param {?} taskName Name of the filter
     * @param {?=} appId ID of the app for the filter
     * @return {?} Details of task filter
     */
    getTaskFilterByName(taskName, appId) {
        return from(this.callApiTaskFilters(appId)).pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => response.data.find((/**
         * @param {?} filter
         * @return {?}
         */
        (filter$$1) => filter$$1.name === taskName)))), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Adds a new task filter
     * @param {?} filter The new filter to add
     * @return {?} Details of task filter just added
     */
    addFilter(filter$$1) {
        return from(this.apiService.getInstance().activiti.userFiltersApi.createUserTaskFilter(filter$$1))
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            return response;
        })), catchError((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err))));
    }
    /**
     * Calls `getUserTaskFilters` from the Alfresco JS API.
     * @param {?=} appId ID of the target app
     * @return {?} List of task filters
     */
    callApiTaskFilters(appId) {
        if (appId) {
            return this.apiService.getInstance().activiti.userFiltersApi.getUserTaskFilters({ appId: appId });
        }
        else {
            return this.apiService.getInstance().activiti.userFiltersApi.getUserTaskFilters();
        }
    }
    /**
     * Creates and returns a filter for "Involved" task instances.
     * @param {?} appId ID of the target app
     * @return {?} The newly created filter
     */
    getInvolvedTasksFilterInstance(appId) {
        return new FilterRepresentationModel({
            'name': 'Involved Tasks',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-align-left',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'open', 'assignment': 'involved' }
        });
    }
    /**
     * Creates and returns a filter for "My Tasks" task instances.
     * @param {?} appId ID of the target app
     * @return {?} The newly created filter
     */
    getMyTasksFilterInstance(appId) {
        return new FilterRepresentationModel({
            'name': 'My Tasks',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-inbox',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'open', 'assignment': 'assignee' }
        });
    }
    /**
     * Creates and returns a filter for "Queued Tasks" task instances.
     * @param {?} appId ID of the target app
     * @return {?} The newly created filter
     */
    getQueuedTasksFilterInstance(appId) {
        return new FilterRepresentationModel({
            'name': 'Queued Tasks',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-record',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'open', 'assignment': 'candidate' }
        });
    }
    /**
     * Creates and returns a filter for "Completed" task instances.
     * @param {?} appId ID of the target app
     * @return {?} The newly created filter
     */
    getCompletedTasksFilterInstance(appId) {
        return new FilterRepresentationModel({
            'name': 'Completed Tasks',
            'appId': appId,
            'recent': true,
            'icon': 'glyphicon-ok-sign',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'completed', 'assignment': 'involved' }
        });
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
TaskFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TaskFilterService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/** @nocollapse */ TaskFilterService.ngInjectableDef = defineInjectable({ factory: function TaskFilterService_Factory() { return new TaskFilterService(inject(AlfrescoApiService), inject(LogService)); }, token: TaskFilterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskFiltersComponent {
    /**
     * @param {?} taskFilterService
     * @param {?} taskListService
     * @param {?} appsProcessService
     */
    constructor(taskFilterService, taskListService, appsProcessService) {
        this.taskFilterService = taskFilterService;
        this.taskListService = taskListService;
        this.appsProcessService = appsProcessService;
        /**
         * Emitted when a filter in the list is clicked.
         */
        this.filterClick = new EventEmitter();
        /**
         * Emitted when the list is loaded.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs during loading.
         */
        this.error = new EventEmitter();
        this.filters = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconsMDL = new IconModel();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const appName = changes['appName'];
        /** @type {?} */
        const appId = changes['appId'];
        /** @type {?} */
        const filter$$1 = changes['filterParam'];
        if (appName && appName.currentValue) {
            this.getFiltersByAppName(appName.currentValue);
        }
        else if (appId && appId.currentValue !== appId.previousValue) {
            this.getFiltersByAppId(appId.currentValue);
        }
        else if (filter$$1 && filter$$1.currentValue !== filter$$1.previousValue) {
            this.selectFilter(filter$$1.currentValue);
        }
    }
    /**
     * Return the task list filtered by appId or by appName
     * @param {?=} appId
     * @param {?=} appName
     * @return {?}
     */
    getFilters(appId, appName) {
        appName ? this.getFiltersByAppName(appName) : this.getFiltersByAppId(appId);
    }
    /**
     * Return the filter list filtered by appId
     * @param {?=} appId - optional
     * @return {?}
     */
    getFiltersByAppId(appId) {
        this.taskFilterService.getTaskListFilters(appId).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            if (res.length === 0 && this.isFilterListEmpty()) {
                this.createFiltersByAppId(appId);
            }
            else {
                this.resetFilter();
                this.filters = res;
                this.selectFilter(this.filterParam);
                this.success.emit(res);
            }
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * Return the filter list filtered by appName
     * @param {?} appName
     * @return {?}
     */
    getFiltersByAppName(appName) {
        this.appsProcessService.getDeployedApplicationsByName(appName).subscribe((/**
         * @param {?} application
         * @return {?}
         */
        (application) => {
            this.getFiltersByAppId(application.id);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * Create default filters by appId
     * @param {?=} appId
     * @return {?}
     */
    createFiltersByAppId(appId) {
        this.taskFilterService.createDefaultFilters(appId).subscribe((/**
         * @param {?} resDefault
         * @return {?}
         */
        (resDefault) => {
            this.resetFilter();
            this.filters = resDefault;
            this.selectFilter(this.filterParam);
            this.success.emit(resDefault);
        }), (/**
         * @param {?} errDefault
         * @return {?}
         */
        (errDefault) => {
            this.error.emit(errDefault);
        }));
    }
    /**
     * Pass the selected filter as next
     * @param {?} newFilter
     * @return {?}
     */
    selectFilter(newFilter) {
        if (newFilter) {
            this.currentFilter = this.filters.find((/**
             * @param {?} filter
             * @param {?} index
             * @return {?}
             */
            (filter$$1, index) => newFilter.index === index ||
                newFilter.id === filter$$1.id ||
                (newFilter.name &&
                    (newFilter.name.toLocaleLowerCase() === filter$$1.name.toLocaleLowerCase()))));
        }
        if (!this.currentFilter) {
            this.selectDefaultTaskFilter();
        }
    }
    /**
     * @param {?} newFilter
     * @return {?}
     */
    selectFilterAndEmit(newFilter) {
        this.selectFilter(newFilter);
        this.filterClick.emit(this.currentFilter);
    }
    /**
     * Select filter with task
     * @param {?} taskId
     * @return {?}
     */
    selectFilterWithTask(taskId) {
        /** @type {?} */
        const filteredFilterList = [];
        this.taskListService.getFilterForTaskById(taskId, this.filters).subscribe((/**
         * @param {?} filter
         * @return {?}
         */
        (filter$$1) => {
            filteredFilterList.push(filter$$1);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }), (/**
         * @return {?}
         */
        () => {
            if (filteredFilterList.length > 0) {
                this.selectFilter(filteredFilterList[0]);
                this.filterClick.emit(this.currentFilter);
            }
        }));
    }
    /**
     * Select as default task filter the first in the list
     * @return {?}
     */
    selectDefaultTaskFilter() {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
        }
    }
    /**
     * Return the current task
     * @return {?}
     */
    getCurrentFilter() {
        return this.currentFilter;
    }
    /**
     * Check if the filter list is empty
     * @return {?}
     */
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    /**
     * Reset the filters properties
     * @private
     * @return {?}
     */
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
    /**
     * Return current filter icon
     * @param {?} icon
     * @return {?}
     */
    getFilterIcon(icon) {
        return this.iconsMDL.mapGlyphiconToMaterialDesignIcons(icon);
    }
}
TaskFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-filters',
                template: "<div class=\"menu-container\">\n    <mat-list class=\"adf-menu-list\">\n        <mat-list-item (click)=\"selectFilterAndEmit(filter)\" *ngFor=\"let filter of filters\"\n                      class=\"adf-filters__entry\" [class.adf-active]=\"currentFilter === filter\">\n            <mat-icon *ngIf=\"showIcon\" matListIcon class=\"adf-filters__entry-icon\">{{getFilterIcon(filter.icon)}}</mat-icon>\n            <span matLine [attr.data-automation-id]=\"filter.name + '_filter'\">{{filter.name}}</span>\n        </mat-list-item>\n    </mat-list>\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
TaskFiltersComponent.ctorParameters = () => [
    { type: TaskFilterService },
    { type: TaskListService },
    { type: AppsProcessService }
];
TaskFiltersComponent.propDecorators = {
    filterParam: [{ type: Input }],
    filterClick: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    appId: [{ type: Input }],
    appName: [{ type: Input }],
    showIcon: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const JSON_FORMAT = 'json';
/** @type {?} */
const PDF_FORMAT = 'pdf';
class TaskAuditDirective {
    /**
     *
     * @param {?} contentService
     * @param {?} taskListService
     */
    constructor(contentService, taskListService) {
        this.contentService = contentService;
        this.taskListService = taskListService;
        /**
         * Name of the downloaded file (for PDF downloads).
         */
        this.fileName = 'Audit';
        /**
         * Format of the audit information. Can be "pdf" or "json".
         */
        this.format = 'pdf';
        /**
         * Enables downloading of the audit when the decorated element is clicked.
         */
        this.download = true;
        /**
         * Emitted when the decorated element is clicked.
         */
        this.clicked = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.isValidType()) {
            this.setDefaultFormatType();
        }
    }
    /**
     * @return {?}
     */
    isValidType() {
        if (this.format && (this.isJsonFormat() || this.isPdfFormat())) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    setDefaultFormatType() {
        this.format = PDF_FORMAT;
    }
    /**
     * fetch the audit information in the requested format
     * @return {?}
     */
    fetchAuditInfo() {
        if (this.isPdfFormat()) {
            this.taskListService.fetchTaskAuditPdfById(this.taskId).subscribe((/**
             * @param {?} blob
             * @return {?}
             */
            (blob) => {
                this.audit = blob;
                if (this.download) {
                    this.contentService.downloadBlob(this.audit, this.fileName + '.pdf');
                }
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
        else {
            this.taskListService.fetchTaskAuditJsonById(this.taskId).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.audit = res;
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
    }
    /**
     * @return {?}
     */
    onClickAudit() {
        this.fetchAuditInfo();
    }
    /**
     * @return {?}
     */
    isJsonFormat() {
        return this.format === JSON_FORMAT;
    }
    /**
     * @return {?}
     */
    isPdfFormat() {
        return this.format === PDF_FORMAT;
    }
}
TaskAuditDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[adf-task-audit]',
                host: {
                    'role': 'button',
                    '(click)': 'onClickAudit()'
                }
            },] }
];
/** @nocollapse */
TaskAuditDirective.ctorParameters = () => [
    { type: ContentService },
    { type: TaskListService }
];
TaskAuditDirective.propDecorators = {
    taskId: [{ type: Input, args: ['task-id',] }],
    fileName: [{ type: Input }],
    format: [{ type: Input }],
    download: [{ type: Input }],
    clicked: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = MOMENT_DATE_FORMATS;
class StartTaskComponent {
    /**
     * Constructor
     * @param {?} taskService
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     * @param {?} formBuilder
     * @param {?} logService
     */
    constructor(taskService, dateAdapter, userPreferencesService, formBuilder, logService) {
        this.taskService = taskService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.formBuilder = formBuilder;
        this.logService = logService;
        this.FORMAT_DATE = 'DD/MM/YYYY';
        this.MAX_LENGTH = 255;
        /**
         * Default Task Name.
         */
        this.name = '';
        /**
         * Emitted when the task is successfully created.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when the cancel button is clicked by the user.
         */
        this.cancel = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.taskDetailsModel = new TaskDetailsModel();
        this.dateError = false;
        this.maxTaskNameLength = this.MAX_LENGTH;
        this.loading = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.name) {
            this.taskDetailsModel.name = this.name;
        }
        this.validateMaxTaskNameLength();
        this.field = new FormFieldModel(new FormModel(), { id: this.assigneeId, value: this.assigneeId, placeholder: 'Assignee' });
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            this.dateAdapter.setLocale(locale);
        }));
        this.loadFormsTask();
        this.buildForm();
    }
    /**
     * @return {?}
     */
    buildForm() {
        this.taskForm = this.formBuilder.group({
            name: new FormControl(this.taskDetailsModel.name, [Validators.required, Validators.maxLength(this.maxTaskNameLength), this.whitespaceValidator]),
            description: new FormControl('', [this.whitespaceValidator]),
            formKey: new FormControl('')
        });
        this.taskForm.valueChanges.subscribe((/**
         * @param {?} taskFormValues
         * @return {?}
         */
        (taskFormValues) => this.setTaskDetails(taskFormValues)));
    }
    /**
     * @param {?} control
     * @return {?}
     */
    whitespaceValidator(control) {
        if (control.value) {
            /** @type {?} */
            const isWhitespace = (control.value || '').trim().length === 0;
            /** @type {?} */
            const isValid = control.value.length === 0 || !isWhitespace;
            return isValid ? null : { 'whitespace': true };
        }
    }
    /**
     * @param {?} form
     * @return {?}
     */
    setTaskDetails(form) {
        this.taskDetailsModel.name = form.name;
        this.taskDetailsModel.description = form.description;
        this.taskDetailsModel.formKey = form.formKey ? form.formKey.toString() : null;
    }
    /**
     * @return {?}
     */
    isFormValid() {
        return this.taskForm.valid && !this.dateError && !this.loading;
    }
    /**
     * @return {?}
     */
    saveTask() {
        this.loading = true;
        if (this.appId) {
            this.taskDetailsModel.category = this.appId.toString();
        }
        this.taskService.createNewTask(this.taskDetailsModel)
            .pipe(switchMap((/**
         * @param {?} createRes
         * @return {?}
         */
        (createRes) => this.attachForm(createRes.id, this.taskDetailsModel.formKey).pipe(defaultIfEmpty(createRes), switchMap((/**
         * @param {?} attachRes
         * @return {?}
         */
        (attachRes) => this.assignTaskByUserId(createRes.id, this.assigneeId).pipe(defaultIfEmpty(attachRes ? attachRes : createRes))))))))
            .subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            this.loading = false;
            this.success.emit(res);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.loading = false;
            this.error.emit(err);
            this.logService.error('An error occurred while creating new task');
        }));
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    getAssigneeId(userId) {
        this.assigneeId = userId;
    }
    /**
     * @private
     * @param {?} taskId
     * @param {?} formKey
     * @return {?}
     */
    attachForm(taskId, formKey) {
        /** @type {?} */
        let response = of();
        if (taskId && formKey) {
            response = this.taskService.attachFormToATask(taskId, parseInt(formKey, 10));
        }
        return response;
    }
    /**
     * @private
     * @param {?} taskId
     * @param {?} userId
     * @return {?}
     */
    assignTaskByUserId(taskId, userId) {
        /** @type {?} */
        let response = of();
        if (taskId && userId) {
            response = this.taskService.assignTaskByUserId(taskId, userId);
        }
        return response;
    }
    /**
     * @return {?}
     */
    onCancel() {
        this.cancel.emit();
    }
    /**
     * @private
     * @return {?}
     */
    loadFormsTask() {
        this.forms$ = this.taskService.getFormList();
    }
    /**
     * @param {?} user
     * @return {?}
     */
    isUserNameEmpty(user) {
        return !user || (this.isEmpty(user.firstName) && this.isEmpty(user.lastName));
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    isEmpty(data) {
        return data === undefined || data === null || data.trim().length === 0;
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @param {?=} delimiter
     * @return {?}
     */
    getDisplayUser(firstName, lastName, delimiter = '-') {
        firstName = (firstName !== null ? firstName : '');
        lastName = (lastName !== null ? lastName : '');
        return firstName + delimiter + lastName;
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        this.dateError = false;
        if (newDateValue) {
            /** @type {?} */
            let momentDate;
            if (typeof newDateValue === 'string') {
                momentDate = moment$1(newDateValue, this.FORMAT_DATE, true);
            }
            else {
                momentDate = newDateValue;
            }
            if (momentDate.isValid()) {
                this.taskDetailsModel.dueDate = momentDate.toDate();
            }
            else {
                this.dateError = true;
                this.taskDetailsModel.dueDate = null;
            }
        }
        else {
            this.taskDetailsModel.dueDate = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    validateMaxTaskNameLength() {
        if (this.maxTaskNameLength > this.MAX_LENGTH) {
            this.maxTaskNameLength = this.MAX_LENGTH;
            this.logService.log(`the task name length cannot be greater than ${this.MAX_LENGTH}`);
        }
    }
    /**
     * @return {?}
     */
    get nameController() {
        return this.taskForm.get('name');
    }
    /**
     * @return {?}
     */
    get descriptionController() {
        return this.taskForm.get('description');
    }
    /**
     * @return {?}
     */
    get formKeyController() {
        return this.taskForm.get('formKey');
    }
}
StartTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-task',
                template: "<mat-card fxFlex=\"70%\" class=\"adf-new-task-layout-card\">\n    <mat-card-header fxLayout=\"row\" fxLayoutAlign=\"start center\" fxLayoutGap=\"10px\" class=\"adf-new-task-heading\">\n        <mat-card-title>{{'ADF_TASK_LIST.START_TASK.FORM.TITLE' | translate}}</mat-card-title>\n    </mat-card-header>\n    <mat-card-content>\n        <form [formGroup]=\"taskForm\" fxLayout=\"column\" fxLayoutGap=\"10px\">\n            <div class=\"adf-task-name\">\n                <mat-form-field fxFlex>\n                    <mat-label>{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.NAME' | translate}}</mat-label>\n                    <input\n                        matInput\n                        id=\"name_id\"\n                        formControlName=\"name\">\n                        <mat-error *ngIf=\"nameController.hasError('required') || nameController.hasError('whitespace')\">\n                            {{ 'ADF_TASK_LIST.START_TASK.FORM.ERROR.REQUIRED' | translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"nameController.hasError('maxlength')\">\n                            {{ 'ADF_TASK_LIST.START_TASK.FORM.ERROR.MAXIMUM_LENGTH' | translate : { characters : maxTaskNameLength } }}\n                        </mat-error>\n                </mat-form-field>\n            </div>\n            <div class=\"adf-task-description\">\n                <mat-form-field fxFlex>\n                    <mat-label>{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.DESCRIPTION' | translate}}</mat-label>\n                    <textarea\n                        matInput\n                        rows=\"1\"\n                        id=\"description_id\"\n                        formControlName=\"description\">\n                    </textarea>\n                    <mat-error *ngIf=\"descriptionController.hasError('whitespace')\">\n                        {{ 'ADF_TASK_LIST.START_TASK.FORM.ERROR.MESSAGE' | translate }}\n                    </mat-error>\n                </mat-form-field>\n            </div>\n            <div class=\"input-row\" fxLayout=\"row\" fxLayout.lt-md=\"column\" fxLayoutGap=\"20px\" fxLayoutGap.lt-md=\"0px\">\n                <mat-form-field fxFlex>\n                    <input\n                        matInput\n                        (keyup)=\"onDateChanged($event.srcElement.value)\"\n                        (dateInput)=\"onDateChanged($event.value)\"\n                        [matDatepicker]=\"taskDatePicker\"\n                        placeholder=\"{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.DATE'|translate}}\"\n                        id=\"date_id\">\n                    <mat-datepicker-toggle\n                        matSuffix\n                        [for]=\"taskDatePicker\"></mat-datepicker-toggle>\n                    <mat-datepicker\n                        #taskDatePicker\n                        [touchUi]=\"true\">\n                    </mat-datepicker>\n                    <div class=\"adf-error-text-container\">\n                        <div *ngIf=\"dateError\">\n                            <div class=\"adf-error-text\">{{'ADF_TASK_LIST.START_TASK.FORM.ERROR.DATE'|translate}}</div>\n                            <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n                        </div>\n                    </div>\n                </mat-form-field>\n                <div fxFlex>\n                    <people-widget\n                        (peopleSelected)=\"getAssigneeId($event)\"\n                        [field]=\"field\"\n                        class=\"adf-people-widget-content\"></people-widget>\n                </div>\n            </div>\n            <div class=\"adf-task-form\">\n                <mat-form-field fxFlex=\"48%\" fxFlex.xs=\"100%\">\n                    <mat-label id=\"form_label\">{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.FORM'|translate}}</mat-label>\n                    <mat-select\n                        id=\"form_id\"\n                        class=\"form-control\"\n                        formControlName=\"formKey\">\n                    <mat-option>{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.NONE'|translate}}</mat-option>\n                    <mat-option *ngFor=\"let form of forms$ | async\" [value]=\"form.id\">{{ form.name }}</mat-option>\n                    </mat-select>\n                </mat-form-field>\n            </div>\n        </form>\n    </mat-card-content>\n    <mat-card-actions>\n        <div class=\"adf-new-task-footer\" fxLayout=\"row\" fxLayoutAlign=\"end end\">\n            <button\n                mat-button\n                (click)=\"onCancel()\"\n                id=\"button-cancel\">\n                {{'ADF_TASK_LIST.START_TASK.FORM.ACTION.CANCEL'|translate}}\n            </button>\n            <button\n                color=\"primary\"\n                mat-button\n                [disabled]=\"!isFormValid()\"\n                (click)=\"saveTask()\"\n                id=\"button-start\">\n                {{'ADF_TASK_LIST.START_TASK.FORM.ACTION.START'|translate}}\n            </button>\n        </div>\n    </mat-card-actions>\n</mat-card>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
StartTaskComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: DateAdapter },
    { type: UserPreferencesService },
    { type: FormBuilder },
    { type: LogService }
];
StartTaskComponent.propDecorators = {
    appId: [{ type: Input }],
    name: [{ type: Input }],
    success: [{ type: Output }],
    cancel: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskStandaloneComponent {
    constructor() {
        /**
         * If true then Task completed message is shown and `Complete` and `Cancel` buttons are hidden.
         */
        this.isCompleted = false;
        /**
         * Toggles rendering of the `Complete` button.
         */
        this.hasCompletePermission = true;
        // TODO: rename all with show prefix
        /**
         * Toggles rendering of the `Cancel` button.
         */
        this.hideCancelButton = true;
        /**
         * Emitted when the "Cancel" button is clicked.
         */
        this.cancel = new EventEmitter();
        /**
         * Emitted when the form associated with the task is completed.
         */
        this.complete = new EventEmitter();
        /**
         * Emitted when the form associated with the form task is attached.
         */
        this.showAttachForm = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onCancelButtonClick() {
        this.cancel.emit();
    }
    /**
     * @return {?}
     */
    onCompleteButtonClick() {
        this.complete.emit();
    }
    /**
     * @return {?}
     */
    hasCompleteButton() {
        return this.hasCompletePermission && !this.isCompleted;
    }
    /**
     * @return {?}
     */
    hasCancelButton() {
        return !this.hideCancelButton && !this.isCompleted;
    }
    /**
     * @return {?}
     */
    hasAttachFormButton() {
        return !this.isCompleted;
    }
    /**
     * @return {?}
     */
    onShowAttachForm() {
        this.showAttachForm.emit();
    }
}
TaskStandaloneComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-standalone',
                template: "<mat-card class=\"adf-message-card\">\n    <mat-card-content>\n        <div class=\"adf-no-form-message-container\">\n            <div class=\"adf-no-form-message-list\">\n                <div *ngIf=\"!isCompleted; else completedMessage\" class=\"adf-no-form-message\">\n                    <span id=\"adf-no-form-message\">{{'ADF_TASK_LIST.STANDALONE_TASK.NO_FORM_MESSAGE' | translate}}</span>\n                </div>\n                <ng-template #completedMessage>\n                    <div id=\"adf-completed-form-message\" class=\"adf-no-form-message\">\n                        <p>{{'ADF_TASK_LIST.STANDALONE_TASK.COMPLETE_TASK_MESSAGE' | translate : {taskName : taskName} }}</p>\n                    </div>\n                    <div class=\"adf-no-form-submessage\">\n                        {{'ADF_TASK_LIST.STANDALONE_TASK.COMPLETE_TASK_SUB_MESSAGE' | translate}}\n                    </div>\n                </ng-template>\n            </div>\n        </div>\n    </mat-card-content>\n\n    <mat-card-actions class=\"adf-no-form-mat-card-actions\">\n        <button mat-button *ngIf=\"hasAttachFormButton()\" id=\"adf-no-form-attach-form-button\" (click)=\"onShowAttachForm()\">{{ 'ADF_TASK_LIST.START_TASK.FORM.LABEL.ATTACHFORM' | translate }}</button>\n        <div>\n            <button mat-button *ngIf=\"hasCancelButton()\" id=\"adf-no-form-cancel-button\" (click)=\"onCancelButtonClick()\">{{ 'ADF_TASK_LIST.START_TASK.FORM.ACTION.CANCEL' | translate }}</button>\n            <button mat-button *ngIf=\"hasCompleteButton()\" id=\"adf-no-form-complete-button\" color=\"primary\" (click)=\"onCompleteButtonClick()\">{{ 'ADF_TASK_LIST.DETAILS.BUTTON.COMPLETE' | translate }}</button>\n        </div>\n    </mat-card-actions>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
TaskStandaloneComponent.ctorParameters = () => [];
TaskStandaloneComponent.propDecorators = {
    taskName: [{ type: Input }],
    taskId: [{ type: Input }],
    isCompleted: [{ type: Input }],
    hasCompletePermission: [{ type: Input }],
    hideCancelButton: [{ type: Input }],
    cancel: [{ type: Output }],
    complete: [{ type: Output }],
    showAttachForm: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttachFormComponent {
    /**
     * @param {?} taskService
     * @param {?} logService
     * @param {?} formService
     */
    constructor(taskService, logService, formService) {
        this.taskService = taskService;
        this.logService = logService;
        this.formService = formService;
        /**
         * Emitted when the "Cancel" button is clicked.
         */
        this.cancelAttachForm = new EventEmitter();
        /**
         * Emitted when the form is attached successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.disableSubmit = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.attachFormControl = new FormControl('', Validators.required);
        this.attachFormControl.valueChanges.subscribe((/**
         * @param {?} currentValue
         * @return {?}
         */
        (currentValue) => {
            if (this.attachFormControl.valid) {
                if (this.formId !== currentValue) {
                    this.disableSubmit = false;
                }
                else {
                    this.disableSubmit = true;
                }
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.formId = undefined;
        this.disableSubmit = true;
        this.loadFormsTask();
        if (this.formKey) {
            this.onFormAttached();
        }
    }
    /**
     * @return {?}
     */
    onCancelButtonClick() {
        this.selectedFormId = this.formId;
        this.cancelAttachForm.emit();
    }
    /**
     * @return {?}
     */
    onRemoveButtonClick() {
        this.taskService.deleteForm(this.taskId).subscribe((/**
         * @return {?}
         */
        () => {
            this.formId = this.selectedFormId = null;
            this.success.emit();
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
            this.logService.error('An error occurred while trying to delete the form');
        }));
    }
    /**
     * @return {?}
     */
    onAttachFormButtonClick() {
        this.attachForm(this.taskId, this.selectedFormId);
    }
    /**
     * @private
     * @return {?}
     */
    loadFormsTask() {
        this.taskService.getFormList().subscribe((/**
         * @param {?} form
         * @return {?}
         */
        (form) => {
            this.forms = form;
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
            this.logService.error('An error occurred while trying to get the forms');
        }));
    }
    /**
     * @private
     * @return {?}
     */
    onFormAttached() {
        this.formService.getTaskForm(this.taskId)
            .subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            this.formService.getFormDefinitionByName(res.name).subscribe((/**
             * @param {?} formDef
             * @return {?}
             */
            (formDef) => {
                this.formId = this.selectedFormId = formDef;
            }));
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
            this.logService.error('Could not load forms');
        }));
    }
    /**
     * @private
     * @param {?} taskId
     * @param {?} formId
     * @return {?}
     */
    attachForm(taskId, formId) {
        if (taskId && formId) {
            this.taskService.attachFormToATask(taskId, formId)
                .subscribe((/**
             * @return {?}
             */
            () => {
                this.success.emit();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
                this.logService.error('Could not attach form');
            }));
        }
    }
}
AttachFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-attach-form',
                template: "<div class=\"adf-attach-form\">\n    <mat-card>\n        <mat-card-content>\n            <div class=\"adf-no-form-message-container\">\n                <mat-card-title class=\"mat-card-title\">\n                    <h4 class=\"adf-form-title\">{{ 'ADF_TASK_LIST.ATTACH_FORM.SELECT_FORM' | translate }}</h4>\n                </mat-card-title>\n                <div class=\"adf-attach-form-row\">\n                    <mat-form-field class=\"adf-grid-full-width\">\n                        <mat-select [formControl]=\"attachFormControl\" placeholder=\"{{ 'ADF_TASK_LIST.ATTACH_FORM.SELECT_OPTION' | translate }}\" id=\"form_id\" [(ngModel)]=\"selectedFormId\">\n                            <mat-option *ngFor=\"let form of forms\" [value]=\"form.id\">{{ form.name }}</mat-option>\n                        </mat-select>\n                    </mat-form-field>\n                </div>\n\n                <adf-form *ngIf=\"this.attachFormControl.valid\"\n                    [formId]=\"selectedFormId\"\n                    [readOnly]=\"true\"\n                    [showCompleteButton]=\"false\"\n                    [showRefreshButton]=\"false\"\n                    [showValidationIcon]=\"false\">\n                </adf-form>\n            </div>\n        </mat-card-content>\n\n        <mat-card-actions class=\"adf-no-form-mat-card-actions\">\n            <div>\n                <button mat-button id=\"adf-no-form-remove-button\" color=\"warn\" *ngIf=\"formKey\" (click)=\"onRemoveButtonClick()\">{{ 'ADF_TASK_LIST.ATTACH_FORM.REMOVE_FORM' | translate }}</button>\n            </div>\n            <div>\n                <button mat-button id=\"adf-no-form-cancel-button\" (click)=\"onCancelButtonClick()\">{{ 'ADF_TASK_LIST.START_TASK.FORM.ACTION.CANCEL' | translate }}</button>\n                <button mat-button id=\"adf-no-form-attach-form-button\" [disabled]=\"disableSubmit\" color=\"primary\" (click)=\"onAttachFormButtonClick()\">{{ 'ADF_TASK_LIST.START_TASK.FORM.LABEL.ATTACHFORM' | translate }}</button>\n            </div>\n        </mat-card-actions>\n    </mat-card>\n</div>\n",
                styles: [".adf-attach-form .mat-form-field{width:100%}.adf-attach-form-row{display:flex;justify-content:space-between;margin:20px 0}.adf-attach-form .adf-no-form-mat-card-actions{justify-content:space-between;margin-top:30px;text-align:right}"]
            }] }
];
/** @nocollapse */
AttachFormComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: LogService },
    { type: FormService }
];
AttachFormComponent.propDecorators = {
    taskId: [{ type: Input }],
    formKey: [{ type: Input }],
    cancelAttachForm: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessUploadService extends UploadService {
    /**
     * @param {?} apiService
     * @param {?} appConfigService
     */
    constructor(apiService, appConfigService) {
        super(apiService, appConfigService);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    getUploadPromise(file) {
        /** @type {?} */
        const opts = {
            isRelatedContent: true
        };
        /** @type {?} */
        const processInstanceId = file.options.parentId;
        /** @type {?} */
        const promise = this.apiService.getInstance().activiti.contentApi.createRelatedContentOnProcessInstance(processInstanceId, file.file, opts);
        promise.catch((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
        return promise;
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return throwError(error || 'Server error');
    }
}
ProcessUploadService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ProcessUploadService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService }
];
/** @nocollapse */ ProcessUploadService.ngInjectableDef = defineInjectable({ factory: function ProcessUploadService_Factory() { return new ProcessUploadService(inject(AlfrescoApiService), inject(AppConfigService)); }, token: ProcessUploadService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskUploadService extends UploadService {
    /**
     * @param {?} apiService
     * @param {?} appConfigService
     */
    constructor(apiService, appConfigService) {
        super(apiService, appConfigService);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    getUploadPromise(file) {
        /** @type {?} */
        const opts = {
            isRelatedContent: true
        };
        /** @type {?} */
        const taskId = file.options.parentId;
        /** @type {?} */
        const promise = this.apiService.getInstance().activiti.contentApi.createRelatedContentOnTask(taskId, file.file, opts);
        promise.catch((/**
         * @param {?} err
         * @return {?}
         */
        (err) => this.handleError(err)));
        return promise;
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        return throwError(error || 'Server error');
    }
}
TaskUploadService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TaskUploadService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService }
];
/** @nocollapse */ TaskUploadService.ngInjectableDef = defineInjectable({ factory: function TaskUploadService_Factory() { return new TaskUploadService(inject(AlfrescoApiService), inject(AppConfigService)); }, token: TaskUploadService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StartTaskModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.name = obj && obj.name || null;
        this.description = obj && obj.description || null;
        this.assignee = obj && obj.assignee ? new UserProcessModel(obj.assignee) : null;
        this.dueDate = obj && obj.dueDate || null;
        this.formKey = obj && obj.formKey || null;
        this.category = obj && obj.category || null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskDetailsEvent {
    /**
     * @param {?} value
     */
    constructor(value) {
        this._defaultPrevented = false;
        this._value = value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this._defaultPrevented = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This object represent the User Event.
 */
class UserEventModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.type = '';
        this.value = {};
        this.type = obj && obj.type;
        this.value = obj && obj.value || {};
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This object represent the process service user group.*
 */
class UserGroupModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.groups = {};
        this.id = obj && obj.id;
        this.name = obj && obj.name;
        this.externalId = obj && obj.externalId;
        this.status = obj && obj.status;
        this.groups = obj && obj.groups;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function modules() {
    return [
        MatAutocompleteModule, MatButtonModule, MatCardModule, MatDialogModule,
        MatCheckboxModule, MatDatepickerModule, MatGridListModule, MatIconModule, MatInputModule,
        MatListModule, MatOptionModule, MatRadioModule, MatSelectModule, MatSlideToggleModule, MatTableModule,
        MatTabsModule, MatProgressSpinnerModule, MatNativeDateModule, MatRippleModule, MatTooltipModule,
        MatChipsModule, MatMenuModule
    ];
}
const ɵ0$1 = { float: 'never' };
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    { provide: MAT_LABEL_GLOBAL_OPTIONS, useValue: ɵ0$1 }
                ],
                imports: modules(),
                exports: modules()
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessCommentsComponent {
    /**
     * @param {?} commentProcessService
     */
    constructor(commentProcessService) {
        this.commentProcessService = commentProcessService;
        /**
         * Should the comments be read-only?
         */
        this.readOnly = true;
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.comments = [];
        this.beingAdded = false;
        this.comment$ = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => this.commentObserver = observer))
            .pipe(share());
        this.comment$.subscribe((/**
         * @param {?} comment
         * @return {?}
         */
        (comment) => {
            this.comments.push(comment);
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const processInstanceId = changes['processInstanceId'];
        if (processInstanceId) {
            if (processInstanceId.currentValue) {
                this.getProcessInstanceComments(processInstanceId.currentValue);
            }
            else {
                this.resetComments();
            }
        }
    }
    /**
     * @private
     * @param {?} processInstanceId
     * @return {?}
     */
    getProcessInstanceComments(processInstanceId) {
        this.resetComments();
        if (processInstanceId) {
            this.commentProcessService.getProcessInstanceComments(processInstanceId).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                res = res.sort((/**
                 * @param {?} comment1
                 * @param {?} comment2
                 * @return {?}
                 */
                (comment1, comment2) => {
                    /** @type {?} */
                    const date1 = new Date(comment1.created);
                    /** @type {?} */
                    const date2 = new Date(comment2.created);
                    return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                }));
                res.forEach((/**
                 * @param {?} comment
                 * @return {?}
                 */
                (comment) => {
                    this.commentObserver.next(comment);
                }));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetComments() {
        this.comments = [];
    }
    /**
     * @return {?}
     */
    add() {
        if (this.message && this.message.trim() && !this.beingAdded) {
            this.beingAdded = true;
            this.commentProcessService.addProcessInstanceComment(this.processInstanceId, this.message)
                .subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.comments.unshift(res);
                this.message = '';
                this.beingAdded = false;
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
                this.beingAdded = false;
            }));
        }
    }
    /**
     * @return {?}
     */
    clear() {
        this.message = '';
    }
    /**
     * @return {?}
     */
    isReadOnly() {
        return this.readOnly;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    onError(error) {
        this.error.emit(error);
    }
}
ProcessCommentsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-comments',
                template: "<div class=\"adf-comments-container\">\n    <div id=\"comment-header\" class=\"adf-comments-header\">\n        {{'ADF_PROCESS_LIST.DETAILS.COMMENTS.HEADER' | translate: { count: comments?.length} }}\n    </div>\n    <div class=\"adf-comments-input-container\" *ngIf=\"!isReadOnly()\">\n        <mat-form-field class=\"adf-full-width\">\n            <input matInput id=\"comment-input\" placeholder=\"{{'ADF_PROCESS_LIST.DETAILS.COMMENTS.ADD' | translate}}\" [(ngModel)]=\"message\" (keyup.enter)=\"add()\" (keyup.esc)=\"clear()\">\n        </mat-form-field>\n    </div>\n\n    <div *ngIf=\"comments.length > 0\">\n        <adf-comment-list [comments]=\"comments\">\n        </adf-comment-list>\n    </div>\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
ProcessCommentsComponent.ctorParameters = () => [
    { type: CommentProcessService }
];
ProcessCommentsComponent.propDecorators = {
    processInstanceId: [{ type: Input }],
    readOnly: [{ type: Input }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessCommentsModule {
}
ProcessCommentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CommonModule,
                    CoreModule.forChild()
                ],
                declarations: [
                    ProcessCommentsComponent
                ],
                exports: [
                    ProcessCommentsComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeopleSearchComponent {
    constructor() {
        /**
         * Emitted when a search is performed with a new keyword.
         */
        this.searchPeople = new EventEmitter();
        /**
         * Emitted when a user is selected and the action button is clicked.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when the "close" button is clicked.
         */
        this.closeSearch = new EventEmitter();
        this.selectedUser = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.filteredResults$ = this.results
            .pipe(map((/**
         * @param {?} users
         * @return {?}
         */
        (users) => {
            return users.filter((/**
             * @param {?} user
             * @return {?}
             */
            (user) => user.id !== this.selectedUser.id));
        })));
        this.performSearch = this.performSearchCallback.bind(this);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    performSearchCallback(event) {
        this.searchPeople.emit(event);
        return this.filteredResults$;
    }
    /**
     * @param {?} user
     * @return {?}
     */
    onRowClick(user) {
        this.selectedUser = user;
    }
    /**
     * @return {?}
     */
    closeSearchList() {
        this.closeSearch.emit();
    }
    /**
     * @return {?}
     */
    involveUserAndClose() {
        this.involveUser();
        this.closeSearchList();
    }
    /**
     * @return {?}
     */
    involveUser() {
        if (this.selectedUser === undefined) {
            return;
        }
        this.success.emit(this.selectedUser);
    }
}
PeopleSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-search',
                template: "<div class=\"adf-search-text-header\">\n    <ng-content select=\"[adf-people-search-title], [people-search-title]\"></ng-content>\n</div>\n\n<adf-people-search-field [performSearch]=\"performSearch\" (rowClick)=\"onRowClick($event)\"></adf-people-search-field>\n\n<div class=\"search-list-action-container\">\n    <button mat-button type=\"button\" id=\"close-people-search\" (click)=\"closeSearchList()\">\n        {{'ADF_TASK_LIST.PEOPLE.DIALOG_CLOSE' | translate }}\n    </button>\n    <button mat-button type=\"button\" id=\"add-people\" (click)=\"involveUserAndClose()\">\n        <ng-content select=\"[adf-people-search-action-label], [people-search-action-label]\"></ng-content>\n    </button>\n</div>\n",
                host: {
                    'class': 'adf-people-search'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
PeopleSearchComponent.ctorParameters = () => [];
PeopleSearchComponent.propDecorators = {
    results: [{ type: Input }],
    searchPeople: [{ type: Output }],
    success: [{ type: Output }],
    closeSearch: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeopleComponent {
    /**
     * @param {?} logService
     * @param {?} peopleProcessService
     */
    constructor(logService, peopleProcessService) {
        this.logService = logService;
        this.peopleProcessService = peopleProcessService;
        /**
         * The array of User objects to display.
         */
        this.people = [];
        /**
         * The numeric ID of the task.
         */
        this.taskId = '';
        /**
         * Should the data be read-only?
         */
        this.readOnly = false;
        this.showAssignment = false;
        this.peopleSearch$ = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => this.peopleSearchObserver = observer))
            .pipe(share());
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @return {?}
     */
    involveUserAndCloseSearch() {
        if (this.peopleSearch) {
            this.peopleSearch.involveUserAndClose();
        }
    }
    /**
     * @return {?}
     */
    involveUserWithoutCloseSearch() {
        if (this.peopleSearch) {
            this.peopleSearch.involveUser();
        }
    }
    /**
     * @param {?} searchedWord
     * @return {?}
     */
    searchUser(searchedWord) {
        this.peopleProcessService.getWorkflowUsers(this.taskId, searchedWord)
            .subscribe((/**
         * @param {?} users
         * @return {?}
         */
        (users) => {
            this.peopleSearchObserver.next(users);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.logService.error(error)));
    }
    /**
     * @param {?} user
     * @return {?}
     */
    involveUser(user) {
        this.peopleProcessService.involveUserWithTask(this.taskId, user.id.toString())
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.people = [...this.people, user];
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.logService.error('Impossible to involve user with task')));
    }
    /**
     * @param {?} user
     * @return {?}
     */
    removeInvolvedUser(user) {
        this.peopleProcessService.removeInvolvedUser(this.taskId, user.id.toString())
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.people = this.people.filter((/**
             * @param {?} involvedUser
             * @return {?}
             */
            (involvedUser) => {
                return involvedUser.id !== user.id;
            }));
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.logService.error('Impossible to remove involved user from task')));
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @param {?=} delimiter
     * @return {?}
     */
    getDisplayUser(firstName, lastName, delimiter = '-') {
        firstName = (firstName !== null ? firstName : '');
        lastName = (lastName !== null ? lastName : '');
        return firstName + delimiter + lastName;
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @return {?}
     */
    getInitialUserName(firstName, lastName) {
        firstName = (firstName !== null && firstName !== '' ? firstName[0] : '');
        lastName = (lastName !== null && lastName !== '' ? lastName[0] : '');
        return this.getDisplayUser(firstName, lastName, '');
    }
    /**
     * @return {?}
     */
    onAddAssignment() {
        this.showAssignment = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClickAction(event) {
        if (event.type === 'remove') {
            this.removeInvolvedUser(event.value);
        }
    }
    /**
     * @return {?}
     */
    hasPeople() {
        return this.people && this.people.length > 0;
    }
    /**
     * @return {?}
     */
    isEditMode() {
        return !this.readOnly;
    }
    /**
     * @return {?}
     */
    onCloseSearch() {
        this.showAssignment = false;
    }
}
PeopleComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people',
                template: "<mat-card class=\"adf-assignment-top-container\">\n    <div mat-card-content class=\"adf-assignment-top-container-content\">\n        <div class=\"assignment-header\">\n                <div *ngIf=\"hasPeople()\" class=\"adf-assignment-count\" id=\"people-title\">\n                    {{ 'ADF_TASK_LIST.DETAILS.LABELS.PEOPLE' | translate }} {{ ' (' + people.length + ')' }}\n                </div>\n                <div *ngIf=\"!hasPeople()\" class=\"adf-assignment-count\" id=\"no-people-label\">\n                    {{ 'ADF_TASK_LIST.DETAILS.PEOPLE.NONE' | translate }}\n                </div>\n                <div *ngIf=\"isEditMode()\" class=\"adf-add-people\" (click)=\"onAddAssignment()\">\n                    <mat-icon class=\"adf-add-person-icon\">person_add</mat-icon>\n                </div>\n            </div>\n            <div class=\"adf-assignment-container\" *ngIf=\"showAssignment\">\n                <adf-people-search\n                    #peopleSearch\n                    (searchPeople)=\"searchUser($event)\"\n                    (success)=\"involveUser($event)\"\n                    (closeSearch)=\"onCloseSearch()\"\n                    [results]=\"peopleSearch$\">\n                    <ng-container adf-people-search-title>{{ 'ADF_TASK_LIST.DETAILS.LABELS.ADD_PEOPLE' | translate }}</ng-container>\n                    <ng-container adf-people-search-action-label>{{ 'ADF_TASK_LIST.PEOPLE.ADD_USER' | translate }}</ng-container>\n                </adf-people-search>\n            </div>\n            <div class=\"adf-assignment-list-container\" id=\"assignment-people-list\" *ngIf=\"hasPeople()\">\n                <adf-people-list\n                [users]=\"people\"\n                [actions]=\"isEditMode()\"\n                (clickAction)=\"onClickAction($event)\">\n                    <data-columns>\n                        <data-column key=\"firstName\">\n                            <ng-template let-entry=\"$implicit\">\n                                <div *ngIf=\"!entry.row.obj.pictureId\" class=\"adf-people-search-people-pic\">\n                                    {{getInitialUserName(entry.row.obj.firstName, entry.row.obj.lastName)}}</div>\n                                <div>\n                                    <img [alt]=\"getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ')\" *ngIf=\"entry.row.obj.pictureId\" class=\"adf-people-img\"\n                                        [src]=\"peopleProcessService.getUserImage(entry.row.obj)\"/>\n                                </div>\n                            </ng-template>\n                        </data-column>\n                        <data-column key=\"email\" class=\"adf-full-width\">\n                            <ng-template let-entry=\"$implicit\">\n                                <div class=\"adf-people-user-info\">\n                                    <div class=\"adf-people-full-name\">{{ getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ') }}</div>\n                                    <div class=\"adf-people-email\">{{ entry.row.obj.email }}</div>\n                                </div>\n                            </ng-template>\n                        </data-column>\n                    </data-columns>\n                </adf-people-list>\n            </div>\n    </div>\n</mat-card>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
PeopleComponent.ctorParameters = () => [
    { type: LogService },
    { type: PeopleProcessService }
];
PeopleComponent.propDecorators = {
    people: [{ type: Input }],
    taskId: [{ type: Input }],
    readOnly: [{ type: Input }],
    peopleSearch: [{ type: ViewChild, args: ['peopleSearch',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeopleListComponent {
    constructor() {
        /**
         * Toggles whether or not actions should be visible, i.e. the 'Three-Dots' menu.
         */
        this.actions = false;
        /**
         * Emitted when the user clicks a row in the people list.
         */
        this.clickRow = new EventEmitter();
        /**
         * Emitted when the user clicks in the 'Three Dots' drop down menu for a row.
         */
        this.clickAction = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.peopleDataTable.columnList = this.columnList;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    selectUser(event) {
        this.user = event.value.obj;
        this.clickRow.emit(this.user);
    }
    /**
     * @return {?}
     */
    hasActions() {
        return this.actions;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowActionsMenu(event) {
        /** @type {?} */
        const removeAction = {
            title: 'Remove',
            name: 'remove'
        };
        event.value.actions = [
            removeAction
        ];
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExecuteRowAction(event) {
        /** @type {?} */
        const args = event.value;
        /** @type {?} */
        const action = args.action;
        this.clickAction.emit(new UserEventModel({ type: action.name, value: args.row.obj }));
    }
}
PeopleListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-list',
                template: "<adf-datatable\n    #dataTable\n    class=\"adf-task-people-list\"\n    [rows]=\"users\"\n    [actions]=\"hasActions()\"\n    [showHeader]=\"false\"\n    (rowClick)=\"selectUser($event)\"\n    (rowDblClick)=\"selectUser($event)\"\n    (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n    (executeRowAction)=\"onExecuteRowAction($event)\">\n</adf-datatable>\n",
                styles: [""]
            }] }
];
PeopleListComponent.propDecorators = {
    columnList: [{ type: ContentChild, args: [DataColumnListComponent,] }],
    peopleDataTable: [{ type: ViewChild, args: ['dataTable',] }],
    users: [{ type: Input }],
    actions: [{ type: Input }],
    clickRow: [{ type: Output }],
    clickAction: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {?} firstName
 * @param {?} lastName
 * @param {?=} delimiter
 * @return {?}
 */
function getDisplayUser(firstName, lastName, delimiter = '-') {
    firstName = (firstName !== null ? firstName : '');
    lastName = (lastName !== null ? lastName : '');
    return firstName + delimiter + lastName;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeopleSearchFieldComponent {
    /**
     * @param {?} peopleProcessService
     * @param {?} translationService
     */
    constructor(peopleProcessService, translationService) {
        this.peopleProcessService = peopleProcessService;
        this.translationService = translationService;
        this.rowClick = new EventEmitter();
        this.searchUser = new FormControl();
        this.defaultPlaceholder = 'ADF_TASK_LIST.PEOPLE.SEARCH_USER';
        this.users$ = this.searchUser.valueChanges
            .pipe(debounceTime(200), switchMap((/**
         * @param {?} searchWord
         * @return {?}
         */
        (searchWord) => {
            if (searchWord && searchWord.trim()) {
                return this.performSearch(searchWord);
            }
            else {
                return of([]);
            }
        })));
        this.defaultPlaceholder = this.translationService.instant(this.defaultPlaceholder);
    }
    /**
     * @return {?}
     */
    reset() {
        this.searchUser.reset();
    }
    /**
     * @return {?}
     */
    get searchPlaceholder() {
        return this.placeholder || this.defaultPlaceholder;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRowClick(event) {
        this.rowClick.emit(event);
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @param {?=} delimiter
     * @return {?}
     */
    getDisplayUser(firstName, lastName, delimiter = '-') {
        return getDisplayUser(firstName, lastName, delimiter);
    }
    /**
     * @param {?} firstName
     * @param {?} lastName
     * @return {?}
     */
    getInitialUserName(firstName, lastName) {
        firstName = (firstName !== null && firstName !== '' ? firstName[0] : '');
        lastName = (lastName !== null && lastName !== '' ? lastName[0] : '');
        return this.getDisplayUser(firstName, lastName, '');
    }
}
PeopleSearchFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-search-field',
                template: "<mat-form-field class=\"adf-search-text-container\">\n    <input\n        matInput\n        placeholder=\"{{ searchPlaceholder }}\"\n        type=\"text\"\n        id=\"userSearchText\"\n        [value]=\"\"\n        [formControl]=\"searchUser\"\n        data-automation-id=\"adf-people-search-input\">\n</mat-form-field>\n<ng-container *ngIf=\"users$ | async; let users\">\n    <div class=\"adf-search-list-container\" id=\"search-people-list\" *ngIf=\"users.length > 0\">\n        <adf-people-list [users]=\"users\" (clickRow)=\"onRowClick($event)\">\n            <data-columns>\n                <data-column key=\"firstName\">\n                    <ng-template let-entry=\"$implicit\">\n                            <div *ngIf=\"!entry.row.obj.pictureId\" class=\"adf-people-pic\">\n                                {{getInitialUserName(entry.row.obj.firstName, entry.row.obj.lastName)}}</div>\n                            <div>\n                                <img [alt]=\"getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ')\" *ngIf=\"entry.row.obj.pictureId\" class=\"adf-people-img\"\n                                    [src]=\"peopleProcessService.getUserImage(entry.row.obj)\"/>\n                            </div>\n                    </ng-template>\n                </data-column>\n                <data-column key=\"email\" class=\"adf-full-width\">\n                    <ng-template let-entry=\"$implicit\">\n                        <div class=\"adf-people-full-name\">{{ getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ') }}</div>\n                    </ng-template>\n                </data-column>\n            </data-columns>\n        </adf-people-list>\n    </div>\n</ng-container>\n",
                host: { 'class': 'adf-people-search-field' },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
PeopleSearchFieldComponent.ctorParameters = () => [
    { type: PeopleProcessService },
    { type: TranslationService }
];
PeopleSearchFieldComponent.propDecorators = {
    performSearch: [{ type: Input }],
    placeholder: [{ type: Input }],
    rowClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_ASSIGNEE_PLACEHOLDER = 'ADF_TASK_LIST.PEOPLE.ASSIGNEE';
class PeopleSelectorComponent {
    /**
     * @param {?} peopleProcessService
     * @param {?} logService
     * @param {?} translationService
     */
    constructor(peopleProcessService, logService, translationService) {
        this.peopleProcessService = peopleProcessService;
        this.logService = logService;
        this.translationService = translationService;
        this.peopleIdChange = new EventEmitter();
        this.performSearch = this.searchUser.bind(this);
        this.defaultPlaceholder = this.translationService.instant(DEFAULT_ASSIGNEE_PLACEHOLDER);
    }
    /**
     * @param {?} searchWord
     * @return {?}
     */
    searchUser(searchWord) {
        return this.peopleProcessService.getWorkflowUsers(undefined, searchWord)
            .pipe(catchError(this.onSearchUserError.bind(this)));
    }
    /**
     * @private
     * @return {?}
     */
    onSearchUserError() {
        this.logService.error('getWorkflowUsers threw error');
        return of([]);
    }
    /**
     * @param {?} user
     * @return {?}
     */
    userSelected(user) {
        this.updateUserSelection(user);
    }
    /**
     * @return {?}
     */
    userDeselected() {
        this.updateUserSelection(undefined);
    }
    /**
     * @private
     * @param {?} user
     * @return {?}
     */
    updateUserSelection(user) {
        this.selectedUser = user;
        this.peopleIdChange.emit(user && user.id || undefined);
        this.searchFieldComponent.reset();
    }
    /**
     * @return {?}
     */
    get placeholder() {
        if (!this.selectedUser) {
            return this.defaultPlaceholder;
        }
        return getDisplayUser(this.selectedUser.firstName, this.selectedUser.lastName, ' ');
    }
}
PeopleSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-selector',
                template: "<adf-people-search-field\n    #peopleSearchField\n    class=\"adf-people-selector-field\"\n    [performSearch]=\"performSearch\"\n    [placeholder]=\"placeholder\"\n    (rowClick)=\"userSelected($event)\">\n</adf-people-search-field>\n<button\n    *ngIf=\"selectedUser\"\n    mat-icon-button\n    class=\"adf-people-selector-deselect\"\n    data-automation-id=\"adf-people-selector-deselect\"\n    (click)=\"userDeselected()\">\n        <mat-icon>cancel</mat-icon>\n</button>\n",
                host: { 'class': 'adf-people-selector' },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
PeopleSelectorComponent.ctorParameters = () => [
    { type: PeopleProcessService },
    { type: LogService },
    { type: TranslationService }
];
PeopleSelectorComponent.propDecorators = {
    peopleId: [{ type: Input }],
    peopleIdChange: [{ type: Output }],
    searchFieldComponent: [{ type: ViewChild, args: ['peopleSearchField',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class PeopleSearchActionLabelDirective {
}
PeopleSearchActionLabelDirective.decorators = [
    { type: Directive, args: [{ selector: 'adf-people-search-action-label, people-search-action-label' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
class PeopleSearchTitleDirective {
}
PeopleSearchTitleDirective.decorators = [
    { type: Directive, args: [{ selector: 'adf-people-search-title, people-search-title' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PeopleModule {
}
PeopleModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CommonModule,
                    CoreModule.forChild()
                ],
                declarations: [
                    PeopleComponent,
                    PeopleSearchComponent,
                    PeopleSearchFieldComponent,
                    PeopleSelectorComponent,
                    PeopleSearchTitleDirective,
                    PeopleSearchActionLabelDirective,
                    PeopleListComponent
                ],
                exports: [
                    PeopleComponent,
                    PeopleSearchComponent,
                    PeopleSearchFieldComponent,
                    PeopleSelectorComponent,
                    PeopleSearchTitleDirective,
                    PeopleSearchActionLabelDirective,
                    PeopleListComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttachFileWidgetDialogComponent {
    /**
     * @param {?} data
     * @param {?} externalApiService
     */
    constructor(data, externalApiService) {
        this.data = data;
        this.externalApiService = externalApiService;
        ((/** @type {?} */ (externalApiService))).init(data.ecmHost, data.context);
        this.buttonActionName = data.actionName ? `ATTACH-FILE.ACTIONS.${data.actionName.toUpperCase()}` : 'ATTACH-FILE.ACTIONS.CHOOSE';
    }
    /**
     * @return {?}
     */
    isLoggedIn() {
        return this.externalApiService.getInstance().isLoggedIn();
    }
    /**
     * @return {?}
     */
    performLogin() {
        this.loginPanel.submitForm();
    }
    /**
     * @return {?}
     */
    close() {
        this.data.selected.complete();
    }
    /**
     * @param {?} nodeList
     * @return {?}
     */
    onSelect(nodeList) {
        if (nodeList && nodeList[0].isFile) {
            this.chosenNode = nodeList;
        }
        else {
            this.chosenNode = null;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        this.data.selected.next(this.chosenNode);
        this.data.selected.complete();
    }
}
AttachFileWidgetDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-attach-file-widget-dialog',
                template: "<header\n    mat-dialog-title\n    data-automation-id=\"content-node-selector-title\">{{data?.title}}\n</header>\n\n<mat-dialog-content class=\"adf-login-dialog-content\">\n    <adf-login-dialog-panel id=\"attach-file-login-panel\" #adfLoginPanel *ngIf=\"!isLoggedIn()\">\n    </adf-login-dialog-panel>\n    <adf-content-node-selector-panel *ngIf=\"isLoggedIn()\"\n                                     id=\"attach-file-content-node\"\n                                     [isSelectionValid]=\"data?.isSelectionValid\"\n                                     (select)=\"onSelect($event)\">\n    </adf-content-node-selector-panel>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n    <button\n        mat-button\n        (click)=\"close()\"\n        data-automation-id=\"attach-file-dialog-actions-cancel\">{{ 'ATTACH-FILE.ACTIONS.CANCEL' | translate }}\n    </button>\n\n    <button *ngIf=\"!isLoggedIn()\"\n        mat-button\n        (click)=\"performLogin()\"\n        data-automation-id=\"attach-file-dialog-actions-login\">{{ 'ATTACH-FILE.ACTIONS.LOGIN' | translate }}\n    </button>\n\n    <button *ngIf=\"isLoggedIn()\"\n        mat-button\n        [disabled]=\"!chosenNode\"\n        class=\"adf-choose-action\"\n        (click)=\"onClick($event)\"\n        data-automation-id=\"attach-file-dialog-actions-choose\">{{ buttonActionName | translate }}\n    </button>\n\n</mat-dialog-actions>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [AuthenticationService,
                    DocumentListService,
                    SitesService,
                    ContentNodeSelectorService,
                    SearchService,
                    { provide: AlfrescoApiService, useClass: ExternalAlfrescoApiService }],
                styles: [""]
            }] }
];
/** @nocollapse */
AttachFileWidgetDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: AlfrescoApiService }
];
AttachFileWidgetDialogComponent.propDecorators = {
    loginPanel: [{ type: ViewChild, args: ['adfLoginPanel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttachFileWidgetDialogService {
    /**
     * @param {?} dialog
     */
    constructor(dialog) {
        this.dialog = dialog;
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * Opens a dialog to choose a file to upload.
     * @param {?} ecmHost
     * @param {?=} actionName
     * @param {?=} context
     * @return {?} Information about the chosen file(s)
     */
    openLogin(ecmHost, actionName, context) {
        /** @type {?} */
        const titleString = `Please log in for ${ecmHost}`;
        /** @type {?} */
        const selected = new Subject();
        selected.subscribe({
            complete: this.close.bind(this)
        });
        /** @type {?} */
        const data = {
            title: titleString,
            actionName,
            selected,
            ecmHost,
            context,
            isSelectionValid: this.isNodeFile.bind(this)
        };
        this.openLoginDialog(data, 'adf-attach-file-widget-dialog', '630px');
        return selected;
    }
    /**
     * @private
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    openLoginDialog(data, currentPanelClass, chosenWidth) {
        this.dialog.open(AttachFileWidgetDialogComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
    }
    /**
     * Closes the currently open dialog.
     * @return {?}
     */
    close() {
        this.dialog.closeAll();
    }
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    isNodeFile(entry) {
        return entry.isFile;
    }
}
AttachFileWidgetDialogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AttachFileWidgetDialogService.ctorParameters = () => [
    { type: MatDialog }
];
AttachFileWidgetDialogService.propDecorators = {
    error: [{ type: Output }]
};
/** @nocollapse */ AttachFileWidgetDialogService.ngInjectableDef = defineInjectable({ factory: function AttachFileWidgetDialogService_Factory() { return new AttachFileWidgetDialogService(inject(MatDialog$1)); }, token: AttachFileWidgetDialogService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttachFileWidgetComponent extends UploadWidgetComponent {
    /**
     * @param {?} formService
     * @param {?} logger
     * @param {?} thumbnails
     * @param {?} processContentService
     * @param {?} activitiContentService
     * @param {?} contentService
     * @param {?} contentDialog
     * @param {?} appConfigService
     * @param {?} attachDialogService
     */
    constructor(formService, logger, thumbnails, processContentService, activitiContentService, contentService, contentDialog, appConfigService, attachDialogService) {
        super(formService, logger, thumbnails, processContentService);
        this.formService = formService;
        this.logger = logger;
        this.thumbnails = thumbnails;
        this.processContentService = processContentService;
        this.activitiContentService = activitiContentService;
        this.contentService = contentService;
        this.contentDialog = contentDialog;
        this.appConfigService = appConfigService;
        this.attachDialogService = attachDialogService;
        this.repositoryList = [];
        this.tempFilesList = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field &&
            this.field.value &&
            this.field.value.length > 0) {
            this.hasFile = true;
        }
        this.getMultipleFileParam();
        this.activitiContentService.getAlfrescoRepositories(null, true).subscribe((/**
         * @param {?} repoList
         * @return {?}
         */
        (repoList) => {
            this.repositoryList = repoList;
        }));
        this.formService.taskSaved.subscribe((/**
         * @param {?} formSaved
         * @return {?}
         */
        (formSaved) => {
            if (formSaved.form.id === this.field.form.id) {
                this.tempFilesList = [];
            }
        }));
    }
    /**
     * @return {?}
     */
    isFileSourceConfigured() {
        return !!this.field.params && !!this.field.params.fileSource;
    }
    /**
     * @return {?}
     */
    isMultipleSourceUpload() {
        return !this.field.readOnly && this.isFileSourceConfigured() && !this.isOnlyLocalSourceSelected();
    }
    /**
     * @return {?}
     */
    isAllFileSourceSelected() {
        return this.field.params &&
            this.field.params.fileSource &&
            this.field.params.fileSource.serviceId === 'all-file-sources';
    }
    /**
     * @return {?}
     */
    isOnlyLocalSourceSelected() {
        return this.field.params &&
            this.field.params.fileSource &&
            this.field.params.fileSource.serviceId === 'local-file';
    }
    /**
     * @return {?}
     */
    isSimpleUploadButton() {
        return this.isUploadButtonVisible() &&
            !this.isFileSourceConfigured() ||
            this.isOnlyLocalSourceSelected();
    }
    /**
     * @return {?}
     */
    isUploadButtonVisible() {
        return (!this.hasFile || this.multipleOption) && !this.field.readOnly;
    }
    /**
     * @return {?}
     */
    isDefinedSourceFolder() {
        return !!this.field.params &&
            !!this.field.params.fileSource &&
            !!this.field.params.fileSource.selectedFolder;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    isTemporaryFile(file) {
        return this.tempFilesList.findIndex((/**
         * @param {?} elem
         * @return {?}
         */
        (elem) => elem.name === file.name)) >= 0;
    }
    /**
     * @return {?}
     */
    openSelectDialogFromFileSource() {
        /** @type {?} */
        const params = this.field.params;
        if (this.isDefinedSourceFolder()) {
            this.contentDialog.openFileBrowseDialogByFolderId(params.fileSource.selectedFolder.pathId).subscribe((/**
             * @param {?} selections
             * @return {?}
             */
            (selections) => {
                this.tempFilesList.push(...selections);
                this.uploadFileFromCS(selections, this.field.params.fileSource.selectedFolder.accountId, this.field.params.fileSource.selectedFolder.siteId);
            }));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onAttachFileChanged(event) {
        this.tempFilesList.push(...Array.from(event.target.files));
        this.onFileChanged(event);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onRemoveAttachFile(file) {
        if (this.isTemporaryFile(file)) {
            this.tempFilesList.splice(this.tempFilesList.indexOf(((/** @type {?} */ (file))).contentBlob), 1);
        }
        this.removeFile(file);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onAttachFileClicked(file) {
        if (file.isExternal) {
            this.logger.info(`The file ${file.name} comes from an external source and cannot be showed at this moment`);
            return;
        }
        if (this.isTemporaryFile(file)) {
            this.formService.formContentClicked.next(file);
        }
        else {
            this.fileClicked(file);
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    downloadContent(file) {
        if (this.isTemporaryFile(file)) {
            this.contentService.downloadBlob(((/** @type {?} */ (file))).contentBlob, file.name);
        }
        else {
            this.processContentService.getFileRawContent(((/** @type {?} */ (file))).id).subscribe((/**
             * @param {?} blob
             * @return {?}
             */
            (blob) => {
                this.contentService.downloadBlob(blob, ((/** @type {?} */ (file))).name);
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.logger.error('Impossible retrieve content for download');
            }));
        }
    }
    /**
     * @param {?} repository
     * @return {?}
     */
    openSelectDialog(repository) {
        /** @type {?} */
        const accountIdentifier = 'alfresco-' + repository.id + '-' + repository.name;
        /** @type {?} */
        const currentECMHost = this.getDomainHost(this.appConfigService.get(AppConfigValues.ECMHOST));
        /** @type {?} */
        const chosenRepositoryHost = this.getDomainHost(repository.repositoryUrl);
        if (chosenRepositoryHost !== currentECMHost) {
            /** @type {?} */
            const formattedRepositoryHost = repository.repositoryUrl.replace('/alfresco', '');
            this.attachDialogService.openLogin(formattedRepositoryHost).subscribe((/**
             * @param {?} selections
             * @return {?}
             */
            (selections) => {
                selections.forEach((/**
                 * @param {?} node
                 * @return {?}
                 */
                (node) => node.isExternal = true));
                this.tempFilesList.push(...selections);
                this.uploadFileFromCS(selections, accountIdentifier);
            }));
        }
        else {
            this.contentDialog.openFileBrowseDialogBySite().subscribe((/**
             * @param {?} selections
             * @return {?}
             */
            (selections) => {
                this.tempFilesList.push(...selections);
                this.uploadFileFromCS(selections, accountIdentifier);
            }));
        }
    }
    /**
     * @private
     * @param {?} fileNodeList
     * @param {?} accountId
     * @param {?=} siteId
     * @return {?}
     */
    uploadFileFromCS(fileNodeList, accountId, siteId) {
        /** @type {?} */
        const filesSaved = [];
        from(fileNodeList).pipe(mergeMap((/**
         * @param {?} node
         * @return {?}
         */
        (node) => zip(of(node.content.mimeType), this.activitiContentService.applyAlfrescoNode(node, siteId, accountId), of(node.isExternal)))))
            .subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([mimeType, res, isExternal]) => {
            res.mimeType = mimeType;
            res.isExternal = isExternal;
            filesSaved.push(res);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.logger.error(error);
        }), (/**
         * @return {?}
         */
        () => {
            this.field.value = filesSaved;
            this.field.json.value = filesSaved;
            this.hasFile = true;
        }));
    }
    /**
     * @private
     * @param {?} urlToCheck
     * @return {?}
     */
    getDomainHost(urlToCheck) {
        /** @type {?} */
        const result = urlToCheck.match('^(?:https?:\/\/)?(?:[^@\/\n]+@)?(?:www\.)?([^:\/?\n]+)');
        return result[1];
    }
}
AttachFileWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'attach-widget',
                template: "<div class=\"adf-attach-widget {{field.className}}\"\n    [class.adf-invalid]=\"!field.isValid\"\n    [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}\n        <span *ngIf=\"isRequired()\">*</span>\n    </label>\n    <div class=\"adf-attach-widget-container\">\n        <div id=\"adf-attach-widget-simple-upload\" *ngIf=\"isSimpleUploadButton() && isUploadButtonVisible()\">\n            <a mat-raised-button color=\"primary\">\n                {{ 'FORM.FIELD.UPLOAD' | translate }}\n                <mat-icon>file_upload</mat-icon>\n                <input #uploadFiles\n                        [multiple]=\"multipleOption\"\n                        type=\"file\"\n                        [id]=\"field.id\"\n                        (change)=\"onAttachFileChanged($event)\" />\n            </a>\n        </div>\n        <div class=\"adf-attach-widget__menu-upload\" *ngIf=\"isUploadButtonVisible() && isMultipleSourceUpload()\">\n            <button mat-raised-button color=\"primary\" [matMenuTriggerFor]=\"menu\" [id]=\"field.id\">\n                    {{ 'FORM.FIELD.UPLOAD' | translate }}\n                    <mat-icon>attach_file</mat-icon>\n            </button>\n            <mat-menu #menu=\"matMenu\" class=\"adf-attach-widget__menu-content\">\n                <button mat-menu-item (click)=\"uploadFile.click()\"\n                        id=\"attach-local-file\"\n                        *ngIf=\"isAllFileSourceSelected()\">\n                    {{ 'FORM.FIELD.LOCALSTORAGE' | translate }}\n                    <mat-icon>file_upload</mat-icon>\n                    <input #uploadFile\n                            class=\"adf-attach-widget__input-type\"\n                            [multiple]=\"multipleOption\"\n                            type=\"file\"\n                            [id]=\"field.id\"\n                            (change)=\"onAttachFileChanged($event)\" />\n                </button>\n                <button mat-menu-item\n                        *ngIf=\"isDefinedSourceFolder()\"\n                        id=\"attach-{{field.params?.fileSource?.name}}\"\n                        (click)=\"openSelectDialogFromFileSource()\">\n                        {{field.params?.fileSource?.name}}\n                        <mat-icon>\n                            <img alt=\"alfresco\" class=\"adf-attach-widget__image-logo\" src=\"../assets/images/alfresco-flower.svg\">\n                        </mat-icon>\n                </button>\n                <div *ngIf=\"!isDefinedSourceFolder()\">\n                    <button mat-menu-item *ngFor=\"let repo of repositoryList\"\n                            id=\"attach-{{repo?.name}}\"\n                           (click)=\"openSelectDialog(repo)\">\n                            {{repo.name}}\n                            <mat-icon>\n                                <img alt=\"alfresco\" class=\"adf-attach-widget__image-logo\" src=\"../assets/images/alfresco-flower.svg\">\n                            </mat-icon>\n                    </button>\n                </div>\n            </mat-menu>\n        </div>\n    </div>\n</div>\n\n<div id=\"adf-attach-widget-readonly-list\">\n    <mat-list *ngIf=\"hasFile\">\n        <mat-list-item class=\"adf-attach-files-row\" *ngFor=\"let file of field.value\">\n            <img mat-list-icon class=\"adf-attach-widget__icon\"\n                 [id]=\"'file-'+file.id+'-icon'\"\n                 [src]=\"file.content ? getIcon(file.content.mimeType) : getIcon(file.mimeType)\"\n                 [alt]=\"mimeTypeIcon\"\n                 (click)=\"onAttachFileClicked(file)\"\n                 (keyup.enter)=\"onAttachFileClicked(file)\"\n                 role=\"button\"\n                 tabindex=\"0\"/>\n            <span matLine id=\"{{'file-'+file.id}}\" (click)=\"onAttachFileClicked(file)\" (keyup.enter)=\"onAttachFileClicked(file)\"\n                  role=\"button\" tabindex=\"0\" class=\"adf-file\">{{file.name}}</span>\n            <button id=\"{{'file-'+file.id+'-option-menu'}}\" mat-icon-button [matMenuTriggerFor]=\"fileActionMenu\">\n                <mat-icon>more_vert</mat-icon>\n            </button>\n            <mat-menu #fileActionMenu=\"matMenu\" xPosition=\"before\">\n                <button id=\"{{'file-'+file.id+'-show-file'}}\"\n                    [disabled]=\"file.isExternal\"\n                    mat-menu-item (click)=\"onAttachFileClicked(file)\">\n                    <mat-icon>image</mat-icon>\n                    <span>{{ 'FORM.FIELD.SHOW_FILE' | translate }}</span>\n                </button>\n                <button id=\"{{'file-'+file.id+'-download-file'}}\"\n                    mat-menu-item (click)=\"downloadContent(file)\">\n                    <mat-icon>file_download</mat-icon>\n                    <span>{{ 'FORM.FIELD.DOWNLOAD_FILE' | translate }}</span>\n                </button>\n                <button *ngIf=\"!field.readOnly\" id=\"{{'file-'+file.id+'-remove-file'}}\"\n                        mat-menu-item [id]=\"'file-'+file.id+'-remove'\"\n                        (click)=\"onRemoveAttachFile(file);\" (keyup.enter)=\"onRemoveAttachFile(file);\">\n                    <mat-icon class=\"mat-24\">highlight_off</mat-icon>\n                    <span>{{ 'FORM.FIELD.REMOVE_FILE' | translate }}</span>\n                </button>\n            </mat-menu>\n        </mat-list-item>\n    </mat-list>\n</div>\n\n<error-widget [error]=\"field.validationSummary\"></error-widget>\n<error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-attach-widget-container{margin-bottom:15px;display:flex;align-items:center}.adf-attach-widget-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}.adf-attach-widget__menu-upload{display:flex;align-items:center}.adf-attach-widget__input-type{width:.1px;height:.1px;opacity:0;overflow:hidden;position:absolute;z-index:-1}.adf-attach-widget__image-logo{padding-left:5px}.adf-attach-widget-repo-button{padding-left:10px}.adf-attach-widget-repo-button .mat-button-wrapper{display:inline}.adf-attach-widget-repo-button .mat-mini-fab.mat-accent{background-color:inherit}.adf-attach-widget{width:100%;word-break:break-all;padding:.4375em 0;border-top:.84375em solid transparent}.adf-attach-widget__icon{padding:6px;float:left;cursor:pointer}.adf-attach-widget__reset{margin-top:-2px}.adf-attach-files-row .mat-line{margin-bottom:0}"]
            }] }
];
/** @nocollapse */
AttachFileWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService },
    { type: ThumbnailService },
    { type: ProcessContentService },
    { type: ActivitiContentService },
    { type: ContentService },
    { type: ContentNodeDialogService },
    { type: AppConfigService },
    { type: AttachFileWidgetDialogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttachFolderWidgetComponent extends WidgetComponent {
    /**
     * @param {?} contentDialog
     * @param {?} formService
     * @param {?} nodeService
     */
    constructor(contentDialog, formService, nodeService) {
        super();
        this.contentDialog = contentDialog;
        this.formService = formService;
        this.nodeService = nodeService;
        this.hasFolder = false;
        this.selectedFolderName = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field &&
            this.field.value) {
            this.hasFolder = true;
            this.nodeService.getNode(this.field.value).subscribe((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                this.selectedFolderName = node.name;
            }));
        }
    }
    /**
     * @return {?}
     */
    isDefinedSourceFolder() {
        return !!this.field.params &&
            !!this.field.params.folderSource &&
            !!this.field.params.folderSource.selectedFolder;
    }
    /**
     * @return {?}
     */
    openSelectDialogFromFileSource() {
        /** @type {?} */
        const params = this.field.params;
        if (this.isDefinedSourceFolder()) {
            this.contentDialog.openFolderBrowseDialogByFolderId(params.folderSource.selectedFolder.pathId).subscribe((/**
             * @param {?} selections
             * @return {?}
             */
            (selections) => {
                this.selectedFolderName = selections[0].name;
                this.field.value = selections[0].id;
                this.hasFolder = true;
            }));
        }
        else {
            this.contentDialog.openFolderBrowseDialogBySite().subscribe((/**
             * @param {?} selections
             * @return {?}
             */
            (selections) => {
                this.selectedFolderName = selections[0].name;
                this.field.value = selections[0].id;
                this.hasFolder = true;
            }));
        }
    }
    /**
     * @return {?}
     */
    removeFolder() {
        this.field.value = null;
        this.selectedFolderName = '';
        this.hasFolder = false;
    }
}
AttachFolderWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'attach-folder-widget',
                template: "<div class=\"adf-attach-folder-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\"\n     [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n    <div class=\"adf-attach-folder-widget-container\">\n        <div *ngIf=\"hasFolder\" class=\"adf-attach-folder-result\">\n            <mat-icon>folder</mat-icon>\n            <div class=\"adf-attach-folder-files-row\">\n                <span matLine id=\"{{'folder-'+field?.id}}\"\n                        role=\"button\" tabindex=\"0\" class=\"adf-folder\">{{selectedFolderName}}</span>\n                <button *ngIf=\"!field.readOnly\" mat-icon-button [id]=\"'folder-'+field?.id+'-remove'\"\n                        (click)=\"removeFolder();\">\n                    <mat-icon class=\"mat-24\">highlight_off</mat-icon>\n                </button>\n            </div>\n        </div>\n\n        <div class=\"button-row\" *ngIf=\"!hasFolder && !field.readOnly\">\n            <button mat-raised-button\n                color=\"primary\"\n                (click)=\"openSelectDialogFromFileSource()\"\n                [id]=\"'folder-'+field?.id+'-button'\">\n                    {{ 'FORM.FIELD.UPLOAD' | translate }}\n                <mat-icon>cloud_upload</mat-icon>\n            </button>\n        </div>\n    </div>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-attach-folder-widget-container{margin-bottom:15px;display:flex;align-items:center}.adf-attach-folder-widget-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}.adf-attach-folder-widget{width:100%;word-break:break-all;padding:.4375em 0;border-top:.84375em solid transparent}.adf-attach-folder-files-row{padding-left:8px}.adf-attach-folder-files-row .mat-line{margin-bottom:0}.adf-attach-folder-result{display:flex;align-items:center}"]
            }] }
];
/** @nocollapse */
AttachFolderWidgetComponent.ctorParameters = () => [
    { type: ContentNodeDialogService },
    { type: FormService },
    { type: NodesApiService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentWidgetModule {
}
ContentWidgetModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    ContentNodeSelectorModule,
                    MaterialModule
                ],
                entryComponents: [
                    AttachFileWidgetComponent,
                    AttachFolderWidgetComponent,
                    AttachFileWidgetDialogComponent
                ],
                declarations: [
                    AttachFileWidgetComponent,
                    AttachFolderWidgetComponent,
                    AttachFileWidgetDialogComponent
                ],
                exports: [
                    AttachFileWidgetComponent,
                    AttachFolderWidgetComponent,
                    AttachFileWidgetDialogComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormComponent extends FormBaseComponent {
    /**
     * @param {?} formService
     * @param {?} visibilityService
     * @param {?} ecmModelService
     * @param {?} nodeService
     * @param {?} formRenderingService
     */
    constructor(formService, visibilityService, ecmModelService, nodeService, formRenderingService) {
        super();
        this.formService = formService;
        this.visibilityService = visibilityService;
        this.ecmModelService = ecmModelService;
        this.nodeService = nodeService;
        this.formRenderingService = formRenderingService;
        /**
         * Toggle saving of form metadata.
         */
        this.saveMetadata = false;
        /**
         * Emitted when the form is submitted with the `Save` or custom outcomes.
         */
        this.formSaved = new EventEmitter();
        /**
         * Emitted when the form is submitted with the `Complete` outcome.
         */
        this.formCompleted = new EventEmitter();
        /**
         * Emitted when form content is clicked.
         */
        this.formContentClicked = new EventEmitter();
        /**
         * Emitted when the form is loaded or reloaded.
         */
        this.formLoaded = new EventEmitter();
        /**
         * Emitted when form values are refreshed due to a data property change.
         */
        this.formDataRefreshed = new EventEmitter();
        this.debugMode = false;
        this.subscriptions = [];
        this.formRenderingService.setComponentTypeResolver('upload', (/**
         * @return {?}
         */
        () => AttachFileWidgetComponent), true);
        this.formRenderingService.setComponentTypeResolver('select-folder', (/**
         * @return {?}
         */
        () => AttachFolderWidgetComponent), true);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.formService.formContentClicked.subscribe((/**
         * @param {?} content
         * @return {?}
         */
        (content) => {
            this.formContentClicked.emit(content);
        })), this.formService.validateForm.subscribe((/**
         * @param {?} validateFormEvent
         * @return {?}
         */
        (validateFormEvent) => {
            if (validateFormEvent.errorsField.length > 0) {
                this.formError.next(validateFormEvent.errorsField);
            }
        })));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => subscription.unsubscribe()));
        this.subscriptions = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const taskId = changes['taskId'];
        if (taskId && taskId.currentValue) {
            this.getFormByTaskId(taskId.currentValue);
            return;
        }
        /** @type {?} */
        const formId = changes['formId'];
        if (formId && formId.currentValue) {
            this.getFormDefinitionByFormId(formId.currentValue);
            return;
        }
        /** @type {?} */
        const formName = changes['formName'];
        if (formName && formName.currentValue) {
            this.getFormDefinitionByFormName(formName.currentValue);
            return;
        }
        /** @type {?} */
        const nodeId = changes['nodeId'];
        if (nodeId && nodeId.currentValue) {
            this.loadFormForEcmNode(nodeId.currentValue);
            return;
        }
        /** @type {?} */
        const data = changes['data'];
        if (data && data.currentValue) {
            this.refreshFormData();
            return;
        }
    }
    /**
     * Invoked when user clicks form refresh button.
     * @return {?}
     */
    onRefreshClicked() {
        this.loadForm();
    }
    /**
     * @return {?}
     */
    loadForm() {
        if (this.taskId) {
            this.getFormByTaskId(this.taskId);
            return;
        }
        if (this.formId) {
            this.getFormDefinitionByFormId(this.formId);
            return;
        }
        if (this.formName) {
            this.getFormDefinitionByFormName(this.formName);
            return;
        }
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    findProcessVariablesByTaskId(taskId) {
        return this.formService.getTask(taskId).pipe(switchMap((/**
         * @param {?} task
         * @return {?}
         */
        (task) => {
            if (this.isAProcessTask(task)) {
                return this.visibilityService.getTaskProcessVariable(taskId);
            }
            else {
                return of({});
            }
        })));
    }
    /**
     * @param {?} taskRepresentation
     * @return {?}
     */
    isAProcessTask(taskRepresentation) {
        return taskRepresentation.processDefinitionId && taskRepresentation.processDefinitionDeploymentId !== 'null';
    }
    /**
     * @param {?} taskId
     * @return {?}
     */
    getFormByTaskId(taskId) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.findProcessVariablesByTaskId(taskId).subscribe((/**
             * @param {?} processVariables
             * @return {?}
             */
            (processVariables) => {
                this.formService
                    .getTaskForm(taskId)
                    .subscribe((/**
                 * @param {?} form
                 * @return {?}
                 */
                (form) => {
                    /** @type {?} */
                    const parsedForm = this.parseForm(form);
                    this.visibilityService.refreshVisibility(parsedForm);
                    parsedForm.validateForm();
                    this.form = parsedForm;
                    this.onFormLoaded(this.form);
                    resolve(this.form);
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                (error) => {
                    this.handleError(error);
                    // reject(error);
                    resolve(null);
                }));
            }));
        }));
    }
    /**
     * @param {?} formId
     * @return {?}
     */
    getFormDefinitionByFormId(formId) {
        this.formService
            .getFormDefinitionById(formId)
            .subscribe((/**
         * @param {?} form
         * @return {?}
         */
        (form) => {
            this.formName = form.name;
            this.form = this.parseForm(form);
            this.visibilityService.refreshVisibility(this.form);
            this.form.validateForm();
            this.onFormLoaded(this.form);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.handleError(error);
        }));
    }
    /**
     * @param {?} formName
     * @return {?}
     */
    getFormDefinitionByFormName(formName) {
        this.formService
            .getFormDefinitionByName(formName)
            .subscribe((/**
         * @param {?} id
         * @return {?}
         */
        (id) => {
            this.formService.getFormDefinitionById(id).subscribe((/**
             * @param {?} form
             * @return {?}
             */
            (form) => {
                this.form = this.parseForm(form);
                this.visibilityService.refreshVisibility(this.form);
                this.form.validateForm();
                this.onFormLoaded(this.form);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                this.handleError(error);
            }));
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.handleError(error);
        }));
    }
    /**
     * @return {?}
     */
    saveTaskForm() {
        if (this.form && this.form.taskId) {
            this.formService
                .saveTaskForm(this.form.taskId, this.form.values)
                .subscribe((/**
             * @return {?}
             */
            () => {
                this.onTaskSaved(this.form);
                this.storeFormAsMetadata();
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => this.onTaskSavedError(this.form, error)));
        }
    }
    /**
     * @param {?=} outcome
     * @return {?}
     */
    completeTaskForm(outcome) {
        if (this.form && this.form.taskId) {
            this.formService
                .completeTaskForm(this.form.taskId, this.form.values, outcome)
                .subscribe((/**
             * @return {?}
             */
            () => {
                this.onTaskCompleted(this.form);
                this.storeFormAsMetadata();
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => this.onTaskCompletedError(this.form, error)));
        }
    }
    /**
     * @param {?} err
     * @return {?}
     */
    handleError(err) {
        this.error.emit(err);
    }
    /**
     * @param {?} json
     * @return {?}
     */
    parseForm(json) {
        if (json) {
            /** @type {?} */
            const form = new FormModel(json, this.data, this.readOnly, this.formService);
            if (!json.fields) {
                form.outcomes = this.getFormDefinitionOutcomes(form);
            }
            if (this.fieldValidators && this.fieldValidators.length > 0) {
                form.fieldValidators = this.fieldValidators;
            }
            return form;
        }
        return null;
    }
    /**
     * Get custom set of outcomes for a Form Definition.
     * @param {?} form Form definition model.
     * @return {?}
     */
    getFormDefinitionOutcomes(form) {
        return [
            new FormOutcomeModel(form, { id: '$save', name: FormOutcomeModel.SAVE_ACTION, isSystem: true })
        ];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    checkVisibility(field) {
        if (field && field.form) {
            this.visibilityService.refreshVisibility(field.form);
        }
    }
    /**
     * @private
     * @return {?}
     */
    refreshFormData() {
        this.form = this.parseForm(this.form.json);
        this.onFormLoaded(this.form);
        this.onFormDataRefreshed(this.form);
    }
    /**
     * @private
     * @param {?} nodeId
     * @return {?}
     */
    loadFormForEcmNode(nodeId) {
        this.nodeService.getNodeMetadata(nodeId).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            this.data = data.metadata;
            this.loadFormFromActiviti(data.nodeType);
        }), this.handleError);
    }
    /**
     * @param {?} nodeType
     * @return {?}
     */
    loadFormFromActiviti(nodeType) {
        this.formService.searchFrom(nodeType).subscribe((/**
         * @param {?} form
         * @return {?}
         */
        (form) => {
            if (!form) {
                this.formService.createFormFromANode(nodeType).subscribe((/**
                 * @param {?} formMetadata
                 * @return {?}
                 */
                (formMetadata) => {
                    this.loadFormFromFormId(formMetadata.id);
                }));
            }
            else {
                this.loadFormFromFormId(form.id);
            }
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.handleError(error);
        }));
    }
    /**
     * @private
     * @param {?} formId
     * @return {?}
     */
    loadFormFromFormId(formId) {
        this.formId = formId;
        this.loadForm();
    }
    /**
     * @protected
     * @return {?}
     */
    storeFormAsMetadata() {
        if (this.saveMetadata) {
            this.ecmModelService.createEcmTypeForActivitiForm(this.formName, this.form).subscribe((/**
             * @param {?} type
             * @return {?}
             */
            (type) => {
                this.nodeService.createNodeMetadata(type.nodeType || type.entry.prefixedName, EcmModelService.MODEL_NAMESPACE, this.form.values, this.path, this.nameNode);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                this.handleError(error);
            }));
        }
    }
    /**
     * @protected
     * @param {?} form
     * @return {?}
     */
    onFormLoaded(form) {
        this.formLoaded.emit(form);
        this.formService.formLoaded.next(new FormEvent(form));
    }
    /**
     * @protected
     * @param {?} form
     * @return {?}
     */
    onFormDataRefreshed(form) {
        this.formDataRefreshed.emit(form);
        this.formService.formDataRefreshed.next(new FormEvent(form));
    }
    /**
     * @protected
     * @param {?} form
     * @return {?}
     */
    onTaskSaved(form) {
        this.formSaved.emit(form);
        this.formService.taskSaved.next(new FormEvent(form));
    }
    /**
     * @protected
     * @param {?} form
     * @param {?} error
     * @return {?}
     */
    onTaskSavedError(form, error) {
        this.handleError(error);
        this.formService.taskSavedError.next(new FormErrorEvent(form, error));
    }
    /**
     * @protected
     * @param {?} form
     * @return {?}
     */
    onTaskCompleted(form) {
        this.formCompleted.emit(form);
        this.formService.taskCompleted.next(new FormEvent(form));
    }
    /**
     * @protected
     * @param {?} form
     * @param {?} error
     * @return {?}
     */
    onTaskCompletedError(form, error) {
        this.handleError(error);
        this.formService.taskCompletedError.next(new FormErrorEvent(form, error));
    }
    /**
     * @protected
     * @param {?} outcome
     * @return {?}
     */
    onExecuteOutcome(outcome) {
        /** @type {?} */
        const args = new FormOutcomeEvent(outcome);
        this.formService.executeOutcome.next(args);
        if (args.defaultPrevented) {
            return false;
        }
        this.executeOutcome.emit(args);
        if (args.defaultPrevented) {
            return false;
        }
        return true;
    }
}
FormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form',
                template: "<div *ngIf=\"!hasForm()\">\n    <ng-content select=\"[empty-form]\">\n    </ng-content>\n</div>\n\n<div *ngIf=\"hasForm()\" class=\"adf-form-container\">\n    <mat-card>\n        <mat-card-header>\n            <mat-card-title>\n                <h4>\n                    <div *ngIf=\"showValidationIcon\" class=\"adf-form-validation-button\">\n                        <i id=\"adf-valid-form-icon\" class=\"material-icons\"\n                            *ngIf=\"form.isValid; else no_valid_form\">check_circle</i>\n                        <ng-template #no_valid_form>\n                            <i id=\"adf-invalid-form-icon\" class=\"material-icons adf-invalid-color\">error</i>\n                        </ng-template>\n                    </div>\n                    <div *ngIf=\"showRefreshButton\" class=\"adf-form-reload-button\">\n                        <button mat-icon-button (click)=\"onRefreshClicked()\">\n                            <mat-icon>refresh</mat-icon>\n                        </button>\n                    </div>\n                    <span *ngIf=\"isTitleEnabled()\" class=\"adf-form-title\">\n                        {{form.taskName}}\n                        <ng-container *ngIf=\"!form.taskName\">\n                            {{'FORM.FORM_RENDERER.NAMELESS_TASK' | translate}}\n                        </ng-container>\n                    </span>\n\n                </h4>\n            </mat-card-title>\n        </mat-card-header>\n        <mat-card-content>\n            <adf-form-renderer [formDefinition]=\"form\">\n            </adf-form-renderer>\n        </mat-card-content>\n        <mat-card-actions *ngIf=\"form.hasOutcomes()\" class=\"adf-form-mat-card-actions\">\n            <button [id]=\"'adf-form-'+ outcome.name  | formatSpace\" *ngFor=\"let outcome of form.outcomes\"\n                [color]=\"getColorForOutcome(outcome.name)\" mat-button [disabled]=\"!isOutcomeButtonEnabled(outcome)\"\n                [class.adf-form-hide-button]=\"!isOutcomeButtonVisible(outcome, form.readOnly)\"\n                (click)=\"onOutcomeClicked(outcome)\">\n                {{outcome.name | translate | uppercase }}\n            </button>\n        </mat-card-actions>\n    </mat-card>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
FormComponent.ctorParameters = () => [
    { type: FormService },
    { type: WidgetVisibilityService },
    { type: EcmModelService },
    { type: NodeService },
    { type: FormRenderingService }
];
FormComponent.propDecorators = {
    form: [{ type: Input }],
    taskId: [{ type: Input }],
    nodeId: [{ type: Input }],
    formId: [{ type: Input }],
    formName: [{ type: Input }],
    saveMetadata: [{ type: Input }],
    data: [{ type: Input }],
    formSaved: [{ type: Output }],
    formCompleted: [{ type: Output }],
    formContentClicked: [{ type: Output }],
    formLoaded: [{ type: Output }],
    formDataRefreshed: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StartFormComponent extends FormComponent {
    /**
     * @param {?} formService
     * @param {?} visibilityService
     * @param {?} formRenderingService
     */
    constructor(formService, visibilityService, formRenderingService) {
        super(formService, visibilityService, null, null, formRenderingService);
        /**
         * Should form outcome buttons be shown?
         */
        this.showOutcomeButtons = true;
        /**
         * Should the refresh button be shown?
         */
        this.showRefreshButton = true;
        /**
         * Is the form read-only (ie, can't be edited)?
         */
        this.readOnlyForm = false;
        /**
         * Emitted when the user clicks one of the outcome buttons that completes the form.
         */
        this.outcomeClick = new EventEmitter();
        /**
         * Emitted when a field of the form is clicked.
         */
        this.formContentClicked = new EventEmitter();
        this.outcomesContainer = null;
        this.showTitle = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.formService.formContentClicked.subscribe((/**
         * @param {?} content
         * @return {?}
         */
        (content) => {
            this.formContentClicked.emit(content);
        })), this.formService.validateForm.subscribe((/**
         * @param {?} validateFormEvent
         * @return {?}
         */
        (validateFormEvent) => {
            if (validateFormEvent.errorsField.length > 0) {
                this.formError.next(validateFormEvent.errorsField);
            }
        })));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => subscription.unsubscribe()));
        this.subscriptions = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const processDefinitionId = changes['processDefinitionId'];
        if (processDefinitionId && processDefinitionId.currentValue) {
            this.visibilityService.cleanProcessVariable();
            this.getStartFormDefinition(processDefinitionId.currentValue);
            return;
        }
        /** @type {?} */
        const processId = changes['processId'];
        if (processId && processId.currentValue) {
            this.visibilityService.cleanProcessVariable();
            this.loadStartForm(processId.currentValue);
            return;
        }
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    loadStartForm(processId) {
        this.formService.getProcessInstance(processId)
            .subscribe((/**
         * @param {?} instance
         * @return {?}
         */
        (instance) => {
            this.formService
                .getStartFormInstance(processId)
                .subscribe((/**
             * @param {?} form
             * @return {?}
             */
            (form) => {
                this.formName = form.name;
                if (instance.variables) {
                    form.processVariables = instance.variables;
                }
                this.form = this.parseForm(form);
                this.visibilityService.refreshVisibility(this.form);
                this.form.validateForm();
                this.form.readOnly = this.readOnlyForm;
                this.onFormLoaded(this.form);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => this.handleError(error)));
        }));
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    getStartFormDefinition(processId) {
        this.formService
            .getStartFormDefinition(processId)
            .subscribe((/**
         * @param {?} form
         * @return {?}
         */
        (form) => {
            this.formName = form.processDefinitionName;
            this.form = this.parseForm(form);
            this.visibilityService.refreshVisibility(this.form);
            this.form.validateForm();
            this.form.readOnly = this.readOnlyForm;
            this.onFormLoaded(this.form);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.handleError(error)));
    }
    /**
     * @override
     * @param {?} outcome
     * @param {?} isFormReadOnly
     * @return {?}
     */
    isOutcomeButtonVisible(outcome, isFormReadOnly) {
        if (outcome && outcome.isSystem && (outcome.name === FormOutcomeModel.SAVE_ACTION ||
            outcome.name === FormOutcomeModel.COMPLETE_ACTION)) {
            return false;
        }
        else if (outcome && outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
            return true;
        }
        return super.isOutcomeButtonVisible(outcome, isFormReadOnly);
    }
    /**
     * @override
     * @return {?}
     */
    saveTaskForm() {
        // do nothing
    }
    /**
     * @override
     * @return {?}
     */
    onRefreshClicked() {
        if (this.processDefinitionId) {
            this.visibilityService.cleanProcessVariable();
            this.getStartFormDefinition(this.processDefinitionId);
        }
        else if (this.processId) {
            this.visibilityService.cleanProcessVariable();
            this.loadStartForm(this.processId);
        }
    }
    /**
     * @param {?=} outcome
     * @return {?}
     */
    completeTaskForm(outcome) {
        this.outcomeClick.emit(outcome);
    }
}
StartFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-form',
                template: "<div class=\"adf-start-form-container\" *ngIf=\"hasForm()\">\n    <mat-card>\n        <mat-card-header>\n            <mat-card-title>\n                <h2 *ngIf=\"isTitleEnabled()\" class=\"mdl-card__title-text\">{{form.taskName}}</h2>\n            </mat-card-title>\n        </mat-card-header>\n        <mat-card-content>\n            <div *ngIf=\"form.hasTabs()\">\n                <tabs-widget [tabs]=\"form.tabs\" (formTabChanged)=\"checkVisibility($event);\"></tabs-widget>\n            </div>\n\n            <div *ngIf=\"!form.hasTabs() && form.hasFields()\">\n                <div *ngFor=\"let field of form.fields\">\n                    <adf-form-field [field]=\"field.field\"></adf-form-field>\n                </div>\n            </div>\n        </mat-card-content>\n        <mat-card-content class=\"adf-start-form-actions\" *ngIf=\"showOutcomeButtons && form.hasOutcomes()\"\n                          #outcomesContainer>\n            <ng-content select=\"[adf-form-custom-button], [form-custom-button]\"></ng-content>\n\n            <button *ngFor=\"let outcome of form.outcomes\"\n                    mat-button\n                    [attr.data-automation-id]=\"'adf-form-' + outcome.name  | lowercase\"\n                    [disabled]=\"!isOutcomeButtonEnabled(outcome)\"\n                    [class.mdl-button--colored]=\"!outcome.isSystem\"\n                    [class.adf-form-hide-button]=\"!isOutcomeButtonVisible(outcome, form.readOnly)\"\n                    (click)=\"onOutcomeClicked(outcome)\">\n                {{ outcome.name | uppercase | translate | uppercase }}\n            </button>\n        </mat-card-content>\n        <mat-card-actions *ngIf=\"showRefreshButton\">\n            <button mat-button\n                    (click)=\"onRefreshClicked()\">\n                <mat-icon>refresh</mat-icon>\n            </button>\n        </mat-card-actions>\n    </mat-card>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
StartFormComponent.ctorParameters = () => [
    { type: FormService },
    { type: WidgetVisibilityService },
    { type: FormRenderingService }
];
StartFormComponent.propDecorators = {
    processDefinitionId: [{ type: Input }],
    processId: [{ type: Input }],
    showOutcomeButtons: [{ type: Input }],
    showRefreshButton: [{ type: Input }],
    readOnlyForm: [{ type: Input }],
    outcomeClick: [{ type: Output }],
    formContentClicked: [{ type: Output }],
    outcomesContainer: [{ type: ViewChild, args: ['outcomesContainer', {},] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormModule {
}
FormModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    MaterialModule
                ],
                declarations: [
                    FormComponent,
                    StartFormComponent
                ],
                exports: [
                    FormComponent,
                    StartFormComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskListModule {
}
TaskListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    FormsModule,
                    FormModule,
                    ReactiveFormsModule,
                    CoreModule.forChild(),
                    PeopleModule,
                    ProcessCommentsModule,
                    ContentWidgetModule
                ],
                declarations: [
                    NoTaskDetailsTemplateDirective,
                    TaskFiltersComponent,
                    TaskListComponent,
                    TaskDetailsComponent,
                    TaskAuditDirective,
                    ChecklistComponent,
                    TaskHeaderComponent,
                    StartTaskComponent,
                    TaskStandaloneComponent,
                    AttachFormComponent
                ],
                exports: [
                    NoTaskDetailsTemplateDirective,
                    TaskFiltersComponent,
                    TaskListComponent,
                    TaskDetailsComponent,
                    TaskAuditDirective,
                    ChecklistComponent,
                    TaskHeaderComponent,
                    StartTaskComponent,
                    TaskStandaloneComponent,
                    AttachFormComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessInstanceTasksComponent {
    /**
     * @param {?} activitiProcess
     * @param {?} logService
     * @param {?} dialog
     */
    constructor(activitiProcess, logService, dialog) {
        this.activitiProcess = activitiProcess;
        this.logService = logService;
        this.dialog = dialog;
        /**
         * Toggles whether to show a refresh button next to the list of tasks to allow
         * it to be updated from the server.
         */
        this.showRefreshButton = true;
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.activeTasks = [];
        this.completedTasks = [];
        /**
         * Emitted when a task is clicked.
         */
        this.taskClick = new EventEmitter();
        this.task$ = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => this.taskObserver = observer))
            .pipe(share());
        this.completedTask$ = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => this.completedTaskObserver = observer))
            .pipe(share());
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.task$.subscribe((/**
         * @param {?} task
         * @return {?}
         */
        (task) => {
            this.activeTasks.push(task);
        }));
        this.completedTask$.subscribe((/**
         * @param {?} task
         * @return {?}
         */
        (task) => {
            this.completedTasks.push(task);
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const processInstanceDetails = changes['processInstanceDetails'];
        if (processInstanceDetails && processInstanceDetails.currentValue) {
            this.load(processInstanceDetails.currentValue.id);
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    load(processInstanceId) {
        this.loadActive(processInstanceId);
        this.loadCompleted(processInstanceId);
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    loadActive(processInstanceId) {
        this.activeTasks = [];
        if (processInstanceId) {
            this.activitiProcess.getProcessTasks(processInstanceId, null).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                res.forEach((/**
                 * @param {?} task
                 * @return {?}
                 */
                (task) => {
                    this.taskObserver.next(task);
                }));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
        else {
            this.activeTasks = [];
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    loadCompleted(processInstanceId) {
        this.completedTasks = [];
        if (processInstanceId) {
            this.activitiProcess.getProcessTasks(processInstanceId, 'completed').subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                res.forEach((/**
                 * @param {?} task
                 * @return {?}
                 */
                (task) => {
                    this.completedTaskObserver.next(task);
                }));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
        else {
            this.completedTasks = [];
        }
    }
    /**
     * @return {?}
     */
    hasStartFormDefined() {
        return this.processInstanceDetails && this.processInstanceDetails.startFormDefined === true;
    }
    /**
     * @param {?} user
     * @return {?}
     */
    getUserFullName(user) {
        if (user) {
            return (user.firstName && user.firstName !== 'null'
                ? user.firstName + ' ' : '') +
                user.lastName;
        }
        return 'Nobody';
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    getFormatDate(value, format) {
        /** @type {?} */
        const datePipe = new DatePipe('en-US');
        try {
            return datePipe.transform(value, format);
        }
        catch (err) {
            this.logService.error(`ProcessListInstanceTask: error parsing date ${value} to format ${format}`);
        }
    }
    /**
     * @param {?} $event
     * @param {?} task
     * @return {?}
     */
    clickTask($event, task) {
        /** @type {?} */
        const args = new TaskDetailsEvent(task);
        this.taskClick.emit(args);
    }
    /**
     * @return {?}
     */
    clickStartTask() {
        this.processId = this.processInstanceDetails.id;
        this.showStartDialog();
    }
    /**
     * @return {?}
     */
    showStartDialog() {
        this.dialog.open(this.startDialog, { height: '500px', width: '700px' });
    }
    /**
     * @return {?}
     */
    closeStartDialog() {
        this.dialog.closeAll();
    }
    /**
     * @return {?}
     */
    onRefreshClicked() {
        this.load(this.processInstanceDetails.id);
    }
    /**
     * @return {?}
     */
    onFormContentClick() {
        this.closeStartDialog();
    }
}
ProcessInstanceTasksComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-tasks',
                template: "<div  *ngIf=\"showRefreshButton\" class=\"process-tasks-refresh\" >\n    <button mat-icon-button (click)=\"onRefreshClicked()\">\n        <mat-icon class=\"md-24\" aria-label=\"Refresh\">refresh</mat-icon>\n    </button>\n</div>\n\n<!-- ACTIVE FORM -->\n\n<mat-chip-list>\n    <span class=\"adf-chip-label\">{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASKS_ACTIVE'|translate }}</span>\n    <mat-chip class=\"adf-process-badge\" color=\"accent\" selected=\"true\">{{activeTasks?.length}}</mat-chip>\n</mat-chip-list>\n\n<div class=\"menu-container\" *ngIf=\"activeTasks?.length > 0\" data-automation-id=\"active-tasks\">\n    <mat-list>\n        <mat-list-item class=\"process-tasks__task-item\" *ngFor=\"let task of activeTasks\" (click)=\"clickTask($event, task)\">\n                <mat-icon mat-list-icon>assignment</mat-icon>\n                <h3 matLine>{{task.name || 'Nameless task'}}</h3>\n                <span matLine>\n                    {{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASK_SUBTITLE' | translate:{user: getUserFullName(task.assignee), created: getFormatDate(task.created, 'mediumDate') } }}\n                </span>\n        </mat-list-item>\n    </mat-list>\n</div>\n\n<!-- START FORM -->\n\n<div *ngIf=\"activeTasks?.length === 0\" data-automation-id=\"active-tasks-none\" class=\"no-results\">\n    {{ 'ADF_PROCESS_LIST.DETAILS.TASKS.NO_ACTIVE' | translate }}\n</div>\n\n<div *ngIf=\"hasStartFormDefined()\">\n    <span class=\"adf-activiti-label\">{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.START_FORM'|translate }}</span>\n\n    <!--IF START TASK COMPLETED -->\n    <div class=\"menu-container\">\n        <mat-list>\n            <mat-list-item class=\"process-tasks__task-item\" (click)=\"clickStartTask()\">\n                <mat-icon mat-list-icon>assignment</mat-icon>\n                <h3 matLine>{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.START_FORM'|translate }}</h3>\n                <span matLine>\n                    {{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASK_SUBTITLE' | translate:{user:getUserFullName(processInstanceDetails.startedBy), created: getFormatDate(processInstanceDetails.started, 'mediumDate') } }}\n                </span>\n            </mat-list-item>\n        </mat-list>\n    </div>\n\n</div>\n\n<!-- COMPLETED FORM -->\n<mat-chip-list>\n        <span class=\"adf-chip-label\">{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASKS_COMPLETED'|translate }}</span>\n        <mat-chip class=\"adf-process-badge\" color=\"accent\" selected=\"true\">{{completedTasks?.length}}</mat-chip>\n</mat-chip-list>\n\n<div class=\"menu-container\" *ngIf=\"completedTasks?.length > 0\" data-automation-id=\"completed-tasks\">\n    <mat-list>\n        <mat-list-item class=\"process-tasks__task-item\" *ngFor=\"let task of completedTasks\" (click)=\"clickTask($event, task)\">\n            <mat-icon mat-list-icon>assignment</mat-icon>\n            <h3 matLine>{{task.name || 'Nameless task'}}</h3>\n            <span matLine>\n                {{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASK_SUBTITLE' | translate:{user:getUserFullName(task.assignee), created: getFormatDate(task.created, 'mediumDate') } }}\n            </span>\n        </mat-list-item>\n    </mat-list>\n</div>\n\n<div *ngIf=\"completedTasks?.length === 0\" data-automation-id=\"completed-tasks-none\" class=\"no-results\">\n    {{ 'ADF_PROCESS_LIST.DETAILS.TASKS.NO_COMPLETED' | translate }}\n</div>\n\n<ng-template *ngIf=\"hasStartFormDefined()\" #startDialog>\n    <div id=\"adf-start-process-dialog\" class=\"adf-start-process-dialog\">\n        <h4 matDialogTitle>{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.START_FORM'|translate }}</h4>\n        <div mat-dialog-content class=\"adf-start-process-dialog-content\">\n            <adf-start-form [processId]=\"processId\"\n                                 [showRefreshButton]=\"false\" [readOnlyForm]=\"true\"\n                                 (formContentClicked)='onFormContentClick()'>\n            </adf-start-form>\n        </div>\n        <div mat-dialog-actions class=\"adf-start-process-dialog-actions\">\n            <button mat-button type=\"button\" (click)=\"closeStartDialog()\">{{ 'ADF_PROCESS_LIST.DETAILS.TASKS.TASK_CLOSE' | translate }}</button>\n        </div>\n    </div>\n</ng-template>\n",
                styles: [":host{width:100%}.activiti-label{font-weight:bolder;vertical-align:top}.adf-process-badge{pointer-events:none;outline:0}.adf-chip-label{position:relative;top:5px;margin-right:8px;font-weight:700}.menu-container{margin-bottom:32px}.activiti-label+.icon{position:relative;top:-2px}.task-details-dialog{position:fixed;top:50%;-webkit-transform:translate(0,-50%);transform:translate(0,-50%);width:40%}.process-tasks-refresh{float:right}.adf-start-process-dialog{width:100%;height:100%;display:flex;flex-direction:column}.adf-start-process-dialog-content{flex-grow:1}.adf-start-process-dialog-actions{display:flex;justify-content:flex-end}.no-results{margin-left:9px;font-size:14px;font-weight:400;letter-spacing:0;line-height:18px;color:rgba(0,0,0,.54);display:block;padding:12px}.process-tasks__task-item{cursor:pointer}"]
            }] }
];
/** @nocollapse */
ProcessInstanceTasksComponent.ctorParameters = () => [
    { type: ProcessService },
    { type: LogService },
    { type: MatDialog }
];
ProcessInstanceTasksComponent.propDecorators = {
    processInstanceDetails: [{ type: Input }],
    showRefreshButton: [{ type: Input }],
    error: [{ type: Output }],
    startDialog: [{ type: ViewChild, args: ['startDialog',] }],
    taskDetails: [{ type: ViewChild, args: ['taskDetails',] }],
    taskClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessInstanceDetailsComponent {
    /**
     * Constructor
     * @param {?} activitiProcess   Process service
     * @param {?} logService
     */
    constructor(activitiProcess, logService) {
        this.activitiProcess = activitiProcess;
        this.logService = logService;
        /**
         * Toggles whether to show or hide the title.
         */
        this.showTitle = true;
        /**
         * Toggles whether to show or hide the refresh button.
         */
        this.showRefreshButton = true;
        /**
         * Emitted when the current process is cancelled by the user from within the component.
         */
        this.processCancelled = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when a task is clicked.
         */
        this.taskClick = new EventEmitter();
        /**
         * Emitted when the "show diagram" button is clicked.
         */
        this.showProcessDiagram = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const processInstanceId = changes['processInstanceId'];
        if (processInstanceId && !processInstanceId.currentValue) {
            this.reset();
            return;
        }
        if (processInstanceId && processInstanceId.currentValue) {
            this.load(processInstanceId.currentValue);
            return;
        }
    }
    /**
     * Reset the task detail
     * @return {?}
     */
    reset() {
        this.processInstanceDetails = null;
    }
    /**
     * @param {?} processId
     * @return {?}
     */
    load(processId) {
        if (processId) {
            this.activitiProcess.getProcess(processId).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.processInstanceDetails = res;
            }));
        }
    }
    /**
     * @return {?}
     */
    isRunning() {
        return this.processInstanceDetails && !this.processInstanceDetails.ended;
    }
    /**
     * @return {?}
     */
    cancelProcess() {
        this.activitiProcess.cancelProcess(this.processInstanceId).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            this.processCancelled.emit(data);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    // bubbles (taskClick) event
    /**
     * @param {?} event
     * @return {?}
     */
    onTaskClicked(event) {
        this.taskClick.emit(event);
    }
    /**
     * @param {?} dateFormat
     * @return {?}
     */
    getProcessNameOrDescription(dateFormat) {
        /** @type {?} */
        let name = '';
        if (this.processInstanceDetails) {
            name = this.processInstanceDetails.name ||
                this.processInstanceDetails.processDefinitionName + ' - ' + this.getFormatDate(this.processInstanceDetails.started, dateFormat);
        }
        return name;
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    getFormatDate(value, format) {
        /** @type {?} */
        const datePipe = new DatePipe('en-US');
        try {
            return datePipe.transform(value, format);
        }
        catch (err) {
            this.logService.error(`ProcessListInstanceHeader: error parsing date ${value} to format ${format}`);
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    onShowProcessDiagram(processInstanceId) {
        this.showProcessDiagram.emit({ value: this.processInstanceId });
    }
}
ProcessInstanceDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-details',
                template: "<div *ngIf=\"!processInstanceDetails\">{{ 'ADF_PROCESS_LIST.DETAILS.MESSAGES.NONE'|translate }}</div>\n<mat-card *ngIf=\"processInstanceDetails\">\n    <mat-card-header>\n        <mat-card-title>{{ getProcessNameOrDescription('medium') }}</mat-card-title>\n    </mat-card-header>\n    <mat-card-content>\n        <adf-process-instance-header\n            #processInstanceHeader\n            [processInstance]=\"processInstanceDetails\"\n            (showProcessDiagram)=\"onShowProcessDiagram($event)\">\n        </adf-process-instance-header>\n\n        <button class=\"adf-in-medias-res-button\" mat-button id=\"show-diagram-button\" type=\"button\" mat-button mat-raised-button [disabled]=\"!isRunning()\" (click)=\"onShowProcessDiagram(processInstanceId)\">{{ 'ADF_PROCESS_LIST.DETAILS.BUTTON.SHOW_DIAGRAM' | translate }}</button>\n\n        <mat-card>\n            <mat-card-content>\n                <adf-process-instance-tasks\n                    #processInstanceTasks\n                    [processInstanceDetails]=\"processInstanceDetails\"\n                    (taskClick)=\"onTaskClicked($event)\">\n                </adf-process-instance-tasks>\n            </mat-card-content>\n        </mat-card>\n\n        <div data-automation-id=\"header-status\" *ngIf=\"isRunning()\" class=\"adf-in-medias-res-button\">\n            <button mat-button type=\"button\" (click)=\"cancelProcess()\">{{ 'ADF_PROCESS_LIST.DETAILS.BUTTON.CANCEL' | translate }}</button>\n        </div>\n\n        <mat-card>\n            <mat-card-content>\n                <adf-process-instance-comments #activitiComments\n                    [readOnly]=\"false\"\n                    [processInstanceId]=\"processInstanceDetails.id\">\n                </adf-process-instance-comments>\n            </mat-card-content>\n        </mat-card>\n\n    </mat-card-content>\n</mat-card>\n",
                styles: [":host{width:100%}.activiti-process-container{width:100%;min-height:100px;overflow:visible;padding:10px}.adf-comments-dialog{position:fixed;top:50%;-webkit-transform:translate(0,-50%);transform:translate(0,-50%);width:40%}.adf-in-medias-res-button{margin:16px 0}"]
            }] }
];
/** @nocollapse */
ProcessInstanceDetailsComponent.ctorParameters = () => [
    { type: ProcessService },
    { type: LogService }
];
ProcessInstanceDetailsComponent.propDecorators = {
    processInstanceId: [{ type: Input }],
    processInstanceHeader: [{ type: ViewChild, args: ['processInstanceHeader',] }],
    tasksList: [{ type: ViewChild, args: ['processInstanceTasks',] }],
    showTitle: [{ type: Input }],
    showRefreshButton: [{ type: Input }],
    processCancelled: [{ type: Output }],
    error: [{ type: Output }],
    taskClick: [{ type: Output }],
    showProcessDiagram: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const JSON_FORMAT$1 = 'json';
/** @type {?} */
const PDF_FORMAT$1 = 'pdf';
class ProcessAuditDirective {
    /**
     *
     * @param {?} contentService
     * @param {?} processListService
     */
    constructor(contentService, processListService) {
        this.contentService = contentService;
        this.processListService = processListService;
        /**
         * Name of the file to download (for PDF downloads).
         */
        this.fileName = 'Audit';
        /**
         * Format for the audit information (can be "pdf" or "json").
         */
        this.format = 'pdf';
        /**
         * Enables downloading of the audit file on clicking.
         */
        this.download = true;
        /**
         * Emitted when the decorated element is clicked.
         */
        this.clicked = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.isValidType()) {
            this.setDefaultFormatType();
        }
    }
    /**
     * @return {?}
     */
    isValidType() {
        if (this.format && (this.isJsonFormat() || this.isPdfFormat())) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    setDefaultFormatType() {
        this.format = PDF_FORMAT$1;
    }
    /**
     * fetch the audit information in the requested format
     * @return {?}
     */
    fetchAuditInfo() {
        if (this.isPdfFormat()) {
            this.processListService.fetchProcessAuditPdfById(this.processId).subscribe((/**
             * @param {?} blob
             * @return {?}
             */
            (blob) => {
                this.audit = blob;
                if (this.download) {
                    this.contentService.downloadBlob(this.audit, this.fileName + '.pdf');
                }
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
        else {
            this.processListService.fetchProcessAuditJsonById(this.processId).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.audit = res;
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
    }
    /**
     * @return {?}
     */
    onClickAudit() {
        this.fetchAuditInfo();
    }
    /**
     * @return {?}
     */
    isJsonFormat() {
        return this.format === JSON_FORMAT$1;
    }
    /**
     * @return {?}
     */
    isPdfFormat() {
        return this.format === PDF_FORMAT$1;
    }
}
ProcessAuditDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[adf-process-audit]',
                host: {
                    'role': 'button',
                    '(click)': 'onClickAudit()'
                }
            },] }
];
/** @nocollapse */
ProcessAuditDirective.ctorParameters = () => [
    { type: ContentService },
    { type: ProcessService }
];
ProcessAuditDirective.propDecorators = {
    processId: [{ type: Input, args: ['process-id',] }],
    fileName: [{ type: Input }],
    format: [{ type: Input }],
    download: [{ type: Input }],
    clicked: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let processPresetsDefaultModel = {
    'default': [
        {
            'key': 'name',
            'type': 'text',
            'title': 'ADF_PROCESS_LIST.PROPERTIES.NAME',
            'sortable': true
        },
        {
            'key': 'created',
            'type': 'text',
            'title': 'ADF_PROCESS_LIST.PROPERTIES.CREATED',
            'cssClass': 'hidden',
            'sortable': true
        }
    ]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessInstanceListComponent extends DataTableSchema {
    /**
     * @param {?} processService
     * @param {?} userPreferences
     * @param {?} appConfig
     */
    constructor(processService, userPreferences, appConfig) {
        super(appConfig, ProcessInstanceListComponent.PRESET_KEY, processPresetsDefaultModel);
        this.processService = processService;
        this.userPreferences = userPreferences;
        this.FORMAT_DATE = 'll';
        /**
         * The page number of the processes to fetch.
         */
        this.page = 0;
        /**
         * The number of processes to fetch in each page.
         */
        this.size = PaginationComponent.DEFAULT_PAGINATION.maxItems;
        /**
         * Toggles multiple row selection, which renders checkboxes at the beginning of each row
         */
        this.multiselect = false;
        /**
         * Row selection mode. Can be none, `single` or `multiple`. For `multiple` mode,
         * you can use Cmd (macOS) or Ctrl (Win) modifier key to toggle selection for
         * multiple rows.
         */
        this.selectionMode = 'single'; // none|single|multiple
        // none|single|multiple
        /**
         * Toggles default selection of the first row
         */
        this.selectFirstRow = true;
        /**
         * Emitted when a row in the process list is clicked.
         */
        this.rowClick = new EventEmitter();
        /**
         * Emitted when the list of process instances has been loaded successfully from the server.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs while loading the list of process instances from the server.
         */
        this.error = new EventEmitter();
        this.isLoading = true;
        this.rows = [];
        this.sorting = ['created', 'desc'];
        this.size = this.userPreferences.paginationSize;
        this.pagination = new BehaviorSubject((/** @type {?} */ ({
            maxItems: this.size,
            skipCount: 0,
            totalItems: 0
        })));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.createDatatableSchema();
        if (this.data && this.data.getColumns().length === 0) {
            this.data.setColumns(this.columns);
        }
        if (this.appId != null) {
            this.reload();
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.isPropertyChanged(changes)) {
            if (this.isSortChanged(changes)) {
                this.sorting = this.sort ? this.sort.split('-') : this.sorting;
            }
            this.reload();
        }
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    isSortChanged(changes) {
        /** @type {?} */
        const actualSort = changes['sort'];
        return actualSort && actualSort.currentValue && actualSort.currentValue !== actualSort.previousValue;
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    isPropertyChanged(changes) {
        /** @type {?} */
        let changed = false;
        /** @type {?} */
        const appId = changes['appId'];
        /** @type {?} */
        const processDefinitionId = changes['processDefinitionId'];
        /** @type {?} */
        const processInstanceId = changes['processInstanceId'];
        /** @type {?} */
        const state = changes['state'];
        /** @type {?} */
        const sort = changes['sort'];
        /** @type {?} */
        const page = changes['page'];
        /** @type {?} */
        const size = changes['size'];
        if (appId && appId.currentValue) {
            changed = true;
        }
        else if (processDefinitionId) {
            changed = true;
        }
        else if (processInstanceId) {
            changed = true;
        }
        else if (state && state.currentValue) {
            changed = true;
        }
        else if (sort && sort.currentValue) {
            changed = true;
        }
        else if (page && page.currentValue !== page.previousValue) {
            changed = true;
        }
        else if (size && size.currentValue !== size.previousValue) {
            changed = true;
        }
        return changed;
    }
    /**
     * @return {?}
     */
    reload() {
        this.requestNode = this.createRequestNode();
        this.load(this.requestNode);
    }
    /**
     * @private
     * @param {?} requestNode
     * @return {?}
     */
    load(requestNode) {
        this.isLoading = true;
        this.processService.getProcesses(requestNode)
            .subscribe((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            this.rows = this.optimizeProcessDetails(response.data);
            this.selectFirst();
            this.success.emit(response);
            this.isLoading = false;
            this.pagination.next({
                count: response.data.length,
                maxItems: this.size,
                skipCount: this.page * this.size,
                totalItems: response.total
            });
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.error.emit(error);
            this.isLoading = false;
        }));
    }
    /**
     * Select the first instance of a list if present
     * @return {?}
     */
    selectFirst() {
        if (this.selectFirstRow) {
            if (!this.isListEmpty()) {
                /** @type {?} */
                const dataRow = this.rows[0];
                dataRow.isSelected = true;
                this.currentInstanceId = dataRow['id'];
            }
            else {
                this.currentInstanceId = null;
            }
        }
    }
    /**
     * Return the current id
     * @return {?}
     */
    getCurrentId() {
        return this.currentInstanceId;
    }
    /**
     * Check if the list is empty
     * @return {?}
     */
    isListEmpty() {
        return !this.rows || this.rows.length === 0;
    }
    /**
     * Emit the event rowClick passing the current task id when the row is clicked
     * @param {?} event
     * @return {?}
     */
    onRowClick(event) {
        /** @type {?} */
        const item = event;
        this.currentInstanceId = item.value.getValue('id');
        this.rowClick.emit(this.currentInstanceId);
    }
    /**
     * Emit the event rowClick passing the current task id when pressed the Enter key on the selected row
     * @param {?} event
     * @return {?}
     */
    onRowKeyUp(event) {
        if (event.detail.keyboardEvent.key === 'Enter') {
            event.preventDefault();
            this.currentInstanceId = event.detail.row.getValue('id');
            this.rowClick.emit(this.currentInstanceId);
        }
    }
    /**
     * Optimize name field
     * @private
     * @param {?} instances
     * @return {?}
     */
    optimizeProcessDetails(instances) {
        instances = instances.map((/**
         * @param {?} instance
         * @return {?}
         */
        (instance) => {
            instance.name = this.getProcessNameOrDescription(instance, 'medium');
            if (instance.started) {
                instance.started = moment$1(instance.started).format(this.FORMAT_DATE);
            }
            return instance;
        }));
        return instances;
    }
    /**
     * @param {?} processInstance
     * @param {?} dateFormat
     * @return {?}
     */
    getProcessNameOrDescription(processInstance, dateFormat) {
        /** @type {?} */
        let name = '';
        if (processInstance) {
            name = processInstance.name ||
                processInstance.processDefinitionName + ' - ' + this.getFormatDate(processInstance.started, dateFormat);
        }
        return name;
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    getFormatDate(value, format) {
        /** @type {?} */
        const datePipe = new DatePipe('en-US');
        try {
            return datePipe.transform(value, format);
        }
        catch (err) {
            return '';
        }
    }
    /**
     * @private
     * @return {?}
     */
    createRequestNode() {
        /** @type {?} */
        const requestNode = {
            appDefinitionId: this.appId,
            processDefinitionId: this.processDefinitionId,
            processInstanceId: this.processInstanceId,
            state: this.state,
            sort: this.sort,
            page: this.page,
            size: this.size,
            start: 0
        };
        return new ProcessFilterParamRepresentationModel(requestNode);
    }
    /**
     * @param {?} params
     * @return {?}
     */
    updatePagination(params) {
        /** @type {?} */
        const needsReload = params.maxItems || params.skipCount;
        this.size = params.maxItems;
        this.page = this.currentPage(params.skipCount, params.maxItems);
        if (needsReload) {
            this.reload();
        }
    }
    /**
     * @param {?} skipCount
     * @param {?} maxItems
     * @return {?}
     */
    currentPage(skipCount, maxItems) {
        return (skipCount && maxItems) ? Math.floor(skipCount / maxItems) : 0;
    }
}
ProcessInstanceListComponent.PRESET_KEY = 'adf-process-list.presets';
ProcessInstanceListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-list',
                template: "<adf-datatable #dataTable\n    [data]=\"data\"\n    [rows]=\"rows\"\n    [columns]=\"columns\"\n    [sorting]=\"sorting\"\n    [loading]=\"isLoading\"\n    [selectionMode]=\"selectionMode\"\n    [multiselect]=\"multiselect\"\n    (rowClick)=\"onRowClick($event)\"\n    (row-keyup)=\"onRowKeyUp($event)\">\n    <adf-loading-content-template>\n        <ng-template>\n            <!--Add your custom loading template here-->\n            <mat-progress-spinner\n                *ngIf=\"!customLoadingContent\"\n                class=\"adf-process-list-loading-margin\"\n                [color]=\"'primary'\"\n                [mode]=\"'indeterminate'\">\n            </mat-progress-spinner>\n            <ng-content select=\"adf-custom-loading-content-template\"></ng-content>\n        </ng-template>\n    </adf-loading-content-template>\n    <adf-no-content-template>\n        <ng-template>\n                <adf-empty-content *ngIf=\"!customEmptyContent\"\n                    icon=\"assessment\"\n                    [title]=\"(requestNode ? 'ADF_PROCESS_LIST.LIST.TITLE' : 'ADF_PROCESS_LIST.FILTERS.MESSAGES.NONE') | translate \"\n                    [subtitle]=\"'ADF_PROCESS_LIST.LIST.SUBTITLE'| translate\">\n                </adf-empty-content>\n            <ng-content select=\"adf-custom-empty-content-template\"></ng-content>\n        </ng-template>\n    </adf-no-content-template>\n</adf-datatable>\n",
                styles: [".adf-process-list-loading-margin{margin-left:calc((100% - 100px)/ 2);margin-right:calc((100% - 100px)/ 2)}.no-content-message{font-size:16px;font-weight:700;text-align:center;opacity:.54;color:#000}"]
            }] }
];
/** @nocollapse */
ProcessInstanceListComponent.ctorParameters = () => [
    { type: ProcessService },
    { type: UserPreferencesService },
    { type: AppConfigService }
];
ProcessInstanceListComponent.propDecorators = {
    customEmptyContent: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    customLoadingContent: [{ type: ContentChild, args: [CustomLoadingContentTemplateDirective,] }],
    appId: [{ type: Input }],
    processDefinitionId: [{ type: Input }],
    processInstanceId: [{ type: Input }],
    state: [{ type: Input }],
    sort: [{ type: Input }],
    page: [{ type: Input }],
    size: [{ type: Input }],
    data: [{ type: Input }],
    multiselect: [{ type: Input }],
    selectionMode: [{ type: Input }],
    selectFirstRow: [{ type: Input }],
    rowClick: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StartProcessInstanceComponent {
    /**
     * @param {?} activitiProcess
     * @param {?} activitiContentService
     * @param {?} appConfig
     */
    constructor(activitiProcess, activitiContentService, appConfig) {
        this.activitiProcess = activitiProcess;
        this.activitiContentService = activitiContentService;
        this.appConfig = appConfig;
        this.MAX_LENGTH = 255;
        /**
         * (optional) Name to assign to the current process.
         */
        this.name = '';
        /**
         * Hide or show the process selection dropdown.
         */
        this.showSelectProcessDropdown = true;
        /**
         * (optional) Parameter to enable selection of process when filtering.
         */
        this.processFilterSelector = true;
        /**
         * Emitted when the process starts.
         */
        this.start = new EventEmitter();
        /**
         * Emitted when the process is canceled.
         */
        this.cancel = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.processDefinitions = [];
        this.selectedProcessDef = new ProcessDefinitionRepresentation();
        this.errorMessageId = '';
        this.maxProcessNameLength = this.MAX_LENGTH;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.processNameInput = new FormControl(this.name, [Validators.required, Validators.maxLength(this.maxProcessNameLength)]);
        this.processDefinitionInput = new FormControl();
        this.loadStartProcess();
        this.processNameInput.valueChanges.subscribe((/**
         * @param {?} name
         * @return {?}
         */
        (name) => this.name = name));
        this.filteredProcesses = this.processDefinitionInput.valueChanges
            .pipe(map((/**
         * @param {?} value
         * @return {?}
         */
        (value) => this._filter(value))));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['values'] && changes['values'].currentValue) {
            this.moveNodeFromCStoPS();
        }
        if (changes['appId'] && changes['appId'].currentValue) {
            this.appId = changes['appId'].currentValue;
        }
        this.loadStartProcess();
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _filter(value) {
        if (value !== null && value !== undefined) {
            /** @type {?} */
            const filterValue = value.toLowerCase();
            /** @type {?} */
            const filteredProcess = this.processDefinitions.filter((/**
             * @param {?} option
             * @return {?}
             */
            (option) => option.name.toLowerCase().includes(filterValue)));
            if (this.processFilterSelector) {
                this.selectedProcessDef = this.getSelectedProcess(filterValue);
            }
            return filteredProcess;
        }
    }
    /**
     * @param {?} selectedProcess
     * @return {?}
     */
    getSelectedProcess(selectedProcess) {
        /** @type {?} */
        let processSelected = this.processDefinitions.find((/**
         * @param {?} process
         * @return {?}
         */
        (process) => process.name.toLowerCase() === selectedProcess));
        if (!processSelected) {
            processSelected = new ProcessDefinitionRepresentation();
        }
        return processSelected;
    }
    /**
     * @return {?}
     */
    loadStartProcess() {
        this.resetSelectedProcessDefinition();
        this.resetErrorMessage();
        this.activitiProcess.getProcessDefinitions(this.appId).subscribe((/**
         * @param {?} processDefinitionRepresentations
         * @return {?}
         */
        (processDefinitionRepresentations) => {
            this.processDefinitions = processDefinitionRepresentations;
            if (!this.isProcessDefinitionsEmpty()) {
                if (this.processDefinitions.length === 1) {
                    this.selectedProcessDef = this.processDefinitions[0];
                }
                if (this.processDefinitionName) {
                    /** @type {?} */
                    const selectedProcess = this.processDefinitions.find((/**
                     * @param {?} currentProcessDefinition
                     * @return {?}
                     */
                    (currentProcessDefinition) => {
                        return currentProcessDefinition.name === this.processDefinitionName;
                    }));
                    if (selectedProcess) {
                        this.selectedProcessDef = selectedProcess;
                    }
                }
                this.processDefinitionInput.setValue(this.selectedProcessDef.name);
            }
        }), (/**
         * @return {?}
         */
        () => {
            this.errorMessageId = 'ADF_PROCESS_LIST.START_PROCESS.ERROR.LOAD_PROCESS_DEFS';
        }));
    }
    /**
     * @return {?}
     */
    isProcessDefinitionsEmpty() {
        return this.processDefinitions.length === 0;
    }
    /**
     * @return {?}
     */
    getAlfrescoRepositoryName() {
        /** @type {?} */
        let alfrescoRepositoryName = this.appConfig.get(AppConfigValues.ALFRESCO_REPOSITORY_NAME);
        if (!alfrescoRepositoryName) {
            alfrescoRepositoryName = 'alfresco-1';
        }
        return alfrescoRepositoryName + 'Alfresco';
    }
    /**
     * @return {?}
     */
    moveNodeFromCStoPS() {
        /** @type {?} */
        const accountIdentifier = this.getAlfrescoRepositoryName();
        for (const key in this.values) {
            if (this.values.hasOwnProperty(key)) {
                /** @type {?} */
                const currentValue = this.values[key];
                if (currentValue.isFile) {
                    this.activitiContentService.applyAlfrescoNode(currentValue, null, accountIdentifier).subscribe((/**
                     * @param {?} res
                     * @return {?}
                     */
                    (res) => {
                        this.values[key] = [res];
                    }));
                }
            }
        }
    }
    /**
     * @param {?=} outcome
     * @return {?}
     */
    startProcess(outcome) {
        if (this.selectedProcessDef && this.selectedProcessDef.id && this.name) {
            this.resetErrorMessage();
            /** @type {?} */
            const formValues = this.startForm ? this.startForm.form.values : undefined;
            this.activitiProcess.startProcess(this.selectedProcessDef.id, this.name, outcome, formValues, this.variables).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.name = '';
                this.start.emit(res);
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.errorMessageId = 'ADF_PROCESS_LIST.START_PROCESS.ERROR.START';
                this.error.error(err);
            }));
        }
    }
    /**
     * @return {?}
     */
    cancelStartProcess() {
        this.cancel.emit();
    }
    /**
     * @return {?}
     */
    hasStartForm() {
        return this.selectedProcessDef && this.selectedProcessDef.hasStartForm;
    }
    /**
     * @return {?}
     */
    isProcessDefinitionEmpty() {
        return this.processDefinitions ? (this.processDefinitions.length > 0 || this.errorMessageId) : this.errorMessageId;
    }
    /**
     * @return {?}
     */
    isStartFormMissingOrValid() {
        if (this.startForm) {
            return this.startForm.form && this.startForm.form.isValid;
        }
        else {
            return true;
        }
    }
    /**
     * @return {?}
     */
    validateForm() {
        return this.selectedProcessDef && this.selectedProcessDef.id && this.processNameInput.valid && this.isStartFormMissingOrValid();
    }
    /**
     * @private
     * @return {?}
     */
    resetSelectedProcessDefinition() {
        this.selectedProcessDef = new ProcessDefinitionRepresentation();
    }
    /**
     * @private
     * @return {?}
     */
    resetErrorMessage() {
        this.errorMessageId = '';
    }
    /**
     * @return {?}
     */
    hasErrorMessage() {
        return this.processDefinitions.length === 0 && !this.errorMessageId;
    }
    /**
     * @param {?} outcome
     * @return {?}
     */
    onOutcomeClick(outcome) {
        this.startProcess(outcome);
    }
    /**
     * @return {?}
     */
    reset() {
        this.resetSelectedProcessDefinition();
        this.name = '';
        if (this.startForm) {
            this.startForm.data = {};
        }
        this.resetErrorMessage();
    }
    /**
     * @return {?}
     */
    hasProcessName() {
        return this.name ? true : false;
    }
    /**
     * @param {?} process
     * @return {?}
     */
    displayFn(process) {
        if (process) {
            /** @type {?} */
            let processName = process;
            if (typeof process !== 'string') {
                processName = process.name;
            }
            return processName;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    displayDropdown(event) {
        event.stopPropagation();
        if (!this.inputAutocomplete.panelOpen) {
            this.processDefinitionInput.setValue('');
            this.inputAutocomplete.openPanel();
        }
        else {
            this.inputAutocomplete.closePanel();
        }
    }
    /**
     * @return {?}
     */
    get nameController() {
        return this.processNameInput;
    }
}
StartProcessInstanceComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-process',
                template: "<mat-card class=\"adf-start-process\">\n    <mat-card-title>{{'ADF_PROCESS_LIST.START_PROCESS.FORM.TITLE' | translate}}\n    </mat-card-title>\n    <mat-card-content *ngIf=\"isProcessDefinitionEmpty()\">\n        <mat-card-subtitle id=\"error-message\" *ngIf=\"errorMessageId\">\n            {{errorMessageId|translate}}\n        </mat-card-subtitle>\n        <mat-form-field class=\"adf-process-input-container\">\n            <input\n                matInput\n                placeholder=\"{{'ADF_PROCESS_LIST.START_PROCESS.FORM.LABEL.NAME' | translate}}\"\n                [formControl]=\"processNameInput\"\n                id=\"processName\"\n                required/>\n                <mat-error *ngIf=\"nameController.hasError('maxlength')\">\n                    {{ 'ADF_PROCESS_LIST.START_PROCESS.ERROR.MAXIMUM_LENGTH' | translate : { characters : maxProcessNameLength } }}\n                </mat-error>\n        </mat-form-field>\n        <mat-form-field class=\"adf-process-input-container\">\n            <input\n                type=\"text\"\n                placeholder=\"{{'ADF_PROCESS_LIST.START_PROCESS.FORM.LABEL.TYPE'|translate}}\"\n                matInput\n                [formControl]=\"processDefinitionInput\"\n                [matAutocomplete]=\"auto\"\n                id=\"processDefinitionName\"\n                #inputAutocomplete>\n            <div class=\"adf-process-input-autocomplete\">\n                <mat-autocomplete\n                    #auto=\"matAutocomplete\"\n                    id=\"processDefinitionOptions\"\n                    [displayWith]=\"displayFn\">\n                    <mat-option *ngFor=\"let processDef of filteredProcesses | async\" [value]=\"processDef.name\">\n                        {{ processDef.name }}\n                    </mat-option>\n                </mat-autocomplete>\n                <button\n                    id=\"adf-select-process-dropdown\"\n                    *ngIf=\"showSelectProcessDropdown\"\n                    mat-icon-button\n                    (click)=\"displayDropdown($event)\">\n                    <mat-icon>arrow_drop_down</mat-icon>\n                </button>\n            </div>\n        </mat-form-field>\n\n        <adf-start-form\n            #startForm\n            *ngIf=\"hasStartForm()\"\n            [data]=\"values\"\n            [disableStartProcessButton]=\"!hasProcessName()\"\n            [processDefinitionId]=\"selectedProcessDef.id\"\n            (outcomeClick)=\"onOutcomeClick($event)\"\n            [showRefreshButton]=\"false\">\n            <button\n                adf-form-custom-button\n                mat-button\n                (click)=\"cancelStartProcess()\"\n                id=\"cancel_process\">\n                {{'ADF_PROCESS_LIST.START_PROCESS.FORM.ACTION.CANCEL'| translate | uppercase}}\n            </button>\n        </adf-start-form>\n    </mat-card-content>\n    <mat-card-content *ngIf=\"hasErrorMessage()\">\n        <mat-card-subtitle class=\"error-message\" id=\"no-process-message\">\n            {{'ADF_PROCESS_LIST.START_PROCESS.NO_PROCESS_DEFINITIONS' | translate | uppercase}}\n        </mat-card-subtitle>\n    </mat-card-content>\n    <mat-card-actions *ngIf=\"!hasStartForm()\">\n        <button\n            mat-button\n            *ngIf=\"!hasStartForm()\"\n            (click)=\"cancelStartProcess()\"\n            id=\"cancel_process\">\n            {{'ADF_PROCESS_LIST.START_PROCESS.FORM.ACTION.CANCEL'| translate | uppercase}}\n        </button>\n        <button\n            color=\"primary\"\n            mat-button\n            *ngIf=\"!hasStartForm()\"\n            [disabled]=\"!validateForm()\"\n            (click)=\"startProcess()\"\n            data-automation-id=\"btn-start\"\n            id=\"button-start\"\n            class=\"btn-start\">\n            {{'ADF_PROCESS_LIST.START_PROCESS.FORM.ACTION.START' | translate | uppercase}}\n        </button>\n    </mat-card-actions>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-start-process{width:66%;margin-left:auto;margin-right:auto;margin-top:10px}.adf-start-process .mat-select-trigger{font-size:14px!important}.adf-start-process mat-form-field{width:100%}.adf-start-process mat-select{width:100%;padding:16px 0 0}.adf-start-process mat-card-actions{text-align:right}.adf-start-process mat-card-actions .mat-button{text-transform:uppercase!important}.adf-process-input-container mat-form-field{width:100%}.adf-process-input-autocomplete{display:flex}.adf-process-input-autocomplete button{position:absolute;right:-14px;top:0}.adf-start-form-container .mat-card{box-shadow:none!important;padding:0!important}.adf-start-form-actions{text-align:right!important}@media (max-width:600px){.adf-start-process{width:90%;margin-left:auto;margin-right:auto}}"]
            }] }
];
/** @nocollapse */
StartProcessInstanceComponent.ctorParameters = () => [
    { type: ProcessService },
    { type: ActivitiContentService },
    { type: AppConfigService }
];
StartProcessInstanceComponent.propDecorators = {
    appId: [{ type: Input }],
    processDefinitionName: [{ type: Input }],
    variables: [{ type: Input }],
    values: [{ type: Input }],
    name: [{ type: Input }],
    showSelectProcessDropdown: [{ type: Input }],
    processFilterSelector: [{ type: Input }],
    start: [{ type: Output }],
    cancel: [{ type: Output }],
    error: [{ type: Output }],
    startForm: [{ type: ViewChild, args: ['startForm',] }],
    inputAutocomplete: [{ type: ViewChild, args: [MatAutocompleteTrigger,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessFilterRequestRepresentation {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.processDefinitionId = obj && obj.processDefinitionId || null;
        this.appDefinitionId = obj && obj.appDefinitionId || null;
        this.state = obj && obj.state || null;
        this.sort = obj && obj.sort || null;
        this.page = obj && obj.page || 0;
        this.size = obj && obj.size || 25;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessListModule {
}
ProcessListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FlexLayoutModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule.forChild(),
                    TaskListModule,
                    PeopleModule,
                    ContentWidgetModule,
                    ProcessCommentsModule,
                    FormModule
                ],
                declarations: [
                    ProcessInstanceListComponent,
                    ProcessFiltersComponent,
                    ProcessInstanceDetailsComponent,
                    ProcessAuditDirective,
                    ProcessInstanceHeaderComponent,
                    ProcessInstanceTasksComponent,
                    StartProcessInstanceComponent
                ],
                exports: [
                    ProcessInstanceListComponent,
                    ProcessFiltersComponent,
                    ProcessInstanceDetailsComponent,
                    ProcessAuditDirective,
                    ProcessInstanceHeaderComponent,
                    ProcessInstanceTasksComponent,
                    StartProcessInstanceComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppsListComponent {
    /**
     * @param {?} appsProcessService
     * @param {?} translationService
     */
    constructor(appsProcessService, translationService) {
        this.appsProcessService = appsProcessService;
        this.translationService = translationService;
        /**
         * (**required**) Defines the layout of the apps. There are two possible
         * values, "GRID" and "LIST".
         */
        this.layoutType = AppsListComponent.LAYOUT_GRID;
        /**
         * Emitted when an app entry is clicked.
         */
        this.appClick = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.appList = [];
        this.loading = false;
        this.hasEmptyCustomContentTemplate = false;
        this.apps$ = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => this.appsObserver = observer))
            .pipe(share());
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.isValidType()) {
            this.setDefaultLayoutType();
        }
        this.apps$.subscribe((/**
         * @param {?} app
         * @return {?}
         */
        (app) => {
            this.appList.push(app);
        }));
        this.iconsMDL = new IconModel();
        this.load();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.emptyCustomContent) {
            this.hasEmptyCustomContentTemplate = true;
        }
    }
    /**
     * @private
     * @return {?}
     */
    load() {
        this.loading = true;
        this.appsProcessService.getDeployedApplications()
            .subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            this.filterApps(res).forEach((/**
             * @param {?} app
             * @return {?}
             */
            (app) => {
                if (this.isDefaultApp(app)) {
                    app.theme = AppsListComponent.DEFAULT_TASKS_APP_THEME;
                    app.icon = AppsListComponent.DEFAULT_TASKS_APP_ICON;
                    this.appsObserver.next(app);
                }
                else if (app.deploymentId) {
                    this.appsObserver.next(app);
                }
                this.loading = false;
            }));
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
            this.loading = false;
        }));
    }
    /**
     * @param {?} app
     * @return {?}
     */
    isDefaultApp(app) {
        return app.defaultAppId === AppsListComponent.DEFAULT_TASKS_APP;
    }
    /**
     * @param {?} app
     * @return {?}
     */
    getAppName(app) {
        return this.isDefaultApp(app)
            ? this.translationService.get(AppsListComponent.DEFAULT_TASKS_APP_NAME)
            : of(app.name);
    }
    /**
     * Pass the selected app as next
     * @param {?} app
     * @return {?}
     */
    selectApp(app) {
        this.currentApp = app;
        this.appClick.emit(app);
    }
    /**
     * Return true if the appId is the current app
     * @param {?} appId
     * @return {?}
     */
    isSelected(appId) {
        return (this.currentApp !== undefined && appId === this.currentApp.id);
    }
    /**
     * @private
     * @param {?} apps
     * @return {?}
     */
    filterApps(apps) {
        /** @type {?} */
        const filteredApps = [];
        if (this.filtersAppId) {
            apps.filter((/**
             * @param {?} app
             * @return {?}
             */
            (app) => {
                this.filtersAppId.forEach((/**
                 * @param {?} filter
                 * @return {?}
                 */
                (filter$$1) => {
                    if (app.defaultAppId === filter$$1.defaultAppId ||
                        app.deploymentId === filter$$1.deploymentId ||
                        app.name === filter$$1.name ||
                        app.id === filter$$1.id ||
                        app.modelId === filter$$1.modelId ||
                        app.tenantId === filter$$1.tenantId) {
                        filteredApps.push(app);
                    }
                }));
            }));
        }
        else {
            return apps;
        }
        return filteredApps;
    }
    /**
     * Check if the value of the layoutType property is an allowed value
     * @return {?}
     */
    isValidType() {
        if (this.layoutType && (this.layoutType === AppsListComponent.LAYOUT_LIST || this.layoutType === AppsListComponent.LAYOUT_GRID)) {
            return true;
        }
        return false;
    }
    /**
     * Assign the default value to LayoutType
     * @return {?}
     */
    setDefaultLayoutType() {
        this.layoutType = AppsListComponent.LAYOUT_GRID;
    }
    /**
     * Return true if the layout type is LIST
     * @return {?}
     */
    isList() {
        return this.layoutType === AppsListComponent.LAYOUT_LIST;
    }
    /**
     * Return true if the layout type is GRID
     * @return {?}
     */
    isGrid() {
        return this.layoutType === AppsListComponent.LAYOUT_GRID;
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.appList.length === 0;
    }
    /**
     * @return {?}
     */
    isLoading() {
        return this.loading;
    }
    /**
     * @param {?} app
     * @return {?}
     */
    getTheme(app) {
        return app.theme ? app.theme : '';
    }
    /**
     * @param {?} app
     * @return {?}
     */
    getBackgroundIcon(app) {
        return this.iconsMDL.mapGlyphiconToMaterialDesignIcons(app.icon);
    }
}
AppsListComponent.LAYOUT_LIST = 'LIST';
AppsListComponent.LAYOUT_GRID = 'GRID';
AppsListComponent.DEFAULT_TASKS_APP = 'tasks';
AppsListComponent.DEFAULT_TASKS_APP_NAME = 'ADF_TASK_LIST.APPS.TASK_APP_NAME';
AppsListComponent.DEFAULT_TASKS_APP_THEME = 'theme-2';
AppsListComponent.DEFAULT_TASKS_APP_ICON = 'glyphicon-asterisk';
AppsListComponent.DEFAULT_TASKS_APP_MATERIAL_ICON = 'favorite_border';
AppsListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-apps',
                template: "<div class=\"menu-container\" *ngIf=\"!isEmpty()\">\n    <mat-list *ngIf=\"isList()\" class=\"adf-app-list\">\n        <mat-list-item class=\"adf-app-list-item\" (click)=\"selectApp(app)\" (keyup.enter)=\"selectApp(app)\" *ngFor=\"let app of appList\" tabindex=\"0\" role=\"button\" title=\"{{app.name}}\">\n            <mat-icon matListIcon>touch_app</mat-icon>\n            <span matLine>{{getAppName(app) | async}}</span>\n        </mat-list-item>\n    </mat-list>\n    <div fxLayout=\"row wrap\" *ngIf=\"isGrid()\" class=\"adf-app-listgrid\">\n        <div *ngFor=\"let app of appList\"\n            class=\"adf-app-listgrid-item\"\n            fxFlex=\"33.33333%\" fxFlex.lt-md=\"50%\" fxFlex.lt-sm=\"100%\">\n                <mat-card tabindex=\"0\"\n                    fxLayout=\"column\"\n                    role=\"button\"\n                    class=\"adf-app-listgrid-item-card\"\n                    title=\"{{getAppName(app) | async}}\"\n                    [ngClass]=\"[getTheme(app)]\"\n                    (click)=\"selectApp(app)\"\n                    (keyup.enter)=\"selectApp(app)\">\n                        <div class=\"adf-app-listgrid-item-card-logo\">\n                            <mat-icon class=\"adf-app-listgrid-item-card-logo-icon\">{{getBackgroundIcon(app)}}</mat-icon>\n                        </div>\n                        <div mat-card-title class=\"adf-app-listgrid-item-card-title\">\n                            <h1>{{getAppName(app) | async}}</h1>\n                        </div>\n                        <mat-card-subtitle class=\"adf-app-listgrid-item-card-subtitle\" fxFlex=\"1 0 auto\">\n                            <div class=\"adf-line-clamp\">{{app.description}}</div>\n                        </mat-card-subtitle>\n\n                        <mat-card-actions class=\"adf-app-listgrid-item-card-actions\">\n                            <mat-icon class=\"adf-app-listgrid-item-card-actions-icon\" *ngIf=\"isSelected(app.id)\">done</mat-icon>\n                        </mat-card-actions>\n                </mat-card>\n        </div>\n    </div>\n</div>\n\n<ng-container *ngIf=\"isLoading(); else empty\">\n    <div class=\"adf-app-list-spinner\">\n        <mat-spinner></mat-spinner>\n    </div>\n</ng-container>\n\n<ng-template #empty>\n    <div class=\"adf-app-list-empty\" *ngIf=\"isEmpty()\">\n        <ng-content select=\"adf-custom-empty-content\" *ngIf=\"hasEmptyCustomContentTemplate; else defaultEmptyTemplate\" class=\"adf-custom-empty-template\"></ng-content>\n\n        <ng-template #defaultEmptyTemplate>\n            <adf-empty-content\n                icon=\"apps\"\n                [title]=\"'ADF_TASK_LIST.APPS.TITLE' | translate\"\n                [subtitle]=\"'ADF_TASK_LIST.APPS.SUBTITLE' | translate\">\n            </adf-empty-content>\n        </ng-template>\n    </div>\n</ng-template>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
AppsListComponent.ctorParameters = () => [
    { type: AppsProcessService },
    { type: TranslationService }
];
AppsListComponent.propDecorators = {
    emptyCustomContent: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    layoutType: [{ type: Input }],
    filtersAppId: [{ type: Input }],
    appClick: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SelectAppsDialogComponent {
    /**
     * @param {?} appsProcessService
     * @param {?} dialogRef
     * @param {?} data
     */
    constructor(appsProcessService, dialogRef, data) {
        this.appsProcessService = appsProcessService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.appsProcessService.getDeployedApplications().subscribe((/**
         * @param {?} apps
         * @return {?}
         */
        (apps) => {
            this.processApps = apps.filter((/**
             * @param {?} currentApp
             * @return {?}
             */
            (currentApp) => {
                return currentApp.id;
            }));
        }));
    }
    /**
     * @return {?}
     */
    onStart() {
        this.dialogRef.close(this.selectedProcess);
    }
}
SelectAppsDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-select-apps-dialog',
                template: "<header mat-dialog-title id=\"adf-selet-app-dialog-title\">{{'APP.DIALOG.TITLE' | translate}}</header>\n<section mat-dialog-content>\n\n    <mat-select id=\"adf-selet-app-dialog-dropdown\" placeholder=\"{{'APP.DIALOG.LIST' | translate}}\" [(value)]=\"selectedProcess\" >\n        <mat-option *ngFor=\"let currentProcessApp of processApps\" [value]=\"currentProcessApp\">\n            {{ currentProcessApp.name }}\n        </mat-option>\n    </mat-select>\n\n</section>\n<footer mat-dialog-actions fxLayout=\"row\" fxLayoutAlign=\"end center\">\n    <button mat-button (click)=\"onStart()\">{{'APP.DIALOG.START' | translate}}</button>\n</footer>\n"
            }] }
];
/** @nocollapse */
SelectAppsDialogComponent.ctorParameters = () => [
    { type: AppsProcessService },
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppsListModule {
}
AppsListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FlexLayoutModule,
                    CoreModule.forChild()
                ],
                declarations: [
                    AppsListComponent,
                    SelectAppsDialogComponent
                ],
                exports: [
                    AppsListComponent,
                    SelectAppsDialogComponent
                ],
                entryComponents: [
                    SelectAppsDialogComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TaskAttachmentListComponent {
    /**
     * @param {?} activitiContentService
     * @param {?} contentService
     * @param {?} thumbnailService
     * @param {?} ngZone
     */
    constructor(activitiContentService, contentService, thumbnailService, ngZone) {
        this.activitiContentService = activitiContentService;
        this.contentService = contentService;
        this.thumbnailService = thumbnailService;
        this.ngZone = ngZone;
        /**
         * Disable/Enable read only mode for attachment list.
         */
        this.disabled = false;
        /**
         * Emitted when the attachment is double-clicked or a view
         * option is selected from the context menu by the user from within the component.
         * Returns a Blob representing the clicked object.
         */
        this.attachmentClick = new EventEmitter();
        /**
         * Emitted when the attachment list has fetched all the attachments.
         * Returns a list of attachments.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs while fetching the attachments.
         */
        this.error = new EventEmitter();
        this.hasCustomTemplate = false;
        this.attachments = [];
        this.isLoading = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['taskId'] && changes['taskId'].currentValue) {
            this.loadAttachmentsByTaskId(changes['taskId'].currentValue);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.emptyTemplate) {
            this.hasCustomTemplate = true;
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.attachments = [];
    }
    /**
     * @return {?}
     */
    hasCustomEmptyTemplate() {
        return !!this.emptyTemplate;
    }
    /**
     * @return {?}
     */
    reload() {
        this.ngZone.run((/**
         * @return {?}
         */
        () => {
            this.loadAttachmentsByTaskId(this.taskId);
        }));
    }
    /**
     * @param {?} content
     * @return {?}
     */
    add(content) {
        this.ngZone.run((/**
         * @return {?}
         */
        () => {
            this.attachments.push({
                id: content.id,
                name: content.name,
                created: content.created,
                createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
            });
        }));
    }
    /**
     * @private
     * @param {?} taskId
     * @return {?}
     */
    loadAttachmentsByTaskId(taskId) {
        if (taskId) {
            this.isLoading = true;
            this.reset();
            /** @type {?} */
            const opts = 'true';
            this.activitiContentService.getTaskRelatedContent(taskId, opts).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                /** @type {?} */
                const attachList = [];
                res.data.forEach((/**
                 * @param {?} content
                 * @return {?}
                 */
                (content) => {
                    attachList.push({
                        id: content.id,
                        name: content.name,
                        created: content.created,
                        createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                        icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
                    });
                }));
                this.attachments = attachList;
                this.success.emit(this.attachments);
                this.isLoading = false;
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
                this.isLoading = false;
            }));
        }
    }
    /**
     * @param {?} contentId
     * @return {?}
     */
    deleteAttachmentById(contentId) {
        if (contentId) {
            this.activitiContentService.deleteRelatedContent(contentId).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.attachments = this.attachments.filter((/**
                 * @param {?} content
                 * @return {?}
                 */
                (content) => {
                    return content.id !== contentId;
                }));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.attachments && this.attachments.length === 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowActionsMenu(event) {
        /** @type {?} */
        const viewAction = {
            title: 'ADF_TASK_LIST.MENU_ACTIONS.VIEW_CONTENT',
            name: 'view'
        };
        /** @type {?} */
        const removeAction = {
            title: 'ADF_TASK_LIST.MENU_ACTIONS.REMOVE_CONTENT',
            name: 'remove'
        };
        /** @type {?} */
        const downloadAction = {
            title: 'ADF_TASK_LIST.MENU_ACTIONS.DOWNLOAD_CONTENT',
            name: 'download'
        };
        event.value.actions = [
            viewAction,
            downloadAction
        ];
        if (!this.disabled) {
            event.value.actions.splice(1, 0, removeAction);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExecuteRowAction(event) {
        /** @type {?} */
        const args = event.value;
        /** @type {?} */
        const action = args.action;
        if (action.name === 'view') {
            this.emitDocumentContent(args.row.obj);
        }
        else if (action.name === 'remove') {
            this.deleteAttachmentById(args.row.obj.id);
        }
        else if (action.name === 'download') {
            this.downloadContent(args.row.obj);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    openContent(event) {
        /** @type {?} */
        const content = event.value.obj;
        this.emitDocumentContent(content);
    }
    /**
     * @param {?} content
     * @return {?}
     */
    emitDocumentContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((/**
         * @param {?} blob
         * @return {?}
         */
        (blob) => {
            content.contentBlob = blob;
            this.attachmentClick.emit(content);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * @param {?} content
     * @return {?}
     */
    downloadContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((/**
         * @param {?} blob
         * @return {?}
         */
        (blob) => this.contentService.downloadBlob(blob, content.name)), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * @return {?}
     */
    isDisabled() {
        return this.disabled;
    }
}
TaskAttachmentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-attachment-list',
                template: "<adf-datatable [rows]=\"attachments\"\n               [actions]=\"true\"\n               [loading]=\"isLoading\"\n               (rowDblClick)=\"openContent($event)\"\n               (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n               (executeRowAction)=\"onExecuteRowAction($event)\">\n            <adf-no-content-template>\n                <ng-template>\n                    <ng-content *ngIf=\"hasCustomTemplate; else defaulEmptyList\" class=\"adf-custom-empty-template\"></ng-content>\n                    <ng-template #defaulEmptyList>\n                        <adf-empty-list>\n                            <div adf-empty-list-header class=\"adf-empty-list-header\">\n                                {{'ADF_TASK_LIST.ATTACHMENT.EMPTY.HEADER' | translate}}\n                            </div>\n                        </adf-empty-list>\n                    </ng-template>\n                </ng-template>\n            </adf-no-content-template>\n\n            <data-columns>\n                <data-column key=\"icon\" type=\"image\" srTitle=\"ADF_TASK_LIST.PROPERTIES.THUMBNAIL\" [sortable]=\"false\"></data-column>\n                <data-column key=\"name\" type=\"text\" title=\"ADF_TASK_LIST.PROPERTIES.NAME\" class=\"adf-full-width adf-ellipsis-cell\" [sortable]=\"true\"></data-column>\n                <data-column key=\"created\" type=\"date\" format=\"shortDate\" title=\"ADF_TASK_LIST.PROPERTIES.CREATED\"></data-column>\n            </data-columns>\n            <adf-loading-content-template>\n                <ng-template>\n                <!--Add your custom loading template here-->\n                    <mat-progress-spinner class=\"adf-attachment-list-loading-margin\" [color]=\"'primary'\" [mode]=\"'indeterminate'\">\n                    </mat-progress-spinner>\n                </ng-template>\n            </adf-loading-content-template>\n</adf-datatable>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
TaskAttachmentListComponent.ctorParameters = () => [
    { type: ProcessContentService },
    { type: ContentService },
    { type: ThumbnailService },
    { type: NgZone }
];
TaskAttachmentListComponent.propDecorators = {
    emptyTemplate: [{ type: ContentChild, args: [EmptyListComponent,] }],
    taskId: [{ type: Input }],
    disabled: [{ type: Input }],
    attachmentClick: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessAttachmentListComponent {
    /**
     * @param {?} activitiContentService
     * @param {?} contentService
     * @param {?} thumbnailService
     * @param {?} ngZone
     */
    constructor(activitiContentService, contentService, thumbnailService, ngZone) {
        this.activitiContentService = activitiContentService;
        this.contentService = contentService;
        this.thumbnailService = thumbnailService;
        this.ngZone = ngZone;
        /**
         * Disable/Enable read-only mode for attachment list.
         */
        this.disabled = false;
        /**
         * Emitted when the attachment is double-clicked or the
         * view option is selected from the context menu by the user from
         * within the component. Returns a Blob representing the object
         * that was clicked.
         */
        this.attachmentClick = new EventEmitter();
        /**
         * Emitted when the attachment list has fetched all the attachments.
         * Returns a list of attachments.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when the attachment list is not able to fetch the attachments
         * (eg, following a network error).
         */
        this.error = new EventEmitter();
        this.hasCustomTemplate = false;
        this.attachments = [];
        this.isLoading = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['processInstanceId'] && changes['processInstanceId'].currentValue) {
            this.loadAttachmentsByProcessInstanceId(changes['processInstanceId'].currentValue);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.emptyTemplate) {
            this.hasCustomTemplate = true;
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.attachments = [];
    }
    /**
     * @return {?}
     */
    reload() {
        this.ngZone.run((/**
         * @return {?}
         */
        () => {
            this.loadAttachmentsByProcessInstanceId(this.processInstanceId);
        }));
    }
    /**
     * @return {?}
     */
    hasCustomEmptyTemplate() {
        return !!this.emptyTemplate;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    add(content) {
        this.ngZone.run((/**
         * @return {?}
         */
        () => {
            this.attachments.push({
                id: content.id,
                name: content.name,
                created: content.created,
                createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
            });
        }));
    }
    /**
     * @private
     * @param {?} processInstanceId
     * @return {?}
     */
    loadAttachmentsByProcessInstanceId(processInstanceId) {
        if (processInstanceId) {
            this.reset();
            this.isLoading = true;
            /** @type {?} */
            const opts = 'true';
            this.activitiContentService.getProcessRelatedContent(processInstanceId, opts).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                res.data.forEach((/**
                 * @param {?} content
                 * @return {?}
                 */
                (content) => {
                    this.attachments.push({
                        id: content.id,
                        name: content.name,
                        created: content.created,
                        createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                        icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
                    });
                }));
                this.success.emit(this.attachments);
                this.isLoading = false;
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
                this.isLoading = false;
            }));
        }
    }
    /**
     * @private
     * @param {?} contentId
     * @return {?}
     */
    deleteAttachmentById(contentId) {
        if (contentId) {
            this.activitiContentService.deleteRelatedContent(contentId).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.attachments = this.attachments.filter((/**
                 * @param {?} content
                 * @return {?}
                 */
                (content) => {
                    return content.id !== contentId;
                }));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.attachments && this.attachments.length === 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowActionsMenu(event) {
        /** @type {?} */
        const viewAction = {
            title: 'ADF_PROCESS_LIST.MENU_ACTIONS.VIEW_CONTENT',
            name: 'view'
        };
        /** @type {?} */
        const removeAction = {
            title: 'ADF_PROCESS_LIST.MENU_ACTIONS.REMOVE_CONTENT',
            name: 'remove'
        };
        /** @type {?} */
        const downloadAction = {
            title: 'ADF_PROCESS_LIST.MENU_ACTIONS.DOWNLOAD_CONTENT',
            name: 'download'
        };
        event.value.actions = [
            viewAction,
            downloadAction
        ];
        if (!this.disabled) {
            event.value.actions.splice(1, 0, removeAction);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExecuteRowAction(event) {
        /** @type {?} */
        const args = event.value;
        /** @type {?} */
        const action = args.action;
        if (action.name === 'view') {
            this.emitDocumentContent(args.row.obj);
        }
        else if (action.name === 'remove') {
            this.deleteAttachmentById(args.row.obj.id);
        }
        else if (action.name === 'download') {
            this.downloadContent(args.row.obj);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    openContent(event) {
        /** @type {?} */
        const content = event.value.obj;
        this.emitDocumentContent(content);
    }
    /**
     * @param {?} content
     * @return {?}
     */
    emitDocumentContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((/**
         * @param {?} blob
         * @return {?}
         */
        (blob) => {
            content.contentBlob = blob;
            this.attachmentClick.emit(content);
        }), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * @param {?} content
     * @return {?}
     */
    downloadContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((/**
         * @param {?} blob
         * @return {?}
         */
        (blob) => this.contentService.downloadBlob(blob, content.name)), (/**
         * @param {?} err
         * @return {?}
         */
        (err) => {
            this.error.emit(err);
        }));
    }
    /**
     * @return {?}
     */
    isDisabled() {
        return this.disabled;
    }
}
ProcessAttachmentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-attachment-list',
                template: "<adf-datatable  [rows]=\"attachments\" \n                [actions]=\"true\" \n                [loading]=\"isLoading\" \n                (rowDblClick)=\"openContent($event)\" \n                (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n                (executeRowAction)=\"onExecuteRowAction($event)\">\n\n                <adf-no-content-template>\n                    <ng-template>\n                        <ng-content *ngIf=\"hasCustomTemplate; else defaulEmptyList\" class=\"adf-custom-empty-template\"></ng-content>\n                        <ng-template #defaulEmptyList>\n                            <adf-empty-list>\n                                <div adf-empty-list-header class=\"adf-empty-list-header\">\n                                    {{'ADF_PROCESS_LIST.PROCESS-ATTACHMENT.EMPTY.HEADER' | translate}}\n                                </div>\n                            </adf-empty-list>\n                        </ng-template>\n                    </ng-template>\n                </adf-no-content-template>\n\n    <data-columns>\n        <data-column key=\"icon\" type=\"image\" srTitle=\"ADF_PROCESS_LIST.PROPERTIES.THUMBNAIL\" [sortable]=\"false\"></data-column>\n        <data-column key=\"name\" type=\"text\" title=\"{{'ADF_PROCESS_LIST.PROPERTIES.NAME' | translate}}\" class=\"adf-full-width adf-ellipsis-cell\" [sortable]=\"true\"></data-column>\n        <data-column key=\"created\" type=\"date\" format=\"shortDate\" title=\"{{'ADF_PROCESS_LIST.PROPERTIES.CREATED' | translate}}\"></data-column>\n    </data-columns>\n\n    <adf-loading-content-template>\n        <ng-template>\n            <!--Add your custom loading template here-->\n            <mat-progress-spinner class=\"adf-attachment-list-loading-margin\" [color]=\"'primary'\" [mode]=\"'indeterminate'\">\n            </mat-progress-spinner>\n        </ng-template>\n    </adf-loading-content-template>\n\n</adf-datatable>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
ProcessAttachmentListComponent.ctorParameters = () => [
    { type: ProcessContentService },
    { type: ContentService },
    { type: ThumbnailService },
    { type: NgZone }
];
ProcessAttachmentListComponent.propDecorators = {
    emptyTemplate: [{ type: ContentChild, args: [EmptyListComponent,] }],
    processInstanceId: [{ type: Input }],
    disabled: [{ type: Input }],
    attachmentClick: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CreateProcessAttachmentComponent {
    /**
     * @param {?} activitiContentService
     */
    constructor(activitiContentService) {
        this.activitiContentService = activitiContentService;
        /**
         * Emitted when an error occurs while creating or uploading an attachment
         * from the user within the component.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when an attachment is successfully created or uploaded
         * from within the component.
         */
        this.success = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['processInstanceId'] && changes['processInstanceId'].currentValue) {
            this.processInstanceId = changes['processInstanceId'].currentValue;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFileUpload(event) {
        /** @type {?} */
        const filesList = event.detail.files.map((/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => obj.file));
        for (const fileInfoObj of filesList) {
            /** @type {?} */
            const file = fileInfoObj;
            /** @type {?} */
            const opts = {
                isRelatedContent: true
            };
            this.activitiContentService.createProcessRelatedContent(this.processInstanceId, file, opts).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.success.emit(res);
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
    }
}
CreateProcessAttachmentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-create-process-attachment',
                template: "<button\n    id=\"add_new_process_content_button\"\n    color=\"primary\"\n    mat-button\n    mat-raised-button\n    mat-icon-button\n    class=\"adf-create-attachment\"\n    adf-upload=\"true\"\n    [mode]=\"['click']\"\n    [multiple]=\"true\"\n    (upload-files)=\"onFileUpload($event)\">\n    <mat-icon>add</mat-icon>\n</button>\n",
                styles: [".adf-create-attachment{display:inline-block;line-height:0;vertical-align:middle}"]
            }] }
];
/** @nocollapse */
CreateProcessAttachmentComponent.ctorParameters = () => [
    { type: ProcessContentService }
];
CreateProcessAttachmentComponent.propDecorators = {
    processInstanceId: [{ type: Input }],
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttachmentComponent {
    /**
     * @param {?} activitiContentService
     */
    constructor(activitiContentService) {
        this.activitiContentService = activitiContentService;
        /**
         * Emitted when an error occurs while creating or uploading an
         *  attachment from the user within the component.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when an attachment is created or uploaded successfully
         * from within the component.
         */
        this.success = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['taskId'] && changes['taskId'].currentValue) {
            this.taskId = changes['taskId'].currentValue;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFileUpload(event) {
        /** @type {?} */
        const filesList = event.detail.files.map((/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => obj.file));
        for (const fileInfoObj of filesList) {
            /** @type {?} */
            const file = fileInfoObj;
            /** @type {?} */
            const opts = {
                isRelatedContent: true
            };
            this.activitiContentService.createTaskRelatedContent(this.taskId, file, opts).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                this.success.emit(res);
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.error.emit(err);
            }));
        }
    }
}
AttachmentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-create-task-attachment',
                template: "<button\n    color=\"primary\"\n    mat-button\n    mat-raised-button\n    mat-icon-button\n    class=\"adf-create-attachment\"\n    adf-upload=\"true\"\n    [mode]=\"['click']\"\n    [multiple]=\"true\"\n    (upload-files)=\"onFileUpload($event)\">\n    <mat-icon>add</mat-icon>\n</button>\n",
                styles: [".adf-create-attachment{display:inline-block;line-height:0;vertical-align:middle}"]
            }] }
];
/** @nocollapse */
AttachmentComponent.ctorParameters = () => [
    { type: ProcessContentService }
];
AttachmentComponent.propDecorators = {
    taskId: [{ type: Input }],
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttachmentModule {
}
AttachmentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    MaterialModule
                ],
                declarations: [
                    TaskAttachmentListComponent,
                    ProcessAttachmentListComponent,
                    CreateProcessAttachmentComponent,
                    CreateProcessAttachmentComponent,
                    AttachmentComponent
                ],
                exports: [
                    TaskAttachmentListComponent,
                    ProcessAttachmentListComponent,
                    CreateProcessAttachmentComponent,
                    CreateProcessAttachmentComponent,
                    AttachmentComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$2 = {
    name: 'adf-process-services',
    source: 'assets/adf-process-services'
};
class ProcessModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ProcessModule,
            providers: [
                {
                    provide: TRANSLATION_PROVIDER,
                    multi: true,
                    useValue: {
                        name: 'adf-process-services',
                        source: 'assets/adf-process-services'
                    }
                }
            ]
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: ProcessModuleLazy
        };
    }
}
ProcessModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    ProcessCommentsModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    ProcessListModule,
                    TaskListModule,
                    AppsListModule,
                    AttachmentModule,
                    PeopleModule,
                    FormModule
                ],
                providers: [
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: ɵ0$2
                    }
                ],
                exports: [
                    CommonModule,
                    ProcessCommentsModule,
                    FormsModule,
                    ReactiveFormsModule,
                    ProcessListModule,
                    TaskListModule,
                    AppsListModule,
                    AttachmentModule,
                    PeopleModule,
                    FormModule
                ]
            },] }
];
class ProcessModuleLazy {
}
ProcessModuleLazy.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    ProcessCommentsModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    ProcessListModule,
                    TaskListModule,
                    AppsListModule,
                    AttachmentModule,
                    PeopleModule
                ],
                exports: [
                    CommonModule,
                    ProcessCommentsModule,
                    FormsModule,
                    ReactiveFormsModule,
                    ProcessListModule,
                    TaskListModule,
                    AppsListModule,
                    AttachmentModule,
                    PeopleModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ProcessFiltersComponent, ProcessInstanceDetailsComponent, ProcessAuditDirective, ProcessInstanceHeaderComponent, ProcessInstanceTasksComponent, ProcessInstanceListComponent, StartProcessInstanceComponent, ProcessService, ProcessFilterService, FilterProcessRepresentationModel, ProcessFilterParamRepresentationModel, ProcessDefinitionRepresentation, ProcessInstance, ProcessFilterRequestRepresentation, ProcessInstanceVariable, ProcessListModule, TaskListComponent, ChecklistComponent, TaskHeaderComponent, NoTaskDetailsTemplateDirective, TaskFiltersComponent, TaskDetailsComponent, TaskAuditDirective, StartTaskComponent, TaskStandaloneComponent, AttachFormComponent, TaskListService, ProcessUploadService, TaskUploadService, TaskFilterService, AppDefinitionRepresentationModel, FilterParamsModel, FilterRepresentationModel, TaskQueryRequestRepresentationModel, Form, StartTaskModel, TaskDetailsEvent, TaskDetailsModel, TaskListModel, UserEventModel, UserGroupModel, TaskListModule, AppsListComponent, SelectAppsDialogComponent, AppsListModule, TaskAttachmentListComponent, ProcessAttachmentListComponent, CreateProcessAttachmentComponent, AttachmentComponent, AttachmentModule, ProcessCommentsComponent, ProcessCommentsModule, PeopleComponent, PeopleListComponent, PeopleSearchComponent, PeopleSearchFieldComponent, PeopleSelectorComponent, PeopleSearchActionLabelDirective, PeopleSearchTitleDirective, PeopleModule, AttachFileWidgetComponent, AttachFolderWidgetComponent, AttachFileWidgetDialogComponent, AttachFileWidgetDialogService, ContentWidgetModule, FormComponent, StartFormComponent, FormModule, ProcessModule, ProcessModuleLazy, MaterialModule as ɵb, modules as ɵa };

//# sourceMappingURL=adf-process-services.js.map