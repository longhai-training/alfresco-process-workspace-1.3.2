/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { ExtensionLoaderService } from './extension-loader.service';
import * as i0 from "@angular/core";
import * as i1 from "./extension-loader.service";
var RuleService = /** @class */ (function () {
    function RuleService(loader) {
        this.loader = loader;
        this.context = null;
        this.rules = [];
        this.evaluators = {};
    }
    /**
     * @param {?} config
     * @return {?}
     */
    RuleService.prototype.setup = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this.rules = this.loader.getRules(config);
    };
    /**
     * Adds one or more new rule evaluators to the existing set.
     * @param values The new evaluators to add
     */
    /**
     * Adds one or more new rule evaluators to the existing set.
     * @param {?} values The new evaluators to add
     * @return {?}
     */
    RuleService.prototype.setEvaluators = /**
     * Adds one or more new rule evaluators to the existing set.
     * @param {?} values The new evaluators to add
     * @return {?}
     */
    function (values) {
        if (values) {
            this.evaluators = Object.assign({}, this.evaluators, values);
        }
    };
    /**
     * Retrieves a rule using its ID value.
     * @param id The ID value to look for
     * @returns The rule or null if not found
     */
    /**
     * Retrieves a rule using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} The rule or null if not found
     */
    RuleService.prototype.getRuleById = /**
     * Retrieves a rule using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} The rule or null if not found
     */
    function (id) {
        return this.rules.find((/**
         * @param {?} ref
         * @return {?}
         */
        function (ref) { return ref.id === id; }));
    };
    /**
     * Retrieves a RuleEvaluator function using its key name.
     * @param key Key name to look for
     * @returns RuleEvaluator or null if not found
     */
    /**
     * Retrieves a RuleEvaluator function using its key name.
     * @param {?} key Key name to look for
     * @return {?} RuleEvaluator or null if not found
     */
    RuleService.prototype.getEvaluator = /**
     * Retrieves a RuleEvaluator function using its key name.
     * @param {?} key Key name to look for
     * @return {?} RuleEvaluator or null if not found
     */
    function (key) {
        if (key && key.startsWith('!')) {
            /** @type {?} */
            var fn_1 = this.evaluators[key.substring(1)];
            return (/**
             * @param {?} context
             * @param {...?} args
             * @return {?}
             */
            function (context) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return !fn_1.apply(void 0, tslib_1.__spread([context], args));
            });
        }
        return this.evaluators[key];
    };
    /**
     * Evaluates a rule.
     * @param ruleId ID of the rule to evaluate
     * @param context (optional) Custom rule execution context.
     * @returns True if the rule passed, false otherwise
     */
    /**
     * Evaluates a rule.
     * @param {?} ruleId ID of the rule to evaluate
     * @param {?=} context (optional) Custom rule execution context.
     * @return {?} True if the rule passed, false otherwise
     */
    RuleService.prototype.evaluateRule = /**
     * Evaluates a rule.
     * @param {?} ruleId ID of the rule to evaluate
     * @param {?=} context (optional) Custom rule execution context.
     * @return {?} True if the rule passed, false otherwise
     */
    function (ruleId, context) {
        /** @type {?} */
        var ruleRef = this.getRuleById(ruleId);
        context = context || this.context;
        if (ruleRef) {
            /** @type {?} */
            var evaluator = this.getEvaluator(ruleRef.type);
            if (evaluator) {
                return evaluator.apply(void 0, tslib_1.__spread([context], ruleRef.parameters));
            }
        }
        else {
            /** @type {?} */
            var evaluator = this.getEvaluator(ruleId);
            if (evaluator) {
                return evaluator(context);
            }
        }
        return false;
    };
    RuleService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    RuleService.ctorParameters = function () { return [
        { type: ExtensionLoaderService }
    ]; };
    /** @nocollapse */ RuleService.ngInjectableDef = i0.defineInjectable({ factory: function RuleService_Factory() { return new RuleService(i0.inject(i1.ExtensionLoaderService)); }, token: RuleService, providedIn: "root" });
    return RuleService;
}());
export { RuleService };
if (false) {
    /** @type {?} */
    RuleService.prototype.context;
    /** @type {?} */
    RuleService.prototype.rules;
    /** @type {?} */
    RuleService.prototype.evaluators;
    /**
     * @type {?}
     * @protected
     */
    RuleService.prototype.loader;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVsZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1leHRlbnNpb25zLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL3J1bGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUczQyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQzs7O0FBRXBFO0lBUUkscUJBQXNCLE1BQThCO1FBQTlCLFdBQU0sR0FBTixNQUFNLENBQXdCO1FBSnBELFlBQU8sR0FBZ0IsSUFBSSxDQUFDO1FBQzVCLFVBQUssR0FBbUIsRUFBRSxDQUFDO1FBQzNCLGVBQVUsR0FBcUMsRUFBRSxDQUFDO0lBRUssQ0FBQzs7Ozs7SUFFeEQsMkJBQUs7Ozs7SUFBTCxVQUFNLE1BQXVCO1FBQ3pCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOzs7T0FHRzs7Ozs7O0lBQ0gsbUNBQWE7Ozs7O0lBQWIsVUFBYyxNQUF3QztRQUNsRCxJQUFJLE1BQU0sRUFBRTtZQUNSLElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUNoRTtJQUNMLENBQUM7SUFFRDs7OztPQUlHOzs7Ozs7SUFDSCxpQ0FBVzs7Ozs7SUFBWCxVQUFZLEVBQVU7UUFDbEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUk7Ozs7UUFBQyxVQUFDLEdBQUcsSUFBSyxPQUFBLEdBQUcsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFiLENBQWEsRUFBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7OztPQUlHOzs7Ozs7SUFDSCxrQ0FBWTs7Ozs7SUFBWixVQUFhLEdBQVc7UUFDcEIsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTs7Z0JBQ3RCLElBQUUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUM7Ozs7O1lBQU8sVUFBQyxPQUFvQjtnQkFBRSxjQUF3QjtxQkFBeEIsVUFBd0IsRUFBeEIscUJBQXdCLEVBQXhCLElBQXdCO29CQUF4Qiw2QkFBd0I7O2dCQUNsRCxPQUFPLENBQUMsSUFBRSxpQ0FBQyxPQUFPLEdBQUssSUFBSSxFQUFDLENBQUM7WUFDakMsQ0FBQyxFQUFDO1NBQ0w7UUFDRCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7OztPQUtHOzs7Ozs7O0lBQ0gsa0NBQVk7Ozs7OztJQUFaLFVBQWEsTUFBYyxFQUFFLE9BQXFCOztZQUN4QyxPQUFPLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUM7UUFDeEMsT0FBTyxHQUFHLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDO1FBRWxDLElBQUksT0FBTyxFQUFFOztnQkFDSCxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ2pELElBQUksU0FBUyxFQUFFO2dCQUNYLE9BQU8sU0FBUyxpQ0FBQyxPQUFPLEdBQUssT0FBTyxDQUFDLFVBQVUsR0FBRTthQUNwRDtTQUNKO2FBQU07O2dCQUNHLFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztZQUMzQyxJQUFJLFNBQVMsRUFBRTtnQkFDWCxPQUFPLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUM3QjtTQUNKO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQzs7Z0JBdEVKLFVBQVUsU0FBQztvQkFDUixVQUFVLEVBQUUsTUFBTTtpQkFDckI7Ozs7Z0JBSlEsc0JBQXNCOzs7c0JBcEIvQjtDQTZGQyxBQXZFRCxJQXVFQztTQXBFWSxXQUFXOzs7SUFDcEIsOEJBQTRCOztJQUM1Qiw0QkFBMkI7O0lBQzNCLGlDQUFrRDs7Ozs7SUFFdEMsNkJBQXdDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUnVsZVJlZiwgUnVsZUNvbnRleHQsIFJ1bGVFdmFsdWF0b3IsIFJ1bGVQYXJhbWV0ZXIgfSBmcm9tICcuLi9jb25maWcvcnVsZS5leHRlbnNpb25zJztcbmltcG9ydCB7IEV4dGVuc2lvbkNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9leHRlbnNpb24uY29uZmlnJztcbmltcG9ydCB7IEV4dGVuc2lvbkxvYWRlclNlcnZpY2UgfSBmcm9tICcuL2V4dGVuc2lvbi1sb2FkZXIuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgUnVsZVNlcnZpY2Uge1xuICAgIGNvbnRleHQ6IFJ1bGVDb250ZXh0ID0gbnVsbDtcbiAgICBydWxlczogQXJyYXk8UnVsZVJlZj4gPSBbXTtcbiAgICBldmFsdWF0b3JzOiB7IFtrZXk6IHN0cmluZ106IFJ1bGVFdmFsdWF0b3IgfSA9IHt9O1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGxvYWRlcjogRXh0ZW5zaW9uTG9hZGVyU2VydmljZSkge31cblxuICAgIHNldHVwKGNvbmZpZzogRXh0ZW5zaW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMucnVsZXMgPSB0aGlzLmxvYWRlci5nZXRSdWxlcyhjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgbmV3IHJ1bGUgZXZhbHVhdG9ycyB0byB0aGUgZXhpc3Rpbmcgc2V0LlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgVGhlIG5ldyBldmFsdWF0b3JzIHRvIGFkZFxuICAgICAqL1xuICAgIHNldEV2YWx1YXRvcnModmFsdWVzOiB7IFtrZXk6IHN0cmluZ106IFJ1bGVFdmFsdWF0b3IgfSkge1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRvcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmV2YWx1YXRvcnMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBydWxlIHVzaW5nIGl0cyBJRCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHZhbHVlIHRvIGxvb2sgZm9yXG4gICAgICogQHJldHVybnMgVGhlIHJ1bGUgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRSdWxlQnlJZChpZDogc3RyaW5nKTogUnVsZVJlZiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzLmZpbmQoKHJlZikgPT4gcmVmLmlkID09PSBpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgUnVsZUV2YWx1YXRvciBmdW5jdGlvbiB1c2luZyBpdHMga2V5IG5hbWUuXG4gICAgICogQHBhcmFtIGtleSBLZXkgbmFtZSB0byBsb29rIGZvclxuICAgICAqIEByZXR1cm5zIFJ1bGVFdmFsdWF0b3Igb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRFdmFsdWF0b3Ioa2V5OiBzdHJpbmcpOiBSdWxlRXZhbHVhdG9yIHtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aCgnIScpKSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHRoaXMuZXZhbHVhdG9yc1trZXkuc3Vic3RyaW5nKDEpXTtcbiAgICAgICAgICAgIHJldHVybiAoY29udGV4dDogUnVsZUNvbnRleHQsIC4uLmFyZ3M6IFJ1bGVQYXJhbWV0ZXJbXSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhZm4oY29udGV4dCwgLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRvcnNba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZXMgYSBydWxlLlxuICAgICAqIEBwYXJhbSBydWxlSWQgSUQgb2YgdGhlIHJ1bGUgdG8gZXZhbHVhdGVcbiAgICAgKiBAcGFyYW0gY29udGV4dCAob3B0aW9uYWwpIEN1c3RvbSBydWxlIGV4ZWN1dGlvbiBjb250ZXh0LlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHJ1bGUgcGFzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBldmFsdWF0ZVJ1bGUocnVsZUlkOiBzdHJpbmcsIGNvbnRleHQ/OiBSdWxlQ29udGV4dCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBydWxlUmVmID0gdGhpcy5nZXRSdWxlQnlJZChydWxlSWQpO1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgaWYgKHJ1bGVSZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2YWx1YXRvciA9IHRoaXMuZ2V0RXZhbHVhdG9yKHJ1bGVSZWYudHlwZSk7XG4gICAgICAgICAgICBpZiAoZXZhbHVhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRvcihjb250ZXh0LCAuLi5ydWxlUmVmLnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXZhbHVhdG9yID0gdGhpcy5nZXRFdmFsdWF0b3IocnVsZUlkKTtcbiAgICAgICAgICAgIGlmIChldmFsdWF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZhbHVhdG9yKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXX0=