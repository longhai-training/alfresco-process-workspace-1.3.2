/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { ExtensionLoaderService } from './extension-loader.service';
import * as core from '../evaluators/core.evaluators';
import { ComponentRegisterService } from './component-register.service';
import { RuleService } from './rule.service';
import * as i0 from "@angular/core";
import * as i1 from "./extension-loader.service";
import * as i2 from "./component-register.service";
import * as i3 from "./rule.service";
export class ExtensionService {
    /**
     * @param {?} loader
     * @param {?} componentRegister
     * @param {?} ruleService
     */
    constructor(loader, componentRegister, ruleService) {
        this.loader = loader;
        this.componentRegister = componentRegister;
        this.ruleService = ruleService;
        this.config = null;
        this.configPath = 'assets/app.extensions.json';
        this.pluginsPath = 'assets/plugins';
        this.routes = [];
        this.actions = [];
        this.features = [];
        this.authGuards = {};
    }
    /**
     * Loads and registers an extension config file and plugins (specified by path properties).
     * @return {?} The loaded config data
     */
    load() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const config = yield this.loader.load(this.configPath, this.pluginsPath);
            this.setup(config);
            return config;
        });
    }
    /**
     * Registers extensions from a config object.
     * @param {?} config Object with config data
     * @return {?}
     */
    setup(config) {
        if (!config) {
            console.warn('Extension configuration not found');
            return;
        }
        this.config = config;
        this.setEvaluators({
            'core.every': core.every,
            'core.some': core.some,
            'core.not': core.not
        });
        this.actions = this.loader.getActions(config);
        this.routes = this.loader.getRoutes(config);
        this.features = this.loader.getFeatures(config);
        this.ruleService.setup(config);
    }
    /**
     * Gets features by key.
     * @param {?} key Key string, using dot notation
     * @return {?} Features array found by key
     */
    getFeature(key) {
        /** @type {?} */
        const properties = Array.isArray(key) ? [key] : key.split('.');
        return properties.reduce((/**
         * @param {?} prev
         * @param {?} curr
         * @return {?}
         */
        (prev, curr) => prev && prev[curr]), this.features) || [];
    }
    /**
     * @template T
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    getElements(key, fallback = []) {
        return this.loader.getElements(this.config, key, fallback);
    }
    /**
     * Adds one or more new rule evaluators to the existing set.
     * @param {?} values The new evaluators to add
     * @return {?}
     */
    setEvaluators(values) {
        this.ruleService.setEvaluators(values);
    }
    /**
     * Adds one or more new auth guards to the existing set.
     * @param {?} values The new auth guards to add
     * @return {?}
     */
    setAuthGuards(values) {
        if (values) {
            this.authGuards = Object.assign({}, this.authGuards, values);
        }
    }
    /**
     * Adds one or more new components to the existing set.
     * @param {?} values The new components to add
     * @return {?}
     */
    setComponents(values) {
        this.componentRegister.setComponents(values);
    }
    /**
     * Retrieves a route using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} The route or null if not found
     */
    getRouteById(id) {
        return this.routes.find((/**
         * @param {?} route
         * @return {?}
         */
        (route) => route.id === id));
    }
    /**
     * Retrieves one or more auth guards using an array of ID values.
     * @param {?} ids Array of ID value to look for
     * @return {?} Array of auth guards or empty array if none were found
     */
    getAuthGuards(ids) {
        return (ids || [])
            .map((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.authGuards[id]))
            .filter((/**
         * @param {?} guard
         * @return {?}
         */
        (guard) => guard));
    }
    /**
     * Retrieves an action using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} Action or null if not found
     */
    getActionById(id) {
        return this.actions.find((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.id === id));
    }
    /**
     * Retrieves a RuleEvaluator function using its key name.
     * @param {?} key Key name to look for
     * @return {?} RuleEvaluator or null if not found
     */
    getEvaluator(key) {
        return this.ruleService.getEvaluator(key);
    }
    /**
     * Evaluates a rule.
     * @param {?} ruleId ID of the rule to evaluate
     * @param {?=} context (optional) Custom rule execution context.
     * @return {?} True if the rule passed, false otherwise
     */
    evaluateRule(ruleId, context) {
        return this.ruleService.evaluateRule(ruleId, context);
    }
    /**
     * Retrieves a registered extension component using its ID value.
     * @template T
     * @param {?} id The ID value to look for
     * @return {?} The component or null if not found
     */
    getComponentById(id) {
        return this.componentRegister.getComponentById(id);
    }
    /**
     * Retrieves a rule using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} The rule or null if not found
     */
    getRuleById(id) {
        return this.ruleService.getRuleById(id);
    }
    /**
     * Runs a lightweight expression stored in a string.
     * @param {?} value String containing the expression or literal value
     * @param {?=} context Parameter object for the expression with details of app state
     * @return {?} Result of evaluated expression, if found, or the literal value otherwise
     */
    runExpression(value, context) {
        /** @type {?} */
        const pattern = new RegExp(/\$\((.*\)?)\)/g);
        /** @type {?} */
        const matches = pattern.exec(value);
        if (matches && matches.length > 1) {
            /** @type {?} */
            const expression = matches[1];
            /** @type {?} */
            const fn = new Function('context', `return ${expression}`);
            /** @type {?} */
            const result = fn(context);
            return result;
        }
        return value;
    }
}
ExtensionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ExtensionService.ctorParameters = () => [
    { type: ExtensionLoaderService },
    { type: ComponentRegisterService },
    { type: RuleService }
];
/** @nocollapse */ ExtensionService.ngInjectableDef = i0.defineInjectable({ factory: function ExtensionService_Factory() { return new ExtensionService(i0.inject(i1.ExtensionLoaderService), i0.inject(i2.ComponentRegisterService), i0.inject(i3.RuleService)); }, token: ExtensionService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ExtensionService.prototype.config;
    /** @type {?} */
    ExtensionService.prototype.configPath;
    /** @type {?} */
    ExtensionService.prototype.pluginsPath;
    /** @type {?} */
    ExtensionService.prototype.routes;
    /** @type {?} */
    ExtensionService.prototype.actions;
    /** @type {?} */
    ExtensionService.prototype.features;
    /** @type {?} */
    ExtensionService.prototype.authGuards;
    /**
     * @type {?}
     * @protected
     */
    ExtensionService.prototype.loader;
    /**
     * @type {?}
     * @protected
     */
    ExtensionService.prototype.componentRegister;
    /**
     * @type {?}
     * @protected
     */
    ExtensionService.prototype.ruleService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5zaW9uLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWV4dGVuc2lvbnMvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvZXh0ZW5zaW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxVQUFVLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFHakQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFHcEUsT0FBTyxLQUFLLElBQUksTUFBTSwrQkFBK0IsQ0FBQztBQUN0RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUN4RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7O0FBTTdDLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7OztJQVl6QixZQUNjLE1BQThCLEVBQzlCLGlCQUEyQyxFQUMzQyxXQUF3QjtRQUZ4QixXQUFNLEdBQU4sTUFBTSxDQUF3QjtRQUM5QixzQkFBaUIsR0FBakIsaUJBQWlCLENBQTBCO1FBQzNDLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBYjVCLFdBQU0sR0FBb0IsSUFBSSxDQUFDO1FBRXpDLGVBQVUsR0FBRyw0QkFBNEIsQ0FBQztRQUMxQyxnQkFBVyxHQUFHLGdCQUFnQixDQUFDO1FBRS9CLFdBQU0sR0FBb0IsRUFBRSxDQUFDO1FBQzdCLFlBQU8sR0FBcUIsRUFBRSxDQUFDO1FBQy9CLGFBQVEsR0FBZSxFQUFFLENBQUM7UUFDMUIsZUFBVSxHQUFnQyxFQUFFLENBQUM7SUFPN0MsQ0FBQzs7Ozs7SUFNSyxJQUFJOzs7a0JBQ0EsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQ2pDLElBQUksQ0FBQyxVQUFVLEVBQ2YsSUFBSSxDQUFDLFdBQVcsQ0FDbkI7WUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxD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QixXQUFXOzs7Ozs7OztJQVFoQixrQ0FBeUM7O0lBRXpDLHNDQUEwQzs7SUFDMUMsdUNBQStCOztJQUUvQixrQ0FBNkI7O0lBQzdCLG1DQUErQjs7SUFDL0Isb0NBQTBCOztJQUMxQixzQ0FBNkM7Ozs7O0lBR3pDLGtDQUF3Qzs7Ozs7SUFDeEMsNkNBQXFEOzs7OztJQUNyRCx1Q0FBa0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSdWxlRXZhbHVhdG9yLCBSdWxlUmVmLCBSdWxlQ29udGV4dCB9IGZyb20gJy4uL2NvbmZpZy9ydWxlLmV4dGVuc2lvbnMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2V4dGVuc2lvbi5jb25maWcnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uTG9hZGVyU2VydmljZSB9IGZyb20gJy4vZXh0ZW5zaW9uLWxvYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFJvdXRlUmVmIH0gZnJvbSAnLi4vY29uZmlnL3JvdXRpbmcuZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBBY3Rpb25SZWYgfSBmcm9tICcuLi9jb25maWcvYWN0aW9uLmV4dGVuc2lvbnMnO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tICcuLi9ldmFsdWF0b3JzL2NvcmUuZXZhbHVhdG9ycyc7XG5pbXBvcnQgeyBDb21wb25lbnRSZWdpc3RlclNlcnZpY2UgfSBmcm9tICcuL2NvbXBvbmVudC1yZWdpc3Rlci5zZXJ2aWNlJztcbmltcG9ydCB7IFJ1bGVTZXJ2aWNlIH0gZnJvbSAnLi9ydWxlLnNlcnZpY2UnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uRWxlbWVudCB9IGZyb20gJy4uL2NvbmZpZy9leHRlbnNpb24tZWxlbWVudCc7XG5cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uU2VydmljZSB7XG5cbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBFeHRlbnNpb25Db25maWcgPSBudWxsO1xuXG4gICAgY29uZmlnUGF0aCA9ICdhc3NldHMvYXBwLmV4dGVuc2lvbnMuanNvbic7XG4gICAgcGx1Z2luc1BhdGggPSAnYXNzZXRzL3BsdWdpbnMnO1xuXG4gICAgcm91dGVzOiBBcnJheTxSb3V0ZVJlZj4gPSBbXTtcbiAgICBhY3Rpb25zOiBBcnJheTxBY3Rpb25SZWY+ID0gW107XG4gICAgZmVhdHVyZXM6IEFycmF5PGFueT4gPSBbXTtcbiAgICBhdXRoR3VhcmRzOiB7IFtrZXk6IHN0cmluZ106IFR5cGU8e30+IH0gPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcm90ZWN0ZWQgbG9hZGVyOiBFeHRlbnNpb25Mb2FkZXJTZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgY29tcG9uZW50UmVnaXN0ZXI6IENvbXBvbmVudFJlZ2lzdGVyU2VydmljZSxcbiAgICAgICAgcHJvdGVjdGVkIHJ1bGVTZXJ2aWNlOiBSdWxlU2VydmljZVxuICAgICkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFuZCByZWdpc3RlcnMgYW4gZXh0ZW5zaW9uIGNvbmZpZyBmaWxlIGFuZCBwbHVnaW5zIChzcGVjaWZpZWQgYnkgcGF0aCBwcm9wZXJ0aWVzKS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbG9hZGVkIGNvbmZpZyBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgbG9hZCgpOiBQcm9taXNlPEV4dGVuc2lvbkNvbmZpZz4ge1xuICAgICAgICBjb25zdCBjb25maWcgPSBhd2FpdCB0aGlzLmxvYWRlci5sb2FkKFxuICAgICAgICAgICAgdGhpcy5jb25maWdQYXRoLFxuICAgICAgICAgICAgdGhpcy5wbHVnaW5zUGF0aFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNldHVwKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGV4dGVuc2lvbnMgZnJvbSBhIGNvbmZpZyBvYmplY3QuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPYmplY3Qgd2l0aCBjb25maWcgZGF0YVxuICAgICAqL1xuICAgIHNldHVwKGNvbmZpZzogRXh0ZW5zaW9uQ29uZmlnKSB7XG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0V4dGVuc2lvbiBjb25maWd1cmF0aW9uIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgdGhpcy5zZXRFdmFsdWF0b3JzKHtcbiAgICAgICAgICAgICdjb3JlLmV2ZXJ5JzogY29yZS5ldmVyeSxcbiAgICAgICAgICAgICdjb3JlLnNvbWUnOiBjb3JlLnNvbWUsXG4gICAgICAgICAgICAnY29yZS5ub3QnOiBjb3JlLm5vdFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB0aGlzLmxvYWRlci5nZXRBY3Rpb25zKGNvbmZpZyk7XG4gICAgICAgIHRoaXMucm91dGVzID0gdGhpcy5sb2FkZXIuZ2V0Um91dGVzKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSB0aGlzLmxvYWRlci5nZXRGZWF0dXJlcyhjb25maWcpO1xuXG4gICAgICAgIHRoaXMucnVsZVNlcnZpY2Uuc2V0dXAoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGZlYXR1cmVzIGJ5IGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IEtleSBzdHJpbmcsIHVzaW5nIGRvdCBub3RhdGlvblxuICAgICAqIEByZXR1cm5zIEZlYXR1cmVzIGFycmF5IGZvdW5kIGJ5IGtleVxuICAgICAqL1xuICAgIGdldEZlYXR1cmUoa2V5OiBzdHJpbmcpOiBhbnlbXSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXM6IHN0cmluZ1tdID0gQXJyYXkuaXNBcnJheShrZXkpID8gW2tleV0gOiBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBwcmV2ICYmIHByZXZbY3Vycl0sIHRoaXMuZmVhdHVyZXMpIHx8IFtdO1xuICAgIH1cblxuICAgIGdldEVsZW1lbnRzPFQgZXh0ZW5kcyBFeHRlbnNpb25FbGVtZW50PihrZXk6IHN0cmluZywgZmFsbGJhY2s6IEFycmF5PFQ+ID0gW10pOiBBcnJheTxUPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5nZXRFbGVtZW50cyh0aGlzLmNvbmZpZywga2V5LCBmYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBuZXcgcnVsZSBldmFsdWF0b3JzIHRvIHRoZSBleGlzdGluZyBzZXQuXG4gICAgICogQHBhcmFtIHZhbHVlcyBUaGUgbmV3IGV2YWx1YXRvcnMgdG8gYWRkXG4gICAgICovXG4gICAgc2V0RXZhbHVhdG9ycyh2YWx1ZXM6IHsgW2tleTogc3RyaW5nXTogUnVsZUV2YWx1YXRvciB9KSB7XG4gICAgICAgIHRoaXMucnVsZVNlcnZpY2Uuc2V0RXZhbHVhdG9ycyh2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgbmV3IGF1dGggZ3VhcmRzIHRvIHRoZSBleGlzdGluZyBzZXQuXG4gICAgICogQHBhcmFtIHZhbHVlcyBUaGUgbmV3IGF1dGggZ3VhcmRzIHRvIGFkZFxuICAgICAqL1xuICAgIHNldEF1dGhHdWFyZHModmFsdWVzOiB7IFtrZXk6IHN0cmluZ106IFR5cGU8e30+IH0pIHtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5hdXRoR3VhcmRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hdXRoR3VhcmRzLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBuZXcgY29tcG9uZW50cyB0byB0aGUgZXhpc3Rpbmcgc2V0LlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgVGhlIG5ldyBjb21wb25lbnRzIHRvIGFkZFxuICAgICAqL1xuICAgIHNldENvbXBvbmVudHModmFsdWVzOiB7IFtrZXk6IHN0cmluZ106IFR5cGU8e30+IH0pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWdpc3Rlci5zZXRDb21wb25lbnRzKHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcm91dGUgdXNpbmcgaXRzIElEIHZhbHVlLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdmFsdWUgdG8gbG9vayBmb3JcbiAgICAgKiBAcmV0dXJucyBUaGUgcm91dGUgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRSb3V0ZUJ5SWQoaWQ6IHN0cmluZyk6IFJvdXRlUmVmIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVzLmZpbmQoKHJvdXRlKSA9PiByb3V0ZS5pZCA9PT0gaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBvbmUgb3IgbW9yZSBhdXRoIGd1YXJkcyB1c2luZyBhbiBhcnJheSBvZiBJRCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIGlkcyBBcnJheSBvZiBJRCB2YWx1ZSB0byBsb29rIGZvclxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIGF1dGggZ3VhcmRzIG9yIGVtcHR5IGFycmF5IGlmIG5vbmUgd2VyZSBmb3VuZFxuICAgICAqL1xuICAgIGdldEF1dGhHdWFyZHMoaWRzOiBzdHJpbmdbXSk6IEFycmF5PFR5cGU8e30+PiB7XG4gICAgICAgIHJldHVybiAoaWRzIHx8IFtdKVxuICAgICAgICAgICAgLm1hcCgoaWQpID0+IHRoaXMuYXV0aEd1YXJkc1tpZF0pXG4gICAgICAgICAgICAuZmlsdGVyKChndWFyZCkgPT4gZ3VhcmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhY3Rpb24gdXNpbmcgaXRzIElEIHZhbHVlLlxuICAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdmFsdWUgdG8gbG9vayBmb3JcbiAgICAgKiBAcmV0dXJucyBBY3Rpb24gb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRBY3Rpb25CeUlkKGlkOiBzdHJpbmcpOiBBY3Rpb25SZWYge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zLmZpbmQoKGFjdGlvbikgPT4gYWN0aW9uLmlkID09PSBpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgUnVsZUV2YWx1YXRvciBmdW5jdGlvbiB1c2luZyBpdHMga2V5IG5hbWUuXG4gICAgICogQHBhcmFtIGtleSBLZXkgbmFtZSB0byBsb29rIGZvclxuICAgICAqIEByZXR1cm5zIFJ1bGVFdmFsdWF0b3Igb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRFdmFsdWF0b3Ioa2V5OiBzdHJpbmcpOiBSdWxlRXZhbHVhdG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZVNlcnZpY2UuZ2V0RXZhbHVhdG9yKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGEgcnVsZS5cbiAgICAgKiBAcGFyYW0gcnVsZUlkIElEIG9mIHRoZSBydWxlIHRvIGV2YWx1YXRlXG4gICAgICogQHBhcmFtIGNvbnRleHQgKG9wdGlvbmFsKSBDdXN0b20gcnVsZSBleGVjdXRpb24gY29udGV4dC5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBydWxlIHBhc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZXZhbHVhdGVSdWxlKHJ1bGVJZDogc3RyaW5nLCBjb250ZXh0PzogUnVsZUNvbnRleHQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZVNlcnZpY2UuZXZhbHVhdGVSdWxlKHJ1bGVJZCwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcmVnaXN0ZXJlZCBleHRlbnNpb24gY29tcG9uZW50IHVzaW5nIGl0cyBJRCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHZhbHVlIHRvIGxvb2sgZm9yXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBvbmVudCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldENvbXBvbmVudEJ5SWQ8VD4oaWQ6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRSZWdpc3Rlci5nZXRDb21wb25lbnRCeUlkPFQ+KGlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBydWxlIHVzaW5nIGl0cyBJRCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gaWQgVGhlIElEIHZhbHVlIHRvIGxvb2sgZm9yXG4gICAgICogQHJldHVybnMgVGhlIHJ1bGUgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRSdWxlQnlJZChpZDogc3RyaW5nKTogUnVsZVJlZiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVTZXJ2aWNlLmdldFJ1bGVCeUlkKGlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgbGlnaHR3ZWlnaHQgZXhwcmVzc2lvbiBzdG9yZWQgaW4gYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHZhbHVlIFN0cmluZyBjb250YWluaW5nIHRoZSBleHByZXNzaW9uIG9yIGxpdGVyYWwgdmFsdWVcbiAgICAgKiBAcGFyYW0gY29udGV4dCBQYXJhbWV0ZXIgb2JqZWN0IGZvciB0aGUgZXhwcmVzc2lvbiB3aXRoIGRldGFpbHMgb2YgYXBwIHN0YXRlXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIGV2YWx1YXRlZCBleHByZXNzaW9uLCBpZiBmb3VuZCwgb3IgdGhlIGxpdGVyYWwgdmFsdWUgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgcnVuRXhwcmVzc2lvbih2YWx1ZTogc3RyaW5nLCBjb250ZXh0PzogYW55KSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKC9cXCRcXCgoLipcXCk/KVxcKS9nKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdjb250ZXh0JywgYHJldHVybiAke2V4cHJlc3Npb259YCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbihjb250ZXh0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4iXX0=