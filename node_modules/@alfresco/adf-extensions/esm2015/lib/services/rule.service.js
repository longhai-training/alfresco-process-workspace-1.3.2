/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { ExtensionLoaderService } from './extension-loader.service';
import * as i0 from "@angular/core";
import * as i1 from "./extension-loader.service";
export class RuleService {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.context = null;
        this.rules = [];
        this.evaluators = {};
    }
    /**
     * @param {?} config
     * @return {?}
     */
    setup(config) {
        this.rules = this.loader.getRules(config);
    }
    /**
     * Adds one or more new rule evaluators to the existing set.
     * @param {?} values The new evaluators to add
     * @return {?}
     */
    setEvaluators(values) {
        if (values) {
            this.evaluators = Object.assign({}, this.evaluators, values);
        }
    }
    /**
     * Retrieves a rule using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} The rule or null if not found
     */
    getRuleById(id) {
        return this.rules.find((/**
         * @param {?} ref
         * @return {?}
         */
        (ref) => ref.id === id));
    }
    /**
     * Retrieves a RuleEvaluator function using its key name.
     * @param {?} key Key name to look for
     * @return {?} RuleEvaluator or null if not found
     */
    getEvaluator(key) {
        if (key && key.startsWith('!')) {
            /** @type {?} */
            const fn = this.evaluators[key.substring(1)];
            return (/**
             * @param {?} context
             * @param {...?} args
             * @return {?}
             */
            (context, ...args) => {
                return !fn(context, ...args);
            });
        }
        return this.evaluators[key];
    }
    /**
     * Evaluates a rule.
     * @param {?} ruleId ID of the rule to evaluate
     * @param {?=} context (optional) Custom rule execution context.
     * @return {?} True if the rule passed, false otherwise
     */
    evaluateRule(ruleId, context) {
        /** @type {?} */
        const ruleRef = this.getRuleById(ruleId);
        context = context || this.context;
        if (ruleRef) {
            /** @type {?} */
            const evaluator = this.getEvaluator(ruleRef.type);
            if (evaluator) {
                return evaluator(context, ...ruleRef.parameters);
            }
        }
        else {
            /** @type {?} */
            const evaluator = this.getEvaluator(ruleId);
            if (evaluator) {
                return evaluator(context);
            }
        }
        return false;
    }
}
RuleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
RuleService.ctorParameters = () => [
    { type: ExtensionLoaderService }
];
/** @nocollapse */ RuleService.ngInjectableDef = i0.defineInjectable({ factory: function RuleService_Factory() { return new RuleService(i0.inject(i1.ExtensionLoaderService)); }, token: RuleService, providedIn: "root" });
if (false) {
    /** @type {?} */
    RuleService.prototype.context;
    /** @type {?} */
    RuleService.prototype.rules;
    /** @type {?} */
    RuleService.prototype.evaluators;
    /**
     * @type {?}
     * @protected
     */
    RuleService.prototype.loader;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVsZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1leHRlbnNpb25zLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL3J1bGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDOzs7QUFLcEUsTUFBTSxPQUFPLFdBQVc7Ozs7SUFLcEIsWUFBc0IsTUFBOEI7UUFBOUIsV0FBTSxHQUFOLE1BQU0sQ0FBd0I7UUFKcEQsWUFBTyxHQUFnQixJQUFJLENBQUM7UUFDNUIsVUFBSyxHQUFtQixFQUFFLENBQUM7UUFDM0IsZUFBVSxHQUFxQyxFQUFFLENBQUM7SUFFSyxDQUFDOzs7OztJQUV4RCxLQUFLLENBQUMsTUFBdUI7UUFDekIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QyxDQUFDOzs7Ozs7SUFNRCxhQUFhLENBQUMsTUFBd0M7UUFDbEQsSUFBSSxNQUFNLEVBQUU7WUFDUixJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDaEU7SUFDTCxDQUFDOzs7Ozs7SUFPRCxXQUFXLENBQUMsRUFBVTtRQUNsQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSTs7OztRQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBQyxDQUFDO0lBQ25ELENBQUM7Ozs7OztJQU9ELFlBQVksQ0FBQyxHQUFXO1FBQ3BCLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7O2tCQUN0QixFQUFFLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVDOzs7OztZQUFPLENBQUMsT0FBb0IsRUFBRSxHQUFHLElBQXFCLEVBQVcsRUFBRTtnQkFDL0QsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztZQUNqQyxDQUFDLEVBQUM7U0FDTDtRQUNELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoQyxDQUFDOzs7Ozs7O0lBUUQsWUFBWSxDQUFDLE1BQWMsRUFBRSxPQUFxQjs7Y0FDeEMsT0FBTyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDO1FBQ3hDLE9BQU8sR0FBRyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUVsQyxJQUFJLE9BQU8sRUFBRTs7a0JBQ0gsU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztZQUNqRCxJQUFJLFNBQVMsRUFBRTtnQkFDWCxPQUFPLFNBQVMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDcEQ7U0FDSjthQUFNOztrQkFDRyxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7WUFDM0MsSUFBSSxTQUFTLEVBQUU7Z0JBQ1gsT0FBTyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDN0I7U0FDSjtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7OztZQXRFSixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7Ozs7WUFKUSxzQkFBc0I7Ozs7O0lBTTNCLDhCQUE0Qjs7SUFDNUIsNEJBQTJCOztJQUMzQixpQ0FBa0Q7Ozs7O0lBRXRDLDZCQUF3QyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJ1bGVSZWYsIFJ1bGVDb250ZXh0LCBSdWxlRXZhbHVhdG9yLCBSdWxlUGFyYW1ldGVyIH0gZnJvbSAnLi4vY29uZmlnL3J1bGUuZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBFeHRlbnNpb25Db25maWcgfSBmcm9tICcuLi9jb25maWcvZXh0ZW5zaW9uLmNvbmZpZyc7XG5pbXBvcnQgeyBFeHRlbnNpb25Mb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi9leHRlbnNpb24tbG9hZGVyLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFJ1bGVTZXJ2aWNlIHtcbiAgICBjb250ZXh0OiBSdWxlQ29udGV4dCA9IG51bGw7XG4gICAgcnVsZXM6IEFycmF5PFJ1bGVSZWY+ID0gW107XG4gICAgZXZhbHVhdG9yczogeyBba2V5OiBzdHJpbmddOiBSdWxlRXZhbHVhdG9yIH0gPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBsb2FkZXI6IEV4dGVuc2lvbkxvYWRlclNlcnZpY2UpIHt9XG5cbiAgICBzZXR1cChjb25maWc6IEV4dGVuc2lvbkNvbmZpZykge1xuICAgICAgICB0aGlzLnJ1bGVzID0gdGhpcy5sb2FkZXIuZ2V0UnVsZXMoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIG5ldyBydWxlIGV2YWx1YXRvcnMgdG8gdGhlIGV4aXN0aW5nIHNldC5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIFRoZSBuZXcgZXZhbHVhdG9ycyB0byBhZGRcbiAgICAgKi9cbiAgICBzZXRFdmFsdWF0b3JzKHZhbHVlczogeyBba2V5OiBzdHJpbmddOiBSdWxlRXZhbHVhdG9yIH0pIHtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0b3JzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ldmFsdWF0b3JzLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcnVsZSB1c2luZyBpdHMgSUQgdmFsdWUuXG4gICAgICogQHBhcmFtIGlkIFRoZSBJRCB2YWx1ZSB0byBsb29rIGZvclxuICAgICAqIEByZXR1cm5zIFRoZSBydWxlIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0UnVsZUJ5SWQoaWQ6IHN0cmluZyk6IFJ1bGVSZWYge1xuICAgICAgICByZXR1cm4gdGhpcy5ydWxlcy5maW5kKChyZWYpID0+IHJlZi5pZCA9PT0gaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIFJ1bGVFdmFsdWF0b3IgZnVuY3Rpb24gdXNpbmcgaXRzIGtleSBuYW1lLlxuICAgICAqIEBwYXJhbSBrZXkgS2V5IG5hbWUgdG8gbG9vayBmb3JcbiAgICAgKiBAcmV0dXJucyBSdWxlRXZhbHVhdG9yIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0RXZhbHVhdG9yKGtleTogc3RyaW5nKTogUnVsZUV2YWx1YXRvciB7XG4gICAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgoJyEnKSkge1xuICAgICAgICAgICAgY29uc3QgZm4gPSB0aGlzLmV2YWx1YXRvcnNba2V5LnN1YnN0cmluZygxKV07XG4gICAgICAgICAgICByZXR1cm4gKGNvbnRleHQ6IFJ1bGVDb250ZXh0LCAuLi5hcmdzOiBSdWxlUGFyYW1ldGVyW10pOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWZuKGNvbnRleHQsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0b3JzW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGEgcnVsZS5cbiAgICAgKiBAcGFyYW0gcnVsZUlkIElEIG9mIHRoZSBydWxlIHRvIGV2YWx1YXRlXG4gICAgICogQHBhcmFtIGNvbnRleHQgKG9wdGlvbmFsKSBDdXN0b20gcnVsZSBleGVjdXRpb24gY29udGV4dC5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBydWxlIHBhc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZXZhbHVhdGVSdWxlKHJ1bGVJZDogc3RyaW5nLCBjb250ZXh0PzogUnVsZUNvbnRleHQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgcnVsZVJlZiA9IHRoaXMuZ2V0UnVsZUJ5SWQocnVsZUlkKTtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5jb250ZXh0O1xuXG4gICAgICAgIGlmIChydWxlUmVmKSB7XG4gICAgICAgICAgICBjb25zdCBldmFsdWF0b3IgPSB0aGlzLmdldEV2YWx1YXRvcihydWxlUmVmLnR5cGUpO1xuICAgICAgICAgICAgaWYgKGV2YWx1YXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmFsdWF0b3IoY29udGV4dCwgLi4ucnVsZVJlZi5wYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV2YWx1YXRvciA9IHRoaXMuZ2V0RXZhbHVhdG9yKHJ1bGVJZCk7XG4gICAgICAgICAgICBpZiAoZXZhbHVhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRvcihjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIl19