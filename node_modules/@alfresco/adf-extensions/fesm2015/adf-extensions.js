import { HttpClient } from '@angular/common/http';
import '@alfresco/js-api';
import { __awaiter } from 'tslib';
import { Injectable, Component, Input, ComponentFactoryResolver, ViewChild, ViewContainerRef, ViewEncapsulation, ChangeDetectionStrategy, defineInjectable, inject, APP_INITIALIZER, NgModule } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @enum {string} */
const ContentActionType = {
    default: 'default',
    button: 'button',
    separator: 'separator',
    menu: 'menu',
    custom: 'custom',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} target
 * @param {?} key
 * @return {?}
 */
function getValue(target, key) {
    if (!target) {
        return undefined;
    }
    /** @type {?} */
    const keys = key.split('.');
    key = '';
    do {
        key += keys.shift();
        /** @type {?} */
        const value = target[key];
        if (value !== undefined &&
            (typeof value === 'object' || !keys.length)) {
            target = value;
            key = '';
        }
        else if (!keys.length) {
            target = undefined;
        }
        else {
            key += '.';
        }
    } while (keys.length);
    return target;
}
/**
 * @param {?} entry
 * @return {?}
 */
function filterEnabled(entry) {
    return !entry.disabled;
}
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function sortByOrder(a, b) {
    /** @type {?} */
    const left = a.order === undefined ? Number.MAX_SAFE_INTEGER : a.order;
    /** @type {?} */
    const right = b.order === undefined ? Number.MAX_SAFE_INTEGER : b.order;
    return left - right;
}
/**
 * @param {?} acc
 * @param {?} el
 * @param {?} i
 * @param {?} arr
 * @return {?}
 */
function reduceSeparators(acc, el, i, arr) {
    // remove leading separator
    if (i === 0) {
        if (arr[i].type === ContentActionType.separator) {
            return acc;
        }
    }
    // remove duplicate separators
    if (i > 0) {
        /** @type {?} */
        const prev = arr[i - 1];
        if (prev.type === ContentActionType.separator &&
            el.type === ContentActionType.separator) {
            return acc;
        }
        // remove trailing separator
        if (i === arr.length - 1) {
            if (el.type === ContentActionType.separator) {
                return acc;
            }
        }
    }
    return acc.concat(el);
}
/**
 * @param {?} acc
 * @param {?} el
 * @return {?}
 */
function reduceEmptyMenus(acc, el) {
    if (el.type === ContentActionType.menu) {
        if ((el.children || []).length === 0) {
            return acc;
        }
    }
    return acc.concat(el);
}
/**
 * @param {...?} objects
 * @return {?}
 */
function mergeObjects(...objects) {
    /** @type {?} */
    const result = {};
    objects.forEach((/**
     * @param {?} source
     * @return {?}
     */
    (source) => {
        Object.keys(source).forEach((/**
         * @param {?} prop
         * @return {?}
         */
        (prop) => {
            if (!prop.startsWith('$')) {
                if (prop in result && Array.isArray(result[prop])) {
                    // result[prop] = result[prop].concat(source[prop]);
                    result[prop] = mergeArrays(result[prop], source[prop]);
                }
                else if (prop in result && typeof result[prop] === 'object') {
                    result[prop] = mergeObjects(result[prop], source[prop]);
                }
                else {
                    result[prop] = source[prop];
                }
            }
        }));
    }));
    return result;
}
/**
 * @param {?} left
 * @param {?} right
 * @return {?}
 */
function mergeArrays(left, right) {
    /** @type {?} */
    const result = [];
    /** @type {?} */
    const map = {};
    (left || []).forEach((/**
     * @param {?} entry
     * @return {?}
     */
    (entry) => {
        /** @type {?} */
        const element = entry;
        if (element && element.hasOwnProperty('id')) {
            map[element.id] = element;
        }
        else {
            result.push(element);
        }
    }));
    (right || []).forEach((/**
     * @param {?} entry
     * @return {?}
     */
    (entry) => {
        /** @type {?} */
        const element = entry;
        if (element && element.hasOwnProperty('id') && map[element.id]) {
            /** @type {?} */
            const merged = mergeObjects(map[element.id], element);
            map[element.id] = merged;
        }
        else {
            result.push(element);
        }
    }));
    return Object.keys(map).map((/**
     * @param {?} key
     * @return {?}
     */
    (key) => map[key])).concat(result);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExtensionLoaderService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
    }
    /**
     * @param {?} configPath
     * @param {?} pluginsPath
     * @return {?}
     */
    load(configPath, pluginsPath) {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => {
            this.loadConfig(configPath, 0).then((/**
             * @param {?} result
             * @return {?}
             */
            (result) => {
                if (result) {
                    /** @type {?} */
                    let config = result.config;
                    /** @type {?} */
                    const override = sessionStorage.getItem('app.extension.config');
                    if (override) {
                        config = JSON.parse(override);
                    }
                    if (config.$references && config.$references.length > 0) {
                        /** @type {?} */
                        const plugins = config.$references.map((/**
                         * @param {?} name
                         * @param {?} idx
                         * @return {?}
                         */
                        (name, idx) => this.loadConfig(`${pluginsPath}/${name}`, idx)));
                        Promise.all(plugins).then((/**
                         * @param {?} results
                         * @return {?}
                         */
                        (results) => {
                            /** @type {?} */
                            const configs = results
                                .filter((/**
                             * @param {?} entry
                             * @return {?}
                             */
                            (entry) => entry))
                                .sort(sortByOrder)
                                .map((/**
                             * @param {?} entry
                             * @return {?}
                             */
                            (entry) => entry.config));
                            if (configs.length > 0) {
                                config = mergeObjects(config, ...configs);
                            }
                            config = Object.assign({}, config, this.getMetadata(result.config), { $references: configs.map((/**
                                 * @param {?} ext
                                 * @return {?}
                                 */
                                (ext) => this.getMetadata(ext))) });
                            resolve(config);
                        }));
                    }
                    else {
                        resolve(config);
                    }
                }
            }));
        }));
    }
    /**
     * @protected
     * @param {?} config
     * @return {?}
     */
    getMetadata(config) {
        /** @type {?} */
        const result = {};
        Object
            .keys(config)
            .filter((/**
         * @param {?} key
         * @return {?}
         */
        (key) => key.startsWith('$')))
            .forEach((/**
         * @param {?} key
         * @return {?}
         */
        (key) => {
            result[key] = config[key];
        }));
        return result;
    }
    /**
     * @protected
     * @param {?} url
     * @param {?} order
     * @return {?}
     */
    loadConfig(url, order) {
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        (resolve) => {
            this.http.get(url).subscribe((/**
             * @param {?} config
             * @return {?}
             */
            (config) => {
                resolve({
                    order,
                    config
                });
            }), (/**
             * @return {?}
             */
            () => {
                resolve(null);
            }));
        }));
    }
    /**
     * Retrieves configuration elements.
     * Filters element by **enabled** and **order** attributes.
     * Example:
     *  `getElements<ViewerExtensionRef>(config, 'features.viewer.content')`
     * @template T
     * @param {?} config
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    getElements(config, key, fallback = []) {
        /** @type {?} */
        const values = getValue(config, key) || fallback || [];
        return values.filter(filterEnabled).sort(sortByOrder);
    }
    /**
     * @param {?} config
     * @param {?} key
     * @return {?}
     */
    getContentActions(config, key) {
        return this.getElements(config, key).map(this.setActionDefaults);
    }
    /**
     * @param {?} config
     * @return {?}
     */
    getRules(config) {
        if (config && config.rules) {
            return config.rules;
        }
        return [];
    }
    /**
     * @param {?} config
     * @return {?}
     */
    getRoutes(config) {
        if (config) {
            return config.routes || [];
        }
        return [];
    }
    /**
     * @param {?} config
     * @return {?}
     */
    getActions(config) {
        if (config) {
            return config.actions || [];
        }
        return [];
    }
    /**
     * @param {?} config
     * @return {?}
     */
    getFeatures(config) {
        if (config) {
            return config.features || [];
        }
        return [];
    }
    /**
     * @protected
     * @param {?} action
     * @return {?}
     */
    setActionDefaults(action) {
        if (action) {
            action.type = action.type || ContentActionType.default;
            action.icon = action.icon || 'extension';
        }
        return action;
    }
}
ExtensionLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ExtensionLoaderService.ctorParameters = () => [
    { type: HttpClient }
];
/** @nocollapse */ ExtensionLoaderService.ngInjectableDef = defineInjectable({ factory: function ExtensionLoaderService_Factory() { return new ExtensionLoaderService(inject(HttpClient)); }, token: ExtensionLoaderService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {?} context
 * @param {...?} args
 * @return {?}
 */
function not(context, ...args) {
    if (!args || args.length === 0) {
        return false;
    }
    return args
        .every((/**
     * @param {?} arg
     * @return {?}
     */
    (arg) => {
        /** @type {?} */
        const evaluator = context.getEvaluator(arg.value);
        if (!evaluator) {
            console.warn('evaluator not found: ' + arg.value);
            return false;
        }
        return !evaluator(context, ...(arg.parameters || []));
    }));
}
/**
 * @param {?} context
 * @param {...?} args
 * @return {?}
 */
function every(context, ...args) {
    if (!args || args.length === 0) {
        return false;
    }
    return args
        .every((/**
     * @param {?} arg
     * @return {?}
     */
    (arg) => {
        /** @type {?} */
        const evaluator = context.getEvaluator(arg.value);
        if (!evaluator) {
            console.warn('evaluator not found: ' + arg.value);
            return false;
        }
        return evaluator(context, ...(arg.parameters || []));
    }));
}
/**
 * @param {?} context
 * @param {...?} args
 * @return {?}
 */
function some(context, ...args) {
    if (!args || args.length === 0) {
        return false;
    }
    return args
        .some((/**
     * @param {?} arg
     * @return {?}
     */
    (arg) => {
        /** @type {?} */
        const evaluator = context.getEvaluator(arg.value);
        if (!evaluator) {
            console.warn('evaluator not found: ' + arg.value);
            return false;
        }
        return evaluator(context, ...(arg.parameters || []));
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ComponentRegisterService {
    constructor() {
        this.components = {};
    }
    /**
     * @param {?} values
     * @return {?}
     */
    setComponents(values) {
        if (values) {
            this.components = Object.assign({}, this.components, values);
        }
    }
    /**
     * @template T
     * @param {?} id
     * @return {?}
     */
    getComponentById(id) {
        return (/** @type {?} */ (this.components[id]));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    hasComponentById(id) {
        return !!this.getComponentById(id);
    }
}
ComponentRegisterService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ ComponentRegisterService.ngInjectableDef = defineInjectable({ factory: function ComponentRegisterService_Factory() { return new ComponentRegisterService(); }, token: ComponentRegisterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RuleService {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.context = null;
        this.rules = [];
        this.evaluators = {};
    }
    /**
     * @param {?} config
     * @return {?}
     */
    setup(config) {
        this.rules = this.loader.getRules(config);
    }
    /**
     * Adds one or more new rule evaluators to the existing set.
     * @param {?} values The new evaluators to add
     * @return {?}
     */
    setEvaluators(values) {
        if (values) {
            this.evaluators = Object.assign({}, this.evaluators, values);
        }
    }
    /**
     * Retrieves a rule using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} The rule or null if not found
     */
    getRuleById(id) {
        return this.rules.find((/**
         * @param {?} ref
         * @return {?}
         */
        (ref) => ref.id === id));
    }
    /**
     * Retrieves a RuleEvaluator function using its key name.
     * @param {?} key Key name to look for
     * @return {?} RuleEvaluator or null if not found
     */
    getEvaluator(key) {
        if (key && key.startsWith('!')) {
            /** @type {?} */
            const fn = this.evaluators[key.substring(1)];
            return (/**
             * @param {?} context
             * @param {...?} args
             * @return {?}
             */
            (context, ...args) => {
                return !fn(context, ...args);
            });
        }
        return this.evaluators[key];
    }
    /**
     * Evaluates a rule.
     * @param {?} ruleId ID of the rule to evaluate
     * @param {?=} context (optional) Custom rule execution context.
     * @return {?} True if the rule passed, false otherwise
     */
    evaluateRule(ruleId, context) {
        /** @type {?} */
        const ruleRef = this.getRuleById(ruleId);
        context = context || this.context;
        if (ruleRef) {
            /** @type {?} */
            const evaluator = this.getEvaluator(ruleRef.type);
            if (evaluator) {
                return evaluator(context, ...ruleRef.parameters);
            }
        }
        else {
            /** @type {?} */
            const evaluator = this.getEvaluator(ruleId);
            if (evaluator) {
                return evaluator(context);
            }
        }
        return false;
    }
}
RuleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
RuleService.ctorParameters = () => [
    { type: ExtensionLoaderService }
];
/** @nocollapse */ RuleService.ngInjectableDef = defineInjectable({ factory: function RuleService_Factory() { return new RuleService(inject(ExtensionLoaderService)); }, token: RuleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExtensionService {
    /**
     * @param {?} loader
     * @param {?} componentRegister
     * @param {?} ruleService
     */
    constructor(loader, componentRegister, ruleService) {
        this.loader = loader;
        this.componentRegister = componentRegister;
        this.ruleService = ruleService;
        this.config = null;
        this.configPath = 'assets/app.extensions.json';
        this.pluginsPath = 'assets/plugins';
        this.routes = [];
        this.actions = [];
        this.features = [];
        this.authGuards = {};
    }
    /**
     * Loads and registers an extension config file and plugins (specified by path properties).
     * @return {?} The loaded config data
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const config = yield this.loader.load(this.configPath, this.pluginsPath);
            this.setup(config);
            return config;
        });
    }
    /**
     * Registers extensions from a config object.
     * @param {?} config Object with config data
     * @return {?}
     */
    setup(config) {
        if (!config) {
            console.warn('Extension configuration not found');
            return;
        }
        this.config = config;
        this.setEvaluators({
            'core.every': every,
            'core.some': some,
            'core.not': not
        });
        this.actions = this.loader.getActions(config);
        this.routes = this.loader.getRoutes(config);
        this.features = this.loader.getFeatures(config);
        this.ruleService.setup(config);
    }
    /**
     * Gets features by key.
     * @param {?} key Key string, using dot notation
     * @return {?} Features array found by key
     */
    getFeature(key) {
        /** @type {?} */
        const properties = Array.isArray(key) ? [key] : key.split('.');
        return properties.reduce((/**
         * @param {?} prev
         * @param {?} curr
         * @return {?}
         */
        (prev, curr) => prev && prev[curr]), this.features) || [];
    }
    /**
     * @template T
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    getElements(key, fallback = []) {
        return this.loader.getElements(this.config, key, fallback);
    }
    /**
     * Adds one or more new rule evaluators to the existing set.
     * @param {?} values The new evaluators to add
     * @return {?}
     */
    setEvaluators(values) {
        this.ruleService.setEvaluators(values);
    }
    /**
     * Adds one or more new auth guards to the existing set.
     * @param {?} values The new auth guards to add
     * @return {?}
     */
    setAuthGuards(values) {
        if (values) {
            this.authGuards = Object.assign({}, this.authGuards, values);
        }
    }
    /**
     * Adds one or more new components to the existing set.
     * @param {?} values The new components to add
     * @return {?}
     */
    setComponents(values) {
        this.componentRegister.setComponents(values);
    }
    /**
     * Retrieves a route using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} The route or null if not found
     */
    getRouteById(id) {
        return this.routes.find((/**
         * @param {?} route
         * @return {?}
         */
        (route) => route.id === id));
    }
    /**
     * Retrieves one or more auth guards using an array of ID values.
     * @param {?} ids Array of ID value to look for
     * @return {?} Array of auth guards or empty array if none were found
     */
    getAuthGuards(ids) {
        return (ids || [])
            .map((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.authGuards[id]))
            .filter((/**
         * @param {?} guard
         * @return {?}
         */
        (guard) => guard));
    }
    /**
     * Retrieves an action using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} Action or null if not found
     */
    getActionById(id) {
        return this.actions.find((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.id === id));
    }
    /**
     * Retrieves a RuleEvaluator function using its key name.
     * @param {?} key Key name to look for
     * @return {?} RuleEvaluator or null if not found
     */
    getEvaluator(key) {
        return this.ruleService.getEvaluator(key);
    }
    /**
     * Evaluates a rule.
     * @param {?} ruleId ID of the rule to evaluate
     * @param {?=} context (optional) Custom rule execution context.
     * @return {?} True if the rule passed, false otherwise
     */
    evaluateRule(ruleId, context) {
        return this.ruleService.evaluateRule(ruleId, context);
    }
    /**
     * Retrieves a registered extension component using its ID value.
     * @template T
     * @param {?} id The ID value to look for
     * @return {?} The component or null if not found
     */
    getComponentById(id) {
        return this.componentRegister.getComponentById(id);
    }
    /**
     * Retrieves a rule using its ID value.
     * @param {?} id The ID value to look for
     * @return {?} The rule or null if not found
     */
    getRuleById(id) {
        return this.ruleService.getRuleById(id);
    }
    /**
     * Runs a lightweight expression stored in a string.
     * @param {?} value String containing the expression or literal value
     * @param {?=} context Parameter object for the expression with details of app state
     * @return {?} Result of evaluated expression, if found, or the literal value otherwise
     */
    runExpression(value, context) {
        /** @type {?} */
        const pattern = new RegExp(/\$\((.*\)?)\)/g);
        /** @type {?} */
        const matches = pattern.exec(value);
        if (matches && matches.length > 1) {
            /** @type {?} */
            const expression = matches[1];
            /** @type {?} */
            const fn = new Function('context', `return ${expression}`);
            /** @type {?} */
            const result = fn(context);
            return result;
        }
        return value;
    }
}
ExtensionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ExtensionService.ctorParameters = () => [
    { type: ExtensionLoaderService },
    { type: ComponentRegisterService },
    { type: RuleService }
];
/** @nocollapse */ ExtensionService.ngInjectableDef = defineInjectable({ factory: function ExtensionService_Factory() { return new ExtensionService(inject(ExtensionLoaderService), inject(ComponentRegisterService), inject(RuleService)); }, token: ExtensionService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// cSpell:words lifecycle
class DynamicExtensionComponent {
    /**
     * @param {?} extensions
     * @param {?} componentFactoryResolver
     */
    constructor(extensions, componentFactoryResolver) {
        this.extensions = extensions;
        this.componentFactoryResolver = componentFactoryResolver;
        this.loaded = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.loaded) {
            this.loadComponent();
            this.loaded = true;
        }
        if (changes.data) {
            this.data = changes.data.currentValue;
        }
        this.updateInstance();
        this.proxy('ngOnChanges', changes);
    }
    /**
     * @private
     * @return {?}
     */
    loadComponent() {
        /** @type {?} */
        const componentType = this.extensions.getComponentById(this.id);
        if (componentType) {
            /** @type {?} */
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.componentCreated()) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateInstance() {
        if (this.componentCreated()) {
            this.componentRef.instance.data = this.data;
        }
    }
    /**
     * @private
     * @param {?} lifecycleMethod
     * @param {...?} args
     * @return {?}
     */
    proxy(lifecycleMethod, ...args) {
        if (this.componentCreated() && this.lifecycleHookIsImplemented(lifecycleMethod)) {
            this.componentRef.instance[lifecycleMethod].apply(this.componentRef.instance, args);
        }
    }
    /**
     * @private
     * @return {?}
     */
    componentCreated() {
        return !!this.componentRef && !!this.componentRef.instance;
    }
    /**
     * @private
     * @param {?} lifecycleMethod
     * @return {?}
     */
    lifecycleHookIsImplemented(lifecycleMethod) {
        return !!this.componentRef.instance[lifecycleMethod];
    }
}
DynamicExtensionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dynamic-component',
                template: `<div #content></div>`
            }] }
];
/** @nocollapse */
DynamicExtensionComponent.ctorParameters = () => [
    { type: ExtensionService },
    { type: ComponentFactoryResolver }
];
DynamicExtensionComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] }],
    id: [{ type: Input }],
    data: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicTabComponent {
    /**
     * @param {?} extensions
     * @param {?} componentFactoryResolver
     */
    constructor(extensions, componentFactoryResolver) {
        this.extensions = extensions;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const componentType = this.extensions.getComponentById(this.id);
        if (componentType) {
            /** @type {?} */
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
                this.updateInstance();
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.node) {
            this.updateInstance();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateInstance() {
        if (this.componentRef && this.componentRef.instance) {
            this.componentRef.instance.node = this.node;
        }
    }
}
DynamicTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dynamic-tab',
                template: `<div #content></div>`
            }] }
];
/** @nocollapse */
DynamicTabComponent.ctorParameters = () => [
    { type: ExtensionService },
    { type: ComponentFactoryResolver }
];
DynamicTabComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] }],
    id: [{ type: Input }],
    node: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicColumnComponent {
    /**
     * @param {?} extensions
     * @param {?} componentFactoryResolver
     */
    constructor(extensions, componentFactoryResolver) {
        this.extensions = extensions;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const componentType = this.extensions.getComponentById(this.id);
        if (componentType) {
            /** @type {?} */
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
                this.updateInstance();
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.node) {
            this.updateInstance();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateInstance() {
        if (this.componentRef && this.componentRef.instance) {
            this.componentRef.instance.context = this.context;
        }
    }
}
DynamicColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dynamic-column',
                template: `
    <ng-container #content></ng-container>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-dynamic-column' },
                styles: [`
      .adf-dynamic-column {
        display: flex;
        align-items: center;
      }
    `]
            }] }
];
/** @nocollapse */
DynamicColumnComponent.ctorParameters = () => [
    { type: ExtensionService },
    { type: ComponentFactoryResolver }
];
DynamicColumnComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] }],
    id: [{ type: Input }],
    context: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PreviewExtensionComponent {
    /**
     * @param {?} extensionService
     * @param {?} componentFactoryResolver
     */
    constructor(extensionService, componentFactoryResolver) {
        this.extensionService = extensionService;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.id) {
            return;
        }
        /** @type {?} */
        const componentType = this.extensionService.getComponentById(this.id);
        if (componentType) {
            /** @type {?} */
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
                this.updateInstance();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.updateInstance();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateInstance() {
        if (this.componentRef && this.componentRef.instance) {
            /** @type {?} */
            const instance = this.componentRef.instance;
            instance.node = this.node;
            instance.url = this.url;
            instance.extension = this.extension;
        }
    }
}
PreviewExtensionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-preview-extension',
                template: `
    <div #content></div>
  `
            }] }
];
/** @nocollapse */
PreviewExtensionComponent.ctorParameters = () => [
    { type: ExtensionService },
    { type: ComponentFactoryResolver }
];
PreviewExtensionComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] }],
    id: [{ type: Input }],
    url: [{ type: Input }],
    extension: [{ type: Input }],
    node: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppExtensionService {
    /**
     * @param {?} extensionService
     */
    constructor(extensionService) {
        this.extensionService = extensionService;
        this._references = new BehaviorSubject([]);
        this.references$ = this._references.asObservable();
    }
    /**
     * @return {?}
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const config = yield this.extensionService.load();
            this.setup(config);
        });
    }
    /**
     * @param {?} config
     * @return {?}
     */
    setup(config) {
        if (!config) {
            return;
        }
        /** @type {?} */
        const references = (config.$references || [])
            .filter((/**
         * @param {?} entry
         * @return {?}
         */
        (entry) => typeof entry === 'object'))
            .map((/**
         * @param {?} entry
         * @return {?}
         */
        (entry) => (/** @type {?} */ (entry))));
        this._references.next(references);
    }
    /**
     * Provides a collection of document list columns for the particular preset.
     * The result is filtered by the **disabled** state.
     * @param {?} key Preset key.
     * @return {?}
     */
    getDocumentListPreset(key) {
        return this.extensionService
            .getElements(`features.documentList.${key}`)
            .filter((/**
         * @param {?} entry
         * @return {?}
         */
        (entry) => !entry.disabled));
    }
    /**
     * Provides a list of the Viewer content extensions,
     * filtered by **disabled** state and **rules**.
     * @return {?}
     */
    getViewerExtensions() {
        return this.extensionService
            .getElements('features.viewer.content')
            .filter((/**
         * @param {?} extension
         * @return {?}
         */
        (extension) => !this.isViewerExtensionDisabled(extension)));
    }
    /**
     * @protected
     * @param {?} extension
     * @return {?}
     */
    isViewerExtensionDisabled(extension) {
        if (extension) {
            if (extension.disabled) {
                return true;
            }
            if (extension.rules && extension.rules.disabled) {
                return this.extensionService.evaluateRule(extension.rules.disabled);
            }
        }
        return false;
    }
}
AppExtensionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AppExtensionService.ctorParameters = () => [
    { type: ExtensionService }
];
/** @nocollapse */ AppExtensionService.ngInjectableDef = defineInjectable({ factory: function AppExtensionService_Factory() { return new AppExtensionService(inject(ExtensionService)); }, token: AppExtensionService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {?} appExtensionService
 * @return {?}
 */
function setupExtensions(appExtensionService) {
    return (/**
     * @return {?}
     */
    () => appExtensionService.load());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExtensionsModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ExtensionsModule,
            providers: [
                {
                    provide: APP_INITIALIZER,
                    useFactory: setupExtensions,
                    deps: [AppExtensionService],
                    multi: true
                }
            ]
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: ExtensionsModule
        };
    }
}
ExtensionsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DynamicExtensionComponent,
                    DynamicTabComponent,
                    DynamicColumnComponent,
                    PreviewExtensionComponent
                ],
                exports: [
                    DynamicExtensionComponent,
                    DynamicTabComponent,
                    DynamicColumnComponent,
                    PreviewExtensionComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RuleRef {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ExtensionsModule, ContentActionType, getValue, filterEnabled, sortByOrder, reduceSeparators, reduceEmptyMenus, mergeObjects, mergeArrays, RuleRef, ExtensionLoaderService, ExtensionService, ComponentRegisterService, AppExtensionService, PreviewExtensionComponent, DynamicColumnComponent, DynamicExtensionComponent, DynamicTabComponent, RuleService as ɵa, setupExtensions as ɵb };

//# sourceMappingURL=adf-extensions.js.map